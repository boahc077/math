<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: OpenCL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="standoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">4.4.0</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__opencl.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">OpenCL</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Stan's OpenCL backend allows for computation to be executed in parallel on a GPU or in multithreaded CPUs. It is meant to easily conform with <a class="el" href="namespace_eigen.html">Eigen</a> such that you can create and read from a <code>matrix_cl</code> by doing. </p>
<div class="fragment"><div class="line">Eigen::MatrixXd A_eig = Eigen::MatrixXd::Random(10, 10);</div>
<div class="line">matrix_cl&lt;double&gt; A(A_eig);</div>
<div class="line">matrix_cl&lt;double&gt; B = <a class="code" href="group__opencl_ga8bbce98664097d5ea8e55b0b931bd721.html#ga8bbce98664097d5ea8e55b0b931bd721">to_matrix_cl</a>(A_eig);</div>
<div class="line">matrix_cl&lt;double&gt; C = <a class="code" href="group__opencl__kernels_gacdabec78c1cd7feac6047ddd6289800d.html#gacdabec78c1cd7feac6047ddd6289800d">cholesky_decompose</a>(A * B);</div>
<div class="line"><span class="comment">// Read back to eigen matrix.</span></div>
<div class="line">Eigen::MatrixXd C_eig = <a class="code" href="group__opencl_gadf2a61125c6dca5e5a400d56e24cc6d5.html#gadf2a61125c6dca5e5a400d56e24cc6d5">from_matrix_cl</a>(C);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Also for vectors and raw pointers of pointers</span></div>
<div class="line">std::vector&lt;var&gt; A_vec(10, 0);</div>
<div class="line">matrix_cl&lt;var&gt; B_var(A_vec, 10, 1);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a>** A_vari= <span class="comment">// fill</span></div>
<div class="line">matrix_cl&lt;var&gt; B_vari(A_vari, 10, 1);</div>
</div><!-- fragment --><p>Execution is performed in async and Kernel operations are compounded and compiled Just In Time. This allows for a low amount of overhead when passing data to and from the device and executing computations.</p>
<p>For more details see the paper on Arvix. <a href="https://arxiv.org/pdf/1907.01063.pdf">https://arxiv.org/pdf/1907.01063.pdf</a> </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__opencl__kernel__generator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator.html">OpenCL Kernel Generator</a></td></tr>
<tr class="memdesc:group__opencl__kernel__generator"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OpenCL kernel generator is used to combine multiple matrix operations into a single OpenCL kernel. This is much simpler than writing multi-operation kernels by hand. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__matrix__cl__group"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__matrix__cl__group.html">Matrix</a></td></tr>
<tr class="memdesc:group__matrix__cl__group"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> class - allocates memory space on the OpenCL device. Operations on <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> types are executed lazily via the kernel generator and async routines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__opencl__context__group"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl__context__group.html">OpenCL Context</a></td></tr>
<tr class="memdesc:group__opencl__context__group"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization for OpenCL Context: <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__error__checks__opencl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__error__checks__opencl.html">Error Checks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__kernel__executor__opencl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel__executor__opencl.html">Kernel Executor</a></td></tr>
<tr class="memdesc:group__kernel__executor__opencl"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kernel executor allows OpenCL kernels to be executed in async. GPUs have the capability to perform reads, writes, and computation at the same time. In order to maximize the throughput to the device the Kernel Executor assigns matrices read and write events. Write events are blocking in that no further operations can be completed until the write event is finished. However, read events can happen in async together. Take the following for example. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__opencl__kernels"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl__kernels.html">Custom OpenCL kernels</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__prim__fun__opencl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prim__fun__opencl.html">OpenCL overloads of stan/math/prim functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga55b628b5a271afb9f569c34187fd82ad"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_floating_point_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga55b628b5a271afb9f569c34187fd82ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga55b628b5a271afb9f569c34187fd82ad.html#ga55b628b5a271afb9f569c34187fd82ad">stan::math::opencl::cholesky_decompose</a> (<a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:ga55b628b5a271afb9f569c34187fd82ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bbce98664097d5ea8e55b0b931bd721"><td class="memTemplParams" colspan="2">template&lt;typename T , require_st_arithmetic&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8bbce98664097d5ea8e55b0b931bd721"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga8bbce98664097d5ea8e55b0b931bd721.html#ga8bbce98664097d5ea8e55b0b931bd721">stan::math::to_matrix_cl</a> (T &amp;&amp;src)</td></tr>
<tr class="separator:ga8bbce98664097d5ea8e55b0b931bd721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2a61125c6dca5e5a400d56e24cc6d5"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , typename T , require_eigen_t&lt; T_ret &gt; *  = nullptr, require_matrix_cl_t&lt; T &gt; *  = nullptr, require_st_same&lt; T_ret, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadf2a61125c6dca5e5a400d56e24cc6d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gadf2a61125c6dca5e5a400d56e24cc6d5.html#gadf2a61125c6dca5e5a400d56e24cc6d5">stan::math::from_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="separator:gadf2a61125c6dca5e5a400d56e24cc6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad35b73b8bb6ac116683220a20f4c317d"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr, require_not_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad35b73b8bb6ac116683220a20f4c317d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gad35b73b8bb6ac116683220a20f4c317d.html#gad35b73b8bb6ac116683220a20f4c317d">stan::math::from_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="separator:gad35b73b8bb6ac116683220a20f4c317d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e84cc75a88ea72d01c090997fdc556"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T , require_arithmetic_t&lt; T &gt; *  = nullptr, require_same_t&lt; T_dst, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga44e84cc75a88ea72d01c090997fdc556"><td class="memTemplItemLeft" align="right" valign="top">T_dst&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga44e84cc75a88ea72d01c090997fdc556.html#ga44e84cc75a88ea72d01c090997fdc556">stan::math::from_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="separator:ga44e84cc75a88ea72d01c090997fdc556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f99f6ae3dd35f205631e839119f5541"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1f99f6ae3dd35f205631e839119f5541"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga1f99f6ae3dd35f205631e839119f5541.html#ga1f99f6ae3dd35f205631e839119f5541">stan::math::from_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="separator:ga1f99f6ae3dd35f205631e839119f5541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga490df7651c22c9e06d09da69ad303e30"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga490df7651c22c9e06d09da69ad303e30"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga490df7651c22c9e06d09da69ad303e30.html#ga490df7651c22c9e06d09da69ad303e30">stan::math::packed_copy</a> (const T &amp;src)</td></tr>
<tr class="separator:ga490df7651c22c9e06d09da69ad303e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed1f7da1a49ff3c2a9e1147b4eef4662"><td class="memTemplParams" colspan="2">template&lt;matrix_cl_view matrix_view, typename Vec , typename Vec_scalar  = scalar_type_t&lt;Vec&gt;, require_vector_vt&lt; std::is_arithmetic, Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaed1f7da1a49ff3c2a9e1147b4eef4662"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; Vec_scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaed1f7da1a49ff3c2a9e1147b4eef4662.html#gaed1f7da1a49ff3c2a9e1147b4eef4662">stan::math::packed_copy</a> (Vec &amp;&amp;src, int <a class="el" href="group__opencl_ga61254f29c1520f4bffe4ab4e5bbd0e0e.html#ga61254f29c1520f4bffe4ab4e5bbd0e0e">rows</a>)</td></tr>
<tr class="separator:gaed1f7da1a49ff3c2a9e1147b4eef4662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60406331fe144c5088b62ab261a04e87"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga60406331fe144c5088b62ab261a04e87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga60406331fe144c5088b62ab261a04e87.html#ga60406331fe144c5088b62ab261a04e87">stan::math::copy_cl</a> (const T &amp;src)</td></tr>
<tr class="separator:ga60406331fe144c5088b62ab261a04e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_ga9850bbd8d516b87d722ad54947bb9c9f.html#ga9850bbd8d516b87d722ad54947bb9c9f">stan::math::either</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> left_view, const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> right_view)</td></tr>
<tr class="separator:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338a285d4ba933ba6aa7240908919e0f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_ga338a285d4ba933ba6aa7240908919e0f.html#ga338a285d4ba933ba6aa7240908919e0f">stan::math::both</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> left_view, const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> right_view)</td></tr>
<tr class="separator:ga338a285d4ba933ba6aa7240908919e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd63c8a601189c916c8a2157066adb7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_gadd63c8a601189c916c8a2157066adb7c.html#gadd63c8a601189c916c8a2157066adb7c">stan::math::contains_nonzero</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view, const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> part)</td></tr>
<tr class="separator:gadd63c8a601189c916c8a2157066adb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafccee2b081b9edd7c6e6d211157e5490"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_gafccee2b081b9edd7c6e6d211157e5490.html#gafccee2b081b9edd7c6e6d211157e5490">stan::math::transpose</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view)</td></tr>
<tr class="separator:gafccee2b081b9edd7c6e6d211157e5490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga747f014e58d824281b725a7d4868dd77"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_ga747f014e58d824281b725a7d4868dd77.html#ga747f014e58d824281b725a7d4868dd77">stan::math::invert</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view)</td></tr>
<tr class="separator:ga747f014e58d824281b725a7d4868dd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27e938e6fdd621c5903cc37401c54909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_ga27e938e6fdd621c5903cc37401c54909.html#ga27e938e6fdd621c5903cc37401c54909">stan::math::from_eigen_uplo_type</a> (Eigen::UpLoType eigen_type)</td></tr>
<tr class="separator:ga27e938e6fdd621c5903cc37401c54909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e3539ba6e81a0a69e69f09c683252a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga72e3539ba6e81a0a69e69f09c683252a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga72e3539ba6e81a0a69e69f09c683252a.html#ga72e3539ba6e81a0a69e69f09c683252a">stan::math::multiply_transpose</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:ga72e3539ba6e81a0a69e69f09c683252a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41aad12d4ca13a5ae0117d586fb276bf"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_x_cl , typename T_y_cl , typename T_alpha_cl , typename T_beta_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga41aad12d4ca13a5ae0117d586fb276bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x_cl, T_alpha_cl, T_beta_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga41aad12d4ca13a5ae0117d586fb276bf.html#ga41aad12d4ca13a5ae0117d586fb276bf">stan::math::bernoulli_logit_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga41aad12d4ca13a5ae0117d586fb276bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f362f28acd7dfc21fc0df158e8b4df8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4f362f28acd7dfc21fc0df158e8b4df8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga4f362f28acd7dfc21fc0df158e8b4df8.html#ga4f362f28acd7dfc21fc0df158e8b4df8">stan::math::bernoulli_lpmf</a> (const T_n_cl &amp;n, const T_prob_cl &amp;theta)</td></tr>
<tr class="separator:ga4f362f28acd7dfc21fc0df158e8b4df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25bf99f6c2b660ff1bfcdb0bc8440b1d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_size1_cl , typename T_size2_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_size1_cl, T_size2_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_size1_cl, T_size2_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga25bf99f6c2b660ff1bfcdb0bc8440b1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_size1_cl, T_size2_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga25bf99f6c2b660ff1bfcdb0bc8440b1d.html#ga25bf99f6c2b660ff1bfcdb0bc8440b1d">stan::math::beta_binomial_lpmf</a> (const T_n_cl &amp;n, const T_N_cl N, const T_size1_cl &amp;alpha, const T_size2_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga25bf99f6c2b660ff1bfcdb0bc8440b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f3979f0dfb2cfe557bb00f5a420819d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_succ_cl , typename T_scale_fail_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6f3979f0dfb2cfe557bb00f5a420819d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6f3979f0dfb2cfe557bb00f5a420819d.html#ga6f3979f0dfb2cfe557bb00f5a420819d">stan::math::beta_lpdf</a> (const T_y_cl &amp;y, const T_scale_succ_cl &amp;alpha, const T_scale_fail_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga6f3979f0dfb2cfe557bb00f5a420819d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga695bf141835176b401725a1f93c0b00b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_prec_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_prec_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_prec_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga695bf141835176b401725a1f93c0b00b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_prec_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga695bf141835176b401725a1f93c0b00b.html#ga695bf141835176b401725a1f93c0b00b">stan::math::beta_proportion_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_prec_cl &amp;kappa)</td></tr>
<tr class="separator:ga695bf141835176b401725a1f93c0b00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b70ff8b7c0976aa9443ff63026ee3d7"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr, require_any_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6b70ff8b7c0976aa9443ff63026ee3d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6b70ff8b7c0976aa9443ff63026ee3d7.html#ga6b70ff8b7c0976aa9443ff63026ee3d7">stan::math::binomial_logit_lpmf</a> (const T_n_cl &amp;n, const T_N_cl N, const T_prob_cl &amp;alpha)</td></tr>
<tr class="separator:ga6b70ff8b7c0976aa9443ff63026ee3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e355b2eb2a94840f0d2d8df923fc9a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr, require_any_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga12e355b2eb2a94840f0d2d8df923fc9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga12e355b2eb2a94840f0d2d8df923fc9a.html#ga12e355b2eb2a94840f0d2d8df923fc9a">stan::math::binomial_lpmf</a> (const T_n_cl &amp;n, const T_N_cl N, const T_prob_cl &amp;theta)</td></tr>
<tr class="separator:ga12e355b2eb2a94840f0d2d8df923fc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d57691e9a780ada257fb9a3573f7d9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , require_all_prim_or_rev_kernel_expression_t&lt; T_y, T_x, T_alpha, T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga44d57691e9a780ada257fb9a3573f7d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga44d57691e9a780ada257fb9a3573f7d9.html#ga44d57691e9a780ada257fb9a3573f7d9">stan::math::categorical_logit_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga44d57691e9a780ada257fb9a3573f7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47eebee38b750df11f0d6d6aebefd319"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga47eebee38b750df11f0d6d6aebefd319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga47eebee38b750df11f0d6d6aebefd319.html#ga47eebee38b750df11f0d6d6aebefd319">stan::math::cauchy_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga47eebee38b750df11f0d6d6aebefd319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f591b741316b1eba4a2965646029037"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6f591b741316b1eba4a2965646029037"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6f591b741316b1eba4a2965646029037.html#ga6f591b741316b1eba4a2965646029037">stan::math::cauchy_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga6f591b741316b1eba4a2965646029037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ebf1445eace512163f719b3c6153127"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5ebf1445eace512163f719b3c6153127"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5ebf1445eace512163f719b3c6153127.html#ga5ebf1445eace512163f719b3c6153127">stan::math::cauchy_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga5ebf1445eace512163f719b3c6153127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5bc2b295d24a0a13675f8f3465a224"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e5bc2b295d24a0a13675f8f3465a224"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5e5bc2b295d24a0a13675f8f3465a224.html#ga5e5bc2b295d24a0a13675f8f3465a224">stan::math::cauchy_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga5e5bc2b295d24a0a13675f8f3465a224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c220c07244b0448c4743e1a447f27e3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4c220c07244b0448c4743e1a447f27e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga4c220c07244b0448c4743e1a447f27e3.html#ga4c220c07244b0448c4743e1a447f27e3">stan::math::chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu)</td></tr>
<tr class="separator:ga4c220c07244b0448c4743e1a447f27e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0576c38beac678f1164a2cfc172e941e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:ga0576c38beac678f1164a2cfc172e941e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0576c38beac678f1164a2cfc172e941e.html#ga0576c38beac678f1164a2cfc172e941e">stan::math::col</a> (T_x &amp;&amp;x, size_t j)</td></tr>
<tr class="separator:ga0576c38beac678f1164a2cfc172e941e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d4c5b2fb1164cd7dddf3d303785022"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga89d4c5b2fb1164cd7dddf3d303785022"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga89d4c5b2fb1164cd7dddf3d303785022.html#ga89d4c5b2fb1164cd7dddf3d303785022">stan::math::cols</a> (const T_x &amp;x)</td></tr>
<tr class="separator:ga89d4c5b2fb1164cd7dddf3d303785022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaff473895b1f11e364afd4c2d3cb5cab4.html#gaff473895b1f11e364afd4c2d3cb5cab4">stan::math::dims</a> (const T_x &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="separator:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e6c08d7c0cccd3786a7742b135b9a52"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob_cl , typename T_prior_size_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_prob_cl, T_prior_size_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_prob_cl, T_prior_size_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2e6c08d7c0cccd3786a7742b135b9a52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl, T_prior_size_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2e6c08d7c0cccd3786a7742b135b9a52.html#ga2e6c08d7c0cccd3786a7742b135b9a52">stan::math::dirichlet_lpdf</a> (const T_prob_cl &amp;theta, const T_prior_size_cl &amp;alpha)</td></tr>
<tr class="separator:ga2e6c08d7c0cccd3786a7742b135b9a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_a&gt;&gt; </td></tr>
<tr class="memitem:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7fcb23d1bea081595030aedd230f5cf9.html#ga7fcb23d1bea081595030aedd230f5cf9">stan::math::divide</a> (T_a &amp;&amp;a, double d)</td></tr>
<tr class="separator:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc44cdfe2d3632d1e5481cff15fb65b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga2cc44cdfe2d3632d1e5481cff15fb65b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2cc44cdfe2d3632d1e5481cff15fb65b.html#ga2cc44cdfe2d3632d1e5481cff15fb65b">stan::math::divide_columns</a> (<a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;A, const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;B)</td></tr>
<tr class="separator:ga2cc44cdfe2d3632d1e5481cff15fb65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eb269aa25fab63bb03b617210151e4a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga8eb269aa25fab63bb03b617210151e4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga8eb269aa25fab63bb03b617210151e4a.html#ga8eb269aa25fab63bb03b617210151e4a">stan::math::divide_columns</a> (<a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;A, const T2 &amp;divisor)</td></tr>
<tr class="separator:ga8eb269aa25fab63bb03b617210151e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad684c5d3a421b9467f49e310f4de4a79"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad684c5d3a421b9467f49e310f4de4a79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gad684c5d3a421b9467f49e310f4de4a79.html#gad684c5d3a421b9467f49e310f4de4a79">stan::math::double_exponential_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gad684c5d3a421b9467f49e310f4de4a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f5affb2425a19cb23eae6f34f9bc73c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3f5affb2425a19cb23eae6f34f9bc73c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3f5affb2425a19cb23eae6f34f9bc73c.html#ga3f5affb2425a19cb23eae6f34f9bc73c">stan::math::double_exponential_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga3f5affb2425a19cb23eae6f34f9bc73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f8a5af1fc2ad20f7c010879c778b2e"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga88f8a5af1fc2ad20f7c010879c778b2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga88f8a5af1fc2ad20f7c010879c778b2e.html#ga88f8a5af1fc2ad20f7c010879c778b2e">stan::math::double_exponential_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga88f8a5af1fc2ad20f7c010879c778b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32141185398679bb00fe1ce2ba9b66c1"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga32141185398679bb00fe1ce2ba9b66c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga32141185398679bb00fe1ce2ba9b66c1.html#ga32141185398679bb00fe1ce2ba9b66c1">stan::math::double_exponential_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga32141185398679bb00fe1ce2ba9b66c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a9ac563ae060b1db31a94d691ba2ce0"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6a9ac563ae060b1db31a94d691ba2ce0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6a9ac563ae060b1db31a94d691ba2ce0.html#ga6a9ac563ae060b1db31a94d691ba2ce0">stan::math::exp_mod_normal_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="separator:ga6a9ac563ae060b1db31a94d691ba2ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae195effc04066eebadd16c6e241dec57"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae195effc04066eebadd16c6e241dec57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae195effc04066eebadd16c6e241dec57.html#gae195effc04066eebadd16c6e241dec57">stan::math::exp_mod_normal_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="separator:gae195effc04066eebadd16c6e241dec57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa835b5a8631edc35a37662f355d4b0d6"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa835b5a8631edc35a37662f355d4b0d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaa835b5a8631edc35a37662f355d4b0d6.html#gaa835b5a8631edc35a37662f355d4b0d6">stan::math::exp_mod_normal_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="separator:gaa835b5a8631edc35a37662f355d4b0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2860333c4eb25602dc10a31f5f817fb1"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2860333c4eb25602dc10a31f5f817fb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2860333c4eb25602dc10a31f5f817fb1.html#ga2860333c4eb25602dc10a31f5f817fb1">stan::math::exp_mod_normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="separator:ga2860333c4eb25602dc10a31f5f817fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa924ac4e31732ac4be2e7328d1d7bff5"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa924ac4e31732ac4be2e7328d1d7bff5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaa924ac4e31732ac4be2e7328d1d7bff5.html#gaa924ac4e31732ac4be2e7328d1d7bff5">stan::math::exponential_cdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaa924ac4e31732ac4be2e7328d1d7bff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21b7eecccc6bcf97c9dce23b75ec6b62"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga21b7eecccc6bcf97c9dce23b75ec6b62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga21b7eecccc6bcf97c9dce23b75ec6b62.html#ga21b7eecccc6bcf97c9dce23b75ec6b62">stan::math::exponential_lccdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga21b7eecccc6bcf97c9dce23b75ec6b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f8b7c07c493376a4d55cfe84b560221"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0f8b7c07c493376a4d55cfe84b560221"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0f8b7c07c493376a4d55cfe84b560221.html#ga0f8b7c07c493376a4d55cfe84b560221">stan::math::exponential_lcdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga0f8b7c07c493376a4d55cfe84b560221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef8076d4800bf09044f6b2d3206ee8de"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaef8076d4800bf09044f6b2d3206ee8de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaef8076d4800bf09044f6b2d3206ee8de.html#gaef8076d4800bf09044f6b2d3206ee8de">stan::math::exponential_lpdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaef8076d4800bf09044f6b2d3206ee8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70979bb911b646ed0c080be88bb9123e"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga70979bb911b646ed0c080be88bb9123e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga70979bb911b646ed0c080be88bb9123e.html#ga70979bb911b646ed0c080be88bb9123e">stan::math::frechet_cdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga70979bb911b646ed0c080be88bb9123e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5ac156a8c64a383499955efb6be062c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae5ac156a8c64a383499955efb6be062c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae5ac156a8c64a383499955efb6be062c.html#gae5ac156a8c64a383499955efb6be062c">stan::math::frechet_lccdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gae5ac156a8c64a383499955efb6be062c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b1c13dae5e208ae2b700b63d3997a45"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2b1c13dae5e208ae2b700b63d3997a45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2b1c13dae5e208ae2b700b63d3997a45.html#ga2b1c13dae5e208ae2b700b63d3997a45">stan::math::frechet_lcdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga2b1c13dae5e208ae2b700b63d3997a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40919e3150ee05b80682f46cde802c22"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga40919e3150ee05b80682f46cde802c22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga40919e3150ee05b80682f46cde802c22.html#ga40919e3150ee05b80682f46cde802c22">stan::math::frechet_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga40919e3150ee05b80682f46cde802c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3964605bbb452f539ad82458a1a7cc07"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3964605bbb452f539ad82458a1a7cc07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3964605bbb452f539ad82458a1a7cc07.html#ga3964605bbb452f539ad82458a1a7cc07">stan::math::gamma_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga3964605bbb452f539ad82458a1a7cc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae66d06eb626b8357a5fc74289bfe42"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , require_all_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr, require_stan_scalar_t&lt; T_sigma &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7ae66d06eb626b8357a5fc74289bfe42"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7ae66d06eb626b8357a5fc74289bfe42.html#ga7ae66d06eb626b8357a5fc74289bfe42">stan::math::gp_dot_prod_cov</a> (const T_x &amp;x, const T_sigma sigma)</td></tr>
<tr class="separator:ga7ae66d06eb626b8357a5fc74289bfe42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb569d6717740727352a2b67d23adfc"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_y , typename T_sigma , require_all_prim_or_rev_kernel_expression_t&lt; T_x, T_y &gt; *  = nullptr, require_stan_scalar_t&lt; T_sigma &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadfb569d6717740727352a2b67d23adfc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gadfb569d6717740727352a2b67d23adfc.html#gadfb569d6717740727352a2b67d23adfc">stan::math::gp_dot_prod_cov</a> (const T_x &amp;x, const T_y &amp;y, const T_sigma sigma)</td></tr>
<tr class="separator:gadfb569d6717740727352a2b67d23adfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa686087fcae5e7016b355ceb3cf45846"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename  = require_all_arithmetic_t&lt;T1, T2, T3&gt;&gt; </td></tr>
<tr class="memitem:gaa686087fcae5e7016b355ceb3cf45846"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaa686087fcae5e7016b355ceb3cf45846.html#gaa686087fcae5e7016b355ceb3cf45846">stan::math::gp_exp_quad_cov</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="separator:gaa686087fcae5e7016b355ceb3cf45846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ebc1c13865b66015a0f30739b18b28f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename  = require_all_arithmetic_t&lt;T1, T2, T3, T4&gt;&gt; </td></tr>
<tr class="memitem:ga9ebc1c13865b66015a0f30739b18b28f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9ebc1c13865b66015a0f30739b18b28f.html#ga9ebc1c13865b66015a0f30739b18b28f">stan::math::gp_exp_quad_cov</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;x, const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="separator:ga9ebc1c13865b66015a0f30739b18b28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac47f7d0f97a1035236ac74de3b965020"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_kernel_expressions_and_none_scalar_t&lt; T1 &gt; *  = nullptr, require_all_arithmetic_t&lt; T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac47f7d0f97a1035236ac74de3b965020"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac47f7d0f97a1035236ac74de3b965020.html#gac47f7d0f97a1035236ac74de3b965020">stan::math::gp_exponential_cov</a> (const T1 &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="separator:gac47f7d0f97a1035236ac74de3b965020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63ac2500cbe6777efe781d2738148ed4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , require_all_kernel_expressions_and_none_scalar_t&lt; T1, T2 &gt; *  = nullptr, require_all_arithmetic_t&lt; T3, T4 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga63ac2500cbe6777efe781d2738148ed4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga63ac2500cbe6777efe781d2738148ed4.html#ga63ac2500cbe6777efe781d2738148ed4">stan::math::gp_exponential_cov</a> (const T1 &amp;x, const T2 &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="separator:ga63ac2500cbe6777efe781d2738148ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42d71e19927c390c7e2ca70ffe71d600"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_kernel_expressions_and_none_scalar_t&lt; T1 &gt; *  = nullptr, require_all_arithmetic_t&lt; T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga42d71e19927c390c7e2ca70ffe71d600"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga42d71e19927c390c7e2ca70ffe71d600.html#ga42d71e19927c390c7e2ca70ffe71d600">stan::math::gp_matern32_cov</a> (const T1 &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="separator:ga42d71e19927c390c7e2ca70ffe71d600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85aa537a04d32939114f7dd8b75fdc5b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , require_all_kernel_expressions_and_none_scalar_t&lt; T1, T2 &gt; *  = nullptr, require_all_arithmetic_t&lt; T3, T4 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga85aa537a04d32939114f7dd8b75fdc5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga85aa537a04d32939114f7dd8b75fdc5b.html#ga85aa537a04d32939114f7dd8b75fdc5b">stan::math::gp_matern32_cov</a> (const T1 &amp;x, const T2 &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="separator:ga85aa537a04d32939114f7dd8b75fdc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5e4b95241432025c0dbf5693659fda"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_kernel_expressions_and_none_scalar_t&lt; T1 &gt; *  = nullptr, require_all_arithmetic_t&lt; T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaea5e4b95241432025c0dbf5693659fda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaea5e4b95241432025c0dbf5693659fda.html#gaea5e4b95241432025c0dbf5693659fda">stan::math::gp_matern52_cov</a> (const T1 &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="separator:gaea5e4b95241432025c0dbf5693659fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07fab169578cad9bff602bc9c60453a7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , require_all_kernel_expressions_and_none_scalar_t&lt; T1, T2 &gt; *  = nullptr, require_all_arithmetic_t&lt; T3, T4 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga07fab169578cad9bff602bc9c60453a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga07fab169578cad9bff602bc9c60453a7.html#ga07fab169578cad9bff602bc9c60453a7">stan::math::gp_matern52_cov</a> (const T1 &amp;x, const T2 &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="separator:ga07fab169578cad9bff602bc9c60453a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b361cf5a03a7fd55cf5ab3b3d1c285d"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2b361cf5a03a7fd55cf5ab3b3d1c285d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2b361cf5a03a7fd55cf5ab3b3d1c285d.html#ga2b361cf5a03a7fd55cf5ab3b3d1c285d">stan::math::gumbel_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga2b361cf5a03a7fd55cf5ab3b3d1c285d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dded1ca1056f57bf752bccda74ae6b0"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9dded1ca1056f57bf752bccda74ae6b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9dded1ca1056f57bf752bccda74ae6b0.html#ga9dded1ca1056f57bf752bccda74ae6b0">stan::math::gumbel_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga9dded1ca1056f57bf752bccda74ae6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf55abc2c3182268292a063a51c87b6b"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabf55abc2c3182268292a063a51c87b6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gabf55abc2c3182268292a063a51c87b6b.html#gabf55abc2c3182268292a063a51c87b6b">stan::math::gumbel_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gabf55abc2c3182268292a063a51c87b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa88407c66c8c8de7bf26c1d8eadaff84"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa88407c66c8c8de7bf26c1d8eadaff84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaa88407c66c8c8de7bf26c1d8eadaff84.html#gaa88407c66c8c8de7bf26c1d8eadaff84">stan::math::gumbel_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaa88407c66c8c8de7bf26c1d8eadaff84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac32df5b5541df60cd45e329bf067f000"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac32df5b5541df60cd45e329bf067f000"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac32df5b5541df60cd45e329bf067f000.html#gac32df5b5541df60cd45e329bf067f000">stan::math::inv_chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu)</td></tr>
<tr class="separator:gac32df5b5541df60cd45e329bf067f000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0332105689b4e9992e99166c4f3e12"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7e0332105689b4e9992e99166c4f3e12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7e0332105689b4e9992e99166c4f3e12.html#ga7e0332105689b4e9992e99166c4f3e12">stan::math::inv_gamma_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga7e0332105689b4e9992e99166c4f3e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae089d318dec46d3eecab353ccedd07ab"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae089d318dec46d3eecab353ccedd07ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae089d318dec46d3eecab353ccedd07ab.html#gae089d318dec46d3eecab353ccedd07ab">stan::math::logistic_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gae089d318dec46d3eecab353ccedd07ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e1cb21d2e8927cf2458ea675ec832c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga11e1cb21d2e8927cf2458ea675ec832c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga11e1cb21d2e8927cf2458ea675ec832c.html#ga11e1cb21d2e8927cf2458ea675ec832c">stan::math::logistic_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga11e1cb21d2e8927cf2458ea675ec832c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga790f7ff43cded1271978779ae5bc5f8b"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga790f7ff43cded1271978779ae5bc5f8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga790f7ff43cded1271978779ae5bc5f8b.html#ga790f7ff43cded1271978779ae5bc5f8b">stan::math::logistic_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga790f7ff43cded1271978779ae5bc5f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aa767c6b4a5636db46932992cae075b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9aa767c6b4a5636db46932992cae075b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9aa767c6b4a5636db46932992cae075b.html#ga9aa767c6b4a5636db46932992cae075b">stan::math::logistic_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga9aa767c6b4a5636db46932992cae075b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69167b3ae3de102c803fa7b227e9d11f"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga69167b3ae3de102c803fa7b227e9d11f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga69167b3ae3de102c803fa7b227e9d11f.html#ga69167b3ae3de102c803fa7b227e9d11f">stan::math::lognormal_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga69167b3ae3de102c803fa7b227e9d11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2383f947a55d9b0ef8104fc6c84a83ad"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2383f947a55d9b0ef8104fc6c84a83ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2383f947a55d9b0ef8104fc6c84a83ad.html#ga2383f947a55d9b0ef8104fc6c84a83ad">stan::math::lognormal_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga2383f947a55d9b0ef8104fc6c84a83ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9495fcb0a2a223bbf0219e7805bbc487"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9495fcb0a2a223bbf0219e7805bbc487"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9495fcb0a2a223bbf0219e7805bbc487.html#ga9495fcb0a2a223bbf0219e7805bbc487">stan::math::lognormal_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga9495fcb0a2a223bbf0219e7805bbc487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae14854b2ed4e8eed637cdeb8f8d15dbb"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae14854b2ed4e8eed637cdeb8f8d15dbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae14854b2ed4e8eed637cdeb8f8d15dbb.html#gae14854b2ed4e8eed637cdeb8f8d15dbb">stan::math::lognormal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gae14854b2ed4e8eed637cdeb8f8d15dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dbda02859731a08444a98d74777f846"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_covar_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_covar_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3dbda02859731a08444a98d74777f846"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_covar_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3dbda02859731a08444a98d74777f846.html#ga3dbda02859731a08444a98d74777f846">stan::math::multi_normal_cholesky_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_covar_cl &amp;L)</td></tr>
<tr class="separator:ga3dbda02859731a08444a98d74777f846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed19f70ae3520d9ef8c982dace013e8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga6ed19f70ae3520d9ef8c982dace013e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6ed19f70ae3520d9ef8c982dace013e8.html#ga6ed19f70ae3520d9ef8c982dace013e8">stan::math::multiply</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="separator:ga6ed19f70ae3520d9ef8c982dace013e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb16f794da8d9e6341f2543fbab56237"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , typename T_phi_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_x_cl, T_y_cl, T_alpha_cl, T_beta_cl, T_phi_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacb16f794da8d9e6341f2543fbab56237"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x_cl, T_alpha_cl, T_beta_cl, T_phi_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gacb16f794da8d9e6341f2543fbab56237.html#gacb16f794da8d9e6341f2543fbab56237">stan::math::neg_binomial_2_log_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_phi_cl &amp;phi)</td></tr>
<tr class="separator:gacb16f794da8d9e6341f2543fbab56237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c1c0e8c6edb035b297e73193f8cd820"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_log_location_cl , typename T_precision_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7c1c0e8c6edb035b297e73193f8cd820"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7c1c0e8c6edb035b297e73193f8cd820.html#ga7c1c0e8c6edb035b297e73193f8cd820">stan::math::neg_binomial_2_log_lpmf</a> (const T_n_cl &amp;n, const T_log_location_cl &amp;eta, const T_precision_cl &amp;phi)</td></tr>
<tr class="separator:ga7c1c0e8c6edb035b297e73193f8cd820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f3956bcf1b6e3aac673b7b89f2f9b4d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_location_cl , typename T_precision_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_location_cl, T_precision_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_location_cl, T_precision_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0f3956bcf1b6e3aac673b7b89f2f9b4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_location_cl, T_precision_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0f3956bcf1b6e3aac673b7b89f2f9b4d.html#ga0f3956bcf1b6e3aac673b7b89f2f9b4d">stan::math::neg_binomial_2_lpmf</a> (const T_n_cl &amp;n, const T_location_cl &amp;mu, const T_precision_cl &amp;phi)</td></tr>
<tr class="separator:ga0f3956bcf1b6e3aac673b7b89f2f9b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacb77966b5ca780cac193dfeb6e7dc7f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_shape_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaacb77966b5ca780cac193dfeb6e7dc7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaacb77966b5ca780cac193dfeb6e7dc7f.html#gaacb77966b5ca780cac193dfeb6e7dc7f">stan::math::neg_binomial_lpmf</a> (const T_n_cl &amp;n, const T_shape_cl &amp;alpha, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaacb77966b5ca780cac193dfeb6e7dc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5778a9ae4790a5fe723a4d963f721df0"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5778a9ae4790a5fe723a4d963f721df0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5778a9ae4790a5fe723a4d963f721df0.html#ga5778a9ae4790a5fe723a4d963f721df0">stan::math::normal_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga5778a9ae4790a5fe723a4d963f721df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c799735f974356f8d1ab7743960a65"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , typename T_sigma_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_x_cl, T_y_cl, T_alpha_cl, T_beta_cl, T_sigma_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf3c799735f974356f8d1ab7743960a65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl, T_sigma_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaf3c799735f974356f8d1ab7743960a65.html#gaf3c799735f974356f8d1ab7743960a65">stan::math::normal_id_glm_lpdf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_sigma_cl &amp;sigma)</td></tr>
<tr class="separator:gaf3c799735f974356f8d1ab7743960a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ffb7c87522de6e24c7c95fa71b2e116"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4ffb7c87522de6e24c7c95fa71b2e116"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga4ffb7c87522de6e24c7c95fa71b2e116.html#ga4ffb7c87522de6e24c7c95fa71b2e116">stan::math::normal_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga4ffb7c87522de6e24c7c95fa71b2e116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7b2d28bf1c40f0f9ec609d73f1011b2"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa7b2d28bf1c40f0f9ec609d73f1011b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaa7b2d28bf1c40f0f9ec609d73f1011b2.html#gaa7b2d28bf1c40f0f9ec609d73f1011b2">stan::math::normal_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gaa7b2d28bf1c40f0f9ec609d73f1011b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab98a15165135ddb986e4f74cb66817ba"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab98a15165135ddb986e4f74cb66817ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gab98a15165135ddb986e4f74cb66817ba.html#gab98a15165135ddb986e4f74cb66817ba">stan::math::normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gab98a15165135ddb986e4f74cb66817ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga363eead878eb45fb01517e94ac7d4f4b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_beta , typename T_cuts , require_all_prim_or_rev_kernel_expression_t&lt; T_y, T_x, T_beta, T_cuts &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga363eead878eb45fb01517e94ac7d4f4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_beta, T_cuts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga363eead878eb45fb01517e94ac7d4f4b.html#ga363eead878eb45fb01517e94ac7d4f4b">stan::math::ordered_logistic_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_cuts &amp;cuts)</td></tr>
<tr class="separator:ga363eead878eb45fb01517e94ac7d4f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2fa71e9871a9b2f6f720de72177c1f3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_cuts_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_cuts_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa2fa71e9871a9b2f6f720de72177c1f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_cuts_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaa2fa71e9871a9b2f6f720de72177c1f3.html#gaa2fa71e9871a9b2f6f720de72177c1f3">stan::math::ordered_logistic_lpmf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;lambda, const T_cuts_cl &amp;cuts)</td></tr>
<tr class="separator:gaa2fa71e9871a9b2f6f720de72177c1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ac10a703e5d01d02700b4effea8d05"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga99ac10a703e5d01d02700b4effea8d05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga99ac10a703e5d01d02700b4effea8d05.html#ga99ac10a703e5d01d02700b4effea8d05">stan::math::pareto_cdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:ga99ac10a703e5d01d02700b4effea8d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4792e29b438cf1e3a244d26734ec5c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaab4792e29b438cf1e3a244d26734ec5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaab4792e29b438cf1e3a244d26734ec5c.html#gaab4792e29b438cf1e3a244d26734ec5c">stan::math::pareto_lccdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:gaab4792e29b438cf1e3a244d26734ec5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab314951f2c8314308e593e4c23b8d601"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab314951f2c8314308e593e4c23b8d601"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gab314951f2c8314308e593e4c23b8d601.html#gab314951f2c8314308e593e4c23b8d601">stan::math::pareto_lcdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:gab314951f2c8314308e593e4c23b8d601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b5e8eec1c27b30ea994f94070adc148"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7b5e8eec1c27b30ea994f94070adc148"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7b5e8eec1c27b30ea994f94070adc148.html#ga7b5e8eec1c27b30ea994f94070adc148">stan::math::pareto_lpdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:ga7b5e8eec1c27b30ea994f94070adc148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17f33022936713376f9d3e19daaf9430"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga17f33022936713376f9d3e19daaf9430"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga17f33022936713376f9d3e19daaf9430.html#ga17f33022936713376f9d3e19daaf9430">stan::math::pareto_type_2_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:ga17f33022936713376f9d3e19daaf9430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d34272be0ff43f1e882232ac4af9c0"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga72d34272be0ff43f1e882232ac4af9c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga72d34272be0ff43f1e882232ac4af9c0.html#ga72d34272be0ff43f1e882232ac4af9c0">stan::math::pareto_type_2_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:ga72d34272be0ff43f1e882232ac4af9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac04043a4074079cda307e5bc219cb4be"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac04043a4074079cda307e5bc219cb4be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac04043a4074079cda307e5bc219cb4be.html#gac04043a4074079cda307e5bc219cb4be">stan::math::pareto_type_2_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:gac04043a4074079cda307e5bc219cb4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a333811247fce0ea707ce959dffa38"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga83a333811247fce0ea707ce959dffa38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga83a333811247fce0ea707ce959dffa38.html#ga83a333811247fce0ea707ce959dffa38">stan::math::pareto_type_2_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:ga83a333811247fce0ea707ce959dffa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd6c49794202989a029ff70567f55479"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacd6c49794202989a029ff70567f55479"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x_cl, T_alpha_cl, T_beta_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gacd6c49794202989a029ff70567f55479.html#gacd6c49794202989a029ff70567f55479">stan::math::poisson_log_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gacd6c49794202989a029ff70567f55479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b1dba179f6258a2e07a30bdbe97255a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_log_rate_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_log_rate_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_log_rate_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5b1dba179f6258a2e07a30bdbe97255a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_log_rate_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5b1dba179f6258a2e07a30bdbe97255a.html#ga5b1dba179f6258a2e07a30bdbe97255a">stan::math::poisson_log_lpmf</a> (const T_n_cl &amp;n, const T_log_rate_cl &amp;alpha)</td></tr>
<tr class="separator:ga5b1dba179f6258a2e07a30bdbe97255a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfdbbaacbab1d90d71290edc806bace3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_rate_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_rate_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_rate_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabfdbbaacbab1d90d71290edc806bace3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gabfdbbaacbab1d90d71290edc806bace3.html#gabfdbbaacbab1d90d71290edc806bace3">stan::math::poisson_lpmf</a> (const T_n_cl &amp;n, const T_rate_cl &amp;lambda)</td></tr>
<tr class="separator:gabfdbbaacbab1d90d71290edc806bace3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab91408855ed53a17cd6f385acb2f43fc"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab91408855ed53a17cd6f385acb2f43fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gab91408855ed53a17cd6f385acb2f43fc.html#gab91408855ed53a17cd6f385acb2f43fc">stan::math::rayleigh_cdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gab91408855ed53a17cd6f385acb2f43fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26d27cf0c3966c101f0ea1c271f560d1"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga26d27cf0c3966c101f0ea1c271f560d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga26d27cf0c3966c101f0ea1c271f560d1.html#ga26d27cf0c3966c101f0ea1c271f560d1">stan::math::rayleigh_lccdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga26d27cf0c3966c101f0ea1c271f560d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b4eb053f40231980929911c9cb2f7b7"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1b4eb053f40231980929911c9cb2f7b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga1b4eb053f40231980929911c9cb2f7b7.html#ga1b4eb053f40231980929911c9cb2f7b7">stan::math::rayleigh_lcdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga1b4eb053f40231980929911c9cb2f7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga601d163c824e05147660da53e4099bd9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga601d163c824e05147660da53e4099bd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga601d163c824e05147660da53e4099bd9.html#ga601d163c824e05147660da53e4099bd9">stan::math::rayleigh_lpdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga601d163c824e05147660da53e4099bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bbe5a508d5789497afc2cbd03f8004c"><td class="memTemplParams" colspan="2">template&lt;typename T , require_any_t&lt; is_matrix_cl&lt; T &gt;, math::conjunction&lt; is_var&lt; T &gt;, is_matrix_cl&lt; value_type_t&lt; T &gt;&gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3bbe5a508d5789497afc2cbd03f8004c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3bbe5a508d5789497afc2cbd03f8004c.html#ga3bbe5a508d5789497afc2cbd03f8004c">stan::math::rep_array</a> (const <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="separator:ga3bbe5a508d5789497afc2cbd03f8004c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e2c7f71203a6ba2b93d5372ed6cf01e"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e2c7f71203a6ba2b93d5372ed6cf01e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5e2c7f71203a6ba2b93d5372ed6cf01e.html#ga5e2c7f71203a6ba2b93d5372ed6cf01e">stan::math::rep_matrix</a> (const <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &amp;x, int n, int m)</td></tr>
<tr class="separator:ga5e2c7f71203a6ba2b93d5372ed6cf01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f19ec991d6f0ed60695ef33003868d"><td class="memTemplParams" colspan="2">template&lt;typename T , require_arithmetic_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga78f19ec991d6f0ed60695ef33003868d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga78f19ec991d6f0ed60695ef33003868d.html#ga78f19ec991d6f0ed60695ef33003868d">stan::math::rep_matrix</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;x, int m)</td></tr>
<tr class="separator:ga78f19ec991d6f0ed60695ef33003868d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbac6d303d27c8ee22511862dce6c565"><td class="memTemplParams" colspan="2">template&lt;typename T , require_any_t&lt; is_matrix_cl&lt; T &gt;, math::conjunction&lt; is_var&lt; T &gt;, is_matrix_cl&lt; value_type_t&lt; T &gt;&gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabbac6d303d27c8ee22511862dce6c565"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gabbac6d303d27c8ee22511862dce6c565.html#gabbac6d303d27c8ee22511862dce6c565">stan::math::rep_row_vector</a> (const <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="separator:gabbac6d303d27c8ee22511862dce6c565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd9fbe441671cf2a2f88cd3e8d9b8ca8"><td class="memTemplParams" colspan="2">template&lt;typename T , require_any_t&lt; is_matrix_cl&lt; T &gt;, math::conjunction&lt; is_var&lt; T &gt;, is_matrix_cl&lt; value_type_t&lt; T &gt;&gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabd9fbe441671cf2a2f88cd3e8d9b8ca8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gabd9fbe441671cf2a2f88cd3e8d9b8ca8.html#gabd9fbe441671cf2a2f88cd3e8d9b8ca8">stan::math::rep_vector</a> (const <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="separator:gabd9fbe441671cf2a2f88cd3e8d9b8ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80392ae5670adea53e79770aa29c816a"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:ga80392ae5670adea53e79770aa29c816a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga80392ae5670adea53e79770aa29c816a.html#ga80392ae5670adea53e79770aa29c816a">stan::math::row</a> (T_x &amp;&amp;x, size_t j)</td></tr>
<tr class="separator:ga80392ae5670adea53e79770aa29c816a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61254f29c1520f4bffe4ab4e5bbd0e0e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga61254f29c1520f4bffe4ab4e5bbd0e0e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga61254f29c1520f4bffe4ab4e5bbd0e0e.html#ga61254f29c1520f4bffe4ab4e5bbd0e0e">stan::math::rows</a> (const T_x &amp;x)</td></tr>
<tr class="separator:ga61254f29c1520f4bffe4ab4e5bbd0e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga106d028bb360d5c31554ec3495cc41d0"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga106d028bb360d5c31554ec3495cc41d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga106d028bb360d5c31554ec3495cc41d0.html#ga106d028bb360d5c31554ec3495cc41d0">stan::math::scaled_inv_chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu, const T_scale_cl &amp;s)</td></tr>
<tr class="separator:ga106d028bb360d5c31554ec3495cc41d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadacfcfb973fe5c0ab2dac931e50b511e"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadacfcfb973fe5c0ab2dac931e50b511e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gadacfcfb973fe5c0ab2dac931e50b511e.html#gadacfcfb973fe5c0ab2dac931e50b511e">stan::math::skew_double_exponential_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="separator:gadacfcfb973fe5c0ab2dac931e50b511e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36ec8f9f1a5acb9c6dc9e3640a204bda"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga36ec8f9f1a5acb9c6dc9e3640a204bda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga36ec8f9f1a5acb9c6dc9e3640a204bda.html#ga36ec8f9f1a5acb9c6dc9e3640a204bda">stan::math::skew_double_exponential_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="separator:ga36ec8f9f1a5acb9c6dc9e3640a204bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f57073fbf4146f1b66cd5ea4336af7d"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9f57073fbf4146f1b66cd5ea4336af7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9f57073fbf4146f1b66cd5ea4336af7d.html#ga9f57073fbf4146f1b66cd5ea4336af7d">stan::math::skew_double_exponential_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="separator:ga9f57073fbf4146f1b66cd5ea4336af7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga354bf670629966ea8ff1397c3ea6a6a6"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga354bf670629966ea8ff1397c3ea6a6a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga354bf670629966ea8ff1397c3ea6a6a6.html#ga354bf670629966ea8ff1397c3ea6a6a6">stan::math::skew_double_exponential_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="separator:ga354bf670629966ea8ff1397c3ea6a6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac950822e01ad7173a9f42c571933eb06"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac950822e01ad7173a9f42c571933eb06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac950822e01ad7173a9f42c571933eb06.html#gac950822e01ad7173a9f42c571933eb06">stan::math::skew_normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:gac950822e01ad7173a9f42c571933eb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38acf71383b36f5db4ed878c9415b7d4"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga38acf71383b36f5db4ed878c9415b7d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga38acf71383b36f5db4ed878c9415b7d4.html#ga38acf71383b36f5db4ed878c9415b7d4">stan::math::std_normal_cdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="separator:ga38acf71383b36f5db4ed878c9415b7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d733b180253da7249ae23e4e9bda790"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3d733b180253da7249ae23e4e9bda790"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3d733b180253da7249ae23e4e9bda790.html#ga3d733b180253da7249ae23e4e9bda790">stan::math::std_normal_lccdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="separator:ga3d733b180253da7249ae23e4e9bda790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c94cfff116dc2477617f242e356ede"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac4c94cfff116dc2477617f242e356ede"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac4c94cfff116dc2477617f242e356ede.html#gac4c94cfff116dc2477617f242e356ede">stan::math::std_normal_lcdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="separator:gac4c94cfff116dc2477617f242e356ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48200e7b64861fad93fcdf7b24c8cac4"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga48200e7b64861fad93fcdf7b24c8cac4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga48200e7b64861fad93fcdf7b24c8cac4.html#ga48200e7b64861fad93fcdf7b24c8cac4">stan::math::std_normal_lpdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="separator:ga48200e7b64861fad93fcdf7b24c8cac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a3e85cdcb831735bf845adf1c42e234"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8a3e85cdcb831735bf845adf1c42e234"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga8a3e85cdcb831735bf845adf1c42e234.html#ga8a3e85cdcb831735bf845adf1c42e234">stan::math::student_t_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga8a3e85cdcb831735bf845adf1c42e234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccde2dd41ea6e10cce3f5fd53dbfa0ea"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaccde2dd41ea6e10cce3f5fd53dbfa0ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaccde2dd41ea6e10cce3f5fd53dbfa0ea.html#gaccde2dd41ea6e10cce3f5fd53dbfa0ea">stan::math::to_array_1d</a> (T_x &amp;&amp;x)</td></tr>
<tr class="separator:gaccde2dd41ea6e10cce3f5fd53dbfa0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58346dcff1afcdf893e0c0e2ab7fbe3"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae58346dcff1afcdf893e0c0e2ab7fbe3"><td class="memTemplItemLeft" align="right" valign="top">T_x&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae58346dcff1afcdf893e0c0e2ab7fbe3.html#gae58346dcff1afcdf893e0c0e2ab7fbe3">stan::math::to_array_2d</a> (T_x &amp;&amp;x)</td></tr>
<tr class="separator:gae58346dcff1afcdf893e0c0e2ab7fbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aabc784b5f56edb079f21a48efdad54"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0aabc784b5f56edb079f21a48efdad54"><td class="memTemplItemLeft" align="right" valign="top">T_x&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0aabc784b5f56edb079f21a48efdad54.html#ga0aabc784b5f56edb079f21a48efdad54">stan::math::to_matrix</a> (T_x &amp;&amp;x)</td></tr>
<tr class="separator:ga0aabc784b5f56edb079f21a48efdad54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a3715205cf6c1564a87de73c13c22a"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga08a3715205cf6c1564a87de73c13c22a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga08a3715205cf6c1564a87de73c13c22a.html#ga08a3715205cf6c1564a87de73c13c22a">stan::math::to_row_vector</a> (T_x &amp;&amp;x)</td></tr>
<tr class="separator:ga08a3715205cf6c1564a87de73c13c22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0026608053df548f73f9556ffa94dc03"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0026608053df548f73f9556ffa94dc03"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0026608053df548f73f9556ffa94dc03.html#ga0026608053df548f73f9556ffa94dc03">stan::math::to_vector</a> (T_x &amp;&amp;x)</td></tr>
<tr class="separator:ga0026608053df548f73f9556ffa94dc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e86538bd3a160cb58989ff68aa81456"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0e86538bd3a160cb58989ff68aa81456"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0e86538bd3a160cb58989ff68aa81456.html#ga0e86538bd3a160cb58989ff68aa81456">stan::math::uniform_cdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga0e86538bd3a160cb58989ff68aa81456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2dacadd5737ffbb65288cef66d1cfb7"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab2dacadd5737ffbb65288cef66d1cfb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gab2dacadd5737ffbb65288cef66d1cfb7.html#gab2dacadd5737ffbb65288cef66d1cfb7">stan::math::uniform_lccdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gab2dacadd5737ffbb65288cef66d1cfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga260dc4fb650cc809b40e338144ccbf1e"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga260dc4fb650cc809b40e338144ccbf1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga260dc4fb650cc809b40e338144ccbf1e.html#ga260dc4fb650cc809b40e338144ccbf1e">stan::math::uniform_lcdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga260dc4fb650cc809b40e338144ccbf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c081c9922500bedd293b98080c246a9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8c081c9922500bedd293b98080c246a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga8c081c9922500bedd293b98080c246a9.html#ga8c081c9922500bedd293b98080c246a9">stan::math::uniform_lpdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga8c081c9922500bedd293b98080c246a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02f96945c94514afc7c296e5ed4f461e"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga02f96945c94514afc7c296e5ed4f461e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga02f96945c94514afc7c296e5ed4f461e.html#ga02f96945c94514afc7c296e5ed4f461e">stan::math::weibull_cdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga02f96945c94514afc7c296e5ed4f461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga143c39f3c5b17a11b8fac657716a1ca8"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga143c39f3c5b17a11b8fac657716a1ca8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga143c39f3c5b17a11b8fac657716a1ca8.html#ga143c39f3c5b17a11b8fac657716a1ca8">stan::math::weibull_lccdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga143c39f3c5b17a11b8fac657716a1ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77ff0157eda0b5a11c6cacd5bcc07e42"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga77ff0157eda0b5a11c6cacd5bcc07e42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga77ff0157eda0b5a11c6cacd5bcc07e42.html#ga77ff0157eda0b5a11c6cacd5bcc07e42">stan::math::weibull_lcdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga77ff0157eda0b5a11c6cacd5bcc07e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ecf070a86a3bb30c08ced16a1c1bb32"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9ecf070a86a3bb30c08ced16a1c1bb32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9ecf070a86a3bb30c08ced16a1c1bb32.html#ga9ecf070a86a3bb30c08ced16a1c1bb32">stan::math::weibull_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga9ecf070a86a3bb30c08ced16a1c1bb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46313382ff3fae62c662662f93290572"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga46313382ff3fae62c662662f93290572"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga46313382ff3fae62c662662f93290572.html#ga46313382ff3fae62c662662f93290572">stan::math::to_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:ga46313382ff3fae62c662662f93290572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a35989520c40a236b8870762dd0db0"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga34a35989520c40a236b8870762dd0db0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga34a35989520c40a236b8870762dd0db0.html#ga34a35989520c40a236b8870762dd0db0">stan::math::to_matrix_cl</a> (const std::vector&lt; <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt;&gt; &amp;a)</td></tr>
<tr class="separator:ga34a35989520c40a236b8870762dd0db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga095903e22c477b60e69e174c307bd423"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vt&lt; is_var, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga095903e22c477b60e69e174c307bd423"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga095903e22c477b60e69e174c307bd423.html#ga095903e22c477b60e69e174c307bd423">stan::math::to_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="separator:ga095903e22c477b60e69e174c307bd423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga824d07dfec68229d759d260c865e9747"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vt&lt; is_var, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga824d07dfec68229d759d260c865e9747"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga824d07dfec68229d759d260c865e9747.html#ga824d07dfec68229d759d260c865e9747">stan::math::to_matrix_cl</a> (const std::vector&lt; T &gt; &amp;src)</td></tr>
<tr class="separator:ga824d07dfec68229d759d260c865e9747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf3e76a11e9efeae4a1215bfb67c8be"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T , require_var_vt&lt; is_eigen, T_dst &gt; *  = nullptr, require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaedf3e76a11e9efeae4a1215bfb67c8be"><td class="memTemplItemLeft" align="right" valign="top">T_dst&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaedf3e76a11e9efeae4a1215bfb67c8be.html#gaedf3e76a11e9efeae4a1215bfb67c8be">stan::math::from_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:gaedf3e76a11e9efeae4a1215bfb67c8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga016b4e7e4fd48ee3333c5c37507e3d01"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T , require_std_vector_vt&lt; is_var, T_dst &gt; *  = nullptr, require_all_stan_scalar_t&lt; value_type_t&lt; T_dst &gt;&gt; *  = nullptr, require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga016b4e7e4fd48ee3333c5c37507e3d01"><td class="memTemplItemLeft" align="right" valign="top">T_dst&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga016b4e7e4fd48ee3333c5c37507e3d01.html#ga016b4e7e4fd48ee3333c5c37507e3d01">stan::math::from_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:ga016b4e7e4fd48ee3333c5c37507e3d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeefdbbf87e96786f8460982c80c5c06f"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaeefdbbf87e96786f8460982c80c5c06f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaeefdbbf87e96786f8460982c80c5c06f.html#gaeefdbbf87e96786f8460982c80c5c06f">stan::math::from_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="separator:gaeefdbbf87e96786f8460982c80c5c06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5c33973a4c2311bf3f9284149208417"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , require_var_vt&lt; is_matrix_cl, T_ret &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf5c33973a4c2311bf3f9284149208417"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaf5c33973a4c2311bf3f9284149208417.html#gaf5c33973a4c2311bf3f9284149208417">stan::math::rep_matrix</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;A, int n, int m)</td></tr>
<tr class="separator:gaf5c33973a4c2311bf3f9284149208417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57212223aca8e2c1999b268efacecf33"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga57212223aca8e2c1999b268efacecf33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga57212223aca8e2c1999b268efacecf33.html#ga57212223aca8e2c1999b268efacecf33">stan::math::rep_matrix</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A, int m)</td></tr>
<tr class="separator:ga57212223aca8e2c1999b268efacecf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ff9a795bfa5ae75421d00a95e8a6c0"><td class="memTemplParams" colspan="2">template&lt;matrix_cl_view matrix_view = matrix_cl_view::Entire, typename T , require_matrix_cl_st&lt; std::is_floating_point, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga57ff9a795bfa5ae75421d00a95e8a6c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga57ff9a795bfa5ae75421d00a95e8a6c0.html#ga57ff9a795bfa5ae75421d00a95e8a6c0">stan::math::tri_inverse</a> (const T &amp;A)</td></tr>
<tr class="separator:ga57ff9a795bfa5ae75421d00a95e8a6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__opencl_ga8bbce98664097d5ea8e55b0b931bd721_html_ga8bbce98664097d5ea8e55b0b931bd721"><div class="ttname"><a href="group__opencl_ga8bbce98664097d5ea8e55b0b931bd721.html#ga8bbce98664097d5ea8e55b0b931bd721">stan::math::to_matrix_cl</a></div><div class="ttdeci">matrix_cl&lt; scalar_type_t&lt; T &gt; &gt; to_matrix_cl(T &amp;&amp;src)</div><div class="ttdef"><b>Definition:</b> <a href="copy_8hpp_source.html#l00045">copy.hpp:45</a></div></div>
<div class="ttc" id="agroup__opencl_gadf2a61125c6dca5e5a400d56e24cc6d5_html_gadf2a61125c6dca5e5a400d56e24cc6d5"><div class="ttname"><a href="group__opencl_gadf2a61125c6dca5e5a400d56e24cc6d5.html#gadf2a61125c6dca5e5a400d56e24cc6d5">stan::math::from_matrix_cl</a></div><div class="ttdeci">auto from_matrix_cl(const T &amp;src)</div><div class="ttdef"><b>Definition:</b> <a href="copy_8hpp_source.html#l00061">copy.hpp:61</a></div></div>
<div class="ttc" id="anamespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46_html_a61ee1c81e14d0a137cfd8bc8f1ddac46"><div class="ttname"><a href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">stan::math::vari</a></div><div class="ttdeci">vari_value&lt; double &gt; vari</div><div class="ttdef"><b>Definition:</b> <a href="rev_2core_2vari_8hpp_source.html#l00197">vari.hpp:197</a></div></div>
<div class="ttc" id="agroup__opencl__kernels_gacdabec78c1cd7feac6047ddd6289800d_html_gacdabec78c1cd7feac6047ddd6289800d"><div class="ttname"><a href="group__opencl__kernels_gacdabec78c1cd7feac6047ddd6289800d.html#gacdabec78c1cd7feac6047ddd6289800d">stan::math::opencl_kernels::cholesky_decompose</a></div><div class="ttdeci">const kernel_cl&lt; in_out_buffer, int &gt; cholesky_decompose(&quot;cholesky_decompose&quot;, {indexing_helpers, cholesky_decompose_kernel_code})</div></div>

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
