<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: stan::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="standoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">4.4.0</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacestan_1_1math.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">stan::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Matrices and templated mathematical functions. Templated probability distributions. All paramaterizations are based on Bayesian Data Analysis. Function gradients via reverse-mode automatic differentiation. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacestan_1_1math_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_1_1internal.html">internal</a></td></tr>
<tr class="memdesc:namespacestan_1_1math_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">A comparator that works for any container type that has the brackets operator. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacestan_1_1math_1_1opencl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_1_1opencl.html">opencl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacestan_1_1math_1_1opencl__kernels"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_1_1opencl__kernels.html">opencl_kernels</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1abs__fun.html">abs_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return elementwise absolute value of the specified real-valued container.  <a href="structstan_1_1math_1_1abs__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1accumulator.html">accumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to accumulate values and eventually return their sum.  <a href="classstan_1_1math_1_1accumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1accumulator_3_01_t_00_01require__var__t_3_01_t_01_4_01_4.html">accumulator&lt; T, require_var_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to accumulate values and eventually return their sum.  <a href="classstan_1_1math_1_1accumulator_3_01_t_00_01require__var__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1acos__.html">acos_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1acos__fun.html">acos_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a6952d8c23d69dc891dbe78e7d4ea7a80.html#a6952d8c23d69dc891dbe78e7d4ea7a80">acos()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1acos__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1acosh__.html">acosh_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1acosh__fun.html">acosh_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_ae033720f1a26c44aa9d7fb4dcf547155.html#ae033720f1a26c44aa9d7fb4dcf547155">acosh()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1acosh__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1ad__promotable.html">ad_promotable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1ad__tape__observer.html">ad_tape_observer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TBB observer object which is a callback hook called whenever the TBB scheduler adds a new thread to the TBB managed threadpool.  <a href="classstan_1_1math_1_1ad__tape__observer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1addition__.html">addition_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1addition__operator__.html">addition_operator_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1adjoint__results__cl.html">adjoint_results_cl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents results that are adjoints of vars in kernel generrator expressions.  <a href="classstan_1_1math_1_1adjoint__results__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1append__col__.html">append_col_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents appending of cols in kernel generator expressions.  <a href="classstan_1_1math_1_1append__col__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1append__return__type.html">append_return_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1append__return__type_3_01_eigen_1_1_matrix_3_01_t1_00_01_r_00_01_c_01_4_0055a8b04836654f8c0781baa8c862db5f.html">append_return_type&lt; Eigen::Matrix&lt; T1, R, C &gt;, Eigen::Matrix&lt; T2, R, C &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1append__return__type_3_01int_00_01int_01_4.html">append_return_type&lt; int, int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1append__return__type_3_01std_1_1vector_3_01_t1_01_4_00_01std_1_1vector_3_01_t2_01_4_01_4.html">append_return_type&lt; std::vector&lt; T1 &gt;, std::vector&lt; T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1append__row__.html">append_row_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents appending of rows in kernel generator expressions.  <a href="classstan_1_1math_1_1append__row__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary.html">apply_scalar_unary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template class for vectorization of unary scalar functions defined by a template class <code>F</code> to a scalar, standard library vector, or <a class="el" href="namespace_eigen.html">Eigen</a> dense matrix expression template.  <a href="structstan_1_1math_1_1apply__scalar__unary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01fvar_3_01_t_01_4_01_4.html">apply_scalar_unary&lt; F, fvar&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization to fvar for vectorizing a unary scalar function.  <a href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01fvar_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01std_1_1vector_3_01_t_01_4_01_4.html">apply_scalar_unary&lt; F, std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for vectorized functions applying to standard vector containers.  <a href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01std_1_1vector_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__complex__t_3_01_t_01_4_01_4.html">apply_scalar_unary&lt; F, T, require_complex_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for vectorized functions applying to complex arguments.  <a href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__complex__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html">apply_scalar_unary&lt; F, T, require_eigen_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for vectorized functions applying to <a class="el" href="namespace_eigen.html">Eigen</a> matrix arguments.  <a href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__floating__point__t_3_01_t_01_4_01_4.html">apply_scalar_unary&lt; F, T, require_floating_point_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for vectorized functions applying to double arguments.  <a href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__floating__point__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__integral__t_3_01_t_01_4_01_4.html">apply_scalar_unary&lt; F, T, require_integral_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for vectorized functions applying to integer arguments.  <a href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__integral__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__var__matrix__t_3_01_t_01_4_01_4.html">apply_scalar_unary&lt; F, T, require_var_matrix_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01var_01_4.html">apply_scalar_unary&lt; F, var &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization to var for vectorizing a unary scalar function.  <a href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01var_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__vector__unary.html">apply_vector_unary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__vector__unary_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html">apply_vector_unary&lt; T, require_eigen_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template class for vectorization of unary vector functions defined by applying a functor to a standard library vector, <a class="el" href="namespace_eigen.html">Eigen</a> dense matrix expression template, or container of these.  <a href="structstan_1_1math_1_1apply__vector__unary_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__vector__unary_3_01_t_00_01require__std__vector__vt_3_01is__containef7817cd68a98167c2f6049cb72bb785a.html">apply_vector_unary&lt; T, require_std_vector_vt&lt; is_container_or_var_matrix, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation for use with nested containers (std::vectors).  <a href="structstan_1_1math_1_1apply__vector__unary_3_01_t_00_01require__std__vector__vt_3_01is__containef7817cd68a98167c2f6049cb72bb785a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__vector__unary_3_01_t_00_01require__std__vector__vt_3_01is__stan__scalar_00_01_t_01_4_01_4.html">apply_vector_unary&lt; T, require_std_vector_vt&lt; is_stan_scalar, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation for use with (non-nested) std::vectors.  <a href="structstan_1_1math_1_1apply__vector__unary_3_01_t_00_01require__std__vector__vt_3_01is__stan__scalar_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__vector__unary_3_01_t_00_01require__var__matrix__t_3_01_t_01_4_01_4.html">apply_vector_unary&lt; T, require_var_matrix_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation for use with <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;T&gt;</code> types where T inherits from EigenBase.  <a href="structstan_1_1math_1_1apply__vector__unary_3_01_t_00_01require__var__matrix__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1arena__allocator.html">arena_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std library compatible allocator that uses AD stack.  <a href="structstan_1_1math_1_1arena__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1arena__matrix.html">arena_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>Eigen::Matrix</code>, except that the data is stored on AD stack.  <a href="classstan_1_1math_1_1arena__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1arena__matrix__cl.html">arena_matrix_cl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> that schedules its destructor to be called, so it can be used on the AD stack.  <a href="classstan_1_1math_1_1arena__matrix__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1array__builder.html">array_builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for building up arrays in an expression (rather than in statements) using an argument-chaining <a class="el" href="classstan_1_1math_1_1array__builder_abb5d8eaf023afcafdf9bc3cb63147059.html#abb5d8eaf023afcafdf9bc3cb63147059" title="Add one element of type S to array, promoting to type T.">add()</a> method and a getter method <a class="el" href="classstan_1_1math_1_1array__builder_a725410c59aa282c6b23c52fd252aa1a3.html#a725410c59aa282c6b23c52fd252aa1a3" title="Getter method to return array itself.">array()</a> to return the result.  <a href="classstan_1_1math_1_1array__builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1as__column__vector__or__scalar__.html">as_column_vector_or_scalar_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents as_column_vector_or_scalar of a row or column vector in kernel generator expressions.  <a href="classstan_1_1math_1_1as__column__vector__or__scalar__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1asin__.html">asin_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1asin__fun.html">asin_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a1ab75d0165599717cfd1e90f7edcf250.html#a1ab75d0165599717cfd1e90f7edcf250">asin()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1asin__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1asinh__.html">asinh_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1asinh__fun.html">asinh_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a68af8aec6bd04b4d40e5bce59f82b97c.html#a68af8aec6bd04b4d40e5bce59f82b97c">asinh()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1asinh__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1atan__.html">atan_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1atan__fun.html">atan_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a6f0398656b862b1b2eb80145f4877b11.html#a6f0398656b862b1b2eb80145f4877b11">atan()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1atan__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1atanh__.html">atanh_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1atanh__fun.html">atanh_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a9e31606b2cbc69573ec0d7693c8b2a2c.html#a9e31606b2cbc69573ec0d7693c8b2a2c" title="Return inverse hyperbolic tangent of specified value.">atanh()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1atanh__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1_autodiff_stack_singleton.html">AutodiffStackSingleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct always provides access to the autodiff stack using the singleton pattern.  <a href="structstan_1_1math_1_1_autodiff_stack_singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1beta__.html">beta_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1binary__operation.html">binary_operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a binary operation in kernel generator expressions.  <a href="classstan_1_1math_1_1binary__operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1binomial__coefficient__log__.html">binomial_coefficient_log_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1block__.html">block_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents submatrix block in kernel generator expressions.  <a href="classstan_1_1math_1_1block__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1broadcast__.html">broadcast_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a broadcasting operation in kernel generator expressions.  <a href="classstan_1_1math_1_1broadcast__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1calc__if__.html">calc_if_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a calc_if in kernel generator expressions.  <a href="classstan_1_1math_1_1calc__if__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1cast__.html">cast_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a typecast os scalar in kernel generator expressions.  <a href="classstan_1_1math_1_1cast__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1cbrt__.html">cbrt_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1cbrt__fun.html">cbrt_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a64c0dfe5862fc53f1a18d76f14a1dc7e.html#a64c0dfe5862fc53f1a18d76f14a1dc7e" title="Return cube root of specified argument.">cbrt()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1cbrt__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1ceil__.html">ceil_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1ceil__fun.html">ceil_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_ab1b2e9b4a947b81917612a8d1d547afb.html#ab1b2e9b4a947b81917612a8d1d547afb">ceil()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1ceil__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1chainable__alloc.html">chainable_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classstan_1_1math_1_1chainable__alloc.html" title="A chainable_alloc is an object which is constructed and destructed normally but the memory lifespan i...">chainable_alloc</a> is an object which is constructed and destructed normally but the memory lifespan is managed along with the arena allocator for the gradient calculation.  <a href="classstan_1_1math_1_1chainable__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1chainable__object.html">chainable_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classstan_1_1math_1_1chainable__object.html" title="chainable_object hold another object is useful for connecting the lifetime of a specific object to th...">chainable_object</a></code> hold another object is useful for connecting the lifetime of a specific object to the chainable stack  <a href="classstan_1_1math_1_1chainable__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1check__cl__.html">check_cl_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a check in kernel generator expressions.  <a href="classstan_1_1math_1_1check__cl__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1child__type.html">child_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1child__type_3_01_t__struct_3_01_t__child_01_4_01_4.html">child_type&lt; T_struct&lt; T_child &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1col__index.html">col_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents operation that determines column index.  <a href="classstan_1_1math_1_1col__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1colwise__max__.html">colwise_max_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents column wise max - reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1colwise__max__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1colwise__min__.html">colwise_min_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents column wise min - reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1colwise__min__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1colwise__prod__.html">colwise_prod_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents column wise product - reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1colwise__prod__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1colwise__reduction.html">colwise_reduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a column wise reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1colwise__reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1colwise__sum__.html">colwise_sum_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents column wise sum - reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1colwise__sum__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1complex__base.html">complex_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for complex numbers.  <a href="classstan_1_1math_1_1complex__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1conjunction.html">conjunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1conjunction_3_01_t_00_01_ts_8_8_8_01_4.html">conjunction&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1constant__.html">constant_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a matrix of single repeated value in kernel generator expressions.  <a href="classstan_1_1math_1_1constant__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1copysign__.html">copysign_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1cos__.html">cos_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1cos__fun.html">cos_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_ae6cb3a9041ae0b7855b398c3e11cda48.html#ae6cb3a9041ae0b7855b398c3e11cda48">cos()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1cos__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1cosh__.html">cosh_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1cosh__fun.html">cosh_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_aee4fa5213b343a52756c138107ac180b.html#aee4fa5213b343a52756c138107ac180b">cosh()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1cosh__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system.html">coupled_ode_system</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system__impl.html">coupled_ode_system_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system__impl_3_01false_00_01_f_00_01_t__y0_00_01_args_8_8_8_01_4.html">coupled_ode_system_impl&lt; false, F, T_y0, Args... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="structstan_1_1math_1_1coupled__ode__system__impl.html">coupled_ode_system_impl</a></code> template specialization when the state or parameters are autodiff types.  <a href="structstan_1_1math_1_1coupled__ode__system__impl_3_01false_00_01_f_00_01_t__y0_00_01_args_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system__impl_3_01true_00_01_f_00_01_t__y0_00_01_args_8_8_8_01_4.html">coupled_ode_system_impl&lt; true, F, T_y0, Args... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="structstan_1_1math_1_1coupled__ode__system__impl.html">coupled_ode_system_impl</a></code> for arithmetic arguments reduces to the regular ode system (there are no sensitivities)  <a href="structstan_1_1math_1_1coupled__ode__system__impl_3_01true_00_01_f_00_01_t__y0_00_01_args_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1cov__exp__quad__vari.html">cov_exp_quad_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1cov__exp__quad__vari_3_01_t__x_00_01double_00_01_t__l_01_4.html">cov_exp_quad_vari&lt; T_x, double, T_l &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1cvodes__integrator.html">cvodes_integrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrator interface for CVODES' ODE solvers (Adams &amp; BDF methods).  <a href="classstan_1_1math_1_1cvodes__integrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1cvodes__integrator__adjoint__vari.html">cvodes_integrator_adjoint_vari</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrator interface for CVODES' adjoint ODE solvers (Adams &amp; BDF methods).  <a href="classstan_1_1math_1_1cvodes__integrator__adjoint__vari.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1dae__system.html">dae_system</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDAS DAE system that contains information on residual equation functor, sensitivity residual equation functor, as well as initial conditions.  <a href="classstan_1_1math_1_1dae__system.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1diagonal__.html">diagonal_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents diagonal of a matrix (as column vector) in kernel generator expressions.  <a href="classstan_1_1math_1_1diagonal__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1digamma__.html">digamma_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1digamma__fun.html">digamma_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a69702aaa101bf602072fa7bf5fccb48a.html#a69702aaa101bf602072fa7bf5fccb48a" title="Return the derivative of the log gamma function at the specified argument.">digamma()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1digamma__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1disjunction.html">disjunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1disjunction_3_01_cond_00_01_conds_8_8_8_01_4.html">disjunction&lt; Cond, Conds... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1elt__divide__.html">elt_divide_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1elt__function__cl.html">elt_function_cl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an element-wise function in kernel generator expressions.  <a href="classstan_1_1math_1_1elt__function__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1elt__modulo__.html">elt_modulo_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1elt__multiply__.html">elt_multiply_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1equals__.html">equals_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1erf__.html">erf_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1erf__fun.html">erf_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_aa283efca22c0544054a6534443e6e762.html#aa283efca22c0544054a6534443e6e762">erf()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1erf__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1erfc__.html">erfc_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1erfc__fun.html">erfc_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap the <code><a class="el" href="namespacestan_1_1math_ab4c763e4f09069eed96a4e96e33ea8ea.html#ab4c763e4f09069eed96a4e96e33ea8ea">erfc()</a></code> so that it can be vectorized.  <a href="structstan_1_1math_1_1erfc__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1exp2__.html">exp2_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1exp2__fun.html">exp2_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a8c3a577694c8f584e56160580fe0821b.html#a8c3a577694c8f584e56160580fe0821b">exp2()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1exp2__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1exp__.html">exp_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1exp__fun.html">exp_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a11f31444e8584e4debf0d6b706d66880.html#a11f31444e8584e4debf0d6b706d66880">exp()</a></code> so that it can be vectorized.  <a href="structstan_1_1math_1_1exp__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1expm1__.html">expm1_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1expm1__fun.html">expm1_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a8a76b658b94fcf8943f4fb41c586ec94.html#a8a76b658b94fcf8943f4fb41c586ec94">expm1()</a></code> so that it can be vectorized.  <a href="structstan_1_1math_1_1expm1__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1expressions__cl.html">expressions_cl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents multiple expressions that will be calculated in same kernel.  <a href="classstan_1_1math_1_1expressions__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1fabs__.html">fabs_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1fabs__fun.html">fabs_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a6c79c9be5c64873b74f3c6924fef6911.html#a6c79c9be5c64873b74f3c6924fef6911">fabs()</a></code> so that it can be vectorized.  <a href="structstan_1_1math_1_1fabs__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1fdim__.html">fdim_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1_fixed_point_a_d_jac.html">FixedPointADJac</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Jacobian Jxy(Jacobian of unknown x w.r.t.  <a href="structstan_1_1math_1_1_fixed_point_a_d_jac.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1_fixed_point_solver.html">FixedPointSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed point solver for problem of form.  <a href="structstan_1_1math_1_1_fixed_point_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1_fixed_point_solver_3_01_kinsol_fixed_point_env_3_01_f_01_4_00_01fp__jac__type_01_4.html">FixedPointSolver&lt; KinsolFixedPointEnv&lt; F &gt;, fp_jac_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for fixed point solver when using KINSOL.  <a href="structstan_1_1math_1_1_fixed_point_solver_3_01_kinsol_fixed_point_env_3_01_f_01_4_00_01fp__jac__type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1floor__.html">floor_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1floor__fun.html">floor_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a16e5a2666b377e37fe807765ba5f6aaf.html#a16e5a2666b377e37fe807765ba5f6aaf">floor()</a></code> so that it can be vectorized.  <a href="structstan_1_1math_1_1floor__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1fmax__.html">fmax_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1fmin__.html">fmin_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1fmod__.html">fmod_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template class represents scalars used in forward-mode automatic differentiation, which consist of values and directional derivatives of the specified template type.  <a href="structstan_1_1math_1_1fvar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1gevv__vvv__vari.html">gevv_vvv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1greater__than__.html">greater_than_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1greater__than__or__equal__.html">greater_than_or_equal_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_holder.html">Holder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A no-op <a class="el" href="namespace_eigen.html">Eigen</a> operation.  <a href="classstan_1_1math_1_1_holder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1holder__cl__.html">holder_cl_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a no-op in kernel generator expressions.  <a href="classstan_1_1math_1_1holder__cl__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1hybrj__functor__solver.html">hybrj_functor_solver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor with the required operators to call <a class="el" href="namespace_eigen.html">Eigen</a>'s algebraic solver.  <a href="structstan_1_1math_1_1hybrj__functor__solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1hypot__.html">hypot_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1idas__integrator.html">idas_integrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDAS DAE integrator.  <a href="classstan_1_1math_1_1idas__integrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1idas__service.html">idas_service</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each type of Ode(with different rhs functor F and senstivity parameters), we allocate mem and workspace for idas.  <a href="structstan_1_1math_1_1idas__service.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1include__summand.html">include_summand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1include__summand_3_01propto_00_01_t_01_4.html">include_summand&lt; propto, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type.html">index_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html">index_type&lt; T, require_eigen_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4.html">index_type&lt; T, require_std_vector_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4.html">index_type&lt; T, std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1indexing__.html">indexing_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents indexing of a matrix with two matrices of indices.  <a href="classstan_1_1math_1_1indexing__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1inv__cloglog__fun.html">inv_cloglog_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_aba00ed1e73c3a2366226aa4c83e4d8b9.html#aba00ed1e73c3a2366226aa4c83e4d8b9">inv_cloglog()</a> so that it can be vectorized.  <a href="structstan_1_1math_1_1inv__cloglog__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1inv__erfc__fun.html">inv_erfc_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap the <code><a class="el" href="namespacestan_1_1math_a0863d6644325ad15404de50346785e55.html#a0863d6644325ad15404de50346785e55">inv_erfc()</a> function</code> so that it can be vectorized.  <a href="structstan_1_1math_1_1inv__erfc__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1inv__fun.html">inv_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap 1.0 / x so that it can be vectorized.  <a href="structstan_1_1math_1_1inv__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1inv__logit__.html">inv_logit_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1inv__logit__fun.html">inv_logit_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a76a22ee34432be58edb4b6ed9469370a.html#a76a22ee34432be58edb4b6ed9469370a" title="Returns the inverse logit function applied to the argument.">inv_logit()</a> so that it can be vectorized.  <a href="structstan_1_1math_1_1inv__logit__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1inv___phi__.html">inv_Phi_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1inv___phi__fun.html">inv_Phi_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a91bcae4b6bdf262f91673bf7b15fea99.html#a91bcae4b6bdf262f91673bf7b15fea99">inv_Phi()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1inv___phi__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1inv__sqrt__fun.html">inv_sqrt_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code>1 / sqrt(x)</code> so that it can be vectorized.  <a href="structstan_1_1math_1_1inv__sqrt__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1inv__square__.html">inv_square_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1isfinite__.html">isfinite_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1isinf__.html">isinf_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1isnan__.html">isnan_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1kernel__parts.html">kernel_parts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parts of an OpenCL kernel, generated by an expression.  <a href="structstan_1_1math_1_1kernel__parts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1kinsol__system__data.html">kinsol_system_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">KINSOL algebraic system data holder.  <a href="classstan_1_1math_1_1kinsol__system__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1_kinsol_fixed_point_env.html">KinsolFixedPointEnv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">KINSOL algebraic system data holder that handles construction &amp; destruction of SUNDIALS data, as well as auxiliary data that will be used for functor evaluation.  <a href="structstan_1_1math_1_1_kinsol_fixed_point_env.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1lbeta__.html">lbeta_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1ldexp__.html">ldexp_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> is a structure that holds a matrix of type T and the LDLT of its values.  <a href="classstan_1_1math_1_1_l_d_l_t__factor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor_3_01_t_00_01require__eigen__matrix__dynamic__vt_3_01is__var_00_01_t_01_4_01_4.html">LDLT_factor&lt; T, require_eigen_matrix_dynamic_vt&lt; is_var, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> of an <code>Eigen::Matrix&lt;var, Eigen::Dynamic, Eigen::Dynamic&gt;</code> with <code>alloc_in_arena = True</code> holds a copy of the input matrix and the LDLT of its values, with all member variable allocations are done in the arena.  <a href="classstan_1_1math_1_1_l_d_l_t__factor_3_01_t_00_01require__eigen__matrix__dynamic__vt_3_01is__var_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor_3_01_t_00_01require__var__matrix__t_3_01_t_01_4_01_4.html">LDLT_factor&lt; T, require_var_matrix_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> of a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Eigen::MatrixXd&gt;</code> holds a copy of the input <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code> and the LDLT of its values.  <a href="classstan_1_1math_1_1_l_d_l_t__factor_3_01_t_00_01require__var__matrix__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor_3_01_t_00_01std_1_1enable__if__t_3_01bool__constant_3_01isf4ac45f4a445d958dcf96a7b3eb9b05e.html">LDLT_factor&lt; T, std::enable_if_t&lt; bool_constant&lt; is_eigen_matrix_dynamic&lt; T &gt;::value &amp;&amp;!is_var&lt; scalar_type_t&lt; T &gt; &gt;::value &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> is a structure that holds a matrix of type T and the LDLT of its values.  <a href="classstan_1_1math_1_1_l_d_l_t__factor_3_01_t_00_01std_1_1enable__if__t_3_01bool__constant_3_01isf4ac45f4a445d958dcf96a7b3eb9b05e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1less__than__.html">less_than_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1less__than__or__equal__.html">less_than_or_equal_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1lgamma__.html">lgamma_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1lgamma__fun.html">lgamma_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_aead76f03bdbc60484ad760fc31bad40f.html#aead76f03bdbc60484ad760fc31bad40f" title="Return the natural logarithm of the gamma function applied to the specified argument.">lgamma()</a> so that it can be vectorized.  <a href="structstan_1_1math_1_1lgamma__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1lmultiply__.html">lmultiply_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1load__.html">load_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an access to a <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> in kernel generator expressions.  <a href="classstan_1_1math_1_1load__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log10__.html">log10_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log10__fun.html">log10_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a808cbb5ac4003f28e2538805ebe338ef.html#a808cbb5ac4003f28e2538805ebe338ef">log10()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1log10__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log1m__.html">log1m_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log1m__exp__.html">log1m_exp_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log1m__exp__fun.html">log1m_exp_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a7760d28e8fddf268113469b44463de07.html#a7760d28e8fddf268113469b44463de07" title="Return the natural logarithm of one minus the exponentiation of the specified argument.">log1m_exp()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1log1m__exp__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log1m__fun.html">log1m_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a8d92a982acd829e77b3f5b975baa6aed.html#a8d92a982acd829e77b3f5b975baa6aed">log1m()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1log1m__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log1m__inv__logit__.html">log1m_inv_logit_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log1m__inv__logit__fun.html">log1m_inv_logit_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a79f286f8a9043aee8a1a844493da0d55.html#a79f286f8a9043aee8a1a844493da0d55" title="Return the natural logarithm of one minus the inverse logit of the specified argument.">log1m_inv_logit()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1log1m__inv__logit__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log1p__.html">log1p_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log1p__exp__.html">log1p_exp_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log1p__exp__fun.html">log1p_exp_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a0fe928ad2b96b802f6d488ba43167489.html#a0fe928ad2b96b802f6d488ba43167489">log1p_exp()</a> so that it can be vectorized.  <a href="structstan_1_1math_1_1log1p__exp__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log1p__fun.html">log1p_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_aa16e57e82fb1e17f74ef43592748ff32.html#aa16e57e82fb1e17f74ef43592748ff32">log1p()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1log1p__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log2__.html">log2_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log2__fun.html">log2_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a4eea39b4ca603cff7518068499884364.html#a4eea39b4ca603cff7518068499884364" title="Return the base two logarithm of the specified argument.">log2()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1log2__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log__.html">log_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log__diff__exp__.html">log_diff_exp_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log__fun.html">log_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a915ada1e5971c467aa16ee926997a442.html#a915ada1e5971c467aa16ee926997a442">log()</a></code> so that it can be vectorized.  <a href="structstan_1_1math_1_1log__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log__inv__logit__.html">log_inv_logit_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log__inv__logit__diff__.html">log_inv_logit_diff_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log__inv__logit__fun.html">log_inv_logit_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_acd2fe56bce70a04dd11e8a5a32b1b51c.html#acd2fe56bce70a04dd11e8a5a32b1b51c">log_inv_logit()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1log__inv__logit__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1logical__and__.html">logical_and_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1logical__negation__.html">logical_negation_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a logical negation in kernel generator expressions.  <a href="classstan_1_1math_1_1logical__negation__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1logical__or__.html">logical_or_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1logit__.html">logit_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1logit__fun.html">logit_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_ab025eaf1e6f5c920f69c37e7a7f8b319.html#ab025eaf1e6f5c920f69c37e7a7f8b319">logit()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1logit__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an arithmetic matrix on the OpenCL device.  <a href="classstan_1_1math_1_1matrix__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1matrix__cl__base.html">matrix_cl_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-templated base class for <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> simplifies checking if something is <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>.  <a href="classstan_1_1math_1_1matrix__cl__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1matrix__exp__action__handler.html">matrix_exp_action_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of the work by Awad H.  <a href="classstan_1_1math_1_1matrix__exp__action__handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1max__2d__.html">max_2d_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents two dimensional max - reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1max__2d__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1max__op.html">max_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation for max reduction.  <a href="structstan_1_1math_1_1max__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1min__2d__.html">min_2d_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents two dimensional min - reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1min__2d__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1min__op.html">min_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation for min reduction.  <a href="structstan_1_1math_1_1min__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1mpi__cluster.html">mpi_cluster</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI cluster holds MPI resources and must be initialized only once in any MPI program.  <a href="structstan_1_1math_1_1mpi__cluster.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1mpi__command.html">mpi_command</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A MPI command object is used to execute code on worker nodes.  <a href="structstan_1_1math_1_1mpi__command.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1mpi__distributed__apply.html">mpi_distributed_apply</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI command template which calls the static method distributed_apply of the given class F.  <a href="structstan_1_1math_1_1mpi__distributed__apply.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1mpi__is__in__use.html">mpi_is_in_use</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown whenever the MPI resource is busy.  <a href="classstan_1_1math_1_1mpi__is__in__use.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1mpi__parallel__call.html">mpi_parallel_call</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MPI parallel call class manages the distributed evaluation of a collection of tasks following the map - reduce - combine pattern.  <a href="classstan_1_1math_1_1mpi__parallel__call.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1mpi__stop__listen.html">mpi_stop_listen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception used to stop workers nodes from further listening to commands send from the root.  <a href="classstan_1_1math_1_1mpi__stop__listen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1mpi__stop__worker.html">mpi_stop_worker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI command used to stop childs nodes from listening for further commands.  <a href="structstan_1_1math_1_1mpi__stop__worker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1multiply__log__.html">multiply_log_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1name__generator.html">name_generator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique name generator for variables used in generated kernels.  <a href="classstan_1_1math_1_1name__generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1nested__rev__autodiff.html">nested_rev_autodiff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class following the RAII idiom to start and recover nested autodiff scopes.  <a href="classstan_1_1math_1_1nested__rev__autodiff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1nlo__functor.html">nlo_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure which gets passed to <a class="el" href="namespace_eigen.html">Eigen</a>'s dogleg algebraic solver.  <a href="structstan_1_1math_1_1nlo__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1not__equals__.html">not_equals_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__ddv__vari.html">op_ddv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__dv__vari.html">op_dv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__dvd__vari.html">op_dvd_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__dvv__vari.html">op_dvv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__matrix__vari.html">op_matrix_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__v__vari.html">op_v_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vd__vari.html">op_vd_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vdd__vari.html">op_vdd_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vdv__vari.html">op_vdv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vector__vari.html">op_vector_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vv__vari.html">op_vv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vvd__vari.html">op_vvd_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vvv__vari.html">op_vvv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1opencl__code__.html">opencl_code_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents custom code in kernel generator expressions.  <a href="classstan_1_1math_1_1opencl__code__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1opencl__code__output.html">opencl_code_output</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents output variable of custom code in kernel generator expressions.  <a href="classstan_1_1math_1_1opencl__code__output.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1opencl__context.html">opencl_context</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1opencl__context__base.html">opencl_context_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1operands__and__partials.html">operands_and_partials</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00_01fvar_3_01_dx_01_4_01_4.html">operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, fvar&lt; Dx &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00_01var_01_4.html">operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, var &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1operation__cl.html">operation_cl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base for all kernel generator operations.  <a href="classstan_1_1math_1_1operation__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1operation__cl__lhs.html">operation_cl_lhs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base for all kernel generator operations that can be used on left hand side of an expression.  <a href="classstan_1_1math_1_1operation__cl__lhs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1optional__broadcast__.html">optional_broadcast_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an optional broadcasting operation in kernel generator expressions.  <a href="classstan_1_1math_1_1optional__broadcast__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1pass__type.html">pass_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1pass__type_3_01double_01_4.html">pass_type&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1pass__type_3_01int_01_4.html">pass_type&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_phi__.html">Phi_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_phi__approx__.html">Phi_approx_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1_phi__approx__fun.html">Phi_approx_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a628f13a708272b55a72684f3ea8dede5.html#a628f13a708272b55a72684f3ea8dede5" title="Return an approximation of the unit normal cumulative distribution function (CDF).">Phi_approx()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1_phi__approx__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1_phi__fun.html">Phi_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_ac73a2c7f20161172ffee17c7c880019f.html#ac73a2c7f20161172ffee17c7c880019f">Phi()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1_phi__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1pinned__matrix.html">pinned_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>Eigen::Matrix</code>, except that the data is stored in (hopefully pinned) memory, allocated by OpenCL driver.  <a href="classstan_1_1math_1_1pinned__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1pow__.html">pow_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1precomp__vv__vari.html">precomp_vv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1precomp__vvv__vari.html">precomp_vvv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1precomputed__gradients__vari__template.html">precomputed_gradients_vari_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable implementation taking a sequence of operands and partial derivatives with respect to the operands.  <a href="classstan_1_1math_1_1precomputed__gradients__vari__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1prod__2d__.html">prod_2d_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents two dimensional product - reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1prod__2d__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1prod__op.html">prod_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation for product reduction.  <a href="structstan_1_1math_1_1prod__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1profile.html">profile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Profiles C++ lines where the object is in scope.  <a href="classstan_1_1math_1_1profile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1profile__info.html">profile_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used for storing profiling information.  <a href="classstan_1_1math_1_1profile__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__elements.html">promote_elements</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct with static function for elementwise type promotion.  <a href="structstan_1_1math_1_1promote__elements.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__elements_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_00_01_6ab59f25ff7ec3f7c102351ffc9e92c7.html">promote_elements&lt; Eigen::Matrix&lt; T, R, C &gt;, Eigen::Matrix&lt; S, R, C &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct with static function for elementwise type promotion.  <a href="structstan_1_1math_1_1promote__elements_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_00_01_6ab59f25ff7ec3f7c102351ffc9e92c7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__elements_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_00_01_4bbb5eeca2df3769281e2a5aeb9e13c3.html">promote_elements&lt; Eigen::Matrix&lt; T, R, C &gt;, Eigen::Matrix&lt; T, R, C &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct with static function for elementwise type promotion.  <a href="structstan_1_1math_1_1promote__elements_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_00_01_4bbb5eeca2df3769281e2a5aeb9e13c3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__elements_3_01std_1_1vector_3_01_t_01_4_00_01std_1_1vector_3_01_s_01_4_01_4.html">promote_elements&lt; std::vector&lt; T &gt;, std::vector&lt; S &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct with static function for elementwise type promotion.  <a href="structstan_1_1math_1_1promote__elements_3_01std_1_1vector_3_01_t_01_4_00_01std_1_1vector_3_01_s_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__elements_3_01std_1_1vector_3_01_t_01_4_00_01std_1_1vector_3_01_t_01_4_01_4.html">promote_elements&lt; std::vector&lt; T &gt;, std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct with static function for elementwise type promotion.  <a href="structstan_1_1math_1_1promote__elements_3_01std_1_1vector_3_01_t_01_4_00_01std_1_1vector_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__elements_3_01_t_00_01_t_01_4.html">promote_elements&lt; T, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct with static function for elementwise type promotion.  <a href="structstan_1_1math_1_1promote__elements_3_01_t_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type.html">promote_scalar_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate a type for converting a convertible type.  <a href="structstan_1_1math_1_1promote__scalar__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01std_1_1tuple_3_01_promotion_scalars_8_8_8_01_4_06b2709eda18a3a5fb6e91279902bd742.html">promote_scalar_type&lt; std::tuple&lt; PromotionScalars... &gt;, std::tuple&lt; UnPromotedTypes... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_s_00_01require__all__t_3_01is__var_3_016c5eccdcd81e20b0fa598b6620378090.html">promote_scalar_type&lt; T, S, require_all_t&lt; is_var&lt; T &gt;, is_var&lt; S &gt;, is_eigen&lt; value_type_t&lt; S &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code> when the type to convert to is a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code>.  <a href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_s_00_01require__all__t_3_01is__var_3_016c5eccdcd81e20b0fa598b6620378090.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_s_00_01require__all__t_3_01std_1_1is__a40c9697fc3d0d16adcf94696b4bf67ca.html">promote_scalar_type&lt; T, S, require_all_t&lt; std::is_arithmetic&lt; T &gt;, is_var&lt; S &gt;, is_eigen&lt; value_type_t&lt; S &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code> when the type to convert to is arithmetic.  <a href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_s_00_01require__all__t_3_01std_1_1is__a40c9697fc3d0d16adcf94696b4bf67ca.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_s_00_01require__eigen__t_3_01_s_01_4_01_4.html">promote_scalar_type&lt; T, S, require_eigen_t&lt; S &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate a type for a matrix, vector, row vector or Eigen::Array whose underlying scalar is converted from the second template parameter type to the first.  <a href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_s_00_01require__eigen__t_3_01_s_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01std_1_1vector_3_01_s_01_4_01_4.html">promote_scalar_type&lt; T, std::vector&lt; S &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate a type for a container whose underlying scalar is converted from the second template parameter type to the first.  <a href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01std_1_1vector_3_01_s_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1read__fvar__functor.html">read_fvar_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for extracting the values and tangents from a matrix of fvar.  <a href="classstan_1_1math_1_1read__fvar__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1reduction__2d.html">reduction_2d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a two dimensional reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1reduction__2d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1ref__type__for__opencl.html">ref_type_for_opencl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines appropriate type for assigning expression of given type to, so that the resulting type has directly accessible contiguous colum-major data, which is needed to copy to OpenCL device for construction of <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>.  <a href="structstan_1_1math_1_1ref__type__for__opencl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1ref__type__for__opencl_3_01_t_00_01require__arena__matrix__t_3_01_t_01_4_01_4.html">ref_type_for_opencl&lt; T, require_arena_matrix_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1ref__type__for__opencl_3_01_t_00_01require__not__eigen__t_3_01_t_01_4_01_4.html">ref_type_for_opencl&lt; T, require_not_eigen_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1results__cl.html">results_cl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents results that will be calculated in same kernel.  <a href="classstan_1_1math_1_1results__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1round__.html">round_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1round__fun.html">round_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_adb73c37a4cec41a69516391a2336fb11.html#adb73c37a4cec41a69516391a2336fb11" title="Return the closest integer to the specified argument, with halfway cases rounded away from zero.">round()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1round__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1row__index.html">row_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents operation that determines row index.  <a href="classstan_1_1math_1_1row__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1rowwise__max__.html">rowwise_max_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents rowwise max reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1rowwise__max__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1rowwise__min__.html">rowwise_min_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents rowwise min reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1rowwise__min__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1rowwise__prod__.html">rowwise_prod_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents rowwise product reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1rowwise__prod__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1rowwise__reduction.html">rowwise_reduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a rowwise reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1rowwise__reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1rowwise__sum__.html">rowwise_sum_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents rowwise sum reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1rowwise__sum__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1rsqrt__.html">rsqrt_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1scalar__.html">scalar_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a scalar in kernel generator expressions.  <a href="classstan_1_1math_1_1scalar__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_scoped_chainable_stack.html">ScopedChainableStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The AD tape of reverse mode AD is by default stored globally within the process (or thread).  <a href="classstan_1_1math_1_1_scoped_chainable_stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1select__.html">select_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a selection operation in kernel generator expressions.  <a href="classstan_1_1math_1_1select__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view.html">seq_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01double_00_01std_1_1vector_3_01int_01_4_01_4.html">seq_view&lt; double, std::vector&lt; int &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_011_00_01_eigen_1_1_dynamic_01_4_01_4.html">seq_view&lt; T, Eigen::Matrix&lt; S, 1, Eigen::Dynamic &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1_dynamic_00_011_01_4_01_4.html">seq_view&lt; T, Eigen::Matrix&lt; S, Eigen::Dynamic, 1 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1_dynamic_00_01_eigen_1_1_dynamic_01_4_01_4.html">seq_view&lt; T, Eigen::Matrix&lt; S, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01std_1_1vector_3_01_s_01_4_01_4.html">seq_view&lt; T, std::vector&lt; S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01std_1_1vector_3_01std_1_1vector_3_01_t_01_4_01_4_01_4.html">seq_view&lt; T, std::vector&lt; std::vector&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01std_1_1vector_3_01_t_01_4_01_4.html">seq_view&lt; T, std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1sign__fun.html">sign_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a490231ac3d0382d97667cc0711f5b3af.html#a490231ac3d0382d97667cc0711f5b3af" title="Returns signs of the arguments.">sign()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1sign__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1sin__.html">sin_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1sin__fun.html">sin_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_aff3f2dd84567a0566cfdd7eb10e13607.html#aff3f2dd84567a0566cfdd7eb10e13607">sin()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1sin__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1sinh__.html">sinh_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1sinh__fun.html">sinh_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a646a34790ca2b692b2a8c74c4e4fb726.html#a646a34790ca2b692b2a8c74c4e4fb726">sinh()</a> so that it can be vectorized.  <a href="structstan_1_1math_1_1sinh__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1sqrt__.html">sqrt_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1sqrt__fun.html">sqrt_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_aa5231d132852d58cd3fe610221c9766f.html#aa5231d132852d58cd3fe610221c9766f">sqrt()</a></code> so that it can be vectorized.  <a href="structstan_1_1math_1_1sqrt__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1square__.html">square_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1square__fun.html">square_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_ab1ed68bdfff9b340a187964ef7684091.html#ab1ed68bdfff9b340a187964ef7684091">square()</a> so that it can be vectorized.  <a href="structstan_1_1math_1_1square__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1stack__alloc.html">stack_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance of this class provides a memory pool through which blocks of raw memory may be allocated and then collected simultaneously.  <a href="classstan_1_1math_1_1stack__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1std__normal__log__qf__fun.html">std_normal_log_qf_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a4cd6e40d63f90cc814b22b6560ab4e51.html#a4cd6e40d63f90cc814b22b6560ab4e51">std_normal_log_qf()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1std__normal__log__qf__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1step__fun.html">step_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a4ee16e810d0e707c24f7274af63f8635.html#a4ee16e810d0e707c24f7274af63f8635" title="The step, or Heaviside, function.">step()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1step__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1store__type.html">store_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1store__type_3_01double_01_4.html">store_type&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1store__type_3_01int_01_4.html">store_type&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1stored__gradient__vari.html">stored_gradient_vari</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A var implementation that stores the daughter variable implementation pointers and the partial derivative with respect to the result explicitly in arrays constructed on the autodiff memory stack.  <a href="classstan_1_1math_1_1stored__gradient__vari.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1subtraction__.html">subtraction_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1subtraction__operator__.html">subtraction_operator_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1sum__2d__.html">sum_2d_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents two dimensional sum - reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1sum__2d__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1sum__op.html">sum_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation for sum reduction.  <a href="structstan_1_1math_1_1sum__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1tan__.html">tan_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1tan__fun.html">tan_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_ae09b685b660830075f80caaf8a350676.html#ae09b685b660830075f80caaf8a350676">tan()</a></code> so that it can be vectorized.  <a href="structstan_1_1math_1_1tan__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1tanh__.html">tanh_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1tanh__fun.html">tanh_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_ae11dc45fd471bec1a19462ce58f434b8.html#ae11dc45fd471bec1a19462ce58f434b8">tanh()</a></code> so that it can be vectorized.  <a href="structstan_1_1math_1_1tanh__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1tgamma__.html">tgamma_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1tgamma__fun.html">tgamma_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a73eaf0a5d0593bb8610234e0d69e7cec.html#a73eaf0a5d0593bb8610234e0d69e7cec" title="Return the result of applying the gamma function to the specified argument.">tgamma()</a> so that it can be vectorized.  <a href="structstan_1_1math_1_1tgamma__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1to__int__fun.html">to_int_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return elementwise integer value of the specified real-valued container.  <a href="structstan_1_1math_1_1to__int__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1transpose__.html">transpose_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a transpose in kernel generator expressions.  <a href="classstan_1_1math_1_1transpose__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1trigamma__.html">trigamma_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1trigamma__fun.html">trigamma_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a3cf833bfffb0fb87dfc1d1ec81a20122.html#a3cf833bfffb0fb87dfc1d1ec81a20122" title="Return the value of the trigamma function at the specified argument (i.e., the second derivative of t...">trigamma()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1trigamma__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1trunc__.html">trunc_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1trunc__fun.html">trunc_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a79abc1d4f747b3c26c07b2b1e4871603.html#a79abc1d4f747b3c26c07b2b1e4871603" title="Return the nearest integral value that is not larger in magnitude than the specified argument.">trunc()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1trunc__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1unary__minus__.html">unary_minus_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an unary minus operation in kernel generator expressions.  <a href="classstan_1_1math_1_1unary__minus__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1unary__operation__cl.html">unary_operation_cl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a unary operation in kernel generator expressions.  <a href="classstan_1_1math_1_1unary__operation__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1unsafe__chainable__object.html">unsafe_chainable_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classstan_1_1math_1_1unsafe__chainable__object.html" title="unsafe_chainable_object hold another object and is useful for connecting the lifetime of a specific o...">unsafe_chainable_object</a></code> hold another object and is useful for connecting the lifetime of a specific object to the chainable stack.  <a href="classstan_1_1math_1_1unsafe__chainable__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1val__adj__functor.html">val_adj_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for extracting the values and adjoints from a matrix of var or vari.  <a href="classstan_1_1math_1_1val__adj__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1var__value_3_01_t_00_01internal_1_1require__matrix__var__value_3_01_t_01_4_01_4.html">var_value&lt; T, internal::require_matrix_var_value&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Independent (input) and dependent (output) variables for gradients.  <a href="classstan_1_1math_1_1var__value_3_01_t_00_01internal_1_1require__matrix__var__value_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1var__value_3_01_t_00_01require__floating__point__t_3_01_t_01_4_01_4.html">var_value&lt; T, require_floating_point_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Independent (input) and dependent (output) variables for gradients.  <a href="classstan_1_1math_1_1var__value_3_01_t_00_01require__floating__point__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__base.html">vari_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class that all <code><a class="el" href="classstan_1_1math_1_1vari__value.html">vari_value</a></code> and it's derived classes inherit.  <a href="classstan_1_1math_1_1vari__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__cl__base.html">vari_cl_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__value.html">vari_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__value_3_01_t_00_01require__all__t_3_01is__plain__type_3_01_t_01_4_00_668033d9a4bfddcaba56f859af1eb1d1.html">vari_value&lt; T, require_all_t&lt; is_plain_type&lt; T &gt;, is_eigen_dense_base&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable implementation for <a class="el" href="namespace_eigen.html">Eigen</a> dense matrix types.  <a href="classstan_1_1math_1_1vari__value_3_01_t_00_01require__all__t_3_01is__plain__type_3_01_t_01_4_00_668033d9a4bfddcaba56f859af1eb1d1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__value_3_01_t_00_01require__eigen__sparse__base__t_3_01_t_01_4_01_4.html">vari_value&lt; T, require_eigen_sparse_base_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable implementation for <a class="el" href="namespace_eigen.html">Eigen</a> sparse matrix types.  <a href="classstan_1_1math_1_1vari__value_3_01_t_00_01require__eigen__sparse__base__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__value_3_01_t_00_01require__matrix__cl__t_3_01_t_01_4_01_4.html">vari_value&lt; T, require_matrix_cl_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable implementation for <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code>.  <a href="classstan_1_1math_1_1vari__value_3_01_t_00_01require__matrix__cl__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__value_3_01_t_00_01require__t_3_01std_1_1is__floating__point_3_01_t_01_4_01_4_01_4.html">vari_value&lt; T, require_t&lt; std::is_floating_point&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable implementation for floating point types.  <a href="classstan_1_1math_1_1vari__value_3_01_t_00_01require__t_3_01std_1_1is__floating__point_3_01_t_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__view.html">vari_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classstan_1_1math_1_1vari__view.html" title="A vari_view is used to read from a slice of a vari_value with an inner eigen type.">vari_view</a></code> is used to read from a slice of a <code><a class="el" href="classstan_1_1math_1_1vari__value.html">vari_value</a></code> with an inner eigen type.  <a href="classstan_1_1math_1_1vari__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__view_3_01_t_00_01require__all__t_3_01is__eigen_3_01_t_01_4_00_01bool_d1f607cdd61996bbd47cd360a469bd85.html">vari_view&lt; T, require_all_t&lt; is_eigen&lt; T &gt;, bool_constant&lt;!is_plain_type&lt; T &gt;::value &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__view_3_01_t_00_01require__kernel__expression__lhs__t_3_01_t_01_4_01_4.html">vari_view&lt; T, require_kernel_expression_lhs_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__view__eigen.html">vari_view_eigen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is follows the CRTP for methods common to <code><a class="el" href="classstan_1_1math_1_1vari__view.html" title="A vari_view is used to read from a slice of a vari_value with an inner eigen type.">vari_view</a>&lt;&gt;</code> and <code><a class="el" href="classstan_1_1math_1_1vari__value.html">vari_value</a>&lt;Matrix&gt;</code>.  <a href="classstan_1_1math_1_1vari__view__eigen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vi__adj__functor.html">vi_adj_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for extracting the varis and adjoints from a matrix of var.  <a href="classstan_1_1math_1_1vi__adj__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vi__val__adj__functor.html">vi_val_adj_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for extracting the vari*, values, and adjoints from a matrix of var.  <a href="classstan_1_1math_1_1vi__val__adj__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vi__val__functor.html">vi_val_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for extracting the varis and values from a matrix of var.  <a href="classstan_1_1math_1_1vi__val__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1welford__covar__estimator.html">welford_covar_estimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1welford__var__estimator.html">welford_var_estimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a98ff1baf06b8c5e2fc241bba99d0a97d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a98ff1baf06b8c5e2fc241bba99d0a97d.html#a98ff1baf06b8c5e2fc241bba99d0a97d">size_type</a> = Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt;::Index</td></tr>
<tr class="memdesc:a98ff1baf06b8c5e2fc241bba99d0a97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for sizes and indexes in an <a class="el" href="namespace_eigen.html">Eigen</a> matrix with double elements.  <a href="namespacestan_1_1math_a98ff1baf06b8c5e2fc241bba99d0a97d.html#a98ff1baf06b8c5e2fc241bba99d0a97d">More...</a><br /></td></tr>
<tr class="separator:a98ff1baf06b8c5e2fc241bba99d0a97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7898e4d60b5aa24048803800dcb92615"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7898e4d60b5aa24048803800dcb92615.html#a7898e4d60b5aa24048803800dcb92615">matrix_fd</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; double &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a7898e4d60b5aa24048803800dcb92615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcca60033395307902857ddcf00d7e7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1bcca60033395307902857ddcf00d7e7.html#a1bcca60033395307902857ddcf00d7e7">matrix_ffd</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; double &gt; &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a1bcca60033395307902857ddcf00d7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a24a6f0fc822a9aea9fd4429305e3a4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7a24a6f0fc822a9aea9fd4429305e3a4.html#a7a24a6f0fc822a9aea9fd4429305e3a4">vector_fd</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; double &gt;, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:a7a24a6f0fc822a9aea9fd4429305e3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db34b298ebf1a5b3c72826ba0c68109"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9db34b298ebf1a5b3c72826ba0c68109.html#a9db34b298ebf1a5b3c72826ba0c68109">vector_ffd</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; double &gt; &gt;, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:a9db34b298ebf1a5b3c72826ba0c68109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29cb25574a0d858496122b9ff6a1fee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa29cb25574a0d858496122b9ff6a1fee.html#aa29cb25574a0d858496122b9ff6a1fee">row_vector_fd</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; double &gt;, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:aa29cb25574a0d858496122b9ff6a1fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b230b5832302359ccf4437bd70cb88"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac3b230b5832302359ccf4437bd70cb88.html#ac3b230b5832302359ccf4437bd70cb88">row_vector_ffd</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; double &gt; &gt;, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:ac3b230b5832302359ccf4437bd70cb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e63f5c51a7bf76fdacf93d54b150e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa4e63f5c51a7bf76fdacf93d54b150e6.html#aa4e63f5c51a7bf76fdacf93d54b150e6">matrix_fv</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:aa4e63f5c51a7bf76fdacf93d54b150e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e35797725b8511533174aa1eec85a50"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4e35797725b8511533174aa1eec85a50.html#a4e35797725b8511533174aa1eec85a50">matrix_ffv</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a4e35797725b8511533174aa1eec85a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf25849f264623f024b4f6dc48b4c1a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abaf25849f264623f024b4f6dc48b4c1a.html#abaf25849f264623f024b4f6dc48b4c1a">vector_fv</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:abaf25849f264623f024b4f6dc48b4c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae794f45250a72fb1b3f25bcb8f9c6df6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae794f45250a72fb1b3f25bcb8f9c6df6.html#ae794f45250a72fb1b3f25bcb8f9c6df6">vector_ffv</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &gt;, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:ae794f45250a72fb1b3f25bcb8f9c6df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14c80b2ada12fd626e3420a69383fad"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af14c80b2ada12fd626e3420a69383fad.html#af14c80b2ada12fd626e3420a69383fad">row_vector_fv</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:af14c80b2ada12fd626e3420a69383fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0339be280ad62d6dc20d9527b03d46d1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0339be280ad62d6dc20d9527b03d46d1.html#a0339be280ad62d6dc20d9527b03d46d1">row_vector_ffv</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &gt;, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a0339be280ad62d6dc20d9527b03d46d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ba0bf1e3380fb336f20163a4e7e6723"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3ba0bf1e3380fb336f20163a4e7e6723"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a> = std::conditional_t&lt; std::is_lvalue_reference&lt; T &gt;::value, decltype(<a class="el" href="group__opencl__kernel__generator_ga6f7bbba2d8808d1fb7b4264f244d710a.html#ga6f7bbba2d8808d1fb7b4264f244d710a">as_operation_cl</a>(std::declval&lt; T &gt;())), std::remove_reference_t&lt; decltype(<a class="el" href="group__opencl__kernel__generator_ga6f7bbba2d8808d1fb7b4264f244d710a.html#ga6f7bbba2d8808d1fb7b4264f244d710a">as_operation_cl</a>(std::declval&lt; T &gt;()))&gt; &gt;</td></tr>
<tr class="memdesc:ga3ba0bf1e3380fb336f20163a4e7e6723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that results when converting any valid kernel generator expression into operation.  <a href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">More...</a><br /></td></tr>
<tr class="separator:ga3ba0bf1e3380fb336f20163a4e7e6723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac08c412f337e77ef2acea8890a1e3f75"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac08c412f337e77ef2acea8890a1e3f75"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gac08c412f337e77ef2acea8890a1e3f75.html#gac08c412f337e77ef2acea8890a1e3f75">is_without_output</a> = <a class="el" href="structstan_1_1math_1_1internal_1_1is__without__output__impl.html">internal::is_without_output_impl</a>&lt; std::decay_t&lt; T &gt; &gt;</td></tr>
<tr class="separator:gac08c412f337e77ef2acea8890a1e3f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga885842e4dc32fa88f0a50f24344e854f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga885842e4dc32fa88f0a50f24344e854f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga885842e4dc32fa88f0a50f24344e854f.html#ga885842e4dc32fa88f0a50f24344e854f">is_colwise_reduction</a> = <a class="el" href="structstan_1_1math_1_1internal_1_1is__colwise__reduction__impl.html">internal::is_colwise_reduction_impl</a>&lt; std::decay_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga885842e4dc32fa88f0a50f24344e854f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a kernel generator expression is a colwise reduction.  <a href="group__opencl__kernel__generator_ga885842e4dc32fa88f0a50f24344e854f.html#ga885842e4dc32fa88f0a50f24344e854f">More...</a><br /></td></tr>
<tr class="separator:ga885842e4dc32fa88f0a50f24344e854f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861ef063af54567bfa6b90a8bfd8d0bc"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a861ef063af54567bfa6b90a8bfd8d0bc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a861ef063af54567bfa6b90a8bfd8d0bc.html#a861ef063af54567bfa6b90a8bfd8d0bc">common_scalar_t</a> = typename std::common_type_t&lt; typename std::remove_reference_t&lt; Types &gt;::Scalar... &gt;</td></tr>
<tr class="separator:a861ef063af54567bfa6b90a8bfd8d0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac046f4a23bff8176c919a8a7f7dfdf6e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac046f4a23bff8176c919a8a7f7dfdf6e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gac046f4a23bff8176c919a8a7f7dfdf6e.html#gac046f4a23bff8176c919a8a7f7dfdf6e">is_reduction_2d</a> = <a class="el" href="structstan_1_1math_1_1internal_1_1is__reduction__2d__impl.html">internal::is_reduction_2d_impl</a>&lt; std::decay_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:gac046f4a23bff8176c919a8a7f7dfdf6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a kernel generator expression is a colwise reduction.  <a href="group__opencl__kernel__generator_gac046f4a23bff8176c919a8a7f7dfdf6e.html#gac046f4a23bff8176c919a8a7f7dfdf6e">More...</a><br /></td></tr>
<tr class="separator:gac046f4a23bff8176c919a8a7f7dfdf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fb6779eb99f22b6b0ce2662e630e78"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a89fb6779eb99f22b6b0ce2662e630e78"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a89fb6779eb99f22b6b0ce2662e630e78.html#a89fb6779eb99f22b6b0ce2662e630e78">ref_type_for_opencl_t</a> = typename <a class="el" href="structstan_1_1math_1_1ref__type__for__opencl.html">ref_type_for_opencl</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a89fb6779eb99f22b6b0ce2662e630e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8ebba551a7f21f55b348e6af8c9264"><td class="memTemplParams" colspan="2">template&lt;int B = 0&gt; </td></tr>
<tr class="memitem:adb8ebba551a7f21f55b348e6af8c9264"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adb8ebba551a7f21f55b348e6af8c9264.html#adb8ebba551a7f21f55b348e6af8c9264">boost_policy_t</a> = boost::math::policies::policy&lt; boost::math::policies::overflow_error&lt; boost::math::policies::errno_on_error &gt;, boost::math::policies::pole_error&lt; boost::math::policies::errno_on_error &gt;, boost::math::policies::promote_double&lt; false &gt;, boost::math::policies::digits2&lt; B &gt; &gt;</td></tr>
<tr class="memdesc:adb8ebba551a7f21f55b348e6af8c9264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boost policy that overrides the defaults to match the built-in C++ standard library functions.  <a href="namespacestan_1_1math_adb8ebba551a7f21f55b348e6af8c9264.html#adb8ebba551a7f21f55b348e6af8c9264">More...</a><br /></td></tr>
<tr class="separator:adb8ebba551a7f21f55b348e6af8c9264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2e8a0b7c1cca979b7ff43cbb75ca65"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aca2e8a0b7c1cca979b7ff43cbb75ca65.html#aca2e8a0b7c1cca979b7ff43cbb75ca65">matrix_d</a> = Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:aca2e8a0b7c1cca979b7ff43cbb75ca65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for matrix of double values.  <a href="namespacestan_1_1math_aca2e8a0b7c1cca979b7ff43cbb75ca65.html#aca2e8a0b7c1cca979b7ff43cbb75ca65">More...</a><br /></td></tr>
<tr class="separator:aca2e8a0b7c1cca979b7ff43cbb75ca65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4954408ac287ec405ca9b7bf59b3c19b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4954408ac287ec405ca9b7bf59b3c19b.html#a4954408ac287ec405ca9b7bf59b3c19b">vector_d</a> = Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:a4954408ac287ec405ca9b7bf59b3c19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for (column) vector of double values.  <a href="namespacestan_1_1math_a4954408ac287ec405ca9b7bf59b3c19b.html#a4954408ac287ec405ca9b7bf59b3c19b">More...</a><br /></td></tr>
<tr class="separator:a4954408ac287ec405ca9b7bf59b3c19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc78fff4ae93add582ece429d038796a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abc78fff4ae93add582ece429d038796a.html#abc78fff4ae93add582ece429d038796a">row_vector_d</a> = Eigen::Matrix&lt; double, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:abc78fff4ae93add582ece429d038796a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for (row) vector of double values.  <a href="namespacestan_1_1math_abc78fff4ae93add582ece429d038796a.html#abc78fff4ae93add582ece429d038796a">More...</a><br /></td></tr>
<tr class="separator:abc78fff4ae93add582ece429d038796a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26415bab11ad81529d0773ea8aeed544"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a26415bab11ad81529d0773ea8aeed544"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a26415bab11ad81529d0773ea8aeed544.html#a26415bab11ad81529d0773ea8aeed544">index_type_t</a> = typename <a class="el" href="structstan_1_1math_1_1index__type.html">index_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a26415bab11ad81529d0773ea8aeed544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b6bf9b25698d56ae968681706311e4f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4b6bf9b25698d56ae968681706311e4f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_ga4b6bf9b25698d56ae968681706311e4f.html#ga4b6bf9b25698d56ae968681706311e4f">require_tuple_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; std::decay_t&lt; T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ga4b6bf9b25698d56ae968681706311e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_ga4b6bf9b25698d56ae968681706311e4f.html#ga4b6bf9b25698d56ae968681706311e4f">More...</a><br /></td></tr>
<tr class="separator:ga4b6bf9b25698d56ae968681706311e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8bc1c269392118c7eeea2f62a1554b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae8bc1c269392118c7eeea2f62a1554b8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_gae8bc1c269392118c7eeea2f62a1554b8.html#gae8bc1c269392118c7eeea2f62a1554b8">require_not_tuple_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; std::decay_t&lt; T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:gae8bc1c269392118c7eeea2f62a1554b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_gae8bc1c269392118c7eeea2f62a1554b8.html#gae8bc1c269392118c7eeea2f62a1554b8">More...</a><br /></td></tr>
<tr class="separator:gae8bc1c269392118c7eeea2f62a1554b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb16e2de1e255855c6f33f4a902b9d93"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gafb16e2de1e255855c6f33f4a902b9d93"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_gafb16e2de1e255855c6f33f4a902b9d93.html#gafb16e2de1e255855c6f33f4a902b9d93">require_all_tuple_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gafb16e2de1e255855c6f33f4a902b9d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_gafb16e2de1e255855c6f33f4a902b9d93.html#gafb16e2de1e255855c6f33f4a902b9d93">More...</a><br /></td></tr>
<tr class="separator:gafb16e2de1e255855c6f33f4a902b9d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeefd309f064a1a0fd204cac828450541"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaeefd309f064a1a0fd204cac828450541"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_gaeefd309f064a1a0fd204cac828450541.html#gaeefd309f064a1a0fd204cac828450541">require_any_tuple_t</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaeefd309f064a1a0fd204cac828450541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the types satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_gaeefd309f064a1a0fd204cac828450541.html#gaeefd309f064a1a0fd204cac828450541">More...</a><br /></td></tr>
<tr class="separator:gaeefd309f064a1a0fd204cac828450541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad46679eb9ad8a8dc13dc990a34f2f40f"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gad46679eb9ad8a8dc13dc990a34f2f40f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_gad46679eb9ad8a8dc13dc990a34f2f40f.html#gad46679eb9ad8a8dc13dc990a34f2f40f">require_all_not_tuple_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gad46679eb9ad8a8dc13dc990a34f2f40f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_gad46679eb9ad8a8dc13dc990a34f2f40f.html#gad46679eb9ad8a8dc13dc990a34f2f40f">More...</a><br /></td></tr>
<tr class="separator:gad46679eb9ad8a8dc13dc990a34f2f40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabd887c025dd6565398836f57074b9f9"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:gaabd887c025dd6565398836f57074b9f9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_gaabd887c025dd6565398836f57074b9f9.html#gaabd887c025dd6565398836f57074b9f9">require_any_not_tuple_t</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:gaabd887c025dd6565398836f57074b9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the types do not satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_gaabd887c025dd6565398836f57074b9f9.html#gaabd887c025dd6565398836f57074b9f9">More...</a><br /></td></tr>
<tr class="separator:gaabd887c025dd6565398836f57074b9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a7b94d7d24bca53982541eeb458246c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5a7b94d7d24bca53982541eeb458246c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_ga5a7b94d7d24bca53982541eeb458246c.html#ga5a7b94d7d24bca53982541eeb458246c">require_vt_tuple</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:ga5a7b94d7d24bca53982541eeb458246c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require value type satisfies <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_ga5a7b94d7d24bca53982541eeb458246c.html#ga5a7b94d7d24bca53982541eeb458246c">More...</a><br /></td></tr>
<tr class="separator:ga5a7b94d7d24bca53982541eeb458246c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab097a47bc0f89d9cd0e3aa5decf05cd0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab097a47bc0f89d9cd0e3aa5decf05cd0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_gab097a47bc0f89d9cd0e3aa5decf05cd0.html#gab097a47bc0f89d9cd0e3aa5decf05cd0">require_not_vt_tuple</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:gab097a47bc0f89d9cd0e3aa5decf05cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require value type does not satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_gab097a47bc0f89d9cd0e3aa5decf05cd0.html#gab097a47bc0f89d9cd0e3aa5decf05cd0">More...</a><br /></td></tr>
<tr class="separator:gab097a47bc0f89d9cd0e3aa5decf05cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45f68664aec66724a0eec05a841a65f7"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga45f68664aec66724a0eec05a841a65f7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_ga45f68664aec66724a0eec05a841a65f7.html#ga45f68664aec66724a0eec05a841a65f7">require_all_vt_tuple</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt;&gt;... &gt;</td></tr>
<tr class="memdesc:ga45f68664aec66724a0eec05a841a65f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the value types satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_ga45f68664aec66724a0eec05a841a65f7.html#ga45f68664aec66724a0eec05a841a65f7">More...</a><br /></td></tr>
<tr class="separator:ga45f68664aec66724a0eec05a841a65f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dd759f8af6d9935e9cc509b20ca3e1d"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga4dd759f8af6d9935e9cc509b20ca3e1d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_ga4dd759f8af6d9935e9cc509b20ca3e1d.html#ga4dd759f8af6d9935e9cc509b20ca3e1d">require_any_vt_tuple</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt;&gt;... &gt;</td></tr>
<tr class="memdesc:ga4dd759f8af6d9935e9cc509b20ca3e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the value types satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_ga4dd759f8af6d9935e9cc509b20ca3e1d.html#ga4dd759f8af6d9935e9cc509b20ca3e1d">More...</a><br /></td></tr>
<tr class="separator:ga4dd759f8af6d9935e9cc509b20ca3e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga319763b18499e97c5ecf598d1501fd59"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga319763b18499e97c5ecf598d1501fd59"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_ga319763b18499e97c5ecf598d1501fd59.html#ga319763b18499e97c5ecf598d1501fd59">require_all_not_vt_tuple</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt;&gt;... &gt;</td></tr>
<tr class="memdesc:ga319763b18499e97c5ecf598d1501fd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the value types satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_ga319763b18499e97c5ecf598d1501fd59.html#ga319763b18499e97c5ecf598d1501fd59">More...</a><br /></td></tr>
<tr class="separator:ga319763b18499e97c5ecf598d1501fd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga874f1f28a99917992061216be1de2782"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga874f1f28a99917992061216be1de2782"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_ga874f1f28a99917992061216be1de2782.html#ga874f1f28a99917992061216be1de2782">require_any_not_vt_tuple</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt;&gt;... &gt;</td></tr>
<tr class="memdesc:ga874f1f28a99917992061216be1de2782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require at least one of the value types do not satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_ga874f1f28a99917992061216be1de2782.html#ga874f1f28a99917992061216be1de2782">More...</a><br /></td></tr>
<tr class="separator:ga874f1f28a99917992061216be1de2782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8af08e7c936c609497004b295df86ebb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8af08e7c936c609497004b295df86ebb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_ga8af08e7c936c609497004b295df86ebb.html#ga8af08e7c936c609497004b295df86ebb">require_st_tuple</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:ga8af08e7c936c609497004b295df86ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require scalar type satisfies <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_ga8af08e7c936c609497004b295df86ebb.html#ga8af08e7c936c609497004b295df86ebb">More...</a><br /></td></tr>
<tr class="separator:ga8af08e7c936c609497004b295df86ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5275ba2241fd2e6a1b588f80c2a8db99"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5275ba2241fd2e6a1b588f80c2a8db99"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_ga5275ba2241fd2e6a1b588f80c2a8db99.html#ga5275ba2241fd2e6a1b588f80c2a8db99">require_not_st_tuple</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; T &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:ga5275ba2241fd2e6a1b588f80c2a8db99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require scalar type does not satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_ga5275ba2241fd2e6a1b588f80c2a8db99.html#ga5275ba2241fd2e6a1b588f80c2a8db99">More...</a><br /></td></tr>
<tr class="separator:ga5275ba2241fd2e6a1b588f80c2a8db99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ac540611283346dfea4f0ceb7f87abf"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga6ac540611283346dfea4f0ceb7f87abf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_ga6ac540611283346dfea4f0ceb7f87abf.html#ga6ac540611283346dfea4f0ceb7f87abf">require_all_st_tuple</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt;&gt;... &gt;</td></tr>
<tr class="memdesc:ga6ac540611283346dfea4f0ceb7f87abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the scalar types satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_ga6ac540611283346dfea4f0ceb7f87abf.html#ga6ac540611283346dfea4f0ceb7f87abf">More...</a><br /></td></tr>
<tr class="separator:ga6ac540611283346dfea4f0ceb7f87abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eef890725d3f5121270890ceb4c0d11"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga5eef890725d3f5121270890ceb4c0d11"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_ga5eef890725d3f5121270890ceb4c0d11.html#ga5eef890725d3f5121270890ceb4c0d11">require_any_st_tuple</a> = <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt;&gt;... &gt;</td></tr>
<tr class="memdesc:ga5eef890725d3f5121270890ceb4c0d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require any of the scalar types satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_ga5eef890725d3f5121270890ceb4c0d11.html#ga5eef890725d3f5121270890ceb4c0d11">More...</a><br /></td></tr>
<tr class="separator:ga5eef890725d3f5121270890ceb4c0d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga093594db5ceab8ce8fb71df5f16dd0e0"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga093594db5ceab8ce8fb71df5f16dd0e0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_ga093594db5ceab8ce8fb71df5f16dd0e0.html#ga093594db5ceab8ce8fb71df5f16dd0e0">require_all_not_st_tuple</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt;&gt;... &gt;</td></tr>
<tr class="memdesc:ga093594db5ceab8ce8fb71df5f16dd0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the scalar types satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_ga093594db5ceab8ce8fb71df5f16dd0e0.html#ga093594db5ceab8ce8fb71df5f16dd0e0">More...</a><br /></td></tr>
<tr class="separator:ga093594db5ceab8ce8fb71df5f16dd0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga998aece7fee81d6754c0ccafdf8dbb1c"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga998aece7fee81d6754c0ccafdf8dbb1c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_ga998aece7fee81d6754c0ccafdf8dbb1c.html#ga998aece7fee81d6754c0ccafdf8dbb1c">require_any_not_st_tuple</a> = <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; std::decay_t&lt; Types &gt; &gt;&gt;... &gt;</td></tr>
<tr class="memdesc:ga998aece7fee81d6754c0ccafdf8dbb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any of the scalar types do not satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a> <br  />
  <a href="group__tuple__types_ga998aece7fee81d6754c0ccafdf8dbb1c.html#ga998aece7fee81d6754c0ccafdf8dbb1c">More...</a><br /></td></tr>
<tr class="separator:ga998aece7fee81d6754c0ccafdf8dbb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe75d9025a62ed58292f17f09ce61da"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a3fe75d9025a62ed58292f17f09ce61da"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">promote_scalar_t</a> = typename <a class="el" href="structstan_1_1math_1_1promote__scalar__type.html">promote_scalar_type</a>&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; S &gt; &gt;::type</td></tr>
<tr class="separator:a3fe75d9025a62ed58292f17f09ce61da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1478180b7648f5b65e0ba8d884577196"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1478180b7648f5b65e0ba8d884577196.html#a1478180b7648f5b65e0ba8d884577196">ChainableStack</a> = <a class="el" href="structstan_1_1math_1_1_autodiff_stack_singleton.html">AutodiffStackSingleton</a>&lt; <a class="el" href="classstan_1_1math_1_1vari__base.html">vari_base</a>, <a class="el" href="classstan_1_1math_1_1chainable__alloc.html">chainable_alloc</a> &gt;</td></tr>
<tr class="separator:a1478180b7648f5b65e0ba8d884577196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49098e039d56b27054ae93e6644d847"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac49098e039d56b27054ae93e6644d847.html#ac49098e039d56b27054ae93e6644d847">precomputed_gradients_vari</a> = <a class="el" href="classstan_1_1math_1_1precomputed__gradients__vari__template.html">precomputed_gradients_vari_template</a>&lt; std::tuple&lt;&gt;, std::tuple&lt;&gt; &gt;</td></tr>
<tr class="separator:ac49098e039d56b27054ae93e6644d847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab94f7d025f462907958259d7246d43"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeab94f7d025f462907958259d7246d43.html#aeab94f7d025f462907958259d7246d43">profile_key</a> = std::pair&lt; std::string, std::thread::id &gt;</td></tr>
<tr class="separator:aeab94f7d025f462907958259d7246d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84d5e99a0ace79bcb3ae9039c83435b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa84d5e99a0ace79bcb3ae9039c83435b.html#aa84d5e99a0ace79bcb3ae9039c83435b">profile_map</a> = std::map&lt; <a class="el" href="namespacestan_1_1math_aeab94f7d025f462907958259d7246d43.html#aeab94f7d025f462907958259d7246d43">profile_key</a>, <a class="el" href="classstan_1_1math_1_1profile__info.html">profile_info</a> &gt;</td></tr>
<tr class="separator:aa84d5e99a0ace79bcb3ae9039c83435b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1b132685d7ca52bbeb05731a5674d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3a1b132685d7ca52bbeb05731a5674d5.html#a3a1b132685d7ca52bbeb05731a5674d5">matrix_v</a> = Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a3a1b132685d7ca52bbeb05731a5674d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a matrix holding <code>var</code> values.  <a href="namespacestan_1_1math_a3a1b132685d7ca52bbeb05731a5674d5.html#a3a1b132685d7ca52bbeb05731a5674d5">More...</a><br /></td></tr>
<tr class="separator:a3a1b132685d7ca52bbeb05731a5674d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8c89394ec1b09c99d6a5bd2eabfba5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab8c89394ec1b09c99d6a5bd2eabfba5.html#aab8c89394ec1b09c99d6a5bd2eabfba5">vector_v</a> = Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:aab8c89394ec1b09c99d6a5bd2eabfba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a (column) vector holding <code>var</code> values.  <a href="namespacestan_1_1math_aab8c89394ec1b09c99d6a5bd2eabfba5.html#aab8c89394ec1b09c99d6a5bd2eabfba5">More...</a><br /></td></tr>
<tr class="separator:aab8c89394ec1b09c99d6a5bd2eabfba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42483d058e437874b89ced9a3add3e9b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a42483d058e437874b89ced9a3add3e9b.html#a42483d058e437874b89ced9a3add3e9b">row_vector_v</a> = Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a42483d058e437874b89ced9a3add3e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a row vector holding <code>var</code> values.  <a href="namespacestan_1_1math_a42483d058e437874b89ced9a3add3e9b.html#a42483d058e437874b89ced9a3add3e9b">More...</a><br /></td></tr>
<tr class="separator:a42483d058e437874b89ced9a3add3e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0453aa14ed8e8f9963ad346ea9c9f6c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0453aa14ed8e8f9963ad346ea9c9f6c5.html#a0453aa14ed8e8f9963ad346ea9c9f6c5">matrix_vi</a> = Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> *, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a0453aa14ed8e8f9963ad346ea9c9f6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a matrix holding <code>vari*</code> values.  <a href="namespacestan_1_1math_a0453aa14ed8e8f9963ad346ea9c9f6c5.html#a0453aa14ed8e8f9963ad346ea9c9f6c5">More...</a><br /></td></tr>
<tr class="separator:a0453aa14ed8e8f9963ad346ea9c9f6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e37d2da65eb3dac4b57e7d4d89cd23d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9e37d2da65eb3dac4b57e7d4d89cd23d.html#a9e37d2da65eb3dac4b57e7d4d89cd23d">vector_vi</a> = Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> *, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:a9e37d2da65eb3dac4b57e7d4d89cd23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a (column) vector holding <code>vari*</code> values.  <a href="namespacestan_1_1math_a9e37d2da65eb3dac4b57e7d4d89cd23d.html#a9e37d2da65eb3dac4b57e7d4d89cd23d">More...</a><br /></td></tr>
<tr class="separator:a9e37d2da65eb3dac4b57e7d4d89cd23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fbf381dbc3d352d29919b2b8d8ea71"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa9fbf381dbc3d352d29919b2b8d8ea71.html#aa9fbf381dbc3d352d29919b2b8d8ea71">row_vector_vi</a> = Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> *, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:aa9fbf381dbc3d352d29919b2b8d8ea71"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a row vector holding <code>vari*</code> values.  <a href="namespacestan_1_1math_aa9fbf381dbc3d352d29919b2b8d8ea71.html#aa9fbf381dbc3d352d29919b2b8d8ea71">More...</a><br /></td></tr>
<tr class="separator:aa9fbf381dbc3d352d29919b2b8d8ea71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1141ed12907bf4b7c268faa6126762"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> = <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; double &gt;</td></tr>
<tr class="separator:abf1141ed12907bf4b7c268faa6126762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ee1c81e14d0a137cfd8bc8f1ddac46"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> = <a class="el" href="classstan_1_1math_1_1vari__value.html">vari_value</a>&lt; double &gt;</td></tr>
<tr class="separator:a61ee1c81e14d0a137cfd8bc8f1ddac46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9528c837d04c7f4d0a92b8f9e3238925"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> { <br />
&#160;&#160;<a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925a9ac677ee4eec25d9e59707a661d2c5e1">matrix_cl_view::Diagonal</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925ab75fcdd2d72d9e000beab48622402d93">matrix_cl_view::Lower</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925a19de5b94f7b83900d4b296d9fa491aec">matrix_cl_view::Upper</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">matrix_cl_view::Entire</a> = 3
<br />
 }</td></tr>
<tr class="separator:a9528c837d04c7f4d0a92b8f9e3238925"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a51a0614c9ba674f03e3d1b7586e99d27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51a0614c9ba674f03e3d1b7586e99d27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a51a0614c9ba674f03e3d1b7586e99d27.html#a51a0614c9ba674f03e3d1b7586e99d27">operator+</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a51a0614c9ba674f03e3d1b7586e99d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified forward mode addends.  <a href="namespacestan_1_1math_a51a0614c9ba674f03e3d1b7586e99d27.html#a51a0614c9ba674f03e3d1b7586e99d27">More...</a><br /></td></tr>
<tr class="separator:a51a0614c9ba674f03e3d1b7586e99d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc603263add9426b6cdd685c252b1725"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc603263add9426b6cdd685c252b1725"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abc603263add9426b6cdd685c252b1725.html#abc603263add9426b6cdd685c252b1725">operator+</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:abc603263add9426b6cdd685c252b1725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified double and forward mode addends.  <a href="namespacestan_1_1math_abc603263add9426b6cdd685c252b1725.html#abc603263add9426b6cdd685c252b1725">More...</a><br /></td></tr>
<tr class="separator:abc603263add9426b6cdd685c252b1725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff44c9dd673dad99ed7321bc1699a63"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ff44c9dd673dad99ed7321bc1699a63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6ff44c9dd673dad99ed7321bc1699a63.html#a6ff44c9dd673dad99ed7321bc1699a63">operator+</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="memdesc:a6ff44c9dd673dad99ed7321bc1699a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified forward mode and double addends.  <a href="namespacestan_1_1math_a6ff44c9dd673dad99ed7321bc1699a63.html#a6ff44c9dd673dad99ed7321bc1699a63">More...</a><br /></td></tr>
<tr class="separator:a6ff44c9dd673dad99ed7321bc1699a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eba6f623c3c2c0714e2eabbae90290f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1eba6f623c3c2c0714e2eabbae90290f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1eba6f623c3c2c0714e2eabbae90290f.html#a1eba6f623c3c2c0714e2eabbae90290f">operator/</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a1eba6f623c3c2c0714e2eabbae90290f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of dividing the first argument by the second.  <a href="namespacestan_1_1math_a1eba6f623c3c2c0714e2eabbae90290f.html#a1eba6f623c3c2c0714e2eabbae90290f">More...</a><br /></td></tr>
<tr class="separator:a1eba6f623c3c2c0714e2eabbae90290f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c90e7414ae4f736800e721d67e5994"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_arithmetic_t&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac6c90e7414ae4f736800e721d67e5994"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac6c90e7414ae4f736800e721d67e5994.html#ac6c90e7414ae4f736800e721d67e5994">operator/</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, U x2)</td></tr>
<tr class="memdesc:ac6c90e7414ae4f736800e721d67e5994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of dividing the first argument by the second.  <a href="namespacestan_1_1math_ac6c90e7414ae4f736800e721d67e5994.html#ac6c90e7414ae4f736800e721d67e5994">More...</a><br /></td></tr>
<tr class="separator:ac6c90e7414ae4f736800e721d67e5994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2cdb576dcb29850726e43256b2e856"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_arithmetic_t&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aea2cdb576dcb29850726e43256b2e856"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aea2cdb576dcb29850726e43256b2e856.html#aea2cdb576dcb29850726e43256b2e856">operator/</a> (U x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:aea2cdb576dcb29850726e43256b2e856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of dividing the first argument by the second.  <a href="namespacestan_1_1math_aea2cdb576dcb29850726e43256b2e856.html#aea2cdb576dcb29850726e43256b2e856">More...</a><br /></td></tr>
<tr class="separator:aea2cdb576dcb29850726e43256b2e856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ec10bb67fe06c4371c9c4cf2eee3e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42ec10bb67fe06c4371c9c4cf2eee3e4"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a42ec10bb67fe06c4371c9c4cf2eee3e4.html#a42ec10bb67fe06c4371c9c4cf2eee3e4">operator/</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;x1, const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;x2)</td></tr>
<tr class="separator:a42ec10bb67fe06c4371c9c4cf2eee3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0276f66963fb0368fbf0472bbc61c5cd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_arithmetic_t&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0276f66963fb0368fbf0472bbc61c5cd"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0276f66963fb0368fbf0472bbc61c5cd.html#a0276f66963fb0368fbf0472bbc61c5cd">operator/</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;x1, const std::complex&lt; U &gt; &amp;x2)</td></tr>
<tr class="separator:a0276f66963fb0368fbf0472bbc61c5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fea1e6eef139055eef16b1308c6757d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3fea1e6eef139055eef16b1308c6757d"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3fea1e6eef139055eef16b1308c6757d.html#a3fea1e6eef139055eef16b1308c6757d">operator/</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a3fea1e6eef139055eef16b1308c6757d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6520b2ec984f1330d648763a7b22cc0d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_arithmetic_t&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6520b2ec984f1330d648763a7b22cc0d"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6520b2ec984f1330d648763a7b22cc0d.html#a6520b2ec984f1330d648763a7b22cc0d">operator/</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;x1, U x2)</td></tr>
<tr class="separator:a6520b2ec984f1330d648763a7b22cc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a573af8a07d844bae33c9c73647f2cd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_arithmetic_t&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4a573af8a07d844bae33c9c73647f2cd"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a573af8a07d844bae33c9c73647f2cd.html#a4a573af8a07d844bae33c9c73647f2cd">operator/</a> (const std::complex&lt; U &gt; &amp;x1, const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;x2)</td></tr>
<tr class="separator:a4a573af8a07d844bae33c9c73647f2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1d08860da44c2559f6fe094e28833a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_arithmetic_t&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afc1d08860da44c2559f6fe094e28833a"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afc1d08860da44c2559f6fe094e28833a.html#afc1d08860da44c2559f6fe094e28833a">operator/</a> (const std::complex&lt; U &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:afc1d08860da44c2559f6fe094e28833a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fc584fac0e375ebec1b9574ebf360b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05fc584fac0e375ebec1b9574ebf360b"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a05fc584fac0e375ebec1b9574ebf360b.html#a05fc584fac0e375ebec1b9574ebf360b">operator/</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;x2)</td></tr>
<tr class="separator:a05fc584fac0e375ebec1b9574ebf360b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f39679c98ccdb9693347179bcf99f48"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;U&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a2f39679c98ccdb9693347179bcf99f48"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f39679c98ccdb9693347179bcf99f48.html#a2f39679c98ccdb9693347179bcf99f48">operator/</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const std::complex&lt; U &gt; &amp;x2)</td></tr>
<tr class="separator:a2f39679c98ccdb9693347179bcf99f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6dc315822f1fc31d722450fed64a8d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_arithmetic_t&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9f6dc315822f1fc31d722450fed64a8d"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9f6dc315822f1fc31d722450fed64a8d.html#a9f6dc315822f1fc31d722450fed64a8d">operator/</a> (U x1, const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;x2)</td></tr>
<tr class="separator:a9f6dc315822f1fc31d722450fed64a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431129b4a75d77ab60f6cd749bef5a11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a431129b4a75d77ab60f6cd749bef5a11"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a431129b4a75d77ab60f6cd749bef5a11.html#a431129b4a75d77ab60f6cd749bef5a11">operator==</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a431129b4a75d77ab60f6cd749bef5a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified variables have equal values as defined by <code>==</code>.  <a href="namespacestan_1_1math_a431129b4a75d77ab60f6cd749bef5a11.html#a431129b4a75d77ab60f6cd749bef5a11">More...</a><br /></td></tr>
<tr class="separator:a431129b4a75d77ab60f6cd749bef5a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15161ab182b02d135f79a13d68c7318d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15161ab182b02d135f79a13d68c7318d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a15161ab182b02d135f79a13d68c7318d.html#a15161ab182b02d135f79a13d68c7318d">operator==</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:a15161ab182b02d135f79a13d68c7318d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the the first variable has a value equal to the second argument as defined by by <code>==</code>.  <a href="namespacestan_1_1math_a15161ab182b02d135f79a13d68c7318d.html#a15161ab182b02d135f79a13d68c7318d">More...</a><br /></td></tr>
<tr class="separator:a15161ab182b02d135f79a13d68c7318d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4930059b979a995acd759a0746bfc201"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4930059b979a995acd759a0746bfc201"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4930059b979a995acd759a0746bfc201.html#a4930059b979a995acd759a0746bfc201">operator==</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a4930059b979a995acd759a0746bfc201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the the first argument is equal to the value of the second argument as defined by by <code>==</code>.  <a href="namespacestan_1_1math_a4930059b979a995acd759a0746bfc201.html#a4930059b979a995acd759a0746bfc201">More...</a><br /></td></tr>
<tr class="separator:a4930059b979a995acd759a0746bfc201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fefa51b18df1adec77e49f4e792fbc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17fefa51b18df1adec77e49f4e792fbc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a17fefa51b18df1adec77e49f4e792fbc.html#a17fefa51b18df1adec77e49f4e792fbc">operator&gt;</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a17fefa51b18df1adec77e49f4e792fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument has a greater value than the second as defined by <code>&gt;</code>.  <a href="namespacestan_1_1math_a17fefa51b18df1adec77e49f4e792fbc.html#a17fefa51b18df1adec77e49f4e792fbc">More...</a><br /></td></tr>
<tr class="separator:a17fefa51b18df1adec77e49f4e792fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c850c94b22aab8ffd895bdf8faebded"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c850c94b22aab8ffd895bdf8faebded"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9c850c94b22aab8ffd895bdf8faebded.html#a9c850c94b22aab8ffd895bdf8faebded">operator&gt;</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:a9c850c94b22aab8ffd895bdf8faebded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument has a greater value than the second as defined by <code>&gt;</code>.  <a href="namespacestan_1_1math_a9c850c94b22aab8ffd895bdf8faebded.html#a9c850c94b22aab8ffd895bdf8faebded">More...</a><br /></td></tr>
<tr class="separator:a9c850c94b22aab8ffd895bdf8faebded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7b92bb244d32edb94b17c8039ae826"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba7b92bb244d32edb94b17c8039ae826"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aba7b92bb244d32edb94b17c8039ae826.html#aba7b92bb244d32edb94b17c8039ae826">operator&gt;</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:aba7b92bb244d32edb94b17c8039ae826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument has a greater value than the second as defined by <code>&gt;</code>.  <a href="namespacestan_1_1math_aba7b92bb244d32edb94b17c8039ae826.html#aba7b92bb244d32edb94b17c8039ae826">More...</a><br /></td></tr>
<tr class="separator:aba7b92bb244d32edb94b17c8039ae826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dee5c21281cc75cad8ebf9f6c43b98f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5dee5c21281cc75cad8ebf9f6c43b98f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5dee5c21281cc75cad8ebf9f6c43b98f.html#a5dee5c21281cc75cad8ebf9f6c43b98f">operator&gt;=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a5dee5c21281cc75cad8ebf9f6c43b98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the value of the first argument is greater than or equal to that of the second as defined by <code>&gt;=</code>.  <a href="namespacestan_1_1math_a5dee5c21281cc75cad8ebf9f6c43b98f.html#a5dee5c21281cc75cad8ebf9f6c43b98f">More...</a><br /></td></tr>
<tr class="separator:a5dee5c21281cc75cad8ebf9f6c43b98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2097caea2b790905ee2948ef72727df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2097caea2b790905ee2948ef72727df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac2097caea2b790905ee2948ef72727df.html#ac2097caea2b790905ee2948ef72727df">operator&gt;=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:ac2097caea2b790905ee2948ef72727df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the value of the first argument has a value greater than or equal to the second argument as defined by <code>&gt;=</code>.  <a href="namespacestan_1_1math_ac2097caea2b790905ee2948ef72727df.html#ac2097caea2b790905ee2948ef72727df">More...</a><br /></td></tr>
<tr class="separator:ac2097caea2b790905ee2948ef72727df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813edaa4311e1a4c206952f75a85eba8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a813edaa4311e1a4c206952f75a85eba8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a813edaa4311e1a4c206952f75a85eba8.html#a813edaa4311e1a4c206952f75a85eba8">operator&gt;=</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a813edaa4311e1a4c206952f75a85eba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument is greater than or equal to the value of the second argument as defined by <code>&gt;=</code>.  <a href="namespacestan_1_1math_a813edaa4311e1a4c206952f75a85eba8.html#a813edaa4311e1a4c206952f75a85eba8">More...</a><br /></td></tr>
<tr class="separator:a813edaa4311e1a4c206952f75a85eba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b0c7ff4961eb7333aa81f685da55f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50b0c7ff4961eb7333aa81f685da55f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a50b0c7ff4961eb7333aa81f685da55f4.html#a50b0c7ff4961eb7333aa81f685da55f4">operator&lt;</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a50b0c7ff4961eb7333aa81f685da55f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument has a value less than the value of the second argument as defined by <code>&lt;</code>.  <a href="namespacestan_1_1math_a50b0c7ff4961eb7333aa81f685da55f4.html#a50b0c7ff4961eb7333aa81f685da55f4">More...</a><br /></td></tr>
<tr class="separator:a50b0c7ff4961eb7333aa81f685da55f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0194df340cc3564835ff04086374cf97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0194df340cc3564835ff04086374cf97"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0194df340cc3564835ff04086374cf97.html#a0194df340cc3564835ff04086374cf97">operator&lt;</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a0194df340cc3564835ff04086374cf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument is less than the value of the second argument as defined by <code>&lt;</code>.  <a href="namespacestan_1_1math_a0194df340cc3564835ff04086374cf97.html#a0194df340cc3564835ff04086374cf97">More...</a><br /></td></tr>
<tr class="separator:a0194df340cc3564835ff04086374cf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c489941c560664036ee190c9028360"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2c489941c560664036ee190c9028360"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af2c489941c560664036ee190c9028360.html#af2c489941c560664036ee190c9028360">operator&lt;</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:af2c489941c560664036ee190c9028360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument has a value less than the second argument as defined by <code>&lt;</code>.  <a href="namespacestan_1_1math_af2c489941c560664036ee190c9028360.html#af2c489941c560664036ee190c9028360">More...</a><br /></td></tr>
<tr class="separator:af2c489941c560664036ee190c9028360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450ef8aaef08c3137f70a087ae3905c6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a450ef8aaef08c3137f70a087ae3905c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a450ef8aaef08c3137f70a087ae3905c6.html#a450ef8aaef08c3137f70a087ae3905c6">operator&lt;=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a450ef8aaef08c3137f70a087ae3905c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument has a value less than or equal to the value of the second argument as defined by <code>&lt;=</code>.  <a href="namespacestan_1_1math_a450ef8aaef08c3137f70a087ae3905c6.html#a450ef8aaef08c3137f70a087ae3905c6">More...</a><br /></td></tr>
<tr class="separator:a450ef8aaef08c3137f70a087ae3905c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95d660226997cbba13176cec459adaf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab95d660226997cbba13176cec459adaf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab95d660226997cbba13176cec459adaf.html#ab95d660226997cbba13176cec459adaf">operator&lt;=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:ab95d660226997cbba13176cec459adaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument has a value less than or equal to the second argument as defined by <code>&lt;=</code>.  <a href="namespacestan_1_1math_ab95d660226997cbba13176cec459adaf.html#ab95d660226997cbba13176cec459adaf">More...</a><br /></td></tr>
<tr class="separator:ab95d660226997cbba13176cec459adaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5de0aa5a40e981ece663f96ad41997"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca5de0aa5a40e981ece663f96ad41997"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aca5de0aa5a40e981ece663f96ad41997.html#aca5de0aa5a40e981ece663f96ad41997">operator&lt;=</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:aca5de0aa5a40e981ece663f96ad41997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument is less than or equal to the second argument's value as defined by <code>&lt;=</code>.  <a href="namespacestan_1_1math_aca5de0aa5a40e981ece663f96ad41997.html#aca5de0aa5a40e981ece663f96ad41997">More...</a><br /></td></tr>
<tr class="separator:aca5de0aa5a40e981ece663f96ad41997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921c589235fb3b02790ae0c72d0cbb97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a921c589235fb3b02790ae0c72d0cbb97"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a921c589235fb3b02790ae0c72d0cbb97.html#a921c589235fb3b02790ae0c72d0cbb97">operator&amp;&amp;</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a921c589235fb3b02790ae0c72d0cbb97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical conjunction of the values of the two arguments as defined by <code>&amp;&amp;</code>.  <a href="namespacestan_1_1math_a921c589235fb3b02790ae0c72d0cbb97.html#a921c589235fb3b02790ae0c72d0cbb97">More...</a><br /></td></tr>
<tr class="separator:a921c589235fb3b02790ae0c72d0cbb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894b3696d8c6ff62a4f048f09ce5d9d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a894b3696d8c6ff62a4f048f09ce5d9d7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a894b3696d8c6ff62a4f048f09ce5d9d7.html#a894b3696d8c6ff62a4f048f09ce5d9d7">operator&amp;&amp;</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:a894b3696d8c6ff62a4f048f09ce5d9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical conjunction of the values of the two arguments as defined by <code>&amp;&amp;</code>.  <a href="namespacestan_1_1math_a894b3696d8c6ff62a4f048f09ce5d9d7.html#a894b3696d8c6ff62a4f048f09ce5d9d7">More...</a><br /></td></tr>
<tr class="separator:a894b3696d8c6ff62a4f048f09ce5d9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811bbfb8303583dace9a03927066f3b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a811bbfb8303583dace9a03927066f3b9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a811bbfb8303583dace9a03927066f3b9.html#a811bbfb8303583dace9a03927066f3b9">operator&amp;&amp;</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a811bbfb8303583dace9a03927066f3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical conjunction of the values of the two arguments as defined by <code>&amp;&amp;</code>.  <a href="namespacestan_1_1math_a811bbfb8303583dace9a03927066f3b9.html#a811bbfb8303583dace9a03927066f3b9">More...</a><br /></td></tr>
<tr class="separator:a811bbfb8303583dace9a03927066f3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870df08c01d3f20b6d309490007cd891"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a870df08c01d3f20b6d309490007cd891"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a870df08c01d3f20b6d309490007cd891.html#a870df08c01d3f20b6d309490007cd891">operator||</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a870df08c01d3f20b6d309490007cd891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical disjunction of the values of the two arguments as defined by <code>||</code>.  <a href="namespacestan_1_1math_a870df08c01d3f20b6d309490007cd891.html#a870df08c01d3f20b6d309490007cd891">More...</a><br /></td></tr>
<tr class="separator:a870df08c01d3f20b6d309490007cd891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5214b079d9b04b99cd67d232198cafd7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5214b079d9b04b99cd67d232198cafd7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5214b079d9b04b99cd67d232198cafd7.html#a5214b079d9b04b99cd67d232198cafd7">operator||</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:a5214b079d9b04b99cd67d232198cafd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical disjunction of the values of the two arguments as defined by <code>||</code>.  <a href="namespacestan_1_1math_a5214b079d9b04b99cd67d232198cafd7.html#a5214b079d9b04b99cd67d232198cafd7">More...</a><br /></td></tr>
<tr class="separator:a5214b079d9b04b99cd67d232198cafd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcd53339db17c038636407786822243"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7fcd53339db17c038636407786822243"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7fcd53339db17c038636407786822243.html#a7fcd53339db17c038636407786822243">operator||</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a7fcd53339db17c038636407786822243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical disjunction of the values of the two arguments as defined by <code>||</code>.  <a href="namespacestan_1_1math_a7fcd53339db17c038636407786822243.html#a7fcd53339db17c038636407786822243">More...</a><br /></td></tr>
<tr class="separator:a7fcd53339db17c038636407786822243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28de97d20ff5f971f5ec039fc0847892"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28de97d20ff5f971f5ec039fc0847892"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a28de97d20ff5f971f5ec039fc0847892.html#a28de97d20ff5f971f5ec039fc0847892">operator*</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a28de97d20ff5f971f5ec039fc0847892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the two arguments.  <a href="namespacestan_1_1math_a28de97d20ff5f971f5ec039fc0847892.html#a28de97d20ff5f971f5ec039fc0847892">More...</a><br /></td></tr>
<tr class="separator:a28de97d20ff5f971f5ec039fc0847892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554575f6cd2ed2e6f4c62e6b8bf71041"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a554575f6cd2ed2e6f4c62e6b8bf71041"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a554575f6cd2ed2e6f4c62e6b8bf71041.html#a554575f6cd2ed2e6f4c62e6b8bf71041">operator*</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a554575f6cd2ed2e6f4c62e6b8bf71041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the two arguments.  <a href="namespacestan_1_1math_a554575f6cd2ed2e6f4c62e6b8bf71041.html#a554575f6cd2ed2e6f4c62e6b8bf71041">More...</a><br /></td></tr>
<tr class="separator:a554575f6cd2ed2e6f4c62e6b8bf71041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a1dc587625fe95191ea7633a68ef8c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a48a1dc587625fe95191ea7633a68ef8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a48a1dc587625fe95191ea7633a68ef8c.html#a48a1dc587625fe95191ea7633a68ef8c">operator*</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:a48a1dc587625fe95191ea7633a68ef8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the two arguments.  <a href="namespacestan_1_1math_a48a1dc587625fe95191ea7633a68ef8c.html#a48a1dc587625fe95191ea7633a68ef8c">More...</a><br /></td></tr>
<tr class="separator:a48a1dc587625fe95191ea7633a68ef8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65438bf17da7bbedb06bc7c381cea865"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65438bf17da7bbedb06bc7c381cea865"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a65438bf17da7bbedb06bc7c381cea865.html#a65438bf17da7bbedb06bc7c381cea865">operator!=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a65438bf17da7bbedb06bc7c381cea865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the value of the two arguments are not equal as defined by <code>!=</code>.  <a href="namespacestan_1_1math_a65438bf17da7bbedb06bc7c381cea865.html#a65438bf17da7bbedb06bc7c381cea865">More...</a><br /></td></tr>
<tr class="separator:a65438bf17da7bbedb06bc7c381cea865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e121241958fdcc4d2190bc532e9bc5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a41e121241958fdcc4d2190bc532e9bc5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a41e121241958fdcc4d2190bc532e9bc5.html#a41e121241958fdcc4d2190bc532e9bc5">operator!=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:a41e121241958fdcc4d2190bc532e9bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the value of the first argument is not equal to the second argument as defined by <code>!=</code>.  <a href="namespacestan_1_1math_a41e121241958fdcc4d2190bc532e9bc5.html#a41e121241958fdcc4d2190bc532e9bc5">More...</a><br /></td></tr>
<tr class="separator:a41e121241958fdcc4d2190bc532e9bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae982faec66434385fda1c728b0b2bf3d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae982faec66434385fda1c728b0b2bf3d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae982faec66434385fda1c728b0b2bf3d.html#ae982faec66434385fda1c728b0b2bf3d">operator!=</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:ae982faec66434385fda1c728b0b2bf3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument is not equal to the value of the second argument as defined by <code>!=</code>.  <a href="namespacestan_1_1math_ae982faec66434385fda1c728b0b2bf3d.html#ae982faec66434385fda1c728b0b2bf3d">More...</a><br /></td></tr>
<tr class="separator:ae982faec66434385fda1c728b0b2bf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a200e70e0f2b422b6623cf4b19d04da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a200e70e0f2b422b6623cf4b19d04da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6a200e70e0f2b422b6623cf4b19d04da.html#a6a200e70e0f2b422b6623cf4b19d04da">operator-</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a6a200e70e0f2b422b6623cf4b19d04da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of the specified arguments.  <a href="namespacestan_1_1math_a6a200e70e0f2b422b6623cf4b19d04da.html#a6a200e70e0f2b422b6623cf4b19d04da">More...</a><br /></td></tr>
<tr class="separator:a6a200e70e0f2b422b6623cf4b19d04da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc4308c2e0af676d4d8c16a7808a862"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7fc4308c2e0af676d4d8c16a7808a862"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7fc4308c2e0af676d4d8c16a7808a862.html#a7fc4308c2e0af676d4d8c16a7808a862">operator-</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a7fc4308c2e0af676d4d8c16a7808a862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of the specified arguments.  <a href="namespacestan_1_1math_a7fc4308c2e0af676d4d8c16a7808a862.html#a7fc4308c2e0af676d4d8c16a7808a862">More...</a><br /></td></tr>
<tr class="separator:a7fc4308c2e0af676d4d8c16a7808a862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910f7b2027d16bfb6f3d208522ba3553"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a910f7b2027d16bfb6f3d208522ba3553"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a910f7b2027d16bfb6f3d208522ba3553.html#a910f7b2027d16bfb6f3d208522ba3553">operator-</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="memdesc:a910f7b2027d16bfb6f3d208522ba3553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of the specified arguments.  <a href="namespacestan_1_1math_a910f7b2027d16bfb6f3d208522ba3553.html#a910f7b2027d16bfb6f3d208522ba3553">More...</a><br /></td></tr>
<tr class="separator:a910f7b2027d16bfb6f3d208522ba3553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedeee50b418200d06eb867d0ef3b3125"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedeee50b418200d06eb867d0ef3b3125"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aedeee50b418200d06eb867d0ef3b3125.html#aedeee50b418200d06eb867d0ef3b3125">operator-</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:aedeee50b418200d06eb867d0ef3b3125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negation of the specified argument.  <a href="namespacestan_1_1math_aedeee50b418200d06eb867d0ef3b3125.html#aedeee50b418200d06eb867d0ef3b3125">More...</a><br /></td></tr>
<tr class="separator:aedeee50b418200d06eb867d0ef3b3125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a42c3b738d9cc30ea0494cc80c7443"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2a42c3b738d9cc30ea0494cc80c7443"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae2a42c3b738d9cc30ea0494cc80c7443.html#ae2a42c3b738d9cc30ea0494cc80c7443">operator!</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:ae2a42c3b738d9cc30ea0494cc80c7443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negation of the value of the argument as defined by <code>!</code>.  <a href="namespacestan_1_1math_ae2a42c3b738d9cc30ea0494cc80c7443.html#ae2a42c3b738d9cc30ea0494cc80c7443">More...</a><br /></td></tr>
<tr class="separator:ae2a42c3b738d9cc30ea0494cc80c7443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50978cef8ad98493e88b804af788c281"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50978cef8ad98493e88b804af788c281"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a50978cef8ad98493e88b804af788c281.html#a50978cef8ad98493e88b804af788c281">operator+</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a50978cef8ad98493e88b804af788c281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the argument.  <a href="namespacestan_1_1math_a50978cef8ad98493e88b804af788c281.html#a50978cef8ad98493e88b804af788c281">More...</a><br /></td></tr>
<tr class="separator:a50978cef8ad98493e88b804af788c281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae560b842e3ed6e5939dc2177bf158265"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae560b842e3ed6e5939dc2177bf158265"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae560b842e3ed6e5939dc2177bf158265.html#ae560b842e3ed6e5939dc2177bf158265">abs</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ae560b842e3ed6e5939dc2177bf158265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dffb5ff1a339f708ac0faf2429264b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a12dffb5ff1a339f708ac0faf2429264b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a12dffb5ff1a339f708ac0faf2429264b.html#a12dffb5ff1a339f708ac0faf2429264b">abs</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:a12dffb5ff1a339f708ac0faf2429264b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute value of the complex argument.  <a href="namespacestan_1_1math_a12dffb5ff1a339f708ac0faf2429264b.html#a12dffb5ff1a339f708ac0faf2429264b">More...</a><br /></td></tr>
<tr class="separator:a12dffb5ff1a339f708ac0faf2429264b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6952d8c23d69dc891dbe78e7d4ea7a80"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6952d8c23d69dc891dbe78e7d4ea7a80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6952d8c23d69dc891dbe78e7d4ea7a80.html#a6952d8c23d69dc891dbe78e7d4ea7a80">acos</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a6952d8c23d69dc891dbe78e7d4ea7a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9444328dd01de1fd79d80195e8055d58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9444328dd01de1fd79d80195e8055d58"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9444328dd01de1fd79d80195e8055d58.html#a9444328dd01de1fd79d80195e8055d58">acos</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;x)</td></tr>
<tr class="memdesc:a9444328dd01de1fd79d80195e8055d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arc cosine of the complex argument.  <a href="namespacestan_1_1math_a9444328dd01de1fd79d80195e8055d58.html#a9444328dd01de1fd79d80195e8055d58">More...</a><br /></td></tr>
<tr class="separator:a9444328dd01de1fd79d80195e8055d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae033720f1a26c44aa9d7fb4dcf547155"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae033720f1a26c44aa9d7fb4dcf547155"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae033720f1a26c44aa9d7fb4dcf547155.html#ae033720f1a26c44aa9d7fb4dcf547155">acosh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ae033720f1a26c44aa9d7fb4dcf547155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0ceb0e5c12f75669c028204bcceac1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb0ceb0e5c12f75669c028204bcceac1"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adb0ceb0e5c12f75669c028204bcceac1.html#adb0ceb0e5c12f75669c028204bcceac1">acosh</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:adb0ceb0e5c12f75669c028204bcceac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arc cosine of the complex argument.  <a href="namespacestan_1_1math_adb0ceb0e5c12f75669c028204bcceac1.html#adb0ceb0e5c12f75669c028204bcceac1">More...</a><br /></td></tr>
<tr class="separator:adb0ceb0e5c12f75669c028204bcceac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8ad2370c5624d7c0700410e6612514"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c8ad2370c5624d7c0700410e6612514"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7c8ad2370c5624d7c0700410e6612514.html#a7c8ad2370c5624d7c0700410e6612514">arg</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:a7c8ad2370c5624d7c0700410e6612514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the phase angle of the complex argument.  <a href="namespacestan_1_1math_a7c8ad2370c5624d7c0700410e6612514.html#a7c8ad2370c5624d7c0700410e6612514">More...</a><br /></td></tr>
<tr class="separator:a7c8ad2370c5624d7c0700410e6612514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab75d0165599717cfd1e90f7edcf250"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ab75d0165599717cfd1e90f7edcf250"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1ab75d0165599717cfd1e90f7edcf250.html#a1ab75d0165599717cfd1e90f7edcf250">asin</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a1ab75d0165599717cfd1e90f7edcf250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08981fd68e1a4493c9574aef0961ce2a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a08981fd68e1a4493c9574aef0961ce2a"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a08981fd68e1a4493c9574aef0961ce2a.html#a08981fd68e1a4493c9574aef0961ce2a">asin</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:a08981fd68e1a4493c9574aef0961ce2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arc sine of the complex argument.  <a href="namespacestan_1_1math_a08981fd68e1a4493c9574aef0961ce2a.html#a08981fd68e1a4493c9574aef0961ce2a">More...</a><br /></td></tr>
<tr class="separator:a08981fd68e1a4493c9574aef0961ce2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68af8aec6bd04b4d40e5bce59f82b97c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a68af8aec6bd04b4d40e5bce59f82b97c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a68af8aec6bd04b4d40e5bce59f82b97c.html#a68af8aec6bd04b4d40e5bce59f82b97c">asinh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a68af8aec6bd04b4d40e5bce59f82b97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c007706427324dc4a28b9d07521afea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4c007706427324dc4a28b9d07521afea"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4c007706427324dc4a28b9d07521afea.html#a4c007706427324dc4a28b9d07521afea">asinh</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:a4c007706427324dc4a28b9d07521afea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arcsine of the complex argument.  <a href="namespacestan_1_1math_a4c007706427324dc4a28b9d07521afea.html#a4c007706427324dc4a28b9d07521afea">More...</a><br /></td></tr>
<tr class="separator:a4c007706427324dc4a28b9d07521afea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0398656b862b1b2eb80145f4877b11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f0398656b862b1b2eb80145f4877b11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6f0398656b862b1b2eb80145f4877b11.html#a6f0398656b862b1b2eb80145f4877b11">atan</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a6f0398656b862b1b2eb80145f4877b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dc83495b9d7296d2f5a4f83abe24f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4dc83495b9d7296d2f5a4f83abe24f3"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab4dc83495b9d7296d2f5a4f83abe24f3.html#ab4dc83495b9d7296d2f5a4f83abe24f3">atan</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:ab4dc83495b9d7296d2f5a4f83abe24f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arc tangent of the complex argument.  <a href="namespacestan_1_1math_ab4dc83495b9d7296d2f5a4f83abe24f3.html#ab4dc83495b9d7296d2f5a4f83abe24f3">More...</a><br /></td></tr>
<tr class="separator:ab4dc83495b9d7296d2f5a4f83abe24f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4868ee5c5ab673ee54e5dce3be37f1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0c4868ee5c5ab673ee54e5dce3be37f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0c4868ee5c5ab673ee54e5dce3be37f1.html#a0c4868ee5c5ab673ee54e5dce3be37f1">atan2</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a0c4868ee5c5ab673ee54e5dce3be37f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90edcdd4fbbac7fdc662749a8978c8be"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a90edcdd4fbbac7fdc662749a8978c8be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a90edcdd4fbbac7fdc662749a8978c8be.html#a90edcdd4fbbac7fdc662749a8978c8be">atan2</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a90edcdd4fbbac7fdc662749a8978c8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bf927f81109ab2b4dff7fd8fcd18f1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70bf927f81109ab2b4dff7fd8fcd18f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a70bf927f81109ab2b4dff7fd8fcd18f1.html#a70bf927f81109ab2b4dff7fd8fcd18f1">atan2</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:a70bf927f81109ab2b4dff7fd8fcd18f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e31606b2cbc69573ec0d7693c8b2a2c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e31606b2cbc69573ec0d7693c8b2a2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9e31606b2cbc69573ec0d7693c8b2a2c.html#a9e31606b2cbc69573ec0d7693c8b2a2c">atanh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a9e31606b2cbc69573ec0d7693c8b2a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return inverse hyperbolic tangent of specified value.  <a href="namespacestan_1_1math_a9e31606b2cbc69573ec0d7693c8b2a2c.html#a9e31606b2cbc69573ec0d7693c8b2a2c">More...</a><br /></td></tr>
<tr class="separator:a9e31606b2cbc69573ec0d7693c8b2a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d30db084f0325e7509b970e73126348"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d30db084f0325e7509b970e73126348"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4d30db084f0325e7509b970e73126348.html#a4d30db084f0325e7509b970e73126348">atanh</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:a4d30db084f0325e7509b970e73126348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arc tangent of the complex argument.  <a href="namespacestan_1_1math_a4d30db084f0325e7509b970e73126348.html#a4d30db084f0325e7509b970e73126348">More...</a><br /></td></tr>
<tr class="separator:a4d30db084f0325e7509b970e73126348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f08e25e46df323a2429edc45d1c8954"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f08e25e46df323a2429edc45d1c8954"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0f08e25e46df323a2429edc45d1c8954.html#a0f08e25e46df323a2429edc45d1c8954">bessel_first_kind</a> (int v, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a0f08e25e46df323a2429edc45d1c8954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b227eac2dd4cbc55462ecebe940294"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0b227eac2dd4cbc55462ecebe940294"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab0b227eac2dd4cbc55462ecebe940294.html#ab0b227eac2dd4cbc55462ecebe940294">bessel_second_kind</a> (int v, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ab0b227eac2dd4cbc55462ecebe940294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c292999da7b2d1eb7a5b3d94f75525a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c292999da7b2d1eb7a5b3d94f75525a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a7c292999da7b2d1eb7a5b3d94f75525a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return fvar with the beta function applied to the specified arguments and its gradient.  <a href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">More...</a><br /></td></tr>
<tr class="separator:a7c292999da7b2d1eb7a5b3d94f75525a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5268670a67674eb0cc4ea6acce03ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f5268670a67674eb0cc4ea6acce03ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9f5268670a67674eb0cc4ea6acce03ff.html#a9f5268670a67674eb0cc4ea6acce03ff">beta</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a9f5268670a67674eb0cc4ea6acce03ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8c352632b3427712c12cef57ecb3e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade8c352632b3427712c12cef57ecb3e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade8c352632b3427712c12cef57ecb3e4.html#ade8c352632b3427712c12cef57ecb3e4">beta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:ade8c352632b3427712c12cef57ecb3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b43c41a39428567f52630afa375d4c8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8b43c41a39428567f52630afa375d4c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8b43c41a39428567f52630afa375d4c8.html#a8b43c41a39428567f52630afa375d4c8">binary_log_loss</a> (int y, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y_hat)</td></tr>
<tr class="separator:a8b43c41a39428567f52630afa375d4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c0dfe5862fc53f1a18d76f14a1dc7e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64c0dfe5862fc53f1a18d76f14a1dc7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a64c0dfe5862fc53f1a18d76f14a1dc7e.html#a64c0dfe5862fc53f1a18d76f14a1dc7e">cbrt</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a64c0dfe5862fc53f1a18d76f14a1dc7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return cube root of specified argument.  <a href="namespacestan_1_1math_a64c0dfe5862fc53f1a18d76f14a1dc7e.html#a64c0dfe5862fc53f1a18d76f14a1dc7e">More...</a><br /></td></tr>
<tr class="separator:a64c0dfe5862fc53f1a18d76f14a1dc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b2e9b4a947b81917612a8d1d547afb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1b2e9b4a947b81917612a8d1d547afb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab1b2e9b4a947b81917612a8d1d547afb.html#ab1b2e9b4a947b81917612a8d1d547afb">ceil</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ab1b2e9b4a947b81917612a8d1d547afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2569f1c903bcde50c36120a5bfb386f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2569f1c903bcde50c36120a5bfb386f6"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2569f1c903bcde50c36120a5bfb386f6.html#a2569f1c903bcde50c36120a5bfb386f6">conj</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:a2569f1c903bcde50c36120a5bfb386f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the phase angle of the complex argument.  <a href="namespacestan_1_1math_a2569f1c903bcde50c36120a5bfb386f6.html#a2569f1c903bcde50c36120a5bfb386f6">More...</a><br /></td></tr>
<tr class="separator:a2569f1c903bcde50c36120a5bfb386f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cb3a9041ae0b7855b398c3e11cda48"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae6cb3a9041ae0b7855b398c3e11cda48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae6cb3a9041ae0b7855b398c3e11cda48.html#ae6cb3a9041ae0b7855b398c3e11cda48">cos</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ae6cb3a9041ae0b7855b398c3e11cda48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fafa41eb823edfd597107fa40a9dd0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99fafa41eb823edfd597107fa40a9dd0"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a99fafa41eb823edfd597107fa40a9dd0.html#a99fafa41eb823edfd597107fa40a9dd0">cos</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:a99fafa41eb823edfd597107fa40a9dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cosine of the complex argument.  <a href="namespacestan_1_1math_a99fafa41eb823edfd597107fa40a9dd0.html#a99fafa41eb823edfd597107fa40a9dd0">More...</a><br /></td></tr>
<tr class="separator:a99fafa41eb823edfd597107fa40a9dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4fa5213b343a52756c138107ac180b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee4fa5213b343a52756c138107ac180b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aee4fa5213b343a52756c138107ac180b.html#aee4fa5213b343a52756c138107ac180b">cosh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aee4fa5213b343a52756c138107ac180b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba079e237b479771a125c4b7faa1d264"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba079e237b479771a125c4b7faa1d264"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aba079e237b479771a125c4b7faa1d264.html#aba079e237b479771a125c4b7faa1d264">cosh</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:aba079e237b479771a125c4b7faa1d264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic cosine of the complex argument.  <a href="namespacestan_1_1math_aba079e237b479771a125c4b7faa1d264.html#aba079e237b479771a125c4b7faa1d264">More...</a><br /></td></tr>
<tr class="separator:aba079e237b479771a125c4b7faa1d264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b3cbd01c70ddcf5a0c317c2db0a012"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_vt&lt; is_fvar, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a77b3cbd01c70ddcf5a0c317c2db0a012"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a77b3cbd01c70ddcf5a0c317c2db0a012.html#a77b3cbd01c70ddcf5a0c317c2db0a012">determinant</a> (const EigMat &amp;m)</td></tr>
<tr class="separator:a77b3cbd01c70ddcf5a0c317c2db0a012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69702aaa101bf602072fa7bf5fccb48a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69702aaa101bf602072fa7bf5fccb48a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a69702aaa101bf602072fa7bf5fccb48a.html#a69702aaa101bf602072fa7bf5fccb48a">digamma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a69702aaa101bf602072fa7bf5fccb48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the derivative of the log gamma function at the specified argument.  <a href="namespacestan_1_1math_a69702aaa101bf602072fa7bf5fccb48a.html#a69702aaa101bf602072fa7bf5fccb48a">More...</a><br /></td></tr>
<tr class="separator:a69702aaa101bf602072fa7bf5fccb48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa283efca22c0544054a6534443e6e762"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa283efca22c0544054a6534443e6e762"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa283efca22c0544054a6534443e6e762.html#aa283efca22c0544054a6534443e6e762">erf</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aa283efca22c0544054a6534443e6e762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c763e4f09069eed96a4e96e33ea8ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4c763e4f09069eed96a4e96e33ea8ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab4c763e4f09069eed96a4e96e33ea8ea.html#ab4c763e4f09069eed96a4e96e33ea8ea">erfc</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ab4c763e4f09069eed96a4e96e33ea8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f31444e8584e4debf0d6b706d66880"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11f31444e8584e4debf0d6b706d66880"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a11f31444e8584e4debf0d6b706d66880.html#a11f31444e8584e4debf0d6b706d66880">exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a11f31444e8584e4debf0d6b706d66880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b382fb4e8c1e61c6dc29d4a6639b3f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b382fb4e8c1e61c6dc29d4a6639b3f3"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1b382fb4e8c1e61c6dc29d4a6639b3f3.html#a1b382fb4e8c1e61c6dc29d4a6639b3f3">exp</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:a1b382fb4e8c1e61c6dc29d4a6639b3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural exponentiation (base e) of the specified complex number.  <a href="namespacestan_1_1math_a1b382fb4e8c1e61c6dc29d4a6639b3f3.html#a1b382fb4e8c1e61c6dc29d4a6639b3f3">More...</a><br /></td></tr>
<tr class="separator:a1b382fb4e8c1e61c6dc29d4a6639b3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3a577694c8f584e56160580fe0821b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c3a577694c8f584e56160580fe0821b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8c3a577694c8f584e56160580fe0821b.html#a8c3a577694c8f584e56160580fe0821b">exp2</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a8c3a577694c8f584e56160580fe0821b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a76b658b94fcf8943f4fb41c586ec94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a76b658b94fcf8943f4fb41c586ec94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8a76b658b94fcf8943f4fb41c586ec94.html#a8a76b658b94fcf8943f4fb41c586ec94">expm1</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a8a76b658b94fcf8943f4fb41c586ec94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c79c9be5c64873b74f3c6924fef6911"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c79c9be5c64873b74f3c6924fef6911"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6c79c9be5c64873b74f3c6924fef6911.html#a6c79c9be5c64873b74f3c6924fef6911">fabs</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a6c79c9be5c64873b74f3c6924fef6911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bf0997bd0c49bb21d2d3bb7c05e4dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15bf0997bd0c49bb21d2d3bb7c05e4dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a15bf0997bd0c49bb21d2d3bb7c05e4dd.html#a15bf0997bd0c49bb21d2d3bb7c05e4dd">falling_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="memdesc:a15bf0997bd0c49bb21d2d3bb7c05e4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return autodiff variable with the gradient and result of the falling factorial function applied to the inputs.  <a href="namespacestan_1_1math_a15bf0997bd0c49bb21d2d3bb7c05e4dd.html#a15bf0997bd0c49bb21d2d3bb7c05e4dd">More...</a><br /></td></tr>
<tr class="separator:a15bf0997bd0c49bb21d2d3bb7c05e4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d592a51adb08e17639ae46acf15276"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06d592a51adb08e17639ae46acf15276"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a06d592a51adb08e17639ae46acf15276.html#a06d592a51adb08e17639ae46acf15276">fdim</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a06d592a51adb08e17639ae46acf15276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference of the specified values (C++11).  <a href="namespacestan_1_1math_a06d592a51adb08e17639ae46acf15276.html#a06d592a51adb08e17639ae46acf15276">More...</a><br /></td></tr>
<tr class="separator:a06d592a51adb08e17639ae46acf15276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e4058cf85d45333d0bef4cf8fc1ed6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a23e4058cf85d45333d0bef4cf8fc1ed6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a23e4058cf85d45333d0bef4cf8fc1ed6.html#a23e4058cf85d45333d0bef4cf8fc1ed6">fdim</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:a23e4058cf85d45333d0bef4cf8fc1ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference of the specified values (C++11).  <a href="namespacestan_1_1math_a23e4058cf85d45333d0bef4cf8fc1ed6.html#a23e4058cf85d45333d0bef4cf8fc1ed6">More...</a><br /></td></tr>
<tr class="separator:a23e4058cf85d45333d0bef4cf8fc1ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ceade8a5b7256b4ba78087f5c535ea3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ceade8a5b7256b4ba78087f5c535ea3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8ceade8a5b7256b4ba78087f5c535ea3.html#a8ceade8a5b7256b4ba78087f5c535ea3">fdim</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a8ceade8a5b7256b4ba78087f5c535ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference of the specified values (C++11).  <a href="namespacestan_1_1math_a8ceade8a5b7256b4ba78087f5c535ea3.html#a8ceade8a5b7256b4ba78087f5c535ea3">More...</a><br /></td></tr>
<tr class="separator:a8ceade8a5b7256b4ba78087f5c535ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e5a2666b377e37fe807765ba5f6aaf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a16e5a2666b377e37fe807765ba5f6aaf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a16e5a2666b377e37fe807765ba5f6aaf.html#a16e5a2666b377e37fe807765ba5f6aaf">floor</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a16e5a2666b377e37fe807765ba5f6aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83058b690c9f57b57bd6f8f5010cb5a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_stan_scalar_t&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab83058b690c9f57b57bd6f8f5010cb5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab83058b690c9f57b57bd6f8f5010cb5a.html#ab83058b690c9f57b57bd6f8f5010cb5a">fma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt; &amp;x2, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T3 &gt; &amp;x3)</td></tr>
<tr class="memdesc:ab83058b690c9f57b57bd6f8f5010cb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add operation (C99).  <a href="namespacestan_1_1math_ab83058b690c9f57b57bd6f8f5010cb5a.html#ab83058b690c9f57b57bd6f8f5010cb5a">More...</a><br /></td></tr>
<tr class="separator:ab83058b690c9f57b57bd6f8f5010cb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461e537b6a7bbb14091ddcebb6a45de2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_stan_scalar_t&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a461e537b6a7bbb14091ddcebb6a45de2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a461e537b6a7bbb14091ddcebb6a45de2.html#a461e537b6a7bbb14091ddcebb6a45de2">fma</a> (const T1 &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt; &amp;x2, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T3 &gt; &amp;x3)</td></tr>
<tr class="memdesc:a461e537b6a7bbb14091ddcebb6a45de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <a href="namespacestan_1_1math_a461e537b6a7bbb14091ddcebb6a45de2.html#a461e537b6a7bbb14091ddcebb6a45de2">More...</a><br /></td></tr>
<tr class="separator:a461e537b6a7bbb14091ddcebb6a45de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842268976f354c62029ec2a5bc1fb9f8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_stan_scalar_t&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a842268976f354c62029ec2a5bc1fb9f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a842268976f354c62029ec2a5bc1fb9f8.html#a842268976f354c62029ec2a5bc1fb9f8">fma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt; &amp;x1, const T2 &amp;x2, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T3 &gt; &amp;x3)</td></tr>
<tr class="memdesc:a842268976f354c62029ec2a5bc1fb9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <a href="namespacestan_1_1math_a842268976f354c62029ec2a5bc1fb9f8.html#a842268976f354c62029ec2a5bc1fb9f8">More...</a><br /></td></tr>
<tr class="separator:a842268976f354c62029ec2a5bc1fb9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add53d091482c48378c9d2e1c97c3f2b1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_stan_scalar_t&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:add53d091482c48378c9d2e1c97c3f2b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_add53d091482c48378c9d2e1c97c3f2b1.html#add53d091482c48378c9d2e1c97c3f2b1">fma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt; &amp;x2, const T3 &amp;x3)</td></tr>
<tr class="memdesc:add53d091482c48378c9d2e1c97c3f2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <a href="namespacestan_1_1math_add53d091482c48378c9d2e1c97c3f2b1.html#add53d091482c48378c9d2e1c97c3f2b1">More...</a><br /></td></tr>
<tr class="separator:add53d091482c48378c9d2e1c97c3f2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f8a4fd4b4b85e103002df4cd0530e3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_stan_scalar_t&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a89f8a4fd4b4b85e103002df4cd0530e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a89f8a4fd4b4b85e103002df4cd0530e3.html#a89f8a4fd4b4b85e103002df4cd0530e3">fma</a> (const T1 &amp;x1, const T2 &amp;x2, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T3 &gt; &amp;x3)</td></tr>
<tr class="memdesc:a89f8a4fd4b4b85e103002df4cd0530e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <a href="namespacestan_1_1math_a89f8a4fd4b4b85e103002df4cd0530e3.html#a89f8a4fd4b4b85e103002df4cd0530e3">More...</a><br /></td></tr>
<tr class="separator:a89f8a4fd4b4b85e103002df4cd0530e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d9e66afc63fa1d7d25cdf5f15371c7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_stan_scalar_t&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a15d9e66afc63fa1d7d25cdf5f15371c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a15d9e66afc63fa1d7d25cdf5f15371c7.html#a15d9e66afc63fa1d7d25cdf5f15371c7">fma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt; &amp;x1, const T2 &amp;x2, const T3 &amp;x3)</td></tr>
<tr class="memdesc:a15d9e66afc63fa1d7d25cdf5f15371c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <a href="namespacestan_1_1math_a15d9e66afc63fa1d7d25cdf5f15371c7.html#a15d9e66afc63fa1d7d25cdf5f15371c7">More...</a><br /></td></tr>
<tr class="separator:a15d9e66afc63fa1d7d25cdf5f15371c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f763f26455120f91626d7fafbeb775"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_stan_scalar_t&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a07f763f26455120f91626d7fafbeb775"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a07f763f26455120f91626d7fafbeb775.html#a07f763f26455120f91626d7fafbeb775">fma</a> (const T1 &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt; &amp;x2, const T3 &amp;x3)</td></tr>
<tr class="memdesc:a07f763f26455120f91626d7fafbeb775"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <a href="namespacestan_1_1math_a07f763f26455120f91626d7fafbeb775.html#a07f763f26455120f91626d7fafbeb775">More...</a><br /></td></tr>
<tr class="separator:a07f763f26455120f91626d7fafbeb775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0dc47791c87f86c9f93d2cba273c25"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f0dc47791c87f86c9f93d2cba273c25"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1f0dc47791c87f86c9f93d2cba273c25.html#a1f0dc47791c87f86c9f93d2cba273c25">fmax</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a1f0dc47791c87f86c9f93d2cba273c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greater of the two specified arguments.  <a href="namespacestan_1_1math_a1f0dc47791c87f86c9f93d2cba273c25.html#a1f0dc47791c87f86c9f93d2cba273c25">More...</a><br /></td></tr>
<tr class="separator:a1f0dc47791c87f86c9f93d2cba273c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5416095c882b34864c7944edc753b71b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5416095c882b34864c7944edc753b71b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5416095c882b34864c7944edc753b71b.html#a5416095c882b34864c7944edc753b71b">fmax</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a5416095c882b34864c7944edc753b71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greater of the two specified arguments.  <a href="namespacestan_1_1math_a5416095c882b34864c7944edc753b71b.html#a5416095c882b34864c7944edc753b71b">More...</a><br /></td></tr>
<tr class="separator:a5416095c882b34864c7944edc753b71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fcdf2af0d8c6a4087be247396de65c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9fcdf2af0d8c6a4087be247396de65c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9fcdf2af0d8c6a4087be247396de65c9.html#a9fcdf2af0d8c6a4087be247396de65c9">fmax</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="memdesc:a9fcdf2af0d8c6a4087be247396de65c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greater of the two specified arguments.  <a href="namespacestan_1_1math_a9fcdf2af0d8c6a4087be247396de65c9.html#a9fcdf2af0d8c6a4087be247396de65c9">More...</a><br /></td></tr>
<tr class="separator:a9fcdf2af0d8c6a4087be247396de65c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae765dc2aa344a1893f66bffbdab0267c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae765dc2aa344a1893f66bffbdab0267c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae765dc2aa344a1893f66bffbdab0267c.html#ae765dc2aa344a1893f66bffbdab0267c">fmin</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:ae765dc2aa344a1893f66bffbdab0267c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76352d5674e886e8a68f43815875fe39"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a76352d5674e886e8a68f43815875fe39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a76352d5674e886e8a68f43815875fe39.html#a76352d5674e886e8a68f43815875fe39">fmin</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a76352d5674e886e8a68f43815875fe39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435c289fce98eb60c825fa80aa778b90"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a435c289fce98eb60c825fa80aa778b90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a435c289fce98eb60c825fa80aa778b90.html#a435c289fce98eb60c825fa80aa778b90">fmin</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:a435c289fce98eb60c825fa80aa778b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f40b2c56584ebd33037769fddc4d3f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9f40b2c56584ebd33037769fddc4d3f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac9f40b2c56584ebd33037769fddc4d3f.html#ac9f40b2c56584ebd33037769fddc4d3f">fmod</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:ac9f40b2c56584ebd33037769fddc4d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a03975312941dfd6cb03720655c533"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae6a03975312941dfd6cb03720655c533"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae6a03975312941dfd6cb03720655c533.html#ae6a03975312941dfd6cb03720655c533">fmod</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:ae6a03975312941dfd6cb03720655c533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1065cd0e0ee1fc7d0fff90ab59b312"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3e1065cd0e0ee1fc7d0fff90ab59b312"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3e1065cd0e0ee1fc7d0fff90ab59b312.html#a3e1065cd0e0ee1fc7d0fff90ab59b312">fmod</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a3e1065cd0e0ee1fc7d0fff90ab59b312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fad89bd8e78eee42230dd92bcf1b15"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa0fad89bd8e78eee42230dd92bcf1b15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa0fad89bd8e78eee42230dd92bcf1b15.html#aa0fad89bd8e78eee42230dd92bcf1b15">gamma_p</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:aa0fad89bd8e78eee42230dd92bcf1b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2d36440b28eba7712ae2f7d0b384e8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e2d36440b28eba7712ae2f7d0b384e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6e2d36440b28eba7712ae2f7d0b384e8.html#a6e2d36440b28eba7712ae2f7d0b384e8">gamma_p</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:a6e2d36440b28eba7712ae2f7d0b384e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c6b52e19adac5edbd7a42378387f76"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21c6b52e19adac5edbd7a42378387f76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a21c6b52e19adac5edbd7a42378387f76.html#a21c6b52e19adac5edbd7a42378387f76">gamma_p</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a21c6b52e19adac5edbd7a42378387f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743267027c96ebef239be63589a6d594"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a743267027c96ebef239be63589a6d594"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a743267027c96ebef239be63589a6d594.html#a743267027c96ebef239be63589a6d594">gamma_q</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a743267027c96ebef239be63589a6d594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8784b99e08f74d6112fa85d445d1ea33"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8784b99e08f74d6112fa85d445d1ea33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8784b99e08f74d6112fa85d445d1ea33.html#a8784b99e08f74d6112fa85d445d1ea33">gamma_q</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:a8784b99e08f74d6112fa85d445d1ea33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c71835e8465faca6bf377a06f9d24c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab7c71835e8465faca6bf377a06f9d24c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab7c71835e8465faca6bf377a06f9d24c.html#ab7c71835e8465faca6bf377a06f9d24c">gamma_q</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:ab7c71835e8465faca6bf377a06f9d24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89740a27ac232e6024a691f7581e817b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a89740a27ac232e6024a691f7581e817b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a89740a27ac232e6024a691f7581e817b.html#a89740a27ac232e6024a691f7581e817b">grad_inc_beta</a> (<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;g1, <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;g2, <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; a, <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; b, <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a89740a27ac232e6024a691f7581e817b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradient of the incomplete beta function beta(a, b, z) with respect to the first two arguments.  <a href="namespacestan_1_1math_a89740a27ac232e6024a691f7581e817b.html#a89740a27ac232e6024a691f7581e817b">More...</a><br /></td></tr>
<tr class="separator:a89740a27ac232e6024a691f7581e817b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d24e9b8412f526a261d15f1c58f6c1"><td class="memTemplParams" colspan="2">template&lt;typename Ta1 , typename Ta2 , typename Tb , typename Tz , require_all_stan_scalar_t&lt; Ta1, Ta2, Tb, Tz &gt; *  = nullptr, require_any_fvar_t&lt; Ta1, Ta2, Tb, Tz &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a60d24e9b8412f526a261d15f1c58f6c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Ta1, Ta1, Tb, Tz &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a60d24e9b8412f526a261d15f1c58f6c1.html#a60d24e9b8412f526a261d15f1c58f6c1">hypergeometric_2F1</a> (const Ta1 &amp;a1, const Ta2 &amp;a2, const Tb &amp;b, const Tz &amp;z)</td></tr>
<tr class="memdesc:a60d24e9b8412f526a261d15f1c58f6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gauss hypergeometric function applied to the input arguments: \(_2F_1(a_1,a_2;b;z)\).  <a href="namespacestan_1_1math_a60d24e9b8412f526a261d15f1c58f6c1.html#a60d24e9b8412f526a261d15f1c58f6c1">More...</a><br /></td></tr>
<tr class="separator:a60d24e9b8412f526a261d15f1c58f6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cc5836dd471451427e528c588b09a9"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , typename Tz , require_all_matrix_t&lt; Ta, Tb &gt; *  = nullptr, require_return_type_t&lt; is_fvar, Ta, Tb, Tz &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a29cc5836dd471451427e528c588b09a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Ta, Tb, Tz &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a29cc5836dd471451427e528c588b09a9.html#a29cc5836dd471451427e528c588b09a9">hypergeometric_pFq</a> (const Ta &amp;a, const Tb &amp;b, const Tz &amp;z)</td></tr>
<tr class="memdesc:a29cc5836dd471451427e528c588b09a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the generalised hypergeometric (pFq) function applied to the input arguments.  <a href="namespacestan_1_1math_a29cc5836dd471451427e528c588b09a9.html#a29cc5836dd471451427e528c588b09a9">More...</a><br /></td></tr>
<tr class="separator:a29cc5836dd471451427e528c588b09a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd88cd5e3b00b9d099acd2482ca6fbf2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd88cd5e3b00b9d099acd2482ca6fbf2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acd88cd5e3b00b9d099acd2482ca6fbf2.html#acd88cd5e3b00b9d099acd2482ca6fbf2">hypot</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:acd88cd5e3b00b9d099acd2482ca6fbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of the hypotenuse of a right triangle with opposite and adjacent side lengths given by the specified arguments (C++11).  <a href="namespacestan_1_1math_acd88cd5e3b00b9d099acd2482ca6fbf2.html#acd88cd5e3b00b9d099acd2482ca6fbf2">More...</a><br /></td></tr>
<tr class="separator:acd88cd5e3b00b9d099acd2482ca6fbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67f7936faba65b51aea1fec6ab84ad2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae67f7936faba65b51aea1fec6ab84ad2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae67f7936faba65b51aea1fec6ab84ad2.html#ae67f7936faba65b51aea1fec6ab84ad2">hypot</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="memdesc:ae67f7936faba65b51aea1fec6ab84ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of the hypotenuse of a right triangle with opposite and adjacent side lengths given by the specified arguments (C++11).  <a href="namespacestan_1_1math_ae67f7936faba65b51aea1fec6ab84ad2.html#ae67f7936faba65b51aea1fec6ab84ad2">More...</a><br /></td></tr>
<tr class="separator:ae67f7936faba65b51aea1fec6ab84ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b8cedeee60d523e56c8b50ca4cc283"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a26b8cedeee60d523e56c8b50ca4cc283"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a26b8cedeee60d523e56c8b50ca4cc283.html#a26b8cedeee60d523e56c8b50ca4cc283">hypot</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a26b8cedeee60d523e56c8b50ca4cc283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of the hypotenuse of a right triangle with opposite and adjacent side lengths given by the specified arguments (C++11).  <a href="namespacestan_1_1math_a26b8cedeee60d523e56c8b50ca4cc283.html#a26b8cedeee60d523e56c8b50ca4cc283">More...</a><br /></td></tr>
<tr class="separator:a26b8cedeee60d523e56c8b50ca4cc283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9988ca802426ba048ba5d5d9ad71e2e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9988ca802426ba048ba5d5d9ad71e2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af9988ca802426ba048ba5d5d9ad71e2e.html#af9988ca802426ba048ba5d5d9ad71e2e">inc_beta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;a, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;b, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:af9988ca802426ba048ba5d5d9ad71e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c7f987cec8720b849664642bd82422"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac4c7f987cec8720b849664642bd82422"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac4c7f987cec8720b849664642bd82422.html#ac4c7f987cec8720b849664642bd82422">inc_beta</a> (double a, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;b, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ac4c7f987cec8720b849664642bd82422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a412999a794de1b47328738f2f1306"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a58a412999a794de1b47328738f2f1306"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a58a412999a794de1b47328738f2f1306.html#a58a412999a794de1b47328738f2f1306">inc_beta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;a, double b, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a58a412999a794de1b47328738f2f1306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa470e198e9a0873e09b86a951d79b54f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa470e198e9a0873e09b86a951d79b54f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa470e198e9a0873e09b86a951d79b54f.html#aa470e198e9a0873e09b86a951d79b54f">inc_beta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;a, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;b, double x)</td></tr>
<tr class="separator:aa470e198e9a0873e09b86a951d79b54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90900cc252999792d78649faa2815ab6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a90900cc252999792d78649faa2815ab6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a90900cc252999792d78649faa2815ab6.html#a90900cc252999792d78649faa2815ab6">inc_beta</a> (double a, double b, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a90900cc252999792d78649faa2815ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a38fb633824f835cee25d3604939717"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a38fb633824f835cee25d3604939717"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5a38fb633824f835cee25d3604939717.html#a5a38fb633824f835cee25d3604939717">inc_beta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;a, double b, double x)</td></tr>
<tr class="separator:a5a38fb633824f835cee25d3604939717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6e0cbcdaa146113980f4db3df324cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada6e0cbcdaa146113980f4db3df324cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ada6e0cbcdaa146113980f4db3df324cd.html#ada6e0cbcdaa146113980f4db3df324cd">inc_beta</a> (double a, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;b, double x)</td></tr>
<tr class="separator:ada6e0cbcdaa146113980f4db3df324cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5386561ba622e05cb64345fdad6a3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2a5386561ba622e05cb64345fdad6a3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2a5386561ba622e05cb64345fdad6a3b.html#a2a5386561ba622e05cb64345fdad6a3b">inv</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a2a5386561ba622e05cb64345fdad6a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba00ed1e73c3a2366226aa4c83e4d8b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba00ed1e73c3a2366226aa4c83e4d8b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aba00ed1e73c3a2366226aa4c83e4d8b9.html#aba00ed1e73c3a2366226aa4c83e4d8b9">inv_cloglog</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aba00ed1e73c3a2366226aa4c83e4d8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0863d6644325ad15404de50346785e55"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0863d6644325ad15404de50346785e55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0863d6644325ad15404de50346785e55.html#a0863d6644325ad15404de50346785e55">inv_erfc</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a0863d6644325ad15404de50346785e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251969c394fad97373c78187492f21f0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_stan_scalar_t&lt; T1, T2, T3 &gt; *  = nullptr, require_any_fvar_t&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a251969c394fad97373c78187492f21f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="namespacestan_aabaa16e71f5249e2921c992ae2006995.html#aabaa16e71f5249e2921c992ae2006995">partials_return_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a251969c394fad97373c78187492f21f0.html#a251969c394fad97373c78187492f21f0">inv_inc_beta</a> (const T1 &amp;a, const T2 &amp;b, const T3 &amp;p)</td></tr>
<tr class="memdesc:a251969c394fad97373c78187492f21f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of the normalized incomplete beta function of a, b, with probability p.  <a href="namespacestan_1_1math_a251969c394fad97373c78187492f21f0.html#a251969c394fad97373c78187492f21f0">More...</a><br /></td></tr>
<tr class="separator:a251969c394fad97373c78187492f21f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a22ee34432be58edb4b6ed9469370a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a76a22ee34432be58edb4b6ed9469370a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a76a22ee34432be58edb4b6ed9469370a.html#a76a22ee34432be58edb4b6ed9469370a">inv_logit</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a76a22ee34432be58edb4b6ed9469370a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse logit function applied to the argument.  <a href="namespacestan_1_1math_a76a22ee34432be58edb4b6ed9469370a.html#a76a22ee34432be58edb4b6ed9469370a">More...</a><br /></td></tr>
<tr class="separator:a76a22ee34432be58edb4b6ed9469370a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bcae4b6bdf262f91673bf7b15fea99"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91bcae4b6bdf262f91673bf7b15fea99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a91bcae4b6bdf262f91673bf7b15fea99.html#a91bcae4b6bdf262f91673bf7b15fea99">inv_Phi</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="separator:a91bcae4b6bdf262f91673bf7b15fea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2d4971bfd22beacb304bdd5b9d3395"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca2d4971bfd22beacb304bdd5b9d3395"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aca2d4971bfd22beacb304bdd5b9d3395.html#aca2d4971bfd22beacb304bdd5b9d3395">inv_sqrt</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aca2d4971bfd22beacb304bdd5b9d3395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c1f6b0f3c9f48fa30e09f2d929336d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa7c1f6b0f3c9f48fa30e09f2d929336d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa7c1f6b0f3c9f48fa30e09f2d929336d.html#aa7c1f6b0f3c9f48fa30e09f2d929336d">inv_square</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aa7c1f6b0f3c9f48fa30e09f2d929336d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9758a1234f70a8b8954caff1a3ffbf03"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_vt&lt; is_fvar, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9758a1234f70a8b8954caff1a3ffbf03"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, EigMat::RowsAtCompileTime, EigMat::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9758a1234f70a8b8954caff1a3ffbf03.html#a9758a1234f70a8b8954caff1a3ffbf03">inverse</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a9758a1234f70a8b8954caff1a3ffbf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward mode specialization of calculating the inverse of the matrix.  <a href="namespacestan_1_1math_a9758a1234f70a8b8954caff1a3ffbf03.html#a9758a1234f70a8b8954caff1a3ffbf03">More...</a><br /></td></tr>
<tr class="separator:a9758a1234f70a8b8954caff1a3ffbf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad359149ebad087910f96e62f88287c1f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad359149ebad087910f96e62f88287c1f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad359149ebad087910f96e62f88287c1f.html#ad359149ebad087910f96e62f88287c1f">is_inf</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:ad359149ebad087910f96e62f88287c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the input's value is infinite and 0 otherwise.  <a href="namespacestan_1_1math_ad359149ebad087910f96e62f88287c1f.html#ad359149ebad087910f96e62f88287c1f">More...</a><br /></td></tr>
<tr class="separator:ad359149ebad087910f96e62f88287c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254953197ba565e7d5ef61ea7fa0fbd2"><td class="memTemplParams" colspan="2">template&lt;typename T , require_fvar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a254953197ba565e7d5ef61ea7fa0fbd2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a254953197ba565e7d5ef61ea7fa0fbd2.html#a254953197ba565e7d5ef61ea7fa0fbd2">is_nan</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:a254953197ba565e7d5ef61ea7fa0fbd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the input's value is NaN and 0 otherwise.  <a href="namespacestan_1_1math_a254953197ba565e7d5ef61ea7fa0fbd2.html#a254953197ba565e7d5ef61ea7fa0fbd2">More...</a><br /></td></tr>
<tr class="separator:a254953197ba565e7d5ef61ea7fa0fbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ff22e60ccff4f720d813cf30c801b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac1ff22e60ccff4f720d813cf30c801b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac1ff22e60ccff4f720d813cf30c801b6.html#ac1ff22e60ccff4f720d813cf30c801b6">lambert_w0</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ac1ff22e60ccff4f720d813cf30c801b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9639d15cf696cb1cd047a1b61a7f5928"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9639d15cf696cb1cd047a1b61a7f5928"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9639d15cf696cb1cd047a1b61a7f5928.html#a9639d15cf696cb1cd047a1b61a7f5928">lambert_wm1</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a9639d15cf696cb1cd047a1b61a7f5928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51be9d210e223a8aa4241e2d725e295"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac51be9d210e223a8aa4241e2d725e295"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac51be9d210e223a8aa4241e2d725e295.html#ac51be9d210e223a8aa4241e2d725e295">lbeta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:ac51be9d210e223a8aa4241e2d725e295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab925716230b89990950167983810a970"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab925716230b89990950167983810a970"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab925716230b89990950167983810a970.html#ab925716230b89990950167983810a970">lbeta</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:ab925716230b89990950167983810a970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe54aa714ac9bc4417df7a9ea01e7bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2fe54aa714ac9bc4417df7a9ea01e7bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2fe54aa714ac9bc4417df7a9ea01e7bf.html#a2fe54aa714ac9bc4417df7a9ea01e7bf">lbeta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:a2fe54aa714ac9bc4417df7a9ea01e7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0285044dc46f4fb351a4048f39f53096"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0285044dc46f4fb351a4048f39f53096"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0285044dc46f4fb351a4048f39f53096.html#a0285044dc46f4fb351a4048f39f53096">ldexp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;a, int b)</td></tr>
<tr class="memdesc:a0285044dc46f4fb351a4048f39f53096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of a (the significand) times 2 to power b (the exponent).  <a href="namespacestan_1_1math_a0285044dc46f4fb351a4048f39f53096.html#a0285044dc46f4fb351a4048f39f53096">More...</a><br /></td></tr>
<tr class="separator:a0285044dc46f4fb351a4048f39f53096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead76f03bdbc60484ad760fc31bad40f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aead76f03bdbc60484ad760fc31bad40f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aead76f03bdbc60484ad760fc31bad40f.html#aead76f03bdbc60484ad760fc31bad40f">lgamma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:aead76f03bdbc60484ad760fc31bad40f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the gamma function applied to the specified argument.  <a href="namespacestan_1_1math_aead76f03bdbc60484ad760fc31bad40f.html#aead76f03bdbc60484ad760fc31bad40f">More...</a><br /></td></tr>
<tr class="separator:aead76f03bdbc60484ad760fc31bad40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a2ce5363737a8a5e4ef87192052268"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51a2ce5363737a8a5e4ef87192052268"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a51a2ce5363737a8a5e4ef87192052268.html#a51a2ce5363737a8a5e4ef87192052268">lmgamma</a> (int x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a51a2ce5363737a8a5e4ef87192052268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329536a85718ab3c9506b87a17bc7a8b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a329536a85718ab3c9506b87a17bc7a8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a329536a85718ab3c9506b87a17bc7a8b.html#a329536a85718ab3c9506b87a17bc7a8b">lmultiply</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a329536a85718ab3c9506b87a17bc7a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff422b755e08f775f36737f851103a28"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff422b755e08f775f36737f851103a28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aff422b755e08f775f36737f851103a28.html#aff422b755e08f775f36737f851103a28">lmultiply</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:aff422b755e08f775f36737f851103a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068e8ca11114a326ba28bfa83e514756"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a068e8ca11114a326ba28bfa83e514756"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a068e8ca11114a326ba28bfa83e514756.html#a068e8ca11114a326ba28bfa83e514756">lmultiply</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:a068e8ca11114a326ba28bfa83e514756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915ada1e5971c467aa16ee926997a442"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a915ada1e5971c467aa16ee926997a442"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a915ada1e5971c467aa16ee926997a442.html#a915ada1e5971c467aa16ee926997a442">log</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a915ada1e5971c467aa16ee926997a442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f50c673fd6df86d00afb684ef278645"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f50c673fd6df86d00afb684ef278645"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6f50c673fd6df86d00afb684ef278645.html#a6f50c673fd6df86d00afb684ef278645">log</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:a6f50c673fd6df86d00afb684ef278645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm (base e) of the specified complex argument.  <a href="namespacestan_1_1math_a6f50c673fd6df86d00afb684ef278645.html#a6f50c673fd6df86d00afb684ef278645">More...</a><br /></td></tr>
<tr class="separator:a6f50c673fd6df86d00afb684ef278645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808cbb5ac4003f28e2538805ebe338ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a808cbb5ac4003f28e2538805ebe338ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a808cbb5ac4003f28e2538805ebe338ef.html#a808cbb5ac4003f28e2538805ebe338ef">log10</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a808cbb5ac4003f28e2538805ebe338ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89240c5ff7e11172b83f5ffac6edc04"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af89240c5ff7e11172b83f5ffac6edc04"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af89240c5ff7e11172b83f5ffac6edc04.html#af89240c5ff7e11172b83f5ffac6edc04">log10</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:af89240c5ff7e11172b83f5ffac6edc04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base 10 logarithm of the specified complex number.  <a href="namespacestan_1_1math_af89240c5ff7e11172b83f5ffac6edc04.html#af89240c5ff7e11172b83f5ffac6edc04">More...</a><br /></td></tr>
<tr class="separator:af89240c5ff7e11172b83f5ffac6edc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d92a982acd829e77b3f5b975baa6aed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d92a982acd829e77b3f5b975baa6aed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8d92a982acd829e77b3f5b975baa6aed.html#a8d92a982acd829e77b3f5b975baa6aed">log1m</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a8d92a982acd829e77b3f5b975baa6aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7760d28e8fddf268113469b44463de07"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7760d28e8fddf268113469b44463de07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7760d28e8fddf268113469b44463de07.html#a7760d28e8fddf268113469b44463de07">log1m_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a7760d28e8fddf268113469b44463de07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one minus the exponentiation of the specified argument.  <a href="namespacestan_1_1math_a7760d28e8fddf268113469b44463de07.html#a7760d28e8fddf268113469b44463de07">More...</a><br /></td></tr>
<tr class="separator:a7760d28e8fddf268113469b44463de07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f286f8a9043aee8a1a844493da0d55"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a79f286f8a9043aee8a1a844493da0d55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a79f286f8a9043aee8a1a844493da0d55.html#a79f286f8a9043aee8a1a844493da0d55">log1m_inv_logit</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a79f286f8a9043aee8a1a844493da0d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one minus the inverse logit of the specified argument.  <a href="namespacestan_1_1math_a79f286f8a9043aee8a1a844493da0d55.html#a79f286f8a9043aee8a1a844493da0d55">More...</a><br /></td></tr>
<tr class="separator:a79f286f8a9043aee8a1a844493da0d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16e57e82fb1e17f74ef43592748ff32"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa16e57e82fb1e17f74ef43592748ff32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa16e57e82fb1e17f74ef43592748ff32.html#aa16e57e82fb1e17f74ef43592748ff32">log1p</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aa16e57e82fb1e17f74ef43592748ff32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe928ad2b96b802f6d488ba43167489"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0fe928ad2b96b802f6d488ba43167489"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0fe928ad2b96b802f6d488ba43167489.html#a0fe928ad2b96b802f6d488ba43167489">log1p_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a0fe928ad2b96b802f6d488ba43167489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eea39b4ca603cff7518068499884364"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4eea39b4ca603cff7518068499884364"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4eea39b4ca603cff7518068499884364.html#a4eea39b4ca603cff7518068499884364">log2</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a4eea39b4ca603cff7518068499884364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base two logarithm of the specified argument.  <a href="namespacestan_1_1math_a4eea39b4ca603cff7518068499884364.html#a4eea39b4ca603cff7518068499884364">More...</a><br /></td></tr>
<tr class="separator:a4eea39b4ca603cff7518068499884364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b163550f61a7a0929371968db4f397"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_vt&lt; is_fvar, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a42b163550f61a7a0929371968db4f397"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a42b163550f61a7a0929371968db4f397.html#a42b163550f61a7a0929371968db4f397">log_determinant</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a42b163550f61a7a0929371968db4f397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log absolute determinant of the specified square matrix.  <a href="namespacestan_1_1math_a42b163550f61a7a0929371968db4f397.html#a42b163550f61a7a0929371968db4f397">More...</a><br /></td></tr>
<tr class="separator:a42b163550f61a7a0929371968db4f397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba84f8c43b399f555647a0402a710ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ba84f8c43b399f555647a0402a710ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1ba84f8c43b399f555647a0402a710ef.html#a1ba84f8c43b399f555647a0402a710ef">log_diff_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a1ba84f8c43b399f555647a0402a710ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d912f496e0e7531747754e11cb704a7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_arithmetic_t&lt; T1 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3d912f496e0e7531747754e11cb704a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3d912f496e0e7531747754e11cb704a7.html#a3d912f496e0e7531747754e11cb704a7">log_diff_exp</a> (const T1 &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt; &amp;x2)</td></tr>
<tr class="separator:a3d912f496e0e7531747754e11cb704a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced93fbe376bb05a3dffc2e42274a85a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_arithmetic_t&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aced93fbe376bb05a3dffc2e42274a85a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aced93fbe376bb05a3dffc2e42274a85a.html#aced93fbe376bb05a3dffc2e42274a85a">log_diff_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt; &amp;x1, const T2 &amp;x2)</td></tr>
<tr class="separator:aced93fbe376bb05a3dffc2e42274a85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e4116dfd00db87062ef7c0f76e8c27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a58e4116dfd00db87062ef7c0f76e8c27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a58e4116dfd00db87062ef7c0f76e8c27.html#a58e4116dfd00db87062ef7c0f76e8c27">log_falling_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="separator:a58e4116dfd00db87062ef7c0f76e8c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00155292aa8f1f0fa1e8b8c1a9c9b24e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00155292aa8f1f0fa1e8b8c1a9c9b24e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a00155292aa8f1f0fa1e8b8c1a9c9b24e.html#a00155292aa8f1f0fa1e8b8c1a9c9b24e">log_falling_factorial</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="separator:a00155292aa8f1f0fa1e8b8c1a9c9b24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa89f085049a091796950c42991a720"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6fa89f085049a091796950c42991a720"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6fa89f085049a091796950c42991a720.html#a6fa89f085049a091796950c42991a720">log_falling_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double n)</td></tr>
<tr class="separator:a6fa89f085049a091796950c42991a720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2fe56bce70a04dd11e8a5a32b1b51c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd2fe56bce70a04dd11e8a5a32b1b51c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acd2fe56bce70a04dd11e8a5a32b1b51c.html#acd2fe56bce70a04dd11e8a5a32b1b51c">log_inv_logit</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:acd2fe56bce70a04dd11e8a5a32b1b51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7521ffa983d16d8337f1149fa4fef847"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7521ffa983d16d8337f1149fa4fef847"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7521ffa983d16d8337f1149fa4fef847.html#a7521ffa983d16d8337f1149fa4fef847">log_inv_logit_diff</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a7521ffa983d16d8337f1149fa4fef847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns fvar with the natural logarithm of the difference of the inverse logits of the specified arguments and its gradients.  <a href="namespacestan_1_1math_a7521ffa983d16d8337f1149fa4fef847.html#a7521ffa983d16d8337f1149fa4fef847">More...</a><br /></td></tr>
<tr class="separator:a7521ffa983d16d8337f1149fa4fef847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e77c5f088c0f3a1d90f4b895e29bd40"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e77c5f088c0f3a1d90f4b895e29bd40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6e77c5f088c0f3a1d90f4b895e29bd40.html#a6e77c5f088c0f3a1d90f4b895e29bd40">log_inv_logit_diff</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="separator:a6e77c5f088c0f3a1d90f4b895e29bd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6865ceb241e2f618ec5deba363013911"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6865ceb241e2f618ec5deba363013911"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6865ceb241e2f618ec5deba363013911.html#a6865ceb241e2f618ec5deba363013911">log_inv_logit_diff</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:a6865ceb241e2f618ec5deba363013911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938cde7de0933bf75aa436720b5c90a9"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , typename T_lambda1 , typename T_lambda2 , int N&gt; </td></tr>
<tr class="memitem:a938cde7de0933bf75aa436720b5c90a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a938cde7de0933bf75aa436720b5c90a9.html#a938cde7de0933bf75aa436720b5c90a9">log_mix_partial_helper</a> (const T_theta &amp;theta, const T_lambda1 &amp;lambda1, const T_lambda2 &amp;lambda2, <a class="el" href="group__type__trait_ga546483131616701876a9f1307f5a413d.html#ga546483131616701876a9f1307f5a413d">promote_args_t</a>&lt; T_theta, T_lambda1, T_lambda2 &gt;(&amp;partials_array)[N])</td></tr>
<tr class="separator:a938cde7de0933bf75aa436720b5c90a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014f4431773309ae7fd1420b0f6aa99f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a014f4431773309ae7fd1420b0f6aa99f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a014f4431773309ae7fd1420b0f6aa99f.html#a014f4431773309ae7fd1420b0f6aa99f">log_mix</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;theta, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda2)</td></tr>
<tr class="memdesc:a014f4431773309ae7fd1420b0f6aa99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log mixture density with specified mixing proportion and log densities and its derivative at each.  <a href="namespacestan_1_1math_a014f4431773309ae7fd1420b0f6aa99f.html#a014f4431773309ae7fd1420b0f6aa99f">More...</a><br /></td></tr>
<tr class="separator:a014f4431773309ae7fd1420b0f6aa99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51d61eeb056f168b62931f4494a827d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , require_all_arithmetic_t&lt; P &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad51d61eeb056f168b62931f4494a827d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad51d61eeb056f168b62931f4494a827d.html#ad51d61eeb056f168b62931f4494a827d">log_mix</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;theta, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda1, P lambda2)</td></tr>
<tr class="separator:ad51d61eeb056f168b62931f4494a827d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c3b3011ed34c161396151737cece82"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , require_all_arithmetic_t&lt; P &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a59c3b3011ed34c161396151737cece82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a59c3b3011ed34c161396151737cece82.html#a59c3b3011ed34c161396151737cece82">log_mix</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;theta, P lambda1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda2)</td></tr>
<tr class="separator:a59c3b3011ed34c161396151737cece82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724b9302bcaa5f80e9cd75432b2d7b14"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , require_all_arithmetic_t&lt; P &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a724b9302bcaa5f80e9cd75432b2d7b14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a724b9302bcaa5f80e9cd75432b2d7b14.html#a724b9302bcaa5f80e9cd75432b2d7b14">log_mix</a> (P theta, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda2)</td></tr>
<tr class="separator:a724b9302bcaa5f80e9cd75432b2d7b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931e2159107817aa98e095937521d702"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P1 , typename P2 , require_all_arithmetic_t&lt; P1, P2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a931e2159107817aa98e095937521d702"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a931e2159107817aa98e095937521d702.html#a931e2159107817aa98e095937521d702">log_mix</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;theta, P1 lambda1, P2 lambda2)</td></tr>
<tr class="separator:a931e2159107817aa98e095937521d702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f8db612c040ea05160377383774b0c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P1 , typename P2 , require_all_arithmetic_t&lt; P1, P2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a08f8db612c040ea05160377383774b0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a08f8db612c040ea05160377383774b0c.html#a08f8db612c040ea05160377383774b0c">log_mix</a> (P1 theta, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda1, P2 lambda2)</td></tr>
<tr class="separator:a08f8db612c040ea05160377383774b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc03ce7a557f5df2ffa002f65261c86"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P1 , typename P2 , require_all_arithmetic_t&lt; P1, P2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adcc03ce7a557f5df2ffa002f65261c86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adcc03ce7a557f5df2ffa002f65261c86.html#adcc03ce7a557f5df2ffa002f65261c86">log_mix</a> (P1 theta, P2 lambda1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda2)</td></tr>
<tr class="separator:adcc03ce7a557f5df2ffa002f65261c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4aff0dd42a2b0b33ac55e9a45f35b1e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4aff0dd42a2b0b33ac55e9a45f35b1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa4aff0dd42a2b0b33ac55e9a45f35b1e.html#aa4aff0dd42a2b0b33ac55e9a45f35b1e">log_rising_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="separator:aa4aff0dd42a2b0b33ac55e9a45f35b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e293e0508ba250c307ecd9e0833f394"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7e293e0508ba250c307ecd9e0833f394"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7e293e0508ba250c307ecd9e0833f394.html#a7e293e0508ba250c307ecd9e0833f394">log_rising_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double n)</td></tr>
<tr class="separator:a7e293e0508ba250c307ecd9e0833f394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70af0a51cb1fcf8a88b558823b3292ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70af0a51cb1fcf8a88b558823b3292ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a70af0a51cb1fcf8a88b558823b3292ce.html#a70af0a51cb1fcf8a88b558823b3292ce">log_rising_factorial</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="separator:a70af0a51cb1fcf8a88b558823b3292ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d1fba816ec9bab4fa798aee35e0241"><td class="memTemplParams" colspan="2">template&lt;typename T , require_vector_st&lt; is_fvar, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac8d1fba816ec9bab4fa798aee35e0241"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac8d1fba816ec9bab4fa798aee35e0241.html#ac8d1fba816ec9bab4fa798aee35e0241">log_softmax</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ac8d1fba816ec9bab4fa798aee35e0241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log softmax of the specified vector or container of vectors.  <a href="namespacestan_1_1math_ac8d1fba816ec9bab4fa798aee35e0241.html#ac8d1fba816ec9bab4fa798aee35e0241">More...</a><br /></td></tr>
<tr class="separator:ac8d1fba816ec9bab4fa798aee35e0241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177e64b45d304afc52540d776de8dbe1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a177e64b45d304afc52540d776de8dbe1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a177e64b45d304afc52540d776de8dbe1.html#a177e64b45d304afc52540d776de8dbe1">log_sum_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a177e64b45d304afc52540d776de8dbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f71749d764dc0eb325db3960e58cc5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a48f71749d764dc0eb325db3960e58cc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a48f71749d764dc0eb325db3960e58cc5.html#a48f71749d764dc0eb325db3960e58cc5">log_sum_exp</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a48f71749d764dc0eb325db3960e58cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ef64a8bcabd3a5581ad058c5908925"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87ef64a8bcabd3a5581ad058c5908925"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a87ef64a8bcabd3a5581ad058c5908925.html#a87ef64a8bcabd3a5581ad058c5908925">log_sum_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:a87ef64a8bcabd3a5581ad058c5908925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c58a64be70f069f3a2a86ef475101b"><td class="memTemplParams" colspan="2">template&lt;typename T , require_container_st&lt; is_fvar, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae7c58a64be70f069f3a2a86ef475101b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae7c58a64be70f069f3a2a86ef475101b.html#ae7c58a64be70f069f3a2a86ef475101b">log_sum_exp</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae7c58a64be70f069f3a2a86ef475101b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the sum of the exponentiated values of the specified matrix of values.  <a href="namespacestan_1_1math_ae7c58a64be70f069f3a2a86ef475101b.html#ae7c58a64be70f069f3a2a86ef475101b">More...</a><br /></td></tr>
<tr class="separator:ae7c58a64be70f069f3a2a86ef475101b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab025eaf1e6f5c920f69c37e7a7f8b319"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab025eaf1e6f5c920f69c37e7a7f8b319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab025eaf1e6f5c920f69c37e7a7f8b319.html#ab025eaf1e6f5c920f69c37e7a7f8b319">logit</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ab025eaf1e6f5c920f69c37e7a7f8b319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cfaaa35ed78c2a12842125064b3751"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_eigen_vt&lt; is_fvar, T1, T2 &gt; *  = nullptr, require_vt_same&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac0cfaaa35ed78c2a12842125064b3751"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T1 &gt;, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac0cfaaa35ed78c2a12842125064b3751.html#ac0cfaaa35ed78c2a12842125064b3751">mdivide_left</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="separator:ac0cfaaa35ed78c2a12842125064b3751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943b9c89144096009afa4a371ed57baf"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_eigen_vt&lt; std::is_arithmetic, T1 &gt; *  = nullptr, require_eigen_vt&lt; is_fvar, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a943b9c89144096009afa4a371ed57baf"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T2 &gt;, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a943b9c89144096009afa4a371ed57baf.html#a943b9c89144096009afa4a371ed57baf">mdivide_left</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="separator:a943b9c89144096009afa4a371ed57baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77916317836fe86823f3ab3affc634a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename EigMat , require_eigen_vt&lt; std::is_arithmetic, T &gt; *  = nullptr, require_eigen_vt&lt; is_fvar, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab77916317836fe86823f3ab3affc634a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, EigMat::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab77916317836fe86823f3ab3affc634a.html#ab77916317836fe86823f3ab3affc634a">mdivide_left_ldlt</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A, const EigMat &amp;b)</td></tr>
<tr class="memdesc:ab77916317836fe86823f3ab3affc634a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> of A.  <a href="namespacestan_1_1math_ab77916317836fe86823f3ab3affc634a.html#ab77916317836fe86823f3ab3affc634a">More...</a><br /></td></tr>
<tr class="separator:ab77916317836fe86823f3ab3affc634a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0203512b8d43d651d6b3d318841f6458"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_eigen_vt&lt; is_fvar, T1, T2 &gt; *  = nullptr, require_vt_same&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0203512b8d43d651d6b3d318841f6458"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T1 &gt;, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0203512b8d43d651d6b3d318841f6458.html#a0203512b8d43d651d6b3d318841f6458">mdivide_left_tri_low</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="separator:a0203512b8d43d651d6b3d318841f6458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2a4f36e649d8140ff7b2688bbb5a29"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_eigen_t&lt; T1 &gt; *  = nullptr, require_vt_same&lt; double, T1 &gt; *  = nullptr, require_eigen_vt&lt; is_fvar, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0f2a4f36e649d8140ff7b2688bbb5a29"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T2 &gt;, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0f2a4f36e649d8140ff7b2688bbb5a29.html#a0f2a4f36e649d8140ff7b2688bbb5a29">mdivide_left_tri_low</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="separator:a0f2a4f36e649d8140ff7b2688bbb5a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277489b09d9d7cb5d56436a28d17f84d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_eigen_vt&lt; is_fvar, T1 &gt; *  = nullptr, require_eigen_t&lt; T2 &gt; *  = nullptr, require_vt_same&lt; double, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a277489b09d9d7cb5d56436a28d17f84d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T1 &gt;, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a277489b09d9d7cb5d56436a28d17f84d.html#a277489b09d9d7cb5d56436a28d17f84d">mdivide_left_tri_low</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="separator:a277489b09d9d7cb5d56436a28d17f84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795819fe0d7a24027ea88b5da2ce75f3"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_eigen_vt&lt; is_fvar, EigMat1, EigMat2 &gt; *  = nullptr, require_vt_same&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a795819fe0d7a24027ea88b5da2ce75f3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat1 &gt;, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a795819fe0d7a24027ea88b5da2ce75f3.html#a795819fe0d7a24027ea88b5da2ce75f3">mdivide_right</a> (const EigMat1 &amp;A, const EigMat2 &amp;b)</td></tr>
<tr class="separator:a795819fe0d7a24027ea88b5da2ce75f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f7267d394e62801e70697bc2b0b4ec"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_eigen_vt&lt; std::is_arithmetic, EigMat1 &gt; *  = nullptr, require_eigen_vt&lt; is_fvar, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a28f7267d394e62801e70697bc2b0b4ec"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat2 &gt;, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a28f7267d394e62801e70697bc2b0b4ec.html#a28f7267d394e62801e70697bc2b0b4ec">mdivide_right</a> (const EigMat1 &amp;A, const EigMat2 &amp;b)</td></tr>
<tr class="separator:a28f7267d394e62801e70697bc2b0b4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3293ab7589a3737cc35158ec22b2425c"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_eigen_vt&lt; is_fvar, EigMat1, EigMat2 &gt; *  = nullptr, require_vt_same&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3293ab7589a3737cc35158ec22b2425c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat1 &gt;, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3293ab7589a3737cc35158ec22b2425c.html#a3293ab7589a3737cc35158ec22b2425c">mdivide_right_tri_low</a> (const EigMat1 &amp;A, const EigMat2 &amp;b)</td></tr>
<tr class="separator:a3293ab7589a3737cc35158ec22b2425c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7125f51bf51fe7c23310c852e63450bc"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_eigen_vt&lt; std::is_arithmetic, EigMat1 &gt; *  = nullptr, require_eigen_vt&lt; is_fvar, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7125f51bf51fe7c23310c852e63450bc"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat2 &gt;, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7125f51bf51fe7c23310c852e63450bc.html#a7125f51bf51fe7c23310c852e63450bc">mdivide_right_tri_low</a> (const EigMat1 &amp;A, const EigMat2 &amp;b)</td></tr>
<tr class="separator:a7125f51bf51fe7c23310c852e63450bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb3160540f6fe745abb846df2174742"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adcb3160540f6fe745abb846df2174742"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adcb3160540f6fe745abb846df2174742.html#adcb3160540f6fe745abb846df2174742">modified_bessel_first_kind</a> (int v, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:adcb3160540f6fe745abb846df2174742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3277f8bf3ed3b3e36a61dedd4ed0449b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3277f8bf3ed3b3e36a61dedd4ed0449b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3277f8bf3ed3b3e36a61dedd4ed0449b.html#a3277f8bf3ed3b3e36a61dedd4ed0449b">modified_bessel_second_kind</a> (int v, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a3277f8bf3ed3b3e36a61dedd4ed0449b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68817034db6ea04cda51c87bc86329a6"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , require_all_eigen_vt&lt; is_fvar, Mat1, Mat2 &gt; *  = nullptr, require_vt_same&lt; Mat1, Mat2 &gt; *  = nullptr, require_not_eigen_row_and_col_t&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a68817034db6ea04cda51c87bc86329a6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a68817034db6ea04cda51c87bc86329a6.html#a68817034db6ea04cda51c87bc86329a6">multiply</a> (const Mat1 &amp;m1, const Mat2 &amp;m2)</td></tr>
<tr class="memdesc:a68817034db6ea04cda51c87bc86329a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the specified matrices.  <a href="namespacestan_1_1math_a68817034db6ea04cda51c87bc86329a6.html#a68817034db6ea04cda51c87bc86329a6">More...</a><br /></td></tr>
<tr class="separator:a68817034db6ea04cda51c87bc86329a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055efd6bb49a1df5ea4da98d1078d0e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a055efd6bb49a1df5ea4da98d1078d0e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a055efd6bb49a1df5ea4da98d1078d0e6.html#a055efd6bb49a1df5ea4da98d1078d0e6">multiply_log</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a055efd6bb49a1df5ea4da98d1078d0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0147592479ba45fd59bafba8dfe1f8bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0147592479ba45fd59bafba8dfe1f8bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0147592479ba45fd59bafba8dfe1f8bb.html#a0147592479ba45fd59bafba8dfe1f8bb">multiply_log</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a0147592479ba45fd59bafba8dfe1f8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3520759a80d0a52b33a2221658201c9b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3520759a80d0a52b33a2221658201c9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3520759a80d0a52b33a2221658201c9b.html#a3520759a80d0a52b33a2221658201c9b">multiply_log</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:a3520759a80d0a52b33a2221658201c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfbfa2b7f2e869903ebf48533e5bada"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_vt&lt; is_fvar, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acbfbfa2b7f2e869903ebf48533e5bada"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, EigMat::RowsAtCompileTime, EigMat::RowsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acbfbfa2b7f2e869903ebf48533e5bada.html#acbfbfa2b7f2e869903ebf48533e5bada">multiply_lower_tri_self_transpose</a> (const EigMat &amp;m)</td></tr>
<tr class="separator:acbfbfa2b7f2e869903ebf48533e5bada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb91df61b345e1e0ae05a1c0df043cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adbb91df61b345e1e0ae05a1c0df043cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adbb91df61b345e1e0ae05a1c0df043cf.html#adbb91df61b345e1e0ae05a1c0df043cf">norm</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:adbb91df61b345e1e0ae05a1c0df043cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the squared magnitude of the complex argument.  <a href="namespacestan_1_1math_adbb91df61b345e1e0ae05a1c0df043cf.html#adbb91df61b345e1e0ae05a1c0df043cf">More...</a><br /></td></tr>
<tr class="separator:adbb91df61b345e1e0ae05a1c0df043cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a82697cb0e7f7ff15e6d33382dec0b"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_eigen_vt&lt; is_fvar, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af6a82697cb0e7f7ff15e6d33382dec0b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af6a82697cb0e7f7ff15e6d33382dec0b.html#af6a82697cb0e7f7ff15e6d33382dec0b">norm1</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:af6a82697cb0e7f7ff15e6d33382dec0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L1 norm of the specified vector of values.  <a href="namespacestan_1_1math_af6a82697cb0e7f7ff15e6d33382dec0b.html#af6a82697cb0e7f7ff15e6d33382dec0b">More...</a><br /></td></tr>
<tr class="separator:af6a82697cb0e7f7ff15e6d33382dec0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c35ec2e065a564903d2b4e33bb53a1"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_eigen_vt&lt; is_fvar, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af9c35ec2e065a564903d2b4e33bb53a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af9c35ec2e065a564903d2b4e33bb53a1.html#af9c35ec2e065a564903d2b4e33bb53a1">norm2</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:af9c35ec2e065a564903d2b4e33bb53a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L2 norm of the specified vector of values.  <a href="namespacestan_1_1math_af9c35ec2e065a564903d2b4e33bb53a1.html#af9c35ec2e065a564903d2b4e33bb53a1">More...</a><br /></td></tr>
<tr class="separator:af9c35ec2e065a564903d2b4e33bb53a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b09a69d6aeee461a009b6355889e9e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b09a69d6aeee461a009b6355889e9e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9b09a69d6aeee461a009b6355889e9e4.html#a9b09a69d6aeee461a009b6355889e9e4">owens_t</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a9b09a69d6aeee461a009b6355889e9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Owen's T function applied to the specified arguments.  <a href="namespacestan_1_1math_a9b09a69d6aeee461a009b6355889e9e4.html#a9b09a69d6aeee461a009b6355889e9e4">More...</a><br /></td></tr>
<tr class="separator:a9b09a69d6aeee461a009b6355889e9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6485e70c48e61dce351c8810db79a33"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6485e70c48e61dce351c8810db79a33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af6485e70c48e61dce351c8810db79a33.html#af6485e70c48e61dce351c8810db79a33">owens_t</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:af6485e70c48e61dce351c8810db79a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Owen's T function applied to the specified arguments.  <a href="namespacestan_1_1math_af6485e70c48e61dce351c8810db79a33.html#af6485e70c48e61dce351c8810db79a33">More...</a><br /></td></tr>
<tr class="separator:af6485e70c48e61dce351c8810db79a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67322823be2c1f19e4c91fe3e69b778c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a67322823be2c1f19e4c91fe3e69b778c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a67322823be2c1f19e4c91fe3e69b778c.html#a67322823be2c1f19e4c91fe3e69b778c">owens_t</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="memdesc:a67322823be2c1f19e4c91fe3e69b778c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Owen's T function applied to the specified arguments.  <a href="namespacestan_1_1math_a67322823be2c1f19e4c91fe3e69b778c.html#a67322823be2c1f19e4c91fe3e69b778c">More...</a><br /></td></tr>
<tr class="separator:a67322823be2c1f19e4c91fe3e69b778c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73a2c7f20161172ffee17c7c880019f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac73a2c7f20161172ffee17c7c880019f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac73a2c7f20161172ffee17c7c880019f.html#ac73a2c7f20161172ffee17c7c880019f">Phi</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ac73a2c7f20161172ffee17c7c880019f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628f13a708272b55a72684f3ea8dede5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a628f13a708272b55a72684f3ea8dede5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a628f13a708272b55a72684f3ea8dede5.html#a628f13a708272b55a72684f3ea8dede5">Phi_approx</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a628f13a708272b55a72684f3ea8dede5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an approximation of the unit normal cumulative distribution function (CDF).  <a href="namespacestan_1_1math_a628f13a708272b55a72684f3ea8dede5.html#a628f13a708272b55a72684f3ea8dede5">More...</a><br /></td></tr>
<tr class="separator:a628f13a708272b55a72684f3ea8dede5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c6bbaca7d8550c54766be2f13a6bed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9c6bbaca7d8550c54766be2f13a6bed"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac9c6bbaca7d8550c54766be2f13a6bed.html#ac9c6bbaca7d8550c54766be2f13a6bed">polar</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;r, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;theta)</td></tr>
<tr class="memdesc:ac9c6bbaca7d8550c54766be2f13a6bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns complex number with specified magnitude and phase angle.  <a href="namespacestan_1_1math_ac9c6bbaca7d8550c54766be2f13a6bed.html#ac9c6bbaca7d8550c54766be2f13a6bed">More...</a><br /></td></tr>
<tr class="separator:ac9c6bbaca7d8550c54766be2f13a6bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc33bc0f309de48b384239e083f13c97"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:abc33bc0f309de48b384239e083f13c97"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abc33bc0f309de48b384239e083f13c97.html#abc33bc0f309de48b384239e083f13c97">polar</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;r, U theta)</td></tr>
<tr class="memdesc:abc33bc0f309de48b384239e083f13c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns complex number with specified magnitude and phase angle.  <a href="namespacestan_1_1math_abc33bc0f309de48b384239e083f13c97.html#abc33bc0f309de48b384239e083f13c97">More...</a><br /></td></tr>
<tr class="separator:abc33bc0f309de48b384239e083f13c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b49697de3d04506679ebe02e81d0cff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a5b49697de3d04506679ebe02e81d0cff"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5b49697de3d04506679ebe02e81d0cff.html#a5b49697de3d04506679ebe02e81d0cff">polar</a> (U r, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;theta)</td></tr>
<tr class="memdesc:a5b49697de3d04506679ebe02e81d0cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns complex number with specified magnitude and phase angle.  <a href="namespacestan_1_1math_a5b49697de3d04506679ebe02e81d0cff.html#a5b49697de3d04506679ebe02e81d0cff">More...</a><br /></td></tr>
<tr class="separator:a5b49697de3d04506679ebe02e81d0cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27caea996a79cd150f26db44fd635684"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27caea996a79cd150f26db44fd635684"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a27caea996a79cd150f26db44fd635684.html#a27caea996a79cd150f26db44fd635684">pow</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a27caea996a79cd150f26db44fd635684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7470df39900220b7c032f34b66eea009"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename  = require_arithmetic_t&lt;U&gt;&gt; </td></tr>
<tr class="memitem:a7470df39900220b7c032f34b66eea009"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7470df39900220b7c032f34b66eea009.html#a7470df39900220b7c032f34b66eea009">pow</a> (U x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a7470df39900220b7c032f34b66eea009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff8408120965a2f8a26f2d088355718"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename  = require_arithmetic_t&lt;U&gt;&gt; </td></tr>
<tr class="memitem:adff8408120965a2f8a26f2d088355718"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adff8408120965a2f8a26f2d088355718.html#adff8408120965a2f8a26f2d088355718">pow</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, U x2)</td></tr>
<tr class="separator:adff8408120965a2f8a26f2d088355718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca122c4ef80289f0a7b3ccc5e41b2587"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:aca122c4ef80289f0a7b3ccc5e41b2587"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aca122c4ef80289f0a7b3ccc5e41b2587.html#aca122c4ef80289f0a7b3ccc5e41b2587">pow</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt;&gt; &amp;x, const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt;&gt; &amp;y)</td></tr>
<tr class="memdesc:aca122c4ef80289f0a7b3ccc5e41b2587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_aca122c4ef80289f0a7b3ccc5e41b2587.html#aca122c4ef80289f0a7b3ccc5e41b2587">More...</a><br /></td></tr>
<tr class="separator:aca122c4ef80289f0a7b3ccc5e41b2587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9965952b2626722afc961e9b407024d"><td class="memTemplParams" colspan="2">template&lt;typename V , typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ac9965952b2626722afc961e9b407024d"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac9965952b2626722afc961e9b407024d.html#ac9965952b2626722afc961e9b407024d">pow</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt;&gt; &amp;x, const std::complex&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:ac9965952b2626722afc961e9b407024d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_ac9965952b2626722afc961e9b407024d.html#ac9965952b2626722afc961e9b407024d">More...</a><br /></td></tr>
<tr class="separator:ac9965952b2626722afc961e9b407024d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f97b089fa7765920f23f6e0d3089508"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a1f97b089fa7765920f23f6e0d3089508"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1f97b089fa7765920f23f6e0d3089508.html#a1f97b089fa7765920f23f6e0d3089508">pow</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt;&gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a1f97b089fa7765920f23f6e0d3089508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_a1f97b089fa7765920f23f6e0d3089508.html#a1f97b089fa7765920f23f6e0d3089508">More...</a><br /></td></tr>
<tr class="separator:a1f97b089fa7765920f23f6e0d3089508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5353c53a08983375cd3e497edc1b830d"><td class="memTemplParams" colspan="2">template&lt;typename V , typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a5353c53a08983375cd3e497edc1b830d"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5353c53a08983375cd3e497edc1b830d.html#a5353c53a08983375cd3e497edc1b830d">pow</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt;&gt; &amp;x, const T &amp;y)</td></tr>
<tr class="memdesc:a5353c53a08983375cd3e497edc1b830d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_a5353c53a08983375cd3e497edc1b830d.html#a5353c53a08983375cd3e497edc1b830d">More...</a><br /></td></tr>
<tr class="separator:a5353c53a08983375cd3e497edc1b830d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29554d4cda39ef974de8d15391eb321"><td class="memTemplParams" colspan="2">template&lt;typename V , typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ae29554d4cda39ef974de8d15391eb321"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae29554d4cda39ef974de8d15391eb321.html#ae29554d4cda39ef974de8d15391eb321">pow</a> (const std::complex&lt; T &gt; &amp;x, const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt;&gt; &amp;y)</td></tr>
<tr class="memdesc:ae29554d4cda39ef974de8d15391eb321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_ae29554d4cda39ef974de8d15391eb321.html#ae29554d4cda39ef974de8d15391eb321">More...</a><br /></td></tr>
<tr class="separator:ae29554d4cda39ef974de8d15391eb321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf3fffa391deb27054f53f9b01bfa33"><td class="memTemplParams" colspan="2">template&lt;typename V , typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:abaf3fffa391deb27054f53f9b01bfa33"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abaf3fffa391deb27054f53f9b01bfa33.html#abaf3fffa391deb27054f53f9b01bfa33">pow</a> (const std::complex&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:abaf3fffa391deb27054f53f9b01bfa33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_abaf3fffa391deb27054f53f9b01bfa33.html#abaf3fffa391deb27054f53f9b01bfa33">More...</a><br /></td></tr>
<tr class="separator:abaf3fffa391deb27054f53f9b01bfa33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fca1fdaf24fe4aabb84181a6908200"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:ae2fca1fdaf24fe4aabb84181a6908200"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae2fca1fdaf24fe4aabb84181a6908200.html#ae2fca1fdaf24fe4aabb84181a6908200">pow</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt; &amp;x, const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt;&gt; &amp;y)</td></tr>
<tr class="memdesc:ae2fca1fdaf24fe4aabb84181a6908200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_ae2fca1fdaf24fe4aabb84181a6908200.html#ae2fca1fdaf24fe4aabb84181a6908200">More...</a><br /></td></tr>
<tr class="separator:ae2fca1fdaf24fe4aabb84181a6908200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa57d072457cd4a68a602bb02aacecba"><td class="memTemplParams" colspan="2">template&lt;typename V , typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:afa57d072457cd4a68a602bb02aacecba"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afa57d072457cd4a68a602bb02aacecba.html#afa57d072457cd4a68a602bb02aacecba">pow</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt; &amp;x, const std::complex&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:afa57d072457cd4a68a602bb02aacecba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_afa57d072457cd4a68a602bb02aacecba.html#afa57d072457cd4a68a602bb02aacecba">More...</a><br /></td></tr>
<tr class="separator:afa57d072457cd4a68a602bb02aacecba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6570ebe030468c3c0a4069c2c04ebed"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ac6570ebe030468c3c0a4069c2c04ebed"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac6570ebe030468c3c0a4069c2c04ebed.html#ac6570ebe030468c3c0a4069c2c04ebed">pow</a> (T x, const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; V &gt;&gt; &amp;y)</td></tr>
<tr class="memdesc:ac6570ebe030468c3c0a4069c2c04ebed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_ac6570ebe030468c3c0a4069c2c04ebed.html#ac6570ebe030468c3c0a4069c2c04ebed">More...</a><br /></td></tr>
<tr class="separator:ac6570ebe030468c3c0a4069c2c04ebed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032ac4fe53ef7b6de417dd05ed49f6bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a032ac4fe53ef7b6de417dd05ed49f6bb"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a032ac4fe53ef7b6de417dd05ed49f6bb.html#a032ac4fe53ef7b6de417dd05ed49f6bb">pow</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;x, int y)</td></tr>
<tr class="memdesc:a032ac4fe53ef7b6de417dd05ed49f6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_a032ac4fe53ef7b6de417dd05ed49f6bb.html#a032ac4fe53ef7b6de417dd05ed49f6bb">More...</a><br /></td></tr>
<tr class="separator:a032ac4fe53ef7b6de417dd05ed49f6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24337e3af682981f05d1cc022e675891"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24337e3af682981f05d1cc022e675891"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a24337e3af682981f05d1cc022e675891.html#a24337e3af682981f05d1cc022e675891">primitive_value</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a24337e3af682981f05d1cc022e675891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the primitive value of the specified forward-mode autodiff variable.  <a href="namespacestan_1_1math_a24337e3af682981f05d1cc022e675891.html#a24337e3af682981f05d1cc022e675891">More...</a><br /></td></tr>
<tr class="separator:a24337e3af682981f05d1cc022e675891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c3669113f5ec13c8cffef7e41ca62b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70c3669113f5ec13c8cffef7e41ca62b"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a70c3669113f5ec13c8cffef7e41ca62b.html#a70c3669113f5ec13c8cffef7e41ca62b">proj</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:a70c3669113f5ec13c8cffef7e41ca62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the projection of the complex argument onto the Riemann sphere.  <a href="namespacestan_1_1math_a70c3669113f5ec13c8cffef7e41ca62b.html#a70c3669113f5ec13c8cffef7e41ca62b">More...</a><br /></td></tr>
<tr class="separator:a70c3669113f5ec13c8cffef7e41ca62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9b4c5e8162b2ecfe9684d5df843522"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_eigen_t&lt; EigMat1, EigMat2 &gt; *  = nullptr, require_not_eigen_col_vector_t&lt; EigMat2 &gt; *  = nullptr, require_any_vt_fvar&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3e9b4c5e8162b2ecfe9684d5df843522"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">promote_scalar_t</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, EigMat2 &gt;, EigMat2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3e9b4c5e8162b2ecfe9684d5df843522.html#a3e9b4c5e8162b2ecfe9684d5df843522">quad_form</a> (const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:a3e9b4c5e8162b2ecfe9684d5df843522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \).  <a href="namespacestan_1_1math_a3e9b4c5e8162b2ecfe9684d5df843522.html#a3e9b4c5e8162b2ecfe9684d5df843522">More...</a><br /></td></tr>
<tr class="separator:a3e9b4c5e8162b2ecfe9684d5df843522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c1facb546e41ea17eac927e636358a"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename ColVec , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_eigen_col_vector_t&lt; ColVec &gt; *  = nullptr, require_any_vt_fvar&lt; EigMat, ColVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a22c1facb546e41ea17eac927e636358a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat, ColVec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a22c1facb546e41ea17eac927e636358a.html#a22c1facb546e41ea17eac927e636358a">quad_form</a> (const EigMat &amp;A, const ColVec &amp;B)</td></tr>
<tr class="memdesc:a22c1facb546e41ea17eac927e636358a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \).  <a href="namespacestan_1_1math_a22c1facb546e41ea17eac927e636358a.html#a22c1facb546e41ea17eac927e636358a">More...</a><br /></td></tr>
<tr class="separator:a22c1facb546e41ea17eac927e636358a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84384b8de9a2668f95c8997a90067aeb"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_eigen_t&lt; EigMat1, EigMat2 &gt; *  = nullptr, require_not_eigen_col_vector_t&lt; EigMat2 &gt; *  = nullptr, require_any_vt_fvar&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a84384b8de9a2668f95c8997a90067aeb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">promote_scalar_t</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, EigMat2 &gt;, EigMat2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a84384b8de9a2668f95c8997a90067aeb.html#a84384b8de9a2668f95c8997a90067aeb">quad_form_sym</a> (const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:a84384b8de9a2668f95c8997a90067aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \) of a symmetric matrix.  <a href="namespacestan_1_1math_a84384b8de9a2668f95c8997a90067aeb.html#a84384b8de9a2668f95c8997a90067aeb">More...</a><br /></td></tr>
<tr class="separator:a84384b8de9a2668f95c8997a90067aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051cf78d3ee705a39c552439b9951090"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename ColVec , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_eigen_col_vector_t&lt; ColVec &gt; *  = nullptr, require_any_vt_fvar&lt; EigMat, ColVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a051cf78d3ee705a39c552439b9951090"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat, ColVec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a051cf78d3ee705a39c552439b9951090.html#a051cf78d3ee705a39c552439b9951090">quad_form_sym</a> (const EigMat &amp;A, const ColVec &amp;B)</td></tr>
<tr class="memdesc:a051cf78d3ee705a39c552439b9951090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \) of a symmetric matrix.  <a href="namespacestan_1_1math_a051cf78d3ee705a39c552439b9951090.html#a051cf78d3ee705a39c552439b9951090">More...</a><br /></td></tr>
<tr class="separator:a051cf78d3ee705a39c552439b9951090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a58ef73a4780899fdc9e1d04bc0a08"><td class="memTemplParams" colspan="2">template&lt;typename EigFvar , typename EigOut &gt; </td></tr>
<tr class="memitem:ac4a58ef73a4780899fdc9e1d04bc0a08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac4a58ef73a4780899fdc9e1d04bc0a08.html#ac4a58ef73a4780899fdc9e1d04bc0a08">read_fvar</a> (const EigFvar &amp;FvarMat, EigOut &amp;ValMat, EigOut &amp;DMat)</td></tr>
<tr class="memdesc:ac4a58ef73a4780899fdc9e1d04bc0a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function applying the <a class="el" href="classstan_1_1math_1_1read__fvar__functor.html" title="Functor for extracting the values and tangents from a matrix of fvar.">read_fvar_functor</a> to extract the values and tangets of a given fvar matrix into separate matrices.  <a href="namespacestan_1_1math_ac4a58ef73a4780899fdc9e1d04bc0a08.html#ac4a58ef73a4780899fdc9e1d04bc0a08">More...</a><br /></td></tr>
<tr class="separator:ac4a58ef73a4780899fdc9e1d04bc0a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55d03cf2ba8027e82e8a3e3980bd213"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa55d03cf2ba8027e82e8a3e3980bd213"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa55d03cf2ba8027e82e8a3e3980bd213.html#aa55d03cf2ba8027e82e8a3e3980bd213">rising_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="memdesc:aa55d03cf2ba8027e82e8a3e3980bd213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return autodiff variable with the gradient and result of the rising factorial function applied to the inputs.  <a href="namespacestan_1_1math_aa55d03cf2ba8027e82e8a3e3980bd213.html#aa55d03cf2ba8027e82e8a3e3980bd213">More...</a><br /></td></tr>
<tr class="separator:aa55d03cf2ba8027e82e8a3e3980bd213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb73c37a4cec41a69516391a2336fb11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb73c37a4cec41a69516391a2336fb11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adb73c37a4cec41a69516391a2336fb11.html#adb73c37a4cec41a69516391a2336fb11">round</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:adb73c37a4cec41a69516391a2336fb11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the closest integer to the specified argument, with halfway cases rounded away from zero.  <a href="namespacestan_1_1math_adb73c37a4cec41a69516391a2336fb11.html#adb73c37a4cec41a69516391a2336fb11">More...</a><br /></td></tr>
<tr class="separator:adb73c37a4cec41a69516391a2336fb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3f2dd84567a0566cfdd7eb10e13607"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff3f2dd84567a0566cfdd7eb10e13607"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aff3f2dd84567a0566cfdd7eb10e13607.html#aff3f2dd84567a0566cfdd7eb10e13607">sin</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aff3f2dd84567a0566cfdd7eb10e13607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4871fe0d13233000c324cb4fafc590"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0c4871fe0d13233000c324cb4fafc590"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0c4871fe0d13233000c324cb4fafc590.html#a0c4871fe0d13233000c324cb4fafc590">sin</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:a0c4871fe0d13233000c324cb4fafc590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sine of the complex argument.  <a href="namespacestan_1_1math_a0c4871fe0d13233000c324cb4fafc590.html#a0c4871fe0d13233000c324cb4fafc590">More...</a><br /></td></tr>
<tr class="separator:a0c4871fe0d13233000c324cb4fafc590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646a34790ca2b692b2a8c74c4e4fb726"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a646a34790ca2b692b2a8c74c4e4fb726"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a646a34790ca2b692b2a8c74c4e4fb726.html#a646a34790ca2b692b2a8c74c4e4fb726">sinh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a646a34790ca2b692b2a8c74c4e4fb726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fb7a7b427e5343773ed35b7c80cd7e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50fb7a7b427e5343773ed35b7c80cd7e"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a50fb7a7b427e5343773ed35b7c80cd7e.html#a50fb7a7b427e5343773ed35b7c80cd7e">sinh</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:a50fb7a7b427e5343773ed35b7c80cd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic sine of the complex argument.  <a href="namespacestan_1_1math_a50fb7a7b427e5343773ed35b7c80cd7e.html#a50fb7a7b427e5343773ed35b7c80cd7e">More...</a><br /></td></tr>
<tr class="separator:a50fb7a7b427e5343773ed35b7c80cd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0a27848dbb868c6bd0eece92064a10"><td class="memTemplParams" colspan="2">template&lt;typename ColVec , require_eigen_col_vector_vt&lt; is_fvar, ColVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4f0a27848dbb868c6bd0eece92064a10"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4f0a27848dbb868c6bd0eece92064a10.html#a4f0a27848dbb868c6bd0eece92064a10">softmax</a> (const ColVec &amp;alpha)</td></tr>
<tr class="separator:a4f0a27848dbb868c6bd0eece92064a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5231d132852d58cd3fe610221c9766f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5231d132852d58cd3fe610221c9766f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa5231d132852d58cd3fe610221c9766f.html#aa5231d132852d58cd3fe610221c9766f">sqrt</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aa5231d132852d58cd3fe610221c9766f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad97e663faa49a556727ab234afae143"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad97e663faa49a556727ab234afae143"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aad97e663faa49a556727ab234afae143.html#aad97e663faa49a556727ab234afae143">sqrt</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:aad97e663faa49a556727ab234afae143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of the complex argument.  <a href="namespacestan_1_1math_aad97e663faa49a556727ab234afae143.html#aad97e663faa49a556727ab234afae143">More...</a><br /></td></tr>
<tr class="separator:aad97e663faa49a556727ab234afae143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ed68bdfff9b340a187964ef7684091"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1ed68bdfff9b340a187964ef7684091"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab1ed68bdfff9b340a187964ef7684091.html#ab1ed68bdfff9b340a187964ef7684091">square</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ab1ed68bdfff9b340a187964ef7684091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7953d993880449ed4d741e6e891d2f7b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7953d993880449ed4d741e6e891d2f7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7953d993880449ed4d741e6e891d2f7b.html#a7953d993880449ed4d741e6e891d2f7b">sum</a> (const std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;m)</td></tr>
<tr class="memdesc:a7953d993880449ed4d741e6e891d2f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the entries of the specified standard vector.  <a href="namespacestan_1_1math_a7953d993880449ed4d741e6e891d2f7b.html#a7953d993880449ed4d741e6e891d2f7b">More...</a><br /></td></tr>
<tr class="separator:a7953d993880449ed4d741e6e891d2f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e94757d2d429c4b0a09e0cf00343a3"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vt&lt; is_fvar, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af8e94757d2d429c4b0a09e0cf00343a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af8e94757d2d429c4b0a09e0cf00343a3.html#af8e94757d2d429c4b0a09e0cf00343a3">sum</a> (const T &amp;m)</td></tr>
<tr class="memdesc:af8e94757d2d429c4b0a09e0cf00343a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the entries of the specified matrix.  <a href="namespacestan_1_1math_af8e94757d2d429c4b0a09e0cf00343a3.html#af8e94757d2d429c4b0a09e0cf00343a3">More...</a><br /></td></tr>
<tr class="separator:af8e94757d2d429c4b0a09e0cf00343a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09b685b660830075f80caaf8a350676"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae09b685b660830075f80caaf8a350676"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae09b685b660830075f80caaf8a350676.html#ae09b685b660830075f80caaf8a350676">tan</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ae09b685b660830075f80caaf8a350676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd6316861f64fc523371b13ebfb0a8f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8bd6316861f64fc523371b13ebfb0a8f"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8bd6316861f64fc523371b13ebfb0a8f.html#a8bd6316861f64fc523371b13ebfb0a8f">tan</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:a8bd6316861f64fc523371b13ebfb0a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tangent of the complex argument.  <a href="namespacestan_1_1math_a8bd6316861f64fc523371b13ebfb0a8f.html#a8bd6316861f64fc523371b13ebfb0a8f">More...</a><br /></td></tr>
<tr class="separator:a8bd6316861f64fc523371b13ebfb0a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11dc45fd471bec1a19462ce58f434b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae11dc45fd471bec1a19462ce58f434b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae11dc45fd471bec1a19462ce58f434b8.html#ae11dc45fd471bec1a19462ce58f434b8">tanh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ae11dc45fd471bec1a19462ce58f434b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a64837aec18bd06bd1e756dec1efaa7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a64837aec18bd06bd1e756dec1efaa7"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5a64837aec18bd06bd1e756dec1efaa7.html#a5a64837aec18bd06bd1e756dec1efaa7">tanh</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:a5a64837aec18bd06bd1e756dec1efaa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic tangent of the complex argument.  <a href="namespacestan_1_1math_a5a64837aec18bd06bd1e756dec1efaa7.html#a5a64837aec18bd06bd1e756dec1efaa7">More...</a><br /></td></tr>
<tr class="separator:a5a64837aec18bd06bd1e756dec1efaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527b352662b5d83b4feeafc464ac9d31"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_vt&lt; is_fvar, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a527b352662b5d83b4feeafc464ac9d31"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, EigMat::RowsAtCompileTime, EigMat::RowsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a527b352662b5d83b4feeafc464ac9d31.html#a527b352662b5d83b4feeafc464ac9d31">tcrossprod</a> (const EigMat &amp;m)</td></tr>
<tr class="separator:a527b352662b5d83b4feeafc464ac9d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73eaf0a5d0593bb8610234e0d69e7cec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a73eaf0a5d0593bb8610234e0d69e7cec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a73eaf0a5d0593bb8610234e0d69e7cec.html#a73eaf0a5d0593bb8610234e0d69e7cec">tgamma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a73eaf0a5d0593bb8610234e0d69e7cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of applying the gamma function to the specified argument.  <a href="namespacestan_1_1math_a73eaf0a5d0593bb8610234e0d69e7cec.html#a73eaf0a5d0593bb8610234e0d69e7cec">More...</a><br /></td></tr>
<tr class="separator:a73eaf0a5d0593bb8610234e0d69e7cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50af30a515a56a4f697274aee27392a6"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr, require_not_fvar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a50af30a515a56a4f697274aee27392a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a50af30a515a56a4f697274aee27392a6.html#a50af30a515a56a4f697274aee27392a6">to_fvar</a> (const T &amp;x)</td></tr>
<tr class="separator:a50af30a515a56a4f697274aee27392a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4201dbfc4e237d161256d6dbca2f5830"><td class="memTemplParams" colspan="2">template&lt;typename T , require_fvar_t&lt; scalar_type_t&lt; T &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4201dbfc4e237d161256d6dbca2f5830"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4201dbfc4e237d161256d6dbca2f5830.html#a4201dbfc4e237d161256d6dbca2f5830">to_fvar</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:a4201dbfc4e237d161256d6dbca2f5830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_fvar for [containers of] fvars.  <a href="namespacestan_1_1math_a4201dbfc4e237d161256d6dbca2f5830.html#a4201dbfc4e237d161256d6dbca2f5830">More...</a><br /></td></tr>
<tr class="separator:a4201dbfc4e237d161256d6dbca2f5830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3e1362a4de8a9143246413e9bf9e99"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e3e1362a4de8a9143246413e9bf9e99"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1e3e1362a4de8a9143246413e9bf9e99.html#a1e3e1362a4de8a9143246413e9bf9e99">to_fvar</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a1e3e1362a4de8a9143246413e9bf9e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9ffd571f615dfff619e6134020c4f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b9ffd571f615dfff619e6134020c4f3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0b9ffd571f615dfff619e6134020c4f3.html#a0b9ffd571f615dfff619e6134020c4f3">to_fvar</a> (const std::vector&lt; T &gt; &amp;v, const std::vector&lt; T &gt; &amp;d)</td></tr>
<tr class="separator:a0b9ffd571f615dfff619e6134020c4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f32c570b3659db28343e9ee576d343"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr, require_not_eigen_vt&lt; is_fvar, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a30f32c570b3659db28343e9ee576d343"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">promote_scalar_t</a>&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt;, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a30f32c570b3659db28343e9ee576d343.html#a30f32c570b3659db28343e9ee576d343">to_fvar</a> (const T &amp;m)</td></tr>
<tr class="separator:a30f32c570b3659db28343e9ee576d343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e9d6cbb739e725b7094a344e167320"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_eigen_t&lt; T1, T2 &gt; *  = nullptr, require_vt_same&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a64e9d6cbb739e725b7094a344e167320"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">promote_scalar_t</a>&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T1 &gt; &gt;, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a64e9d6cbb739e725b7094a344e167320.html#a64e9d6cbb739e725b7094a344e167320">to_fvar</a> (const T1 &amp;val, const T2 &amp;deriv)</td></tr>
<tr class="separator:a64e9d6cbb739e725b7094a344e167320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfff6ba01b015f838e62299a222263eb"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_eigen_t&lt; EigMat1, EigMat2 &gt; *  = nullptr, require_any_vt_fvar&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acfff6ba01b015f838e62299a222263eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, EigMat2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acfff6ba01b015f838e62299a222263eb.html#acfff6ba01b015f838e62299a222263eb">trace_quad_form</a> (const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="separator:acfff6ba01b015f838e62299a222263eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf833bfffb0fb87dfc1d1ec81a20122"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3cf833bfffb0fb87dfc1d1ec81a20122"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3cf833bfffb0fb87dfc1d1ec81a20122.html#a3cf833bfffb0fb87dfc1d1ec81a20122">trigamma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;u)</td></tr>
<tr class="memdesc:a3cf833bfffb0fb87dfc1d1ec81a20122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the trigamma function at the specified argument (i.e., the second derivative of the log Gamma function at the specified argument).  <a href="namespacestan_1_1math_a3cf833bfffb0fb87dfc1d1ec81a20122.html#a3cf833bfffb0fb87dfc1d1ec81a20122">More...</a><br /></td></tr>
<tr class="separator:a3cf833bfffb0fb87dfc1d1ec81a20122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79abc1d4f747b3c26c07b2b1e4871603"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a79abc1d4f747b3c26c07b2b1e4871603"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a79abc1d4f747b3c26c07b2b1e4871603.html#a79abc1d4f747b3c26c07b2b1e4871603">trunc</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a79abc1d4f747b3c26c07b2b1e4871603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nearest integral value that is not larger in magnitude than the specified argument.  <a href="namespacestan_1_1math_a79abc1d4f747b3c26c07b2b1e4871603.html#a79abc1d4f747b3c26c07b2b1e4871603">More...</a><br /></td></tr>
<tr class="separator:a79abc1d4f747b3c26c07b2b1e4871603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0dbe10537c33325d1663707365740f"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_col_vector_vt&lt; is_fvar, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5b0dbe10537c33325d1663707365740f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5b0dbe10537c33325d1663707365740f.html#a5b0dbe10537c33325d1663707365740f">unit_vector_constrain</a> (const EigMat &amp;y)</td></tr>
<tr class="separator:a5b0dbe10537c33325d1663707365740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83c2d6f94d37cf1a07a0636a6be7abd"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename T , require_eigen_vt&lt; is_fvar, EigMat &gt; *  = nullptr, require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af83c2d6f94d37cf1a07a0636a6be7abd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af83c2d6f94d37cf1a07a0636a6be7abd.html#af83c2d6f94d37cf1a07a0636a6be7abd">unit_vector_constrain</a> (const EigMat &amp;y, T &amp;lp)</td></tr>
<tr class="separator:af83c2d6f94d37cf1a07a0636a6be7abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541f8f9d951f4d48c457dcecad5e326b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a541f8f9d951f4d48c457dcecad5e326b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a541f8f9d951f4d48c457dcecad5e326b.html#a541f8f9d951f4d48c457dcecad5e326b">value_of</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a541f8f9d951f4d48c457dcecad5e326b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified variable.  <a href="namespacestan_1_1math_a541f8f9d951f4d48c457dcecad5e326b.html#a541f8f9d951f4d48c457dcecad5e326b">More...</a><br /></td></tr>
<tr class="separator:a541f8f9d951f4d48c457dcecad5e326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b8cbdec7c35e7c93b0f47dae3c5498"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00b8cbdec7c35e7c93b0f47dae3c5498"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a00b8cbdec7c35e7c93b0f47dae3c5498.html#a00b8cbdec7c35e7c93b0f47dae3c5498">value_of_rec</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a00b8cbdec7c35e7c93b0f47dae3c5498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified variable.  <a href="namespacestan_1_1math_a00b8cbdec7c35e7c93b0f47dae3c5498.html#a00b8cbdec7c35e7c93b0f47dae3c5498">More...</a><br /></td></tr>
<tr class="separator:a00b8cbdec7c35e7c93b0f47dae3c5498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410200762bf5cf510708cc72e89cd00c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a410200762bf5cf510708cc72e89cd00c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a410200762bf5cf510708cc72e89cd00c.html#a410200762bf5cf510708cc72e89cd00c">gradient</a> (const F &amp;f, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, T &amp;fx, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;grad_fx)</td></tr>
<tr class="memdesc:a410200762bf5cf510708cc72e89cd00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value and the gradient of the specified function at the specified argument.  <a href="namespacestan_1_1math_a410200762bf5cf510708cc72e89cd00c.html#a410200762bf5cf510708cc72e89cd00c">More...</a><br /></td></tr>
<tr class="separator:a410200762bf5cf510708cc72e89cd00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7006e79de4699a89e4980e1a6097770"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ab7006e79de4699a89e4980e1a6097770"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab7006e79de4699a89e4980e1a6097770.html#ab7006e79de4699a89e4980e1a6097770">hessian</a> (const F &amp;f, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, T &amp;fx, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;<a class="el" href="namespacestan_1_1math_ae47da1792e5d3b1564c57ecb3a0de900.html#ae47da1792e5d3b1564c57ecb3a0de900">grad</a>, Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;H)</td></tr>
<tr class="memdesc:ab7006e79de4699a89e4980e1a6097770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value, the gradient, and the Hessian, of the specified function at the specified argument in time O(N^3) time and O(N^2) space.  <a href="namespacestan_1_1math_ab7006e79de4699a89e4980e1a6097770.html#ab7006e79de4699a89e4980e1a6097770">More...</a><br /></td></tr>
<tr class="separator:ab7006e79de4699a89e4980e1a6097770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130c490b4d72b62bac8d835492731da3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a130c490b4d72b62bac8d835492731da3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a130c490b4d72b62bac8d835492731da3.html#a130c490b4d72b62bac8d835492731da3">jacobian</a> (const F &amp;f, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;fx, Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;J)</td></tr>
<tr class="separator:a130c490b4d72b62bac8d835492731da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd6e40d63f90cc814b22b6560ab4e51"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4cd6e40d63f90cc814b22b6560ab4e51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4cd6e40d63f90cc814b22b6560ab4e51.html#a4cd6e40d63f90cc814b22b6560ab4e51">std_normal_log_qf</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="separator:a4cd6e40d63f90cc814b22b6560ab4e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7add35b0758b1d0541f7e919c36412f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7add35b0758b1d0541f7e919c36412f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7add35b0758b1d0541f7e919c36412f9.html#a7add35b0758b1d0541f7e919c36412f9">is_aligned</a> (T *ptr, unsigned int bytes_aligned)</td></tr>
<tr class="memdesc:a7add35b0758b1d0541f7e919c36412f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified pointer is aligned on the number of bytes.  <a href="namespacestan_1_1math_a7add35b0758b1d0541f7e919c36412f9.html#a7add35b0758b1d0541f7e919c36412f9">More...</a><br /></td></tr>
<tr class="separator:a7add35b0758b1d0541f7e919c36412f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0597dca74b96a4287c6f848489288d44"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a0597dca74b96a4287c6f848489288d44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0597dca74b96a4287c6f848489288d44.html#a0597dca74b96a4287c6f848489288d44">derivative</a> (const F &amp;f, const T &amp;x, T &amp;fx, T &amp;dfx_dx)</td></tr>
<tr class="memdesc:a0597dca74b96a4287c6f848489288d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the derivative of the specified univariate function at the specified argument.  <a href="namespacestan_1_1math_a0597dca74b96a4287c6f848489288d44.html#a0597dca74b96a4287c6f848489288d44">More...</a><br /></td></tr>
<tr class="separator:a0597dca74b96a4287c6f848489288d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90abf1400d2766c892fc438a83f7b4c1"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a90abf1400d2766c892fc438a83f7b4c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a90abf1400d2766c892fc438a83f7b4c1.html#a90abf1400d2766c892fc438a83f7b4c1">finite_diff_grad_hessian</a> (const F &amp;f, const Eigen::VectorXd &amp;x, double &amp;fx, Eigen::MatrixXd &amp;hess, std::vector&lt; Eigen::MatrixXd &gt; &amp;grad_hess_fx, double epsilon=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-04)</td></tr>
<tr class="memdesc:a90abf1400d2766c892fc438a83f7b4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value and the gradient of the hessian of the specified function at the specified argument using second-order autodiff and first-order finite difference.  <a href="namespacestan_1_1math_a90abf1400d2766c892fc438a83f7b4c1.html#a90abf1400d2766c892fc438a83f7b4c1">More...</a><br /></td></tr>
<tr class="separator:a90abf1400d2766c892fc438a83f7b4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f72777ad8719863ce55d610b656091"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a01f72777ad8719863ce55d610b656091"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a01f72777ad8719863ce55d610b656091.html#a01f72777ad8719863ce55d610b656091">finite_diff_grad_hessian_auto</a> (const F &amp;f, const Eigen::VectorXd &amp;x, double &amp;fx, Eigen::MatrixXd &amp;hess, std::vector&lt; Eigen::MatrixXd &gt; &amp;grad_hess_fx)</td></tr>
<tr class="memdesc:a01f72777ad8719863ce55d610b656091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value, Hessian, and the gradient of the Hessian of the specified function at the specified argument using second-order autodiff and first-order finite difference.  <a href="namespacestan_1_1math_a01f72777ad8719863ce55d610b656091.html#a01f72777ad8719863ce55d610b656091">More...</a><br /></td></tr>
<tr class="separator:a01f72777ad8719863ce55d610b656091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367affe85da63060b14ae8bc988f0df6"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a367affe85da63060b14ae8bc988f0df6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a367affe85da63060b14ae8bc988f0df6.html#a367affe85da63060b14ae8bc988f0df6">grad_hessian</a> (const F &amp;f, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, double &amp;fx, Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;H, std::vector&lt; Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &gt; &amp;grad_H)</td></tr>
<tr class="memdesc:a367affe85da63060b14ae8bc988f0df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value, the Hessian, and the gradient of the Hessian of the specified function at the specified argument.  <a href="namespacestan_1_1math_a367affe85da63060b14ae8bc988f0df6.html#a367affe85da63060b14ae8bc988f0df6">More...</a><br /></td></tr>
<tr class="separator:a367affe85da63060b14ae8bc988f0df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7face099d2313985131cde21ae17d8f"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:aa7face099d2313985131cde21ae17d8f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa7face099d2313985131cde21ae17d8f.html#aa7face099d2313985131cde21ae17d8f">grad_tr_mat_times_hessian</a> (const F &amp;f, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;M, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;grad_tr_MH)</td></tr>
<tr class="separator:aa7face099d2313985131cde21ae17d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4059a767ad9af62d85cfb9685e250e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename F &gt; </td></tr>
<tr class="memitem:aef4059a767ad9af62d85cfb9685e250e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aef4059a767ad9af62d85cfb9685e250e.html#aef4059a767ad9af62d85cfb9685e250e">gradient_dot_vector</a> (const F &amp;f, const Eigen::Matrix&lt; T1, Eigen::Dynamic, 1 &gt; &amp;x, const Eigen::Matrix&lt; T2, Eigen::Dynamic, 1 &gt; &amp;v, T1 &amp;fx, T1 &amp;grad_fx_dot_v)</td></tr>
<tr class="separator:aef4059a767ad9af62d85cfb9685e250e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01474168e03d94b982b6b4fd694b3302"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a01474168e03d94b982b6b4fd694b3302"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a01474168e03d94b982b6b4fd694b3302.html#a01474168e03d94b982b6b4fd694b3302">hessian</a> (const F &amp;f, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, double &amp;fx, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;<a class="el" href="namespacestan_1_1math_ae47da1792e5d3b1564c57ecb3a0de900.html#ae47da1792e5d3b1564c57ecb3a0de900">grad</a>, Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;H)</td></tr>
<tr class="memdesc:a01474168e03d94b982b6b4fd694b3302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value, the gradient, and the Hessian, of the specified function at the specified argument in O(N^2) time and O(N^2) space.  <a href="namespacestan_1_1math_a01474168e03d94b982b6b4fd694b3302.html#a01474168e03d94b982b6b4fd694b3302">More...</a><br /></td></tr>
<tr class="separator:a01474168e03d94b982b6b4fd694b3302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69389a1cd22b50df04a87245292f7f85"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a69389a1cd22b50df04a87245292f7f85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a69389a1cd22b50df04a87245292f7f85.html#a69389a1cd22b50df04a87245292f7f85">hessian_times_vector</a> (const F &amp;f, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;v, double &amp;fx, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;Hv)</td></tr>
<tr class="separator:a69389a1cd22b50df04a87245292f7f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb76a7877dac777de4757af8f2677be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a1bb76a7877dac777de4757af8f2677be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1bb76a7877dac777de4757af8f2677be.html#a1bb76a7877dac777de4757af8f2677be">hessian_times_vector</a> (const F &amp;f, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v, T &amp;fx, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;Hv)</td></tr>
<tr class="separator:a1bb76a7877dac777de4757af8f2677be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75dae6137f91377c351b2f648b1c18e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:af75dae6137f91377c351b2f648b1c18e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af75dae6137f91377c351b2f648b1c18e.html#af75dae6137f91377c351b2f648b1c18e">partial_derivative</a> (const F &amp;f, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, int n, T &amp;fx, T &amp;dfx_dxn)</td></tr>
<tr class="memdesc:af75dae6137f91377c351b2f648b1c18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the partial derivative of the specified multivariate function at the specified argument.  <a href="namespacestan_1_1math_af75dae6137f91377c351b2f648b1c18e.html#af75dae6137f91377c351b2f648b1c18e">More...</a><br /></td></tr>
<tr class="separator:af75dae6137f91377c351b2f648b1c18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bbce98664097d5ea8e55b0b931bd721"><td class="memTemplParams" colspan="2">template&lt;typename T , require_st_arithmetic&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8bbce98664097d5ea8e55b0b931bd721"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga8bbce98664097d5ea8e55b0b931bd721.html#ga8bbce98664097d5ea8e55b0b931bd721">to_matrix_cl</a> (T &amp;&amp;src)</td></tr>
<tr class="separator:ga8bbce98664097d5ea8e55b0b931bd721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2a61125c6dca5e5a400d56e24cc6d5"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , typename T , require_eigen_t&lt; T_ret &gt; *  = nullptr, require_matrix_cl_t&lt; T &gt; *  = nullptr, require_st_same&lt; T_ret, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadf2a61125c6dca5e5a400d56e24cc6d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gadf2a61125c6dca5e5a400d56e24cc6d5.html#gadf2a61125c6dca5e5a400d56e24cc6d5">from_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="separator:gadf2a61125c6dca5e5a400d56e24cc6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad35b73b8bb6ac116683220a20f4c317d"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr, require_not_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad35b73b8bb6ac116683220a20f4c317d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gad35b73b8bb6ac116683220a20f4c317d.html#gad35b73b8bb6ac116683220a20f4c317d">from_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="separator:gad35b73b8bb6ac116683220a20f4c317d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e84cc75a88ea72d01c090997fdc556"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T , require_arithmetic_t&lt; T &gt; *  = nullptr, require_same_t&lt; T_dst, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga44e84cc75a88ea72d01c090997fdc556"><td class="memTemplItemLeft" align="right" valign="top">T_dst&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga44e84cc75a88ea72d01c090997fdc556.html#ga44e84cc75a88ea72d01c090997fdc556">from_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="separator:ga44e84cc75a88ea72d01c090997fdc556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f99f6ae3dd35f205631e839119f5541"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1f99f6ae3dd35f205631e839119f5541"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga1f99f6ae3dd35f205631e839119f5541.html#ga1f99f6ae3dd35f205631e839119f5541">from_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="separator:ga1f99f6ae3dd35f205631e839119f5541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga490df7651c22c9e06d09da69ad303e30"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga490df7651c22c9e06d09da69ad303e30"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga490df7651c22c9e06d09da69ad303e30.html#ga490df7651c22c9e06d09da69ad303e30">packed_copy</a> (const T &amp;src)</td></tr>
<tr class="separator:ga490df7651c22c9e06d09da69ad303e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed1f7da1a49ff3c2a9e1147b4eef4662"><td class="memTemplParams" colspan="2">template&lt;matrix_cl_view matrix_view, typename Vec , typename Vec_scalar  = scalar_type_t&lt;Vec&gt;, require_vector_vt&lt; std::is_arithmetic, Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaed1f7da1a49ff3c2a9e1147b4eef4662"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; Vec_scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaed1f7da1a49ff3c2a9e1147b4eef4662.html#gaed1f7da1a49ff3c2a9e1147b4eef4662">packed_copy</a> (Vec &amp;&amp;src, int <a class="el" href="group__opencl_ga61254f29c1520f4bffe4ab4e5bbd0e0e.html#ga61254f29c1520f4bffe4ab4e5bbd0e0e">rows</a>)</td></tr>
<tr class="separator:gaed1f7da1a49ff3c2a9e1147b4eef4662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60406331fe144c5088b62ab261a04e87"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga60406331fe144c5088b62ab261a04e87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga60406331fe144c5088b62ab261a04e87.html#ga60406331fe144c5088b62ab261a04e87">copy_cl</a> (const T &amp;src)</td></tr>
<tr class="separator:ga60406331fe144c5088b62ab261a04e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37fe55b7d7b3c0ae69f331104dcd3d64"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga37fe55b7d7b3c0ae69f331104dcd3d64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__error__checks__opencl_ga37fe55b7d7b3c0ae69f331104dcd3d64.html#ga37fe55b7d7b3c0ae69f331104dcd3d64">check_mat_not_size_one</a> (const char *function, const char *name, const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:ga37fe55b7d7b3c0ae69f331104dcd3d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga423364ebfbb176382d94cb3e2786d4cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__error__checks__opencl_ga423364ebfbb176382d94cb3e2786d4cc.html#ga423364ebfbb176382d94cb3e2786d4cc">check_opencl_error</a> (const char *function, const cl::Error &amp;<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>)</td></tr>
<tr class="separator:ga423364ebfbb176382d94cb3e2786d4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ea8fac58afac1cbf0d1351f849dd102"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga3ea8fac58afac1cbf0d1351f849dd102"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__error__checks__opencl_ga3ea8fac58afac1cbf0d1351f849dd102.html#ga3ea8fac58afac1cbf0d1351f849dd102">check_symmetric</a> (const char *function, const char *name, const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga3ea8fac58afac1cbf0d1351f849dd102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15a3d98d59dfcc1e81c2a28d207cb645"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga15a3d98d59dfcc1e81c2a28d207cb645"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__error__checks__opencl_ga15a3d98d59dfcc1e81c2a28d207cb645.html#ga15a3d98d59dfcc1e81c2a28d207cb645">check_triangular</a> (const char *function, const char *name, const T &amp;A)</td></tr>
<tr class="separator:ga15a3d98d59dfcc1e81c2a28d207cb645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a8107a1e78d28e7803dfd4a038e381"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac4a8107a1e78d28e7803dfd4a038e381.html#ac4a8107a1e78d28e7803dfd4a038e381">indexing_rev</a> (<a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;adj, const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; int &gt; &amp;idx, const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;res)</td></tr>
<tr class="memdesc:ac4a8107a1e78d28e7803dfd4a038e381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs reverse pass for indexing operation on the OpenCL device.  <a href="namespacestan_1_1math_ac4a8107a1e78d28e7803dfd4a038e381.html#ac4a8107a1e78d28e7803dfd4a038e381">More...</a><br /></td></tr>
<tr class="separator:ac4a8107a1e78d28e7803dfd4a038e381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb1db7fccc42c2b7e5520838ac53e43d"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;Ta, Tb&gt;&gt; </td></tr>
<tr class="memitem:gaeb1db7fccc42c2b7e5520838ac53e43d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaeb1db7fccc42c2b7e5520838ac53e43d.html#gaeb1db7fccc42c2b7e5520838ac53e43d">append_row</a> (Ta &amp;&amp;a, Tb &amp;&amp;b)</td></tr>
<tr class="memdesc:gaeb1db7fccc42c2b7e5520838ac53e43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack the rows of the first argument on top of the second argument.  <a href="group__opencl__kernel__generator_gaeb1db7fccc42c2b7e5520838ac53e43d.html#gaeb1db7fccc42c2b7e5520838ac53e43d">More...</a><br /></td></tr>
<tr class="separator:gaeb1db7fccc42c2b7e5520838ac53e43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga445eb497e5d75296e287de54a4dacc2c"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;Ta, Tb&gt;&gt; </td></tr>
<tr class="memitem:ga445eb497e5d75296e287de54a4dacc2c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga445eb497e5d75296e287de54a4dacc2c.html#ga445eb497e5d75296e287de54a4dacc2c">append_col</a> (Ta &amp;&amp;a, Tb &amp;&amp;b)</td></tr>
<tr class="memdesc:ga445eb497e5d75296e287de54a4dacc2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack the cols of the arguments.  <a href="group__opencl__kernel__generator_ga445eb497e5d75296e287de54a4dacc2c.html#ga445eb497e5d75296e287de54a4dacc2c">More...</a><br /></td></tr>
<tr class="separator:ga445eb497e5d75296e287de54a4dacc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49b6d73fd76664578829b28d346a4f45"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga49b6d73fd76664578829b28d346a4f45"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga49b6d73fd76664578829b28d346a4f45.html#ga49b6d73fd76664578829b28d346a4f45">as_column_vector_or_scalar</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga49b6d73fd76664578829b28d346a4f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">as_column_vector_or_scalar of a kernel generator expression.  <a href="group__opencl__kernel__generator_ga49b6d73fd76664578829b28d346a4f45.html#ga49b6d73fd76664578829b28d346a4f45">More...</a><br /></td></tr>
<tr class="separator:ga49b6d73fd76664578829b28d346a4f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7bbba2d8808d1fb7b4264f244d710a"><td class="memTemplParams" colspan="2">template&lt;typename T_operation , typename  = std::enable_if_t&lt;std::is_base_of&lt;              operation_cl_base, std::remove_reference_t&lt;T_operation&gt;&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga6f7bbba2d8808d1fb7b4264f244d710a"><td class="memTemplItemLeft" align="right" valign="top">T_operation &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga6f7bbba2d8808d1fb7b4264f244d710a.html#ga6f7bbba2d8808d1fb7b4264f244d710a">as_operation_cl</a> (T_operation &amp;&amp;a)</td></tr>
<tr class="memdesc:ga6f7bbba2d8808d1fb7b4264f244d710a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts any valid kernel generator expression into an operation.  <a href="group__opencl__kernel__generator_ga6f7bbba2d8808d1fb7b4264f244d710a.html#ga6f7bbba2d8808d1fb7b4264f244d710a">More...</a><br /></td></tr>
<tr class="separator:ga6f7bbba2d8808d1fb7b4264f244d710a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b816fc8c243145bf3186432121ca28d"><td class="memTemplParams" colspan="2">template&lt;typename T_scalar , typename  = require_arithmetic_t&lt;T_scalar&gt;, require_not_same_t&lt; T_scalar, bool &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2b816fc8c243145bf3186432121ca28d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1scalar__.html">scalar_</a>&lt; T_scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga2b816fc8c243145bf3186432121ca28d.html#ga2b816fc8c243145bf3186432121ca28d">as_operation_cl</a> (const T_scalar a)</td></tr>
<tr class="memdesc:ga2b816fc8c243145bf3186432121ca28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts any valid kernel generator expression into an operation.  <a href="group__opencl__kernel__generator_ga2b816fc8c243145bf3186432121ca28d.html#ga2b816fc8c243145bf3186432121ca28d">More...</a><br /></td></tr>
<tr class="separator:ga2b816fc8c243145bf3186432121ca28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06750561594a66752a85501ddf67cb19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1scalar__.html">scalar_</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga06750561594a66752a85501ddf67cb19.html#ga06750561594a66752a85501ddf67cb19">as_operation_cl</a> (const bool a)</td></tr>
<tr class="memdesc:ga06750561594a66752a85501ddf67cb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts any valid kernel generator expression into an operation.  <a href="group__opencl__kernel__generator_ga06750561594a66752a85501ddf67cb19.html#ga06750561594a66752a85501ddf67cb19">More...</a><br /></td></tr>
<tr class="separator:ga06750561594a66752a85501ddf67cb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf5308ae11d9c8512fe7500a1676a39f"><td class="memTemplParams" colspan="2">template&lt;typename T_matrix_cl , typename  = require_any_t&lt;is_matrix_cl&lt;T_matrix_cl&gt;,                                   is_arena_matrix_cl&lt;T_matrix_cl&gt;&gt;&gt; </td></tr>
<tr class="memitem:gaaf5308ae11d9c8512fe7500a1676a39f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1load__.html">load_</a>&lt; T_matrix_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaaf5308ae11d9c8512fe7500a1676a39f.html#gaaf5308ae11d9c8512fe7500a1676a39f">as_operation_cl</a> (T_matrix_cl &amp;&amp;a)</td></tr>
<tr class="memdesc:gaaf5308ae11d9c8512fe7500a1676a39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts any valid kernel generator expression into an operation.  <a href="group__opencl__kernel__generator_gaaf5308ae11d9c8512fe7500a1676a39f.html#gaaf5308ae11d9c8512fe7500a1676a39f">More...</a><br /></td></tr>
<tr class="separator:gaaf5308ae11d9c8512fe7500a1676a39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac471352aba1c5b61a158a66d01b4939f"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_arithmetic_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac471352aba1c5b61a158a66d01b4939f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1addition__operator__.html">addition_operator_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gac471352aba1c5b61a158a66d01b4939f.html#gac471352aba1c5b61a158a66d01b4939f">operator+</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:gac471352aba1c5b61a158a66d01b4939f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga797d34ad217be5a5367c83b2babc4a19"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_arithmetic_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga797d34ad217be5a5367c83b2babc4a19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1addition__.html">addition_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga797d34ad217be5a5367c83b2babc4a19.html#ga797d34ad217be5a5367c83b2babc4a19">add</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga797d34ad217be5a5367c83b2babc4a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a67456244b970053fbcd87ec090556"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_arithmetic_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga16a67456244b970053fbcd87ec090556"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1subtraction__operator__.html">subtraction_operator_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga16a67456244b970053fbcd87ec090556.html#ga16a67456244b970053fbcd87ec090556">operator-</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga16a67456244b970053fbcd87ec090556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ed750041c2713842a3ff07bfc2da660"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_arithmetic_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7ed750041c2713842a3ff07bfc2da660"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1subtraction__.html">subtraction_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga7ed750041c2713842a3ff07bfc2da660.html#ga7ed750041c2713842a3ff07bfc2da660">subtract</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga7ed750041c2713842a3ff07bfc2da660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c1b49022ec40eb9b06d32742f0fd1fc"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_arithmetic_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4c1b49022ec40eb9b06d32742f0fd1fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1elt__multiply__.html">elt_multiply_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga4c1b49022ec40eb9b06d32742f0fd1fc.html#ga4c1b49022ec40eb9b06d32742f0fd1fc">elt_multiply</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga4c1b49022ec40eb9b06d32742f0fd1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7624f0f3d9bed42dfcb1127e69a08277"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_arithmetic_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7624f0f3d9bed42dfcb1127e69a08277"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1elt__divide__.html">elt_divide_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga7624f0f3d9bed42dfcb1127e69a08277.html#ga7624f0f3d9bed42dfcb1127e69a08277">elt_divide</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga7624f0f3d9bed42dfcb1127e69a08277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga755deae6392b83d02554423fad0e3fe3"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_arithmetic_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga755deae6392b83d02554423fad0e3fe3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1elt__modulo__.html">elt_modulo_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga755deae6392b83d02554423fad0e3fe3.html#ga755deae6392b83d02554423fad0e3fe3">operator%</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga755deae6392b83d02554423fad0e3fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbbb9fc498bd12ed245a8e534264d831"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_arithmetic_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacbbb9fc498bd12ed245a8e534264d831"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1less__than__.html">less_than_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gacbbb9fc498bd12ed245a8e534264d831.html#gacbbb9fc498bd12ed245a8e534264d831">operator&lt;</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:gacbbb9fc498bd12ed245a8e534264d831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc3032206697116b8ac44dea2d811c9e"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_arithmetic_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacc3032206697116b8ac44dea2d811c9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1less__than__or__equal__.html">less_than_or_equal_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gacc3032206697116b8ac44dea2d811c9e.html#gacc3032206697116b8ac44dea2d811c9e">operator&lt;=</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:gacc3032206697116b8ac44dea2d811c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ca894130727dac85e2a140be08c6bc5"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_arithmetic_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3ca894130727dac85e2a140be08c6bc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1greater__than__.html">greater_than_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga3ca894130727dac85e2a140be08c6bc5.html#ga3ca894130727dac85e2a140be08c6bc5">operator&gt;</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga3ca894130727dac85e2a140be08c6bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5739eb9332b3d66de21753aa784860bb"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_arithmetic_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5739eb9332b3d66de21753aa784860bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1greater__than__or__equal__.html">greater_than_or_equal_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5739eb9332b3d66de21753aa784860bb.html#ga5739eb9332b3d66de21753aa784860bb">operator&gt;=</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga5739eb9332b3d66de21753aa784860bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30774c1ec552de5de41da7ca0966726f"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_arithmetic_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga30774c1ec552de5de41da7ca0966726f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1equals__.html">equals_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga30774c1ec552de5de41da7ca0966726f.html#ga30774c1ec552de5de41da7ca0966726f">operator==</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga30774c1ec552de5de41da7ca0966726f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5142979df7146339369aceacbea998c"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_arithmetic_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae5142979df7146339369aceacbea998c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1not__equals__.html">not_equals_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gae5142979df7146339369aceacbea998c.html#gae5142979df7146339369aceacbea998c">operator!=</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:gae5142979df7146339369aceacbea998c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb224ea32b8901a2755a330b9cdef913"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_arithmetic_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaeb224ea32b8901a2755a330b9cdef913"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1logical__or__.html">logical_or_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaeb224ea32b8901a2755a330b9cdef913.html#gaeb224ea32b8901a2755a330b9cdef913">operator||</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:gaeb224ea32b8901a2755a330b9cdef913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea3a84a471e5cbcb5bb21772c8215748"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_arithmetic_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaea3a84a471e5cbcb5bb21772c8215748"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1logical__and__.html">logical_and_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaea3a84a471e5cbcb5bb21772c8215748.html#gaea3a84a471e5cbcb5bb21772c8215748">operator&amp;&amp;</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:gaea3a84a471e5cbcb5bb21772c8215748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab652ac12fd5c92edfbde6549ccc489a6"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , typename  = require_arithmetic_t&lt;T_a&gt;, typename  = require_all_kernel_expressions_t&lt;T_b&gt;&gt; </td></tr>
<tr class="memitem:gab652ac12fd5c92edfbde6549ccc489a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1elt__multiply__.html">elt_multiply_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gab652ac12fd5c92edfbde6549ccc489a6.html#gab652ac12fd5c92edfbde6549ccc489a6">operator*</a> (T_a a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:gab652ac12fd5c92edfbde6549ccc489a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of a scalar and a kernel generator expression.  <a href="group__opencl__kernel__generator_gab652ac12fd5c92edfbde6549ccc489a6.html#gab652ac12fd5c92edfbde6549ccc489a6">More...</a><br /></td></tr>
<tr class="separator:gab652ac12fd5c92edfbde6549ccc489a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dfb910e33902957c3c592d6da544718"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , typename  = require_all_kernel_expressions_t&lt;T_a&gt;, typename  = require_arithmetic_t&lt;T_b&gt;&gt; </td></tr>
<tr class="memitem:ga4dfb910e33902957c3c592d6da544718"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1elt__multiply__.html">elt_multiply_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga4dfb910e33902957c3c592d6da544718.html#ga4dfb910e33902957c3c592d6da544718">operator*</a> (T_a &amp;&amp;a, const T_b b)</td></tr>
<tr class="memdesc:ga4dfb910e33902957c3c592d6da544718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of a kernel generator expression and a scalar.  <a href="group__opencl__kernel__generator_ga4dfb910e33902957c3c592d6da544718.html#ga4dfb910e33902957c3c592d6da544718">More...</a><br /></td></tr>
<tr class="separator:ga4dfb910e33902957c3c592d6da544718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d6bb538a249a820efc2c1c6c9623bfd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga1d6bb538a249a820efc2c1c6c9623bfd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga1d6bb538a249a820efc2c1c6c9623bfd.html#ga1d6bb538a249a820efc2c1c6c9623bfd">block_zero_based</a> (T &amp;&amp;a, int start_row, int start_col, int <a class="el" href="group__opencl_ga61254f29c1520f4bffe4ab4e5bbd0e0e.html#ga61254f29c1520f4bffe4ab4e5bbd0e0e">rows</a>, int <a class="el" href="group__opencl_ga89d4c5b2fb1164cd7dddf3d303785022.html#ga89d4c5b2fb1164cd7dddf3d303785022">cols</a>)</td></tr>
<tr class="memdesc:ga1d6bb538a249a820efc2c1c6c9623bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block of a kernel generator expression.  <a href="group__opencl__kernel__generator_ga1d6bb538a249a820efc2c1c6c9623bfd.html#ga1d6bb538a249a820efc2c1c6c9623bfd">More...</a><br /></td></tr>
<tr class="separator:ga1d6bb538a249a820efc2c1c6c9623bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd16ecbfb480688fb732d01e223fab77"><td class="memTemplParams" colspan="2">template&lt;bool Colwise, bool Rowwise, typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gacd16ecbfb480688fb732d01e223fab77"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gacd16ecbfb480688fb732d01e223fab77.html#gacd16ecbfb480688fb732d01e223fab77">broadcast</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:gacd16ecbfb480688fb732d01e223fab77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast an expression in specified dimension(s).  <a href="group__opencl__kernel__generator_gacd16ecbfb480688fb732d01e223fab77.html#gacd16ecbfb480688fb732d01e223fab77">More...</a><br /></td></tr>
<tr class="separator:gacd16ecbfb480688fb732d01e223fab77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ffbc8e3f24b76f2c0b94515c3de334a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga7ffbc8e3f24b76f2c0b94515c3de334a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga7ffbc8e3f24b76f2c0b94515c3de334a.html#ga7ffbc8e3f24b76f2c0b94515c3de334a">rowwise_broadcast</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga7ffbc8e3f24b76f2c0b94515c3de334a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast an expression in rowwise dimmension.  <a href="group__opencl__kernel__generator_ga7ffbc8e3f24b76f2c0b94515c3de334a.html#ga7ffbc8e3f24b76f2c0b94515c3de334a">More...</a><br /></td></tr>
<tr class="separator:ga7ffbc8e3f24b76f2c0b94515c3de334a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa28ef8d2761ad8fa48ad1778f53d82ba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaa28ef8d2761ad8fa48ad1778f53d82ba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaa28ef8d2761ad8fa48ad1778f53d82ba.html#gaa28ef8d2761ad8fa48ad1778f53d82ba">colwise_broadcast</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:gaa28ef8d2761ad8fa48ad1778f53d82ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast an expression in colwise dimmension.  <a href="group__opencl__kernel__generator_gaa28ef8d2761ad8fa48ad1778f53d82ba.html#gaa28ef8d2761ad8fa48ad1778f53d82ba">More...</a><br /></td></tr>
<tr class="separator:gaa28ef8d2761ad8fa48ad1778f53d82ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e76a7b64b8df8889b7f02199ac95a7f"><td class="memTemplParams" colspan="2">template&lt;bool Do_Calculate, typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr, std::enable_if_t&lt; Do_Calculate &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3e76a7b64b8df8889b7f02199ac95a7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1calc__if__.html">calc_if_</a>&lt; true, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga3e76a7b64b8df8889b7f02199ac95a7f.html#ga3e76a7b64b8df8889b7f02199ac95a7f">calc_if</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga3e76a7b64b8df8889b7f02199ac95a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9bf3061a07b8d7519401492fb2bde1b"><td class="memTemplParams" colspan="2">template&lt;bool Do_Calculate, typename T , std::enable_if_t&lt;!Do_Calculate &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab9bf3061a07b8d7519401492fb2bde1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1calc__if__.html">calc_if_</a>&lt; false, <a class="el" href="classstan_1_1math_1_1scalar__.html">scalar_</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gab9bf3061a07b8d7519401492fb2bde1b.html#gab9bf3061a07b8d7519401492fb2bde1b">calc_if</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gab9bf3061a07b8d7519401492fb2bde1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaace1262353bcb0ba8e369e99f3c5339e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaace1262353bcb0ba8e369e99f3c5339e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaace1262353bcb0ba8e369e99f3c5339e.html#gaace1262353bcb0ba8e369e99f3c5339e">cast</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:gaace1262353bcb0ba8e369e99f3c5339e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typecast a kernel generator expression scalar.  <a href="group__opencl__kernel__generator_gaace1262353bcb0ba8e369e99f3c5339e.html#gaace1262353bcb0ba8e369e99f3c5339e">More...</a><br /></td></tr>
<tr class="separator:gaace1262353bcb0ba8e369e99f3c5339e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5904efe5d55bebac3db9dafde40cd512"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5904efe5d55bebac3db9dafde40cd512"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5904efe5d55bebac3db9dafde40cd512.html#ga5904efe5d55bebac3db9dafde40cd512">cast</a> (T a)</td></tr>
<tr class="memdesc:ga5904efe5d55bebac3db9dafde40cd512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typecast a scalar.  <a href="group__opencl__kernel__generator_ga5904efe5d55bebac3db9dafde40cd512.html#ga5904efe5d55bebac3db9dafde40cd512">More...</a><br /></td></tr>
<tr class="separator:ga5904efe5d55bebac3db9dafde40cd512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b0a4a52a729c417161974bfd526c043"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga1b0a4a52a729c417161974bfd526c043"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga1b0a4a52a729c417161974bfd526c043.html#ga1b0a4a52a729c417161974bfd526c043">check_cl</a> (const char *function, const char *var_name, T &amp;&amp;y, const char *must_be)</td></tr>
<tr class="memdesc:ga1b0a4a52a729c417161974bfd526c043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a check on opencl matrix or expression.  <a href="group__opencl__kernel__generator_ga1b0a4a52a729c417161974bfd526c043.html#ga1b0a4a52a729c417161974bfd526c043">More...</a><br /></td></tr>
<tr class="separator:ga1b0a4a52a729c417161974bfd526c043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c8533589d450256f0bb58ebb086f68"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac1c8533589d450256f0bb58ebb086f68"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gac1c8533589d450256f0bb58ebb086f68.html#gac1c8533589d450256f0bb58ebb086f68">colwise_sum</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:gac1c8533589d450256f0bb58ebb086f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column wise sum - reduction of a kernel generator expression.  <a href="group__opencl__kernel__generator_gac1c8533589d450256f0bb58ebb086f68.html#gac1c8533589d450256f0bb58ebb086f68">More...</a><br /></td></tr>
<tr class="separator:gac1c8533589d450256f0bb58ebb086f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e6cea99ace723931f31c6bda069c088"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e6cea99ace723931f31c6bda069c088"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5e6cea99ace723931f31c6bda069c088.html#ga5e6cea99ace723931f31c6bda069c088">colwise_prod</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga5e6cea99ace723931f31c6bda069c088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column wise product - reduction of a kernel generator expression.  <a href="group__opencl__kernel__generator_ga5e6cea99ace723931f31c6bda069c088.html#ga5e6cea99ace723931f31c6bda069c088">More...</a><br /></td></tr>
<tr class="separator:ga5e6cea99ace723931f31c6bda069c088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cfb404a55fe1fd585eb06122493f67b"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9cfb404a55fe1fd585eb06122493f67b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga9cfb404a55fe1fd585eb06122493f67b.html#ga9cfb404a55fe1fd585eb06122493f67b">colwise_max</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga9cfb404a55fe1fd585eb06122493f67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column wise max - reduction of a kernel generator expression.  <a href="group__opencl__kernel__generator_ga9cfb404a55fe1fd585eb06122493f67b.html#ga9cfb404a55fe1fd585eb06122493f67b">More...</a><br /></td></tr>
<tr class="separator:ga9cfb404a55fe1fd585eb06122493f67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5446e97dca7e1fb6288d29df4528cede"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5446e97dca7e1fb6288d29df4528cede"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5446e97dca7e1fb6288d29df4528cede.html#ga5446e97dca7e1fb6288d29df4528cede">colwise_min</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga5446e97dca7e1fb6288d29df4528cede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column wise min - reduction of a kernel generator expression.  <a href="group__opencl__kernel__generator_ga5446e97dca7e1fb6288d29df4528cede.html#ga5446e97dca7e1fb6288d29df4528cede">More...</a><br /></td></tr>
<tr class="separator:ga5446e97dca7e1fb6288d29df4528cede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240b3ea66c560edf50c4b63dab6775c0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_kernel_expression_lhs_t&lt; T1 &gt; *  = nullptr, require_all_kernel_expressions_t&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a240b3ea66c560edf50c4b63dab6775c0"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a240b3ea66c560edf50c4b63dab6775c0.html#a240b3ea66c560edf50c4b63dab6775c0">operator+=</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:a240b3ea66c560edf50c4b63dab6775c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdcd919027229035279ea0f157e5eff"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_kernel_expression_lhs_t&lt; T1 &gt; *  = nullptr, require_all_kernel_expressions_t&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7bdcd919027229035279ea0f157e5eff"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7bdcd919027229035279ea0f157e5eff.html#a7bdcd919027229035279ea0f157e5eff">operator-=</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:a7bdcd919027229035279ea0f157e5eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfa876f91c64c09b6c76add5105d74a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_kernel_expression_lhs_t&lt; T1 &gt; *  = nullptr, require_all_kernel_expressions_t&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adbfa876f91c64c09b6c76add5105d74a"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adbfa876f91c64c09b6c76add5105d74a.html#adbfa876f91c64c09b6c76add5105d74a">operator*=</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:adbfa876f91c64c09b6c76add5105d74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71e31d4c847f3f3fd6d5d35d699b02dc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga71e31d4c847f3f3fd6d5d35d699b02dc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga71e31d4c847f3f3fd6d5d35d699b02dc.html#ga71e31d4c847f3f3fd6d5d35d699b02dc">constant</a> (const T a, int <a class="el" href="group__opencl_ga61254f29c1520f4bffe4ab4e5bbd0e0e.html#ga61254f29c1520f4bffe4ab4e5bbd0e0e">rows</a>, int <a class="el" href="group__opencl_ga89d4c5b2fb1164cd7dddf3d303785022.html#ga89d4c5b2fb1164cd7dddf3d303785022">cols</a>)</td></tr>
<tr class="memdesc:ga71e31d4c847f3f3fd6d5d35d699b02dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix of repeated values in kernel generator expressions.  <a href="group__opencl__kernel__generator_ga71e31d4c847f3f3fd6d5d35d699b02dc.html#ga71e31d4c847f3f3fd6d5d35d699b02dc">More...</a><br /></td></tr>
<tr class="separator:ga71e31d4c847f3f3fd6d5d35d699b02dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6ad1aee7528a82a3261ee6e096cd7ea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gad6ad1aee7528a82a3261ee6e096cd7ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gad6ad1aee7528a82a3261ee6e096cd7ea.html#gad6ad1aee7528a82a3261ee6e096cd7ea">diagonal</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:gad6ad1aee7528a82a3261ee6e096cd7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonal of a kernel generator expression.  <a href="group__opencl__kernel__generator_gad6ad1aee7528a82a3261ee6e096cd7ea.html#gad6ad1aee7528a82a3261ee6e096cd7ea">More...</a><br /></td></tr>
<tr class="separator:gad6ad1aee7528a82a3261ee6e096cd7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e118ecadd42e6aa96fce46add38b876"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga6e118ecadd42e6aa96fce46add38b876"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1rsqrt__.html">rsqrt_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga6e118ecadd42e6aa96fce46add38b876.html#ga6e118ecadd42e6aa96fce46add38b876">rsqrt</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga6e118ecadd42e6aa96fce46add38b876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefdc607149488ead93a8ac2f6169ef39"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaefdc607149488ead93a8ac2f6169ef39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1sqrt__.html">sqrt_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaefdc607149488ead93a8ac2f6169ef39.html#gaefdc607149488ead93a8ac2f6169ef39">sqrt</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gaefdc607149488ead93a8ac2f6169ef39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacf0b6a563b1594dd3414e9f3797dd0c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaacf0b6a563b1594dd3414e9f3797dd0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1cbrt__.html">cbrt_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaacf0b6a563b1594dd3414e9f3797dd0c.html#gaacf0b6a563b1594dd3414e9f3797dd0c">cbrt</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gaacf0b6a563b1594dd3414e9f3797dd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf13338d3baf29b6faf2e2dea0fc18e4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaaf13338d3baf29b6faf2e2dea0fc18e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1exp__.html">exp_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaaf13338d3baf29b6faf2e2dea0fc18e4.html#gaaf13338d3baf29b6faf2e2dea0fc18e4">exp</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gaaf13338d3baf29b6faf2e2dea0fc18e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bafb5782366e25a9b11985233c84686"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga6bafb5782366e25a9b11985233c84686"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1exp2__.html">exp2_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga6bafb5782366e25a9b11985233c84686.html#ga6bafb5782366e25a9b11985233c84686">exp2</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga6bafb5782366e25a9b11985233c84686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc9d8ff2131b169f4633ed2bd5b8b46"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gacdc9d8ff2131b169f4633ed2bd5b8b46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1expm1__.html">expm1_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gacdc9d8ff2131b169f4633ed2bd5b8b46.html#gacdc9d8ff2131b169f4633ed2bd5b8b46">expm1</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gacdc9d8ff2131b169f4633ed2bd5b8b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a1f2ae955537d75ee046616b27fdee"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaf7a1f2ae955537d75ee046616b27fdee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log__.html">log_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaf7a1f2ae955537d75ee046616b27fdee.html#gaf7a1f2ae955537d75ee046616b27fdee">log</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gaf7a1f2ae955537d75ee046616b27fdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd24ed4c4d145400dd327fedd4829829"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gacd24ed4c4d145400dd327fedd4829829"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log2__.html">log2_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gacd24ed4c4d145400dd327fedd4829829.html#gacd24ed4c4d145400dd327fedd4829829">log2</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gacd24ed4c4d145400dd327fedd4829829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4c0a59112ae51ad0969ee96059daf01"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gab4c0a59112ae51ad0969ee96059daf01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log10__.html">log10_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gab4c0a59112ae51ad0969ee96059daf01.html#gab4c0a59112ae51ad0969ee96059daf01">log10</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gab4c0a59112ae51ad0969ee96059daf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga060108acfa5c0a56b9b3fc8f6b4bbbd9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga060108acfa5c0a56b9b3fc8f6b4bbbd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log1p__.html">log1p_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga060108acfa5c0a56b9b3fc8f6b4bbbd9.html#ga060108acfa5c0a56b9b3fc8f6b4bbbd9">log1p</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga060108acfa5c0a56b9b3fc8f6b4bbbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae447e5819baa75f99e0d70f0a206c7be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gae447e5819baa75f99e0d70f0a206c7be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1sin__.html">sin_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gae447e5819baa75f99e0d70f0a206c7be.html#gae447e5819baa75f99e0d70f0a206c7be">sin</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gae447e5819baa75f99e0d70f0a206c7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga538a8bd4aaa9ada724d6e7ff0cafc01d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga538a8bd4aaa9ada724d6e7ff0cafc01d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1sinh__.html">sinh_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga538a8bd4aaa9ada724d6e7ff0cafc01d.html#ga538a8bd4aaa9ada724d6e7ff0cafc01d">sinh</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga538a8bd4aaa9ada724d6e7ff0cafc01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79df3ec402544a6cac78b265bd743c5f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga79df3ec402544a6cac78b265bd743c5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1cos__.html">cos_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga79df3ec402544a6cac78b265bd743c5f.html#ga79df3ec402544a6cac78b265bd743c5f">cos</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga79df3ec402544a6cac78b265bd743c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga405274ae332af9fd0af901e305ecc432"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga405274ae332af9fd0af901e305ecc432"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1cosh__.html">cosh_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga405274ae332af9fd0af901e305ecc432.html#ga405274ae332af9fd0af901e305ecc432">cosh</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga405274ae332af9fd0af901e305ecc432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga895c490afd2917bd1009cfdc352461d7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga895c490afd2917bd1009cfdc352461d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1tan__.html">tan_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga895c490afd2917bd1009cfdc352461d7.html#ga895c490afd2917bd1009cfdc352461d7">tan</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga895c490afd2917bd1009cfdc352461d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa19d7000700ecc3a301ea41f4dc7094d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaa19d7000700ecc3a301ea41f4dc7094d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1tanh__.html">tanh_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaa19d7000700ecc3a301ea41f4dc7094d.html#gaa19d7000700ecc3a301ea41f4dc7094d">tanh</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gaa19d7000700ecc3a301ea41f4dc7094d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3004376b78622c04cbbcacd31e07608c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga3004376b78622c04cbbcacd31e07608c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1asin__.html">asin_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga3004376b78622c04cbbcacd31e07608c.html#ga3004376b78622c04cbbcacd31e07608c">asin</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga3004376b78622c04cbbcacd31e07608c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e848cf554c0d224e3fc0330193f9877"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga1e848cf554c0d224e3fc0330193f9877"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1asinh__.html">asinh_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga1e848cf554c0d224e3fc0330193f9877.html#ga1e848cf554c0d224e3fc0330193f9877">asinh</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga1e848cf554c0d224e3fc0330193f9877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbaf97f0a9ff2358b7fb3f26b148a068"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gadbaf97f0a9ff2358b7fb3f26b148a068"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1acos__.html">acos_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gadbaf97f0a9ff2358b7fb3f26b148a068.html#gadbaf97f0a9ff2358b7fb3f26b148a068">acos</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gadbaf97f0a9ff2358b7fb3f26b148a068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae89af8e227745a6a065fd416feb509cb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gae89af8e227745a6a065fd416feb509cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1acosh__.html">acosh_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gae89af8e227745a6a065fd416feb509cb.html#gae89af8e227745a6a065fd416feb509cb">acosh</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gae89af8e227745a6a065fd416feb509cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8531594cb4eaf3a41f20f78ac3a48270"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga8531594cb4eaf3a41f20f78ac3a48270"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1atan__.html">atan_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga8531594cb4eaf3a41f20f78ac3a48270.html#ga8531594cb4eaf3a41f20f78ac3a48270">atan</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga8531594cb4eaf3a41f20f78ac3a48270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32509aa2d9c1d5aa917e19af3eb25048"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga32509aa2d9c1d5aa917e19af3eb25048"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1atanh__.html">atanh_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga32509aa2d9c1d5aa917e19af3eb25048.html#ga32509aa2d9c1d5aa917e19af3eb25048">atanh</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga32509aa2d9c1d5aa917e19af3eb25048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2da5c81cf13f88f6d832d8de13ad2c7a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga2da5c81cf13f88f6d832d8de13ad2c7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1tgamma__.html">tgamma_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga2da5c81cf13f88f6d832d8de13ad2c7a.html#ga2da5c81cf13f88f6d832d8de13ad2c7a">tgamma</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga2da5c81cf13f88f6d832d8de13ad2c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab26771fe922f6f69538bbe4b71633465"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gab26771fe922f6f69538bbe4b71633465"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1lgamma__.html">lgamma_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gab26771fe922f6f69538bbe4b71633465.html#gab26771fe922f6f69538bbe4b71633465">lgamma</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gab26771fe922f6f69538bbe4b71633465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15ca5270eeb385d3e8da4e43f029f461"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga15ca5270eeb385d3e8da4e43f029f461"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1erf__.html">erf_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga15ca5270eeb385d3e8da4e43f029f461.html#ga15ca5270eeb385d3e8da4e43f029f461">erf</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga15ca5270eeb385d3e8da4e43f029f461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga602d10ec21e7a8fec91f34e46499b94a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga602d10ec21e7a8fec91f34e46499b94a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1erfc__.html">erfc_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga602d10ec21e7a8fec91f34e46499b94a.html#ga602d10ec21e7a8fec91f34e46499b94a">erfc</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga602d10ec21e7a8fec91f34e46499b94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa08cdd2fa8fe88fa708214349e9185a0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaa08cdd2fa8fe88fa708214349e9185a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1floor__.html">floor_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaa08cdd2fa8fe88fa708214349e9185a0.html#gaa08cdd2fa8fe88fa708214349e9185a0">floor</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gaa08cdd2fa8fe88fa708214349e9185a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae7833d6f786e2dc6db70e0850d80a9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga7ae7833d6f786e2dc6db70e0850d80a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1round__.html">round_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga7ae7833d6f786e2dc6db70e0850d80a9.html#ga7ae7833d6f786e2dc6db70e0850d80a9">round</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga7ae7833d6f786e2dc6db70e0850d80a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab5d7cd2eebf5c6a8add5b72c4ff1bb9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaab5d7cd2eebf5c6a8add5b72c4ff1bb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1ceil__.html">ceil_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaab5d7cd2eebf5c6a8add5b72c4ff1bb9.html#gaab5d7cd2eebf5c6a8add5b72c4ff1bb9">ceil</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gaab5d7cd2eebf5c6a8add5b72c4ff1bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2a2630a0e997adf08643728cfbded22"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gab2a2630a0e997adf08643728cfbded22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1fabs__.html">fabs_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gab2a2630a0e997adf08643728cfbded22.html#gab2a2630a0e997adf08643728cfbded22">fabs</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gab2a2630a0e997adf08643728cfbded22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc3321d401221e52c3ba293b4f702206"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gafc3321d401221e52c3ba293b4f702206"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1trunc__.html">trunc_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gafc3321d401221e52c3ba293b4f702206.html#gafc3321d401221e52c3ba293b4f702206">trunc</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gafc3321d401221e52c3ba293b4f702206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae500c2d5cd29a250f8985968b11469e1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gae500c2d5cd29a250f8985968b11469e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1digamma__.html">digamma_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gae500c2d5cd29a250f8985968b11469e1.html#gae500c2d5cd29a250f8985968b11469e1">digamma</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gae500c2d5cd29a250f8985968b11469e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29ac02c27a69f84f6089a136d768f7ae"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga29ac02c27a69f84f6089a136d768f7ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log1m__.html">log1m_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga29ac02c27a69f84f6089a136d768f7ae.html#ga29ac02c27a69f84f6089a136d768f7ae">log1m</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga29ac02c27a69f84f6089a136d768f7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f7f06aa1ebeed5255cb41c696edc80e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga0f7f06aa1ebeed5255cb41c696edc80e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log__inv__logit__.html">log_inv_logit_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga0f7f06aa1ebeed5255cb41c696edc80e.html#ga0f7f06aa1ebeed5255cb41c696edc80e">log_inv_logit</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga0f7f06aa1ebeed5255cb41c696edc80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga317ecd85c5173965d30235d131588bfb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga317ecd85c5173965d30235d131588bfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log1m__exp__.html">log1m_exp_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga317ecd85c5173965d30235d131588bfb.html#ga317ecd85c5173965d30235d131588bfb">log1m_exp</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga317ecd85c5173965d30235d131588bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga940eef2dd077ed15690c4190808f0005"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga940eef2dd077ed15690c4190808f0005"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log1p__exp__.html">log1p_exp_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga940eef2dd077ed15690c4190808f0005.html#ga940eef2dd077ed15690c4190808f0005">log1p_exp</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga940eef2dd077ed15690c4190808f0005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac34c1220d563127a1bbf323d70ee09b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gac34c1220d563127a1bbf323d70ee09b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1inv__square__.html">inv_square_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gac34c1220d563127a1bbf323d70ee09b9.html#gac34c1220d563127a1bbf323d70ee09b9">inv_square</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gac34c1220d563127a1bbf323d70ee09b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3e7065aa8d16aa9742f29bf583bfb1e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gab3e7065aa8d16aa9742f29bf583bfb1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1inv__logit__.html">inv_logit_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gab3e7065aa8d16aa9742f29bf583bfb1e.html#gab3e7065aa8d16aa9742f29bf583bfb1e">inv_logit</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gab3e7065aa8d16aa9742f29bf583bfb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d75067a27509c65ec9e8d2146f296b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga52d75067a27509c65ec9e8d2146f296b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1logit__.html">logit_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga52d75067a27509c65ec9e8d2146f296b.html#ga52d75067a27509c65ec9e8d2146f296b">logit</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga52d75067a27509c65ec9e8d2146f296b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3f8b2366eb44d3ec4288c5a2a272efd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaa3f8b2366eb44d3ec4288c5a2a272efd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1_phi__.html">Phi_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaa3f8b2366eb44d3ec4288c5a2a272efd.html#gaa3f8b2366eb44d3ec4288c5a2a272efd">Phi</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gaa3f8b2366eb44d3ec4288c5a2a272efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07165873e24c3ed2591513d4b34945ea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga07165873e24c3ed2591513d4b34945ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1_phi__approx__.html">Phi_approx_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga07165873e24c3ed2591513d4b34945ea.html#ga07165873e24c3ed2591513d4b34945ea">Phi_approx</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga07165873e24c3ed2591513d4b34945ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9736ab1e49cf354c830a5f9236db889"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gab9736ab1e49cf354c830a5f9236db889"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1inv___phi__.html">inv_Phi_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gab9736ab1e49cf354c830a5f9236db889.html#gab9736ab1e49cf354c830a5f9236db889">inv_Phi</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gab9736ab1e49cf354c830a5f9236db889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21541d45950a0ce64eb64bf37c32b4c6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga21541d45950a0ce64eb64bf37c32b4c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log1m__inv__logit__.html">log1m_inv_logit_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga21541d45950a0ce64eb64bf37c32b4c6.html#ga21541d45950a0ce64eb64bf37c32b4c6">log1m_inv_logit</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga21541d45950a0ce64eb64bf37c32b4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e110dc2239ed5bd1c4bf2ac35cd9a05"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga2e110dc2239ed5bd1c4bf2ac35cd9a05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1trigamma__.html">trigamma_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga2e110dc2239ed5bd1c4bf2ac35cd9a05.html#ga2e110dc2239ed5bd1c4bf2ac35cd9a05">trigamma</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga2e110dc2239ed5bd1c4bf2ac35cd9a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaab42f186e2dbf3b2334895141f8da4b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaaab42f186e2dbf3b2334895141f8da4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1square__.html">square_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaaab42f186e2dbf3b2334895141f8da4b.html#gaaab42f186e2dbf3b2334895141f8da4b">square</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gaaab42f186e2dbf3b2334895141f8da4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b66a74849676df7855e659ea53acb40"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga9b66a74849676df7855e659ea53acb40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1isfinite__.html">isfinite_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga9b66a74849676df7855e659ea53acb40.html#ga9b66a74849676df7855e659ea53acb40">isfinite</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga9b66a74849676df7855e659ea53acb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e043041f5162725ea6ab19e30bb565"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaf4e043041f5162725ea6ab19e30bb565"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1isinf__.html">isinf_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaf4e043041f5162725ea6ab19e30bb565.html#gaf4e043041f5162725ea6ab19e30bb565">isinf</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gaf4e043041f5162725ea6ab19e30bb565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d3933760126825b67529cc7504f492c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga7d3933760126825b67529cc7504f492c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1isnan__.html">isnan_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga7d3933760126825b67529cc7504f492c.html#ga7d3933760126825b67529cc7504f492c">isnan</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga7d3933760126825b67529cc7504f492c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6c6e07c2ed4dca892ddc551c125961a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_t&lt; T1, T2 &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae6c6e07c2ed4dca892ddc551c125961a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1fdim__.html">fdim_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gae6c6e07c2ed4dca892ddc551c125961a.html#gae6c6e07c2ed4dca892ddc551c125961a">fdim</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:gae6c6e07c2ed4dca892ddc551c125961a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94dc7cbf401e5c3b8fe31d7ed23f0637"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_t&lt; T1, T2 &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga94dc7cbf401e5c3b8fe31d7ed23f0637"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1fmax__.html">fmax_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga94dc7cbf401e5c3b8fe31d7ed23f0637.html#ga94dc7cbf401e5c3b8fe31d7ed23f0637">fmax</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga94dc7cbf401e5c3b8fe31d7ed23f0637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cdf5b5d1a25212fa497513b16321b82"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_t&lt; T1, T2 &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7cdf5b5d1a25212fa497513b16321b82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1fmin__.html">fmin_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga7cdf5b5d1a25212fa497513b16321b82.html#ga7cdf5b5d1a25212fa497513b16321b82">fmin</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga7cdf5b5d1a25212fa497513b16321b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48434407a27b16c54dee3ff6d76a7907"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_t&lt; T1, T2 &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga48434407a27b16c54dee3ff6d76a7907"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1fmod__.html">fmod_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga48434407a27b16c54dee3ff6d76a7907.html#ga48434407a27b16c54dee3ff6d76a7907">fmod</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga48434407a27b16c54dee3ff6d76a7907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga600e9a7e8bd0619b1d8d8a9ff0fcc03d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_t&lt; T1, T2 &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga600e9a7e8bd0619b1d8d8a9ff0fcc03d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1hypot__.html">hypot_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga600e9a7e8bd0619b1d8d8a9ff0fcc03d.html#ga600e9a7e8bd0619b1d8d8a9ff0fcc03d">hypot</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga600e9a7e8bd0619b1d8d8a9ff0fcc03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b48173e1ace84d58fb26870e2270cdd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_t&lt; T1, T2 &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2b48173e1ace84d58fb26870e2270cdd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1ldexp__.html">ldexp_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga2b48173e1ace84d58fb26870e2270cdd.html#ga2b48173e1ace84d58fb26870e2270cdd">ldexp</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga2b48173e1ace84d58fb26870e2270cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae8408f2e91941d12f746e27bceff035"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_t&lt; T1, T2 &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaae8408f2e91941d12f746e27bceff035"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1pow__.html">pow_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaae8408f2e91941d12f746e27bceff035.html#gaae8408f2e91941d12f746e27bceff035">pow</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:gaae8408f2e91941d12f746e27bceff035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf385146c7e95d4edcc298f26685f39f0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_t&lt; T1, T2 &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf385146c7e95d4edcc298f26685f39f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1copysign__.html">copysign_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaf385146c7e95d4edcc298f26685f39f0.html#gaf385146c7e95d4edcc298f26685f39f0">copysign</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:gaf385146c7e95d4edcc298f26685f39f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37e798a1b371d4c7565be579c9d2d3f6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_t&lt; T1, T2 &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga37e798a1b371d4c7565be579c9d2d3f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1beta__.html">beta_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga37e798a1b371d4c7565be579c9d2d3f6.html#ga37e798a1b371d4c7565be579c9d2d3f6">beta</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga37e798a1b371d4c7565be579c9d2d3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2ab6cc0a58519a74eaa2903c07b9965"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_t&lt; T1, T2 &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab2ab6cc0a58519a74eaa2903c07b9965"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1binomial__coefficient__log__.html">binomial_coefficient_log_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gab2ab6cc0a58519a74eaa2903c07b9965.html#gab2ab6cc0a58519a74eaa2903c07b9965">binomial_coefficient_log</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:gab2ab6cc0a58519a74eaa2903c07b9965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48a9e27a3a6c3a61e39b7a7153f46514"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_t&lt; T1, T2 &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga48a9e27a3a6c3a61e39b7a7153f46514"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1lbeta__.html">lbeta_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga48a9e27a3a6c3a61e39b7a7153f46514.html#ga48a9e27a3a6c3a61e39b7a7153f46514">lbeta</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga48a9e27a3a6c3a61e39b7a7153f46514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2c58280266c341ef881365a646c6eb4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_t&lt; T1, T2 &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa2c58280266c341ef881365a646c6eb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log__inv__logit__diff__.html">log_inv_logit_diff_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaa2c58280266c341ef881365a646c6eb4.html#gaa2c58280266c341ef881365a646c6eb4">log_inv_logit_diff</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:gaa2c58280266c341ef881365a646c6eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a29079eef48b14a2476cf3a3431bf2e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_t&lt; T1, T2 &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9a29079eef48b14a2476cf3a3431bf2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log__diff__exp__.html">log_diff_exp_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga9a29079eef48b14a2476cf3a3431bf2e.html#ga9a29079eef48b14a2476cf3a3431bf2e">log_diff_exp</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga9a29079eef48b14a2476cf3a3431bf2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac65594e7906f903482992167a4ce3603"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_t&lt; T1, T2 &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac65594e7906f903482992167a4ce3603"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1multiply__log__.html">multiply_log_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gac65594e7906f903482992167a4ce3603.html#gac65594e7906f903482992167a4ce3603">multiply_log</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:gac65594e7906f903482992167a4ce3603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a923e674a5640c420baa60c808eeef"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_t&lt; T1, T2 &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga55a923e674a5640c420baa60c808eeef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1lmultiply__.html">lmultiply_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga55a923e674a5640c420baa60c808eeef.html#ga55a923e674a5640c420baa60c808eeef">lmultiply</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga55a923e674a5640c420baa60c808eeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4354d64457f958a5bd96518c952249"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ptrs, require_all_kernel_expressions_t&lt; T, Ptrs... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5a4354d64457f958a5bd96518c952249"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5a4354d64457f958a5bd96518c952249.html#ga5a4354d64457f958a5bd96518c952249">holder_cl</a> (T &amp;&amp;a, Ptrs *... ptrs)</td></tr>
<tr class="memdesc:ga5a4354d64457f958a5bd96518c952249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a no-op operation that also holds pointer to some other expressions, allocated on heap.  <a href="group__opencl__kernel__generator_ga5a4354d64457f958a5bd96518c952249.html#ga5a4354d64457f958a5bd96518c952249">More...</a><br /></td></tr>
<tr class="separator:ga5a4354d64457f958a5bd96518c952249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1606a52cb1b2b478689f4d0cc3d515e4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args, require_all_kernel_expressions_t&lt; decltype(std::declval&lt; T &gt;()(std::declval&lt; Args &amp; &gt;()...)), Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1606a52cb1b2b478689f4d0cc3d515e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga1606a52cb1b2b478689f4d0cc3d515e4.html#ga1606a52cb1b2b478689f4d0cc3d515e4">make_holder_cl</a> (const T &amp;func, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga1606a52cb1b2b478689f4d0cc3d515e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an expression from given arguments using given functor.  <a href="group__opencl__kernel__generator_ga1606a52cb1b2b478689f4d0cc3d515e4.html#ga1606a52cb1b2b478689f4d0cc3d515e4">More...</a><br /></td></tr>
<tr class="separator:ga1606a52cb1b2b478689f4d0cc3d515e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd7112f019bbee28c6882bef07779e05"><td class="memTemplParams" colspan="2">template&lt;typename T_mat , typename T_row_index , typename T_col_index , require_all_kernel_expressions_t&lt; T_mat, T_row_index, T_col_index &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacd7112f019bbee28c6882bef07779e05"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gacd7112f019bbee28c6882bef07779e05.html#gacd7112f019bbee28c6882bef07779e05">indexing</a> (T_mat &amp;&amp;mat, T_row_index &amp;&amp;<a class="el" href="classstan_1_1math_1_1row__index.html">row_index</a>, T_col_index &amp;&amp;<a class="el" href="classstan_1_1math_1_1col__index.html">col_index</a>)</td></tr>
<tr class="memdesc:gacd7112f019bbee28c6882bef07779e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index a kernel generator expression using two expressions for indices.  <a href="group__opencl__kernel__generator_gacd7112f019bbee28c6882bef07779e05.html#gacd7112f019bbee28c6882bef07779e05">More...</a><br /></td></tr>
<tr class="separator:gacd7112f019bbee28c6882bef07779e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b81ef398cfaf0b0c049900db611533"><td class="memTemplParams" colspan="2">template&lt;typename T_matrix , typename T_vector , typename  = require_all_kernel_expressions_t&lt;T_matrix, T_vector&gt;&gt; </td></tr>
<tr class="memitem:ab5b81ef398cfaf0b0c049900db611533"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab5b81ef398cfaf0b0c049900db611533.html#ab5b81ef398cfaf0b0c049900db611533">matrix_vector_multiply</a> (T_matrix &amp;&amp;matrix, T_vector &amp;&amp;vector)</td></tr>
<tr class="memdesc:ab5b81ef398cfaf0b0c049900db611533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a matrix and a vector on an OpenCL device.  <a href="namespacestan_1_1math_ab5b81ef398cfaf0b0c049900db611533.html#ab5b81ef398cfaf0b0c049900db611533">More...</a><br /></td></tr>
<tr class="separator:ab5b81ef398cfaf0b0c049900db611533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b4b6764e9ae79bd389a150697ab6972"><td class="memTemplParams" colspan="2">template&lt;typename... T_expressions&gt; </td></tr>
<tr class="memitem:ga5b4b6764e9ae79bd389a150697ab6972"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1expressions__cl.html">expressions_cl</a>&lt; T_expressions... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5b4b6764e9ae79bd389a150697ab6972.html#ga5b4b6764e9ae79bd389a150697ab6972">expressions</a> (T_expressions &amp;&amp;... expressions)</td></tr>
<tr class="memdesc:ga5b4b6764e9ae79bd389a150697ab6972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces types for constructing <code><a class="el" href="classstan_1_1math_1_1expressions__cl.html" title="Represents multiple expressions that will be calculated in same kernel.">expressions_cl</a></code> object.  <a href="group__opencl__kernel__generator_ga5b4b6764e9ae79bd389a150697ab6972.html#ga5b4b6764e9ae79bd389a150697ab6972">More...</a><br /></td></tr>
<tr class="separator:ga5b4b6764e9ae79bd389a150697ab6972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a446e25c0da21a49dfe45e21c0bcd19"><td class="memTemplParams" colspan="2">template&lt;typename... T_results&gt; </td></tr>
<tr class="memitem:ga7a446e25c0da21a49dfe45e21c0bcd19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1results__cl.html">results_cl</a>&lt; T_results... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga7a446e25c0da21a49dfe45e21c0bcd19.html#ga7a446e25c0da21a49dfe45e21c0bcd19">results</a> (T_results &amp;&amp;... results)</td></tr>
<tr class="memdesc:ga7a446e25c0da21a49dfe45e21c0bcd19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces types for constructing <code><a class="el" href="classstan_1_1math_1_1results__cl.html" title="Represents results that will be calculated in same kernel.">results_cl</a></code> object.  <a href="group__opencl__kernel__generator_ga7a446e25c0da21a49dfe45e21c0bcd19.html#ga7a446e25c0da21a49dfe45e21c0bcd19">More...</a><br /></td></tr>
<tr class="separator:ga7a446e25c0da21a49dfe45e21c0bcd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d711e389b4c78c0d11c974f53b30c88"><td class="memTemplParams" colspan="2">template&lt;const char * Code, typename... T_arguments, require_all_kernel_expressions_t&lt; T_arguments... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5d711e389b4c78c0d11c974f53b30c88"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5d711e389b4c78c0d11c974f53b30c88.html#ga5d711e389b4c78c0d11c974f53b30c88">opencl_code</a> (std::tuple&lt; typename std::pair&lt; const char *, T_arguments &gt;::first_type... &gt; names, T_arguments &amp;&amp;... arguments)</td></tr>
<tr class="memdesc:ga5d711e389b4c78c0d11c974f53b30c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom code in kernel generator expressions.  <a href="group__opencl__kernel__generator_ga5d711e389b4c78c0d11c974f53b30c88.html#ga5d711e389b4c78c0d11c974f53b30c88">More...</a><br /></td></tr>
<tr class="separator:ga5d711e389b4c78c0d11c974f53b30c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed2c6b3915feff7205c17f8595189f2"><td class="memTemplParams" colspan="2">template&lt;bool Colwise, bool Rowwise, typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a0ed2c6b3915feff7205c17f8595189f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1optional__broadcast__.html">optional_broadcast_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt;, Colwise, Rowwise &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0ed2c6b3915feff7205c17f8595189f2.html#a0ed2c6b3915feff7205c17f8595189f2">optional_broadcast</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a0ed2c6b3915feff7205c17f8595189f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast an expression in specified dimension(s) if the size along that dimension equals 1.  <a href="namespacestan_1_1math_a0ed2c6b3915feff7205c17f8595189f2.html#a0ed2c6b3915feff7205c17f8595189f2">More...</a><br /></td></tr>
<tr class="separator:a0ed2c6b3915feff7205c17f8595189f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78040a58375a862be6e9e5e91ec195f3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a78040a58375a862be6e9e5e91ec195f3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a78040a58375a862be6e9e5e91ec195f3.html#a78040a58375a862be6e9e5e91ec195f3">rowwise_optional_broadcast</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a78040a58375a862be6e9e5e91ec195f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast an expression in rowwise dimmension if the number of columns equals to 1.  <a href="namespacestan_1_1math_a78040a58375a862be6e9e5e91ec195f3.html#a78040a58375a862be6e9e5e91ec195f3">More...</a><br /></td></tr>
<tr class="separator:a78040a58375a862be6e9e5e91ec195f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459ea8ec2e84f892c39c6a2dac77eb6e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a459ea8ec2e84f892c39c6a2dac77eb6e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a459ea8ec2e84f892c39c6a2dac77eb6e.html#a459ea8ec2e84f892c39c6a2dac77eb6e">colwise_optional_broadcast</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a459ea8ec2e84f892c39c6a2dac77eb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast an expression in colwise dimmension if the number of rows equals to 1.  <a href="namespacestan_1_1math_a459ea8ec2e84f892c39c6a2dac77eb6e.html#a459ea8ec2e84f892c39c6a2dac77eb6e">More...</a><br /></td></tr>
<tr class="separator:a459ea8ec2e84f892c39c6a2dac77eb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1462faace0d3fa31a5667ac49b26a823"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1462faace0d3fa31a5667ac49b26a823"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga1462faace0d3fa31a5667ac49b26a823.html#ga1462faace0d3fa31a5667ac49b26a823">sum_2d</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga1462faace0d3fa31a5667ac49b26a823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two dimensional sum - reduction of a kernel generator expression.  <a href="group__opencl__kernel__generator_ga1462faace0d3fa31a5667ac49b26a823.html#ga1462faace0d3fa31a5667ac49b26a823">More...</a><br /></td></tr>
<tr class="separator:ga1462faace0d3fa31a5667ac49b26a823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac70073b0bfbd8cbab725c43d64826bd8"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac70073b0bfbd8cbab725c43d64826bd8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gac70073b0bfbd8cbab725c43d64826bd8.html#gac70073b0bfbd8cbab725c43d64826bd8">prod_2d</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:gac70073b0bfbd8cbab725c43d64826bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two dimensional product - reduction of a kernel generator expression.  <a href="group__opencl__kernel__generator_gac70073b0bfbd8cbab725c43d64826bd8.html#gac70073b0bfbd8cbab725c43d64826bd8">More...</a><br /></td></tr>
<tr class="separator:gac70073b0bfbd8cbab725c43d64826bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeae5d88f953fd148edfaa002e20c883"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaeeae5d88f953fd148edfaa002e20c883"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaeeae5d88f953fd148edfaa002e20c883.html#gaeeae5d88f953fd148edfaa002e20c883">max_2d</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:gaeeae5d88f953fd148edfaa002e20c883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two dimensional max - reduction of a kernel generator expression.  <a href="group__opencl__kernel__generator_gaeeae5d88f953fd148edfaa002e20c883.html#gaeeae5d88f953fd148edfaa002e20c883">More...</a><br /></td></tr>
<tr class="separator:gaeeae5d88f953fd148edfaa002e20c883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40f26738b59030414c5284f3e5a65e94"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga40f26738b59030414c5284f3e5a65e94"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga40f26738b59030414c5284f3e5a65e94.html#ga40f26738b59030414c5284f3e5a65e94">min_2d</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga40f26738b59030414c5284f3e5a65e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two dimensional min - reduction of a kernel generator expression.  <a href="group__opencl__kernel__generator_ga40f26738b59030414c5284f3e5a65e94.html#ga40f26738b59030414c5284f3e5a65e94">More...</a><br /></td></tr>
<tr class="separator:ga40f26738b59030414c5284f3e5a65e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cd6efc415346ed609b5e879489e138f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga9cd6efc415346ed609b5e879489e138f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga9cd6efc415346ed609b5e879489e138f.html#ga9cd6efc415346ed609b5e879489e138f">rowwise_sum</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga9cd6efc415346ed609b5e879489e138f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rowwise sum reduction of a kernel generator expression.  <a href="group__opencl__kernel__generator_ga9cd6efc415346ed609b5e879489e138f.html#ga9cd6efc415346ed609b5e879489e138f">More...</a><br /></td></tr>
<tr class="separator:ga9cd6efc415346ed609b5e879489e138f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab329e15841c51999d18caf1b11fc4d6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaab329e15841c51999d18caf1b11fc4d6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaab329e15841c51999d18caf1b11fc4d6.html#gaab329e15841c51999d18caf1b11fc4d6">rowwise_prod</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:gaab329e15841c51999d18caf1b11fc4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rowwise product reduction of a kernel generator expression.  <a href="group__opencl__kernel__generator_gaab329e15841c51999d18caf1b11fc4d6.html#gaab329e15841c51999d18caf1b11fc4d6">More...</a><br /></td></tr>
<tr class="separator:gaab329e15841c51999d18caf1b11fc4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cffcf5d84759ac5f6c46f19b33d3a7b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga6cffcf5d84759ac5f6c46f19b33d3a7b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga6cffcf5d84759ac5f6c46f19b33d3a7b.html#ga6cffcf5d84759ac5f6c46f19b33d3a7b">rowwise_max</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga6cffcf5d84759ac5f6c46f19b33d3a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rowwise max reduction of a kernel generator expression.  <a href="group__opencl__kernel__generator_ga6cffcf5d84759ac5f6c46f19b33d3a7b.html#ga6cffcf5d84759ac5f6c46f19b33d3a7b">More...</a><br /></td></tr>
<tr class="separator:ga6cffcf5d84759ac5f6c46f19b33d3a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c7b84610288363139813944780f22f4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga7c7b84610288363139813944780f22f4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga7c7b84610288363139813944780f22f4.html#ga7c7b84610288363139813944780f22f4">rowwise_min</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga7c7b84610288363139813944780f22f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Min reduction of a kernel generator expression.  <a href="group__opencl__kernel__generator_ga7c7b84610288363139813944780f22f4.html#ga7c7b84610288363139813944780f22f4">More...</a><br /></td></tr>
<tr class="separator:ga7c7b84610288363139813944780f22f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4edbbf0cedee88f2c4dd5dbcb4e207d2"><td class="memTemplParams" colspan="2">template&lt;typename T_condition , typename T_then , typename T_else , require_all_kernel_expressions_t&lt; T_condition, T_then, T_else &gt; *  = nullptr, require_any_not_arithmetic_t&lt; T_condition, T_then, T_else &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4edbbf0cedee88f2c4dd5dbcb4e207d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1select__.html">select_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_condition &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_then &gt;, <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T_else &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga4edbbf0cedee88f2c4dd5dbcb4e207d2.html#ga4edbbf0cedee88f2c4dd5dbcb4e207d2">select</a> (T_condition &amp;&amp;condition, T_then &amp;&amp;then, T_else &amp;&amp;els)</td></tr>
<tr class="memdesc:ga4edbbf0cedee88f2c4dd5dbcb4e207d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selection operation on kernel generator expressions.  <a href="group__opencl__kernel__generator_ga4edbbf0cedee88f2c4dd5dbcb4e207d2.html#ga4edbbf0cedee88f2c4dd5dbcb4e207d2">More...</a><br /></td></tr>
<tr class="separator:ga4edbbf0cedee88f2c4dd5dbcb4e207d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6760286fb7c3a0b1d93a9ba0c679275"><td class="memTemplParams" colspan="2">template&lt;typename T_then , typename T_else , require_all_arithmetic_t&lt; T_then, T_else &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf6760286fb7c3a0b1d93a9ba0c679275"><td class="memTemplItemLeft" align="right" valign="top">std::common_type_t&lt; T_then, T_else &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaf6760286fb7c3a0b1d93a9ba0c679275.html#gaf6760286fb7c3a0b1d93a9ba0c679275">select</a> (bool condition, T_then then, T_else els)</td></tr>
<tr class="memdesc:gaf6760286fb7c3a0b1d93a9ba0c679275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar overload of the selection operation.  <a href="group__opencl__kernel__generator_gaf6760286fb7c3a0b1d93a9ba0c679275.html#gaf6760286fb7c3a0b1d93a9ba0c679275">More...</a><br /></td></tr>
<tr class="separator:gaf6760286fb7c3a0b1d93a9ba0c679275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58874b947f34c4e6158fb996af4aa4e4"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;Arg&gt;&gt; </td></tr>
<tr class="memitem:ga58874b947f34c4e6158fb996af4aa4e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga58874b947f34c4e6158fb996af4aa4e4.html#ga58874b947f34c4e6158fb996af4aa4e4">transpose</a> (Arg &amp;&amp;a)</td></tr>
<tr class="memdesc:ga58874b947f34c4e6158fb996af4aa4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a kernel generator expression.  <a href="group__opencl__kernel__generator_ga58874b947f34c4e6158fb996af4aa4e4.html#ga58874b947f34c4e6158fb996af4aa4e4">More...</a><br /></td></tr>
<tr class="separator:ga58874b947f34c4e6158fb996af4aa4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455f30f5ce100c02ac1145cf1a01dc3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a455f30f5ce100c02ac1145cf1a01dc3b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a455f30f5ce100c02ac1145cf1a01dc3b.html#a455f30f5ce100c02ac1145cf1a01dc3b">type_str</a> ()</td></tr>
<tr class="memdesc:a455f30f5ce100c02ac1145cf1a01dc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines a string name of a type.  <a href="namespacestan_1_1math_a455f30f5ce100c02ac1145cf1a01dc3b.html#a455f30f5ce100c02ac1145cf1a01dc3b">More...</a><br /></td></tr>
<tr class="separator:a455f30f5ce100c02ac1145cf1a01dc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad578b08682555d22784b9d33822e68c8"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad578b08682555d22784b9d33822e68c8"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad578b08682555d22784b9d33822e68c8.html#ad578b08682555d22784b9d33822e68c8">type_str&lt; double &gt;</a> ()</td></tr>
<tr class="separator:ad578b08682555d22784b9d33822e68c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55f52e09caf33a7e02a2f96c6cd98c9"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab55f52e09caf33a7e02a2f96c6cd98c9"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab55f52e09caf33a7e02a2f96c6cd98c9.html#ab55f52e09caf33a7e02a2f96c6cd98c9">type_str&lt; int &gt;</a> ()</td></tr>
<tr class="separator:ab55f52e09caf33a7e02a2f96c6cd98c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d642f94e1d1cb337c5821b01eb2347"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad8d642f94e1d1cb337c5821b01eb2347"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad8d642f94e1d1cb337c5821b01eb2347.html#ad8d642f94e1d1cb337c5821b01eb2347">type_str&lt; char &gt;</a> ()</td></tr>
<tr class="separator:ad8d642f94e1d1cb337c5821b01eb2347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6b06bd25e0b04d659682e31215b3bb"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1d6b06bd25e0b04d659682e31215b3bb"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1d6b06bd25e0b04d659682e31215b3bb.html#a1d6b06bd25e0b04d659682e31215b3bb">type_str&lt; bool &gt;</a> ()</td></tr>
<tr class="separator:a1d6b06bd25e0b04d659682e31215b3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbc0036cef8e9620e6c996e23f74114"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4cbc0036cef8e9620e6c996e23f74114"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1logical__negation__.html">logical_negation_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4cbc0036cef8e9620e6c996e23f74114.html#a4cbc0036cef8e9620e6c996e23f74114">operator!</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a4cbc0036cef8e9620e6c996e23f74114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical negation of a kernel generator expression.  <a href="namespacestan_1_1math_a4cbc0036cef8e9620e6c996e23f74114.html#a4cbc0036cef8e9620e6c996e23f74114">More...</a><br /></td></tr>
<tr class="separator:a4cbc0036cef8e9620e6c996e23f74114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12be80b4d9f1a4813ce33a4012b0ef4"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa12be80b4d9f1a4813ce33a4012b0ef4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1unary__minus__.html">unary_minus_</a>&lt; <a class="el" href="group__opencl__kernel__generator_ga3ba0bf1e3380fb336f20163a4e7e6723.html#ga3ba0bf1e3380fb336f20163a4e7e6723">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa12be80b4d9f1a4813ce33a4012b0ef4.html#aa12be80b4d9f1a4813ce33a4012b0ef4">operator-</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:aa12be80b4d9f1a4813ce33a4012b0ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus of a kernel generator expression.  <a href="namespacestan_1_1math_aa12be80b4d9f1a4813ce33a4012b0ef4.html#aa12be80b4d9f1a4813ce33a4012b0ef4">More...</a><br /></td></tr>
<tr class="separator:aa12be80b4d9f1a4813ce33a4012b0ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_ga9850bbd8d516b87d722ad54947bb9c9f.html#ga9850bbd8d516b87d722ad54947bb9c9f">either</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> left_view, const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> right_view)</td></tr>
<tr class="separator:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338a285d4ba933ba6aa7240908919e0f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_ga338a285d4ba933ba6aa7240908919e0f.html#ga338a285d4ba933ba6aa7240908919e0f">both</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> left_view, const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> right_view)</td></tr>
<tr class="separator:ga338a285d4ba933ba6aa7240908919e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd63c8a601189c916c8a2157066adb7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_gadd63c8a601189c916c8a2157066adb7c.html#gadd63c8a601189c916c8a2157066adb7c">contains_nonzero</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view, const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> part)</td></tr>
<tr class="separator:gadd63c8a601189c916c8a2157066adb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafccee2b081b9edd7c6e6d211157e5490"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_gafccee2b081b9edd7c6e6d211157e5490.html#gafccee2b081b9edd7c6e6d211157e5490">transpose</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view)</td></tr>
<tr class="separator:gafccee2b081b9edd7c6e6d211157e5490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga747f014e58d824281b725a7d4868dd77"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_ga747f014e58d824281b725a7d4868dd77.html#ga747f014e58d824281b725a7d4868dd77">invert</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view)</td></tr>
<tr class="separator:ga747f014e58d824281b725a7d4868dd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27e938e6fdd621c5903cc37401c54909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_ga27e938e6fdd621c5903cc37401c54909.html#ga27e938e6fdd621c5903cc37401c54909">from_eigen_uplo_type</a> (Eigen::UpLoType eigen_type)</td></tr>
<tr class="separator:ga27e938e6fdd621c5903cc37401c54909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae46253a70141bc9eef9e6fe5bf278b78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl__kernels_gae46253a70141bc9eef9e6fe5bf278b78.html#gae46253a70141bc9eef9e6fe5bf278b78">either</a> (int left_view, int right_view)</td></tr>
<tr class="separator:gae46253a70141bc9eef9e6fe5bf278b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e1f78a060854c0ee5eaf42a9eb21cd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl__kernels_ga4e1f78a060854c0ee5eaf42a9eb21cd5.html#ga4e1f78a060854c0ee5eaf42a9eb21cd5">both</a> (int left_view, int right_view)</td></tr>
<tr class="separator:ga4e1f78a060854c0ee5eaf42a9eb21cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6329dbb31a5e13ede128e993ceb1093f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl__kernels_ga6329dbb31a5e13ede128e993ceb1093f.html#ga6329dbb31a5e13ede128e993ceb1093f">contains_nonzero</a> (int view, int part)</td></tr>
<tr class="separator:ga6329dbb31a5e13ede128e993ceb1093f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e3539ba6e81a0a69e69f09c683252a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga72e3539ba6e81a0a69e69f09c683252a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga72e3539ba6e81a0a69e69f09c683252a.html#ga72e3539ba6e81a0a69e69f09c683252a">multiply_transpose</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="separator:ga72e3539ba6e81a0a69e69f09c683252a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7096ca355b7d691a87e1472a4f4984f"><td class="memTemplParams" colspan="2">template&lt;typename T_m , typename T_a , require_all_kernel_expressions_and_none_scalar_t&lt; T_m &gt; *  = nullptr, require_all_kernel_expressions_t&lt; T_a &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa7096ca355b7d691a87e1472a4f4984f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa7096ca355b7d691a87e1472a4f4984f.html#aa7096ca355b7d691a87e1472a4f4984f">add_diag</a> (T_m &amp;&amp;mat, T_a &amp;&amp;to_add)</td></tr>
<tr class="memdesc:aa7096ca355b7d691a87e1472a4f4984f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matrix with values added along the main diagonal.  <a href="namespacestan_1_1math_aa7096ca355b7d691a87e1472a4f4984f.html#aa7096ca355b7d691a87e1472a4f4984f">More...</a><br /></td></tr>
<tr class="separator:aa7096ca355b7d691a87e1472a4f4984f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad208a430755d3caf47cbb1f76dd0e74"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_y , require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x, T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aad208a430755d3caf47cbb1f76dd0e74"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aad208a430755d3caf47cbb1f76dd0e74.html#aad208a430755d3caf47cbb1f76dd0e74">append_array</a> (T_x &amp;&amp;x, T_y &amp;&amp;y)</td></tr>
<tr class="memdesc:aad208a430755d3caf47cbb1f76dd0e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the concatenation of two specified vectors in the order of the arguments.  <a href="namespacestan_1_1math_aad208a430755d3caf47cbb1f76dd0e74.html#aad208a430755d3caf47cbb1f76dd0e74">More...</a><br /></td></tr>
<tr class="separator:aad208a430755d3caf47cbb1f76dd0e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1a45a9de941995d266911abd83164b4"><td class="memTemplParams" colspan="2">template&lt;typename T_n_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf1a45a9de941995d266911abd83164b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaf1a45a9de941995d266911abd83164b4.html#gaf1a45a9de941995d266911abd83164b4">bernoulli_cdf</a> (const T_n_cl &amp;n, const T_prob_cl &amp;theta)</td></tr>
<tr class="separator:gaf1a45a9de941995d266911abd83164b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga113e042f1cb9a2f549cf06159ec1c27e"><td class="memTemplParams" colspan="2">template&lt;typename T_n_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga113e042f1cb9a2f549cf06159ec1c27e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga113e042f1cb9a2f549cf06159ec1c27e.html#ga113e042f1cb9a2f549cf06159ec1c27e">bernoulli_lccdf</a> (const T_n_cl &amp;n, const T_prob_cl &amp;theta)</td></tr>
<tr class="separator:ga113e042f1cb9a2f549cf06159ec1c27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga214303a31057f84f64edaa1a5adaf871"><td class="memTemplParams" colspan="2">template&lt;typename T_n_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga214303a31057f84f64edaa1a5adaf871"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga214303a31057f84f64edaa1a5adaf871.html#ga214303a31057f84f64edaa1a5adaf871">bernoulli_lcdf</a> (const T_n_cl &amp;n, const T_prob_cl &amp;theta)</td></tr>
<tr class="separator:ga214303a31057f84f64edaa1a5adaf871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41aad12d4ca13a5ae0117d586fb276bf"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_x_cl , typename T_y_cl , typename T_alpha_cl , typename T_beta_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga41aad12d4ca13a5ae0117d586fb276bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x_cl, T_alpha_cl, T_beta_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga41aad12d4ca13a5ae0117d586fb276bf.html#ga41aad12d4ca13a5ae0117d586fb276bf">bernoulli_logit_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga41aad12d4ca13a5ae0117d586fb276bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf027ff427b3038a891dca23dcf8716"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5cf027ff427b3038a891dca23dcf8716"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga5cf027ff427b3038a891dca23dcf8716.html#ga5cf027ff427b3038a891dca23dcf8716">bernoulli_logit_lpmf</a> (const T_n_cl &amp;n, const T_prob_cl &amp;theta)</td></tr>
<tr class="separator:ga5cf027ff427b3038a891dca23dcf8716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f362f28acd7dfc21fc0df158e8b4df8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4f362f28acd7dfc21fc0df158e8b4df8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga4f362f28acd7dfc21fc0df158e8b4df8.html#ga4f362f28acd7dfc21fc0df158e8b4df8">bernoulli_lpmf</a> (const T_n_cl &amp;n, const T_prob_cl &amp;theta)</td></tr>
<tr class="separator:ga4f362f28acd7dfc21fc0df158e8b4df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25bf99f6c2b660ff1bfcdb0bc8440b1d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_size1_cl , typename T_size2_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_size1_cl, T_size2_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_size1_cl, T_size2_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga25bf99f6c2b660ff1bfcdb0bc8440b1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_size1_cl, T_size2_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga25bf99f6c2b660ff1bfcdb0bc8440b1d.html#ga25bf99f6c2b660ff1bfcdb0bc8440b1d">beta_binomial_lpmf</a> (const T_n_cl &amp;n, const T_N_cl N, const T_size1_cl &amp;alpha, const T_size2_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga25bf99f6c2b660ff1bfcdb0bc8440b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f3979f0dfb2cfe557bb00f5a420819d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_succ_cl , typename T_scale_fail_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6f3979f0dfb2cfe557bb00f5a420819d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6f3979f0dfb2cfe557bb00f5a420819d.html#ga6f3979f0dfb2cfe557bb00f5a420819d">beta_lpdf</a> (const T_y_cl &amp;y, const T_scale_succ_cl &amp;alpha, const T_scale_fail_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga6f3979f0dfb2cfe557bb00f5a420819d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga695bf141835176b401725a1f93c0b00b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_prec_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_prec_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_prec_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga695bf141835176b401725a1f93c0b00b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_prec_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga695bf141835176b401725a1f93c0b00b.html#ga695bf141835176b401725a1f93c0b00b">beta_proportion_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_prec_cl &amp;kappa)</td></tr>
<tr class="separator:ga695bf141835176b401725a1f93c0b00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b70ff8b7c0976aa9443ff63026ee3d7"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr, require_any_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6b70ff8b7c0976aa9443ff63026ee3d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6b70ff8b7c0976aa9443ff63026ee3d7.html#ga6b70ff8b7c0976aa9443ff63026ee3d7">binomial_logit_lpmf</a> (const T_n_cl &amp;n, const T_N_cl N, const T_prob_cl &amp;alpha)</td></tr>
<tr class="separator:ga6b70ff8b7c0976aa9443ff63026ee3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e355b2eb2a94840f0d2d8df923fc9a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_prob_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr, require_any_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga12e355b2eb2a94840f0d2d8df923fc9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga12e355b2eb2a94840f0d2d8df923fc9a.html#ga12e355b2eb2a94840f0d2d8df923fc9a">binomial_lpmf</a> (const T_n_cl &amp;n, const T_N_cl N, const T_prob_cl &amp;theta)</td></tr>
<tr class="separator:ga12e355b2eb2a94840f0d2d8df923fc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d6a17dad1f8172090578a7cd1fb372"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:a78d6a17dad1f8172090578a7cd1fb372"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a78d6a17dad1f8172090578a7cd1fb372.html#a78d6a17dad1f8172090578a7cd1fb372">block</a> (T_x &amp;&amp;x, size_t i, size_t j, size_t nrows, size_t ncols)</td></tr>
<tr class="memdesc:a78d6a17dad1f8172090578a7cd1fb372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a nrows x ncols submatrix starting at (i-1, j-1).  <a href="namespacestan_1_1math_a78d6a17dad1f8172090578a7cd1fb372.html#a78d6a17dad1f8172090578a7cd1fb372">More...</a><br /></td></tr>
<tr class="separator:a78d6a17dad1f8172090578a7cd1fb372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d57691e9a780ada257fb9a3573f7d9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , require_all_prim_or_rev_kernel_expression_t&lt; T_y, T_x, T_alpha, T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga44d57691e9a780ada257fb9a3573f7d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga44d57691e9a780ada257fb9a3573f7d9.html#ga44d57691e9a780ada257fb9a3573f7d9">categorical_logit_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga44d57691e9a780ada257fb9a3573f7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47eebee38b750df11f0d6d6aebefd319"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga47eebee38b750df11f0d6d6aebefd319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga47eebee38b750df11f0d6d6aebefd319.html#ga47eebee38b750df11f0d6d6aebefd319">cauchy_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga47eebee38b750df11f0d6d6aebefd319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f591b741316b1eba4a2965646029037"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6f591b741316b1eba4a2965646029037"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6f591b741316b1eba4a2965646029037.html#ga6f591b741316b1eba4a2965646029037">cauchy_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga6f591b741316b1eba4a2965646029037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ebf1445eace512163f719b3c6153127"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5ebf1445eace512163f719b3c6153127"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5ebf1445eace512163f719b3c6153127.html#ga5ebf1445eace512163f719b3c6153127">cauchy_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga5ebf1445eace512163f719b3c6153127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5bc2b295d24a0a13675f8f3465a224"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e5bc2b295d24a0a13675f8f3465a224"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5e5bc2b295d24a0a13675f8f3465a224.html#ga5e5bc2b295d24a0a13675f8f3465a224">cauchy_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga5e5bc2b295d24a0a13675f8f3465a224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c220c07244b0448c4743e1a447f27e3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4c220c07244b0448c4743e1a447f27e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga4c220c07244b0448c4743e1a447f27e3.html#ga4c220c07244b0448c4743e1a447f27e3">chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu)</td></tr>
<tr class="separator:ga4c220c07244b0448c4743e1a447f27e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee95f5f9bc1d70aaaad5cd3642d260de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aee95f5f9bc1d70aaaad5cd3642d260de.html#aee95f5f9bc1d70aaaad5cd3642d260de">cholesky_decompose</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;A)</td></tr>
<tr class="memdesc:aee95f5f9bc1d70aaaad5cd3642d260de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric matrix on the OpenCL device.  <a href="namespacestan_1_1math_aee95f5f9bc1d70aaaad5cd3642d260de.html#aee95f5f9bc1d70aaaad5cd3642d260de">More...</a><br /></td></tr>
<tr class="separator:aee95f5f9bc1d70aaaad5cd3642d260de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0576c38beac678f1164a2cfc172e941e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:ga0576c38beac678f1164a2cfc172e941e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0576c38beac678f1164a2cfc172e941e.html#ga0576c38beac678f1164a2cfc172e941e">col</a> (T_x &amp;&amp;x, size_t j)</td></tr>
<tr class="separator:ga0576c38beac678f1164a2cfc172e941e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d4c5b2fb1164cd7dddf3d303785022"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga89d4c5b2fb1164cd7dddf3d303785022"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga89d4c5b2fb1164cd7dddf3d303785022.html#ga89d4c5b2fb1164cd7dddf3d303785022">cols</a> (const T_x &amp;x)</td></tr>
<tr class="separator:ga89d4c5b2fb1164cd7dddf3d303785022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27f17ba9df72b7f71dd9df068bce800"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_and_none_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af27f17ba9df72b7f71dd9df068bce800"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af27f17ba9df72b7f71dd9df068bce800.html#af27f17ba9df72b7f71dd9df068bce800">columns_dot_product</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="memdesc:af27f17ba9df72b7f71dd9df068bce800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of columns of the specified matrices.  <a href="namespacestan_1_1math_af27f17ba9df72b7f71dd9df068bce800.html#af27f17ba9df72b7f71dd9df068bce800">More...</a><br /></td></tr>
<tr class="separator:af27f17ba9df72b7f71dd9df068bce800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691b94587823c4e693fc46da8a13e33e"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a691b94587823c4e693fc46da8a13e33e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a691b94587823c4e693fc46da8a13e33e.html#a691b94587823c4e693fc46da8a13e33e">columns_dot_self</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a691b94587823c4e693fc46da8a13e33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each column of a matrix with itself.  <a href="namespacestan_1_1math_a691b94587823c4e693fc46da8a13e33e.html#a691b94587823c4e693fc46da8a13e33e">More...</a><br /></td></tr>
<tr class="separator:a691b94587823c4e693fc46da8a13e33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afedcc43410a2d48f44e7938a399df9"><td class="memTemplParams" colspan="2">template&lt;typename T_A , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_A&gt;&gt; </td></tr>
<tr class="memitem:a5afedcc43410a2d48f44e7938a399df9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; typename std::decay_t&lt; T_A &gt;::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5afedcc43410a2d48f44e7938a399df9.html#a5afedcc43410a2d48f44e7938a399df9">crossprod</a> (T_A &amp;&amp;A)</td></tr>
<tr class="memdesc:a5afedcc43410a2d48f44e7938a399df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of pre-multiplying a matrix by its own transpose.  <a href="namespacestan_1_1math_a5afedcc43410a2d48f44e7938a399df9.html#a5afedcc43410a2d48f44e7938a399df9">More...</a><br /></td></tr>
<tr class="separator:a5afedcc43410a2d48f44e7938a399df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794e5c0e3bc4bc31ff2c71420dbac85c"><td class="memTemplParams" colspan="2">template&lt;typename T_vec , require_all_kernel_expressions_and_none_scalar_t&lt; T_vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a794e5c0e3bc4bc31ff2c71420dbac85c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a794e5c0e3bc4bc31ff2c71420dbac85c.html#a794e5c0e3bc4bc31ff2c71420dbac85c">cumulative_sum</a> (T_vec &amp;&amp;v)</td></tr>
<tr class="memdesc:a794e5c0e3bc4bc31ff2c71420dbac85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cumulative sum of the specified vector.  <a href="namespacestan_1_1math_a794e5c0e3bc4bc31ff2c71420dbac85c.html#a794e5c0e3bc4bc31ff2c71420dbac85c">More...</a><br /></td></tr>
<tr class="separator:a794e5c0e3bc4bc31ff2c71420dbac85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb676be2193f182909bf366c075344af"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_all_kernel_expressions_and_none_scalar_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afb676be2193f182909bf366c075344af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afb676be2193f182909bf366c075344af.html#afb676be2193f182909bf366c075344af">diag_matrix</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:afb676be2193f182909bf366c075344af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a square diagonal matrix with the specified vector of coefficients as the diagonal values.  <a href="namespacestan_1_1math_afb676be2193f182909bf366c075344af.html#afb676be2193f182909bf366c075344af">More...</a><br /></td></tr>
<tr class="separator:afb676be2193f182909bf366c075344af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2449099b2cf82b17e9f67d10de36ac40"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_and_none_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2449099b2cf82b17e9f67d10de36ac40"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2449099b2cf82b17e9f67d10de36ac40.html#a2449099b2cf82b17e9f67d10de36ac40">diag_post_multiply</a> (const T1 &amp;m1, const T2 &amp;m2)</td></tr>
<tr class="memdesc:a2449099b2cf82b17e9f67d10de36ac40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of a matrix and the diagonal matrix formed from the vector or row_vector.  <a href="namespacestan_1_1math_a2449099b2cf82b17e9f67d10de36ac40.html#a2449099b2cf82b17e9f67d10de36ac40">More...</a><br /></td></tr>
<tr class="separator:a2449099b2cf82b17e9f67d10de36ac40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4d31a16d3609e40c78e1a81b9b63f7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_and_none_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2f4d31a16d3609e40c78e1a81b9b63f7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f4d31a16d3609e40c78e1a81b9b63f7.html#a2f4d31a16d3609e40c78e1a81b9b63f7">diag_pre_multiply</a> (const T1 &amp;m1, const T2 &amp;m2)</td></tr>
<tr class="memdesc:a2f4d31a16d3609e40c78e1a81b9b63f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the diagonal matrix formed from the vector or row_vector and a matrix.  <a href="namespacestan_1_1math_a2f4d31a16d3609e40c78e1a81b9b63f7.html#a2f4d31a16d3609e40c78e1a81b9b63f7">More...</a><br /></td></tr>
<tr class="separator:a2f4d31a16d3609e40c78e1a81b9b63f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaff473895b1f11e364afd4c2d3cb5cab4.html#gaff473895b1f11e364afd4c2d3cb5cab4">dims</a> (const T_x &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="separator:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e6c08d7c0cccd3786a7742b135b9a52"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob_cl , typename T_prior_size_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_prob_cl, T_prior_size_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_prob_cl, T_prior_size_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2e6c08d7c0cccd3786a7742b135b9a52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl, T_prior_size_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2e6c08d7c0cccd3786a7742b135b9a52.html#ga2e6c08d7c0cccd3786a7742b135b9a52">dirichlet_lpdf</a> (const T_prob_cl &amp;theta, const T_prior_size_cl &amp;alpha)</td></tr>
<tr class="separator:ga2e6c08d7c0cccd3786a7742b135b9a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4365e541726f9e871af45878c75594d8"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4365e541726f9e871af45878c75594d8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4365e541726f9e871af45878c75594d8.html#a4365e541726f9e871af45878c75594d8">distance</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="memdesc:a4365e541726f9e871af45878c75594d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between the specified vectors.  <a href="namespacestan_1_1math_a4365e541726f9e871af45878c75594d8.html#a4365e541726f9e871af45878c75594d8">More...</a><br /></td></tr>
<tr class="separator:a4365e541726f9e871af45878c75594d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_a&gt;&gt; </td></tr>
<tr class="memitem:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7fcb23d1bea081595030aedd230f5cf9.html#ga7fcb23d1bea081595030aedd230f5cf9">divide</a> (T_a &amp;&amp;a, double d)</td></tr>
<tr class="separator:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc44cdfe2d3632d1e5481cff15fb65b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga2cc44cdfe2d3632d1e5481cff15fb65b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2cc44cdfe2d3632d1e5481cff15fb65b.html#ga2cc44cdfe2d3632d1e5481cff15fb65b">divide_columns</a> (<a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;A, const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;B)</td></tr>
<tr class="separator:ga2cc44cdfe2d3632d1e5481cff15fb65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eb269aa25fab63bb03b617210151e4a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga8eb269aa25fab63bb03b617210151e4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga8eb269aa25fab63bb03b617210151e4a.html#ga8eb269aa25fab63bb03b617210151e4a">divide_columns</a> (<a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;A, const T2 &amp;divisor)</td></tr>
<tr class="separator:ga8eb269aa25fab63bb03b617210151e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae433ef8a331544c0ab889ee7ec6e0ba6"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_and_none_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae433ef8a331544c0ab889ee7ec6e0ba6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae433ef8a331544c0ab889ee7ec6e0ba6.html#ae433ef8a331544c0ab889ee7ec6e0ba6">dot_product</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="memdesc:ae433ef8a331544c0ab889ee7ec6e0ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified vectors.  <a href="namespacestan_1_1math_ae433ef8a331544c0ab889ee7ec6e0ba6.html#ae433ef8a331544c0ab889ee7ec6e0ba6">More...</a><br /></td></tr>
<tr class="separator:ae433ef8a331544c0ab889ee7ec6e0ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37be6da87f3444ae2f7a00f6fee2983"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac37be6da87f3444ae2f7a00f6fee2983"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac37be6da87f3444ae2f7a00f6fee2983.html#ac37be6da87f3444ae2f7a00f6fee2983">dot_self</a> (const T &amp;a)</td></tr>
<tr class="memdesc:ac37be6da87f3444ae2f7a00f6fee2983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns squared norm of a vector or matrix.  <a href="namespacestan_1_1math_ac37be6da87f3444ae2f7a00f6fee2983.html#ac37be6da87f3444ae2f7a00f6fee2983">More...</a><br /></td></tr>
<tr class="separator:ac37be6da87f3444ae2f7a00f6fee2983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad684c5d3a421b9467f49e310f4de4a79"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad684c5d3a421b9467f49e310f4de4a79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gad684c5d3a421b9467f49e310f4de4a79.html#gad684c5d3a421b9467f49e310f4de4a79">double_exponential_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gad684c5d3a421b9467f49e310f4de4a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f5affb2425a19cb23eae6f34f9bc73c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3f5affb2425a19cb23eae6f34f9bc73c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3f5affb2425a19cb23eae6f34f9bc73c.html#ga3f5affb2425a19cb23eae6f34f9bc73c">double_exponential_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga3f5affb2425a19cb23eae6f34f9bc73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f8a5af1fc2ad20f7c010879c778b2e"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga88f8a5af1fc2ad20f7c010879c778b2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga88f8a5af1fc2ad20f7c010879c778b2e.html#ga88f8a5af1fc2ad20f7c010879c778b2e">double_exponential_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga88f8a5af1fc2ad20f7c010879c778b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32141185398679bb00fe1ce2ba9b66c1"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga32141185398679bb00fe1ce2ba9b66c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga32141185398679bb00fe1ce2ba9b66c1.html#ga32141185398679bb00fe1ce2ba9b66c1">double_exponential_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga32141185398679bb00fe1ce2ba9b66c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9395aef635a423cdf53a9b938f6a5069"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9395aef635a423cdf53a9b938f6a5069.html#a9395aef635a423cdf53a9b938f6a5069">eigenvalues_sym</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;m)</td></tr>
<tr class="separator:a9395aef635a423cdf53a9b938f6a5069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb48a3b6a98c6e32139492f7c2e1c266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adb48a3b6a98c6e32139492f7c2e1c266.html#adb48a3b6a98c6e32139492f7c2e1c266">eigenvectors_sym</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;m)</td></tr>
<tr class="separator:adb48a3b6a98c6e32139492f7c2e1c266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a9ac563ae060b1db31a94d691ba2ce0"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6a9ac563ae060b1db31a94d691ba2ce0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6a9ac563ae060b1db31a94d691ba2ce0.html#ga6a9ac563ae060b1db31a94d691ba2ce0">exp_mod_normal_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="separator:ga6a9ac563ae060b1db31a94d691ba2ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae195effc04066eebadd16c6e241dec57"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae195effc04066eebadd16c6e241dec57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae195effc04066eebadd16c6e241dec57.html#gae195effc04066eebadd16c6e241dec57">exp_mod_normal_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="separator:gae195effc04066eebadd16c6e241dec57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa835b5a8631edc35a37662f355d4b0d6"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa835b5a8631edc35a37662f355d4b0d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaa835b5a8631edc35a37662f355d4b0d6.html#gaa835b5a8631edc35a37662f355d4b0d6">exp_mod_normal_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="separator:gaa835b5a8631edc35a37662f355d4b0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2860333c4eb25602dc10a31f5f817fb1"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2860333c4eb25602dc10a31f5f817fb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2860333c4eb25602dc10a31f5f817fb1.html#ga2860333c4eb25602dc10a31f5f817fb1">exp_mod_normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="separator:ga2860333c4eb25602dc10a31f5f817fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa924ac4e31732ac4be2e7328d1d7bff5"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa924ac4e31732ac4be2e7328d1d7bff5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaa924ac4e31732ac4be2e7328d1d7bff5.html#gaa924ac4e31732ac4be2e7328d1d7bff5">exponential_cdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaa924ac4e31732ac4be2e7328d1d7bff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21b7eecccc6bcf97c9dce23b75ec6b62"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga21b7eecccc6bcf97c9dce23b75ec6b62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga21b7eecccc6bcf97c9dce23b75ec6b62.html#ga21b7eecccc6bcf97c9dce23b75ec6b62">exponential_lccdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga21b7eecccc6bcf97c9dce23b75ec6b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f8b7c07c493376a4d55cfe84b560221"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0f8b7c07c493376a4d55cfe84b560221"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0f8b7c07c493376a4d55cfe84b560221.html#ga0f8b7c07c493376a4d55cfe84b560221">exponential_lcdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga0f8b7c07c493376a4d55cfe84b560221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef8076d4800bf09044f6b2d3206ee8de"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaef8076d4800bf09044f6b2d3206ee8de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaef8076d4800bf09044f6b2d3206ee8de.html#gaef8076d4800bf09044f6b2d3206ee8de">exponential_lpdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaef8076d4800bf09044f6b2d3206ee8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70979bb911b646ed0c080be88bb9123e"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga70979bb911b646ed0c080be88bb9123e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga70979bb911b646ed0c080be88bb9123e.html#ga70979bb911b646ed0c080be88bb9123e">frechet_cdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga70979bb911b646ed0c080be88bb9123e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5ac156a8c64a383499955efb6be062c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae5ac156a8c64a383499955efb6be062c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae5ac156a8c64a383499955efb6be062c.html#gae5ac156a8c64a383499955efb6be062c">frechet_lccdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gae5ac156a8c64a383499955efb6be062c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b1c13dae5e208ae2b700b63d3997a45"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2b1c13dae5e208ae2b700b63d3997a45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2b1c13dae5e208ae2b700b63d3997a45.html#ga2b1c13dae5e208ae2b700b63d3997a45">frechet_lcdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga2b1c13dae5e208ae2b700b63d3997a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40919e3150ee05b80682f46cde802c22"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga40919e3150ee05b80682f46cde802c22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga40919e3150ee05b80682f46cde802c22.html#ga40919e3150ee05b80682f46cde802c22">frechet_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga40919e3150ee05b80682f46cde802c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3964605bbb452f539ad82458a1a7cc07"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3964605bbb452f539ad82458a1a7cc07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3964605bbb452f539ad82458a1a7cc07.html#ga3964605bbb452f539ad82458a1a7cc07">gamma_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga3964605bbb452f539ad82458a1a7cc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae66d06eb626b8357a5fc74289bfe42"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , require_all_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr, require_stan_scalar_t&lt; T_sigma &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7ae66d06eb626b8357a5fc74289bfe42"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7ae66d06eb626b8357a5fc74289bfe42.html#ga7ae66d06eb626b8357a5fc74289bfe42">gp_dot_prod_cov</a> (const T_x &amp;x, const T_sigma sigma)</td></tr>
<tr class="separator:ga7ae66d06eb626b8357a5fc74289bfe42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb569d6717740727352a2b67d23adfc"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_y , typename T_sigma , require_all_prim_or_rev_kernel_expression_t&lt; T_x, T_y &gt; *  = nullptr, require_stan_scalar_t&lt; T_sigma &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadfb569d6717740727352a2b67d23adfc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gadfb569d6717740727352a2b67d23adfc.html#gadfb569d6717740727352a2b67d23adfc">gp_dot_prod_cov</a> (const T_x &amp;x, const T_y &amp;y, const T_sigma sigma)</td></tr>
<tr class="separator:gadfb569d6717740727352a2b67d23adfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa686087fcae5e7016b355ceb3cf45846"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename  = require_all_arithmetic_t&lt;T1, T2, T3&gt;&gt; </td></tr>
<tr class="memitem:gaa686087fcae5e7016b355ceb3cf45846"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaa686087fcae5e7016b355ceb3cf45846.html#gaa686087fcae5e7016b355ceb3cf45846">gp_exp_quad_cov</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="separator:gaa686087fcae5e7016b355ceb3cf45846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ebc1c13865b66015a0f30739b18b28f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename  = require_all_arithmetic_t&lt;T1, T2, T3, T4&gt;&gt; </td></tr>
<tr class="memitem:ga9ebc1c13865b66015a0f30739b18b28f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9ebc1c13865b66015a0f30739b18b28f.html#ga9ebc1c13865b66015a0f30739b18b28f">gp_exp_quad_cov</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;x, const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="separator:ga9ebc1c13865b66015a0f30739b18b28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac47f7d0f97a1035236ac74de3b965020"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_kernel_expressions_and_none_scalar_t&lt; T1 &gt; *  = nullptr, require_all_arithmetic_t&lt; T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac47f7d0f97a1035236ac74de3b965020"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac47f7d0f97a1035236ac74de3b965020.html#gac47f7d0f97a1035236ac74de3b965020">gp_exponential_cov</a> (const T1 &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="separator:gac47f7d0f97a1035236ac74de3b965020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63ac2500cbe6777efe781d2738148ed4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , require_all_kernel_expressions_and_none_scalar_t&lt; T1, T2 &gt; *  = nullptr, require_all_arithmetic_t&lt; T3, T4 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga63ac2500cbe6777efe781d2738148ed4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga63ac2500cbe6777efe781d2738148ed4.html#ga63ac2500cbe6777efe781d2738148ed4">gp_exponential_cov</a> (const T1 &amp;x, const T2 &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="separator:ga63ac2500cbe6777efe781d2738148ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42d71e19927c390c7e2ca70ffe71d600"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_kernel_expressions_and_none_scalar_t&lt; T1 &gt; *  = nullptr, require_all_arithmetic_t&lt; T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga42d71e19927c390c7e2ca70ffe71d600"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga42d71e19927c390c7e2ca70ffe71d600.html#ga42d71e19927c390c7e2ca70ffe71d600">gp_matern32_cov</a> (const T1 &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="separator:ga42d71e19927c390c7e2ca70ffe71d600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85aa537a04d32939114f7dd8b75fdc5b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , require_all_kernel_expressions_and_none_scalar_t&lt; T1, T2 &gt; *  = nullptr, require_all_arithmetic_t&lt; T3, T4 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga85aa537a04d32939114f7dd8b75fdc5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga85aa537a04d32939114f7dd8b75fdc5b.html#ga85aa537a04d32939114f7dd8b75fdc5b">gp_matern32_cov</a> (const T1 &amp;x, const T2 &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="separator:ga85aa537a04d32939114f7dd8b75fdc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5e4b95241432025c0dbf5693659fda"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_kernel_expressions_and_none_scalar_t&lt; T1 &gt; *  = nullptr, require_all_arithmetic_t&lt; T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaea5e4b95241432025c0dbf5693659fda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaea5e4b95241432025c0dbf5693659fda.html#gaea5e4b95241432025c0dbf5693659fda">gp_matern52_cov</a> (const T1 &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="separator:gaea5e4b95241432025c0dbf5693659fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07fab169578cad9bff602bc9c60453a7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , require_all_kernel_expressions_and_none_scalar_t&lt; T1, T2 &gt; *  = nullptr, require_all_arithmetic_t&lt; T3, T4 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga07fab169578cad9bff602bc9c60453a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga07fab169578cad9bff602bc9c60453a7.html#ga07fab169578cad9bff602bc9c60453a7">gp_matern52_cov</a> (const T1 &amp;x, const T2 &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="separator:ga07fab169578cad9bff602bc9c60453a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b361cf5a03a7fd55cf5ab3b3d1c285d"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2b361cf5a03a7fd55cf5ab3b3d1c285d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2b361cf5a03a7fd55cf5ab3b3d1c285d.html#ga2b361cf5a03a7fd55cf5ab3b3d1c285d">gumbel_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga2b361cf5a03a7fd55cf5ab3b3d1c285d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dded1ca1056f57bf752bccda74ae6b0"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9dded1ca1056f57bf752bccda74ae6b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9dded1ca1056f57bf752bccda74ae6b0.html#ga9dded1ca1056f57bf752bccda74ae6b0">gumbel_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga9dded1ca1056f57bf752bccda74ae6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf55abc2c3182268292a063a51c87b6b"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabf55abc2c3182268292a063a51c87b6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gabf55abc2c3182268292a063a51c87b6b.html#gabf55abc2c3182268292a063a51c87b6b">gumbel_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gabf55abc2c3182268292a063a51c87b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa88407c66c8c8de7bf26c1d8eadaff84"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa88407c66c8c8de7bf26c1d8eadaff84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaa88407c66c8c8de7bf26c1d8eadaff84.html#gaa88407c66c8c8de7bf26c1d8eadaff84">gumbel_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaa88407c66c8c8de7bf26c1d8eadaff84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe637c649bea17f34938bf704ef60f0"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:abfe637c649bea17f34938bf704ef60f0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abfe637c649bea17f34938bf704ef60f0.html#abfe637c649bea17f34938bf704ef60f0">head</a> (T_x &amp;&amp;x, size_t n)</td></tr>
<tr class="memdesc:abfe637c649bea17f34938bf704ef60f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a vector or row vector (same as input) from the front of the specified vector or row vector.  <a href="namespacestan_1_1math_abfe637c649bea17f34938bf704ef60f0.html#abfe637c649bea17f34938bf704ef60f0">More...</a><br /></td></tr>
<tr class="separator:abfe637c649bea17f34938bf704ef60f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd0997e88883571dd1e2ce4211ed4c7"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_matrix_cl_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9dd0997e88883571dd1e2ce4211ed4c7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9dd0997e88883571dd1e2ce4211ed4c7.html#a9dd0997e88883571dd1e2ce4211ed4c7">identity_matrix</a> (int K)</td></tr>
<tr class="memdesc:a9dd0997e88883571dd1e2ce4211ed4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a square identity matrix.  <a href="namespacestan_1_1math_a9dd0997e88883571dd1e2ce4211ed4c7.html#a9dd0997e88883571dd1e2ce4211ed4c7">More...</a><br /></td></tr>
<tr class="separator:a9dd0997e88883571dd1e2ce4211ed4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8c2964caa6056c143f9d4f5b4a58cd"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:a4a8c2964caa6056c143f9d4f5b4a58cd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a8c2964caa6056c143f9d4f5b4a58cd.html#a4a8c2964caa6056c143f9d4f5b4a58cd">inv</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:a4a8c2964caa6056c143f9d4f5b4a58cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise 1.0 / x of the specified argument, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_a4a8c2964caa6056c143f9d4f5b4a58cd.html#a4a8c2964caa6056c143f9d4f5b4a58cd">More...</a><br /></td></tr>
<tr class="separator:a4a8c2964caa6056c143f9d4f5b4a58cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac32df5b5541df60cd45e329bf067f000"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac32df5b5541df60cd45e329bf067f000"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac32df5b5541df60cd45e329bf067f000.html#gac32df5b5541df60cd45e329bf067f000">inv_chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu)</td></tr>
<tr class="separator:gac32df5b5541df60cd45e329bf067f000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a6835ceb0371d066c976f968d9a9b3"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:a87a6835ceb0371d066c976f968d9a9b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a87a6835ceb0371d066c976f968d9a9b3.html#a87a6835ceb0371d066c976f968d9a9b3">inv_cloglog</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:a87a6835ceb0371d066c976f968d9a9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse complementary log-log function.  <a href="namespacestan_1_1math_a87a6835ceb0371d066c976f968d9a9b3.html#a87a6835ceb0371d066c976f968d9a9b3">More...</a><br /></td></tr>
<tr class="separator:a87a6835ceb0371d066c976f968d9a9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0332105689b4e9992e99166c4f3e12"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7e0332105689b4e9992e99166c4f3e12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7e0332105689b4e9992e99166c4f3e12.html#ga7e0332105689b4e9992e99166c4f3e12">inv_gamma_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga7e0332105689b4e9992e99166c4f3e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16f311fb7acec6ddd7b910545ad2b2d"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:af16f311fb7acec6ddd7b910545ad2b2d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af16f311fb7acec6ddd7b910545ad2b2d.html#af16f311fb7acec6ddd7b910545ad2b2d">inv_sqrt</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:af16f311fb7acec6ddd7b910545ad2b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise <code>1 / sqrt(x)</code> of the specified kernel generator expression.  <a href="namespacestan_1_1math_af16f311fb7acec6ddd7b910545ad2b2d.html#af16f311fb7acec6ddd7b910545ad2b2d">More...</a><br /></td></tr>
<tr class="separator:af16f311fb7acec6ddd7b910545ad2b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef2d29ab9580b97017968d1d6f7fa8d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr, require_all_kernel_expressions_t&lt; L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaef2d29ab9580b97017968d1d6f7fa8d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaef2d29ab9580b97017968d1d6f7fa8d.html#aaef2d29ab9580b97017968d1d6f7fa8d">lb_constrain</a> (T &amp;&amp;x, L &amp;&amp;lb)</td></tr>
<tr class="memdesc:aaef2d29ab9580b97017968d1d6f7fa8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-bounded value for the specified unconstrained input and specified lower bound.  <a href="namespacestan_1_1math_aaef2d29ab9580b97017968d1d6f7fa8d.html#aaef2d29ab9580b97017968d1d6f7fa8d">More...</a><br /></td></tr>
<tr class="separator:aaef2d29ab9580b97017968d1d6f7fa8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af087a399bed41edf6d77ab35ddca4d0a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr, require_all_kernel_expressions_t&lt; L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af087a399bed41edf6d77ab35ddca4d0a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af087a399bed41edf6d77ab35ddca4d0a.html#af087a399bed41edf6d77ab35ddca4d0a">lb_constrain</a> (const T &amp;x, const L &amp;lb, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L &gt; &amp;lp)</td></tr>
<tr class="memdesc:af087a399bed41edf6d77ab35ddca4d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-bounded value for the specified unconstrained input and specified lower bound.  <a href="namespacestan_1_1math_af087a399bed41edf6d77ab35ddca4d0a.html#af087a399bed41edf6d77ab35ddca4d0a">More...</a><br /></td></tr>
<tr class="separator:af087a399bed41edf6d77ab35ddca4d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7802f2b80410744fd64711a697f944"><td class="memTemplParams" colspan="2">template&lt;typename T_theta_cl , typename T_lambda_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_theta_cl, T_lambda_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ade7802f2b80410744fd64711a697f944"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade7802f2b80410744fd64711a697f944.html#ade7802f2b80410744fd64711a697f944">log_mix</a> (const T_theta_cl &amp;theta, const T_lambda_cl &amp;lambda)</td></tr>
<tr class="memdesc:ade7802f2b80410744fd64711a697f944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log mixture density with specified mixing proportions and log densities.  <a href="namespacestan_1_1math_ade7802f2b80410744fd64711a697f944.html#ade7802f2b80410744fd64711a697f944">More...</a><br /></td></tr>
<tr class="separator:ade7802f2b80410744fd64711a697f944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d64f5d2d1346e103aaec385cdd8fd01"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1d64f5d2d1346e103aaec385cdd8fd01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1d64f5d2d1346e103aaec385cdd8fd01.html#a1d64f5d2d1346e103aaec385cdd8fd01">log_softmax</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a1d64f5d2d1346e103aaec385cdd8fd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return log of the softmax of the specified vector.  <a href="namespacestan_1_1math_a1d64f5d2d1346e103aaec385cdd8fd01.html#a1d64f5d2d1346e103aaec385cdd8fd01">More...</a><br /></td></tr>
<tr class="separator:a1d64f5d2d1346e103aaec385cdd8fd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b30449ff23e5fedb01ec972d06e9e89"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8b30449ff23e5fedb01ec972d06e9e89"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8b30449ff23e5fedb01ec972d06e9e89.html#a8b30449ff23e5fedb01ec972d06e9e89">log_sum_exp</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a8b30449ff23e5fedb01ec972d06e9e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the sum of the exponentiated values of the specified matrix of values.  <a href="namespacestan_1_1math_a8b30449ff23e5fedb01ec972d06e9e89.html#a8b30449ff23e5fedb01ec972d06e9e89">More...</a><br /></td></tr>
<tr class="separator:a8b30449ff23e5fedb01ec972d06e9e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae089d318dec46d3eecab353ccedd07ab"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae089d318dec46d3eecab353ccedd07ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae089d318dec46d3eecab353ccedd07ab.html#gae089d318dec46d3eecab353ccedd07ab">logistic_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gae089d318dec46d3eecab353ccedd07ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e1cb21d2e8927cf2458ea675ec832c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga11e1cb21d2e8927cf2458ea675ec832c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga11e1cb21d2e8927cf2458ea675ec832c.html#ga11e1cb21d2e8927cf2458ea675ec832c">logistic_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga11e1cb21d2e8927cf2458ea675ec832c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga790f7ff43cded1271978779ae5bc5f8b"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga790f7ff43cded1271978779ae5bc5f8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga790f7ff43cded1271978779ae5bc5f8b.html#ga790f7ff43cded1271978779ae5bc5f8b">logistic_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga790f7ff43cded1271978779ae5bc5f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aa767c6b4a5636db46932992cae075b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9aa767c6b4a5636db46932992cae075b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9aa767c6b4a5636db46932992cae075b.html#ga9aa767c6b4a5636db46932992cae075b">logistic_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga9aa767c6b4a5636db46932992cae075b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69167b3ae3de102c803fa7b227e9d11f"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga69167b3ae3de102c803fa7b227e9d11f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga69167b3ae3de102c803fa7b227e9d11f.html#ga69167b3ae3de102c803fa7b227e9d11f">lognormal_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga69167b3ae3de102c803fa7b227e9d11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2383f947a55d9b0ef8104fc6c84a83ad"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2383f947a55d9b0ef8104fc6c84a83ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2383f947a55d9b0ef8104fc6c84a83ad.html#ga2383f947a55d9b0ef8104fc6c84a83ad">lognormal_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga2383f947a55d9b0ef8104fc6c84a83ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9495fcb0a2a223bbf0219e7805bbc487"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9495fcb0a2a223bbf0219e7805bbc487"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9495fcb0a2a223bbf0219e7805bbc487.html#ga9495fcb0a2a223bbf0219e7805bbc487">lognormal_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga9495fcb0a2a223bbf0219e7805bbc487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae14854b2ed4e8eed637cdeb8f8d15dbb"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae14854b2ed4e8eed637cdeb8f8d15dbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae14854b2ed4e8eed637cdeb8f8d15dbb.html#gae14854b2ed4e8eed637cdeb8f8d15dbb">lognormal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gae14854b2ed4e8eed637cdeb8f8d15dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185af85cbddb9968a661beff04bec7d2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr, require_all_kernel_expressions_t&lt; L, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a185af85cbddb9968a661beff04bec7d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a185af85cbddb9968a661beff04bec7d2.html#a185af85cbddb9968a661beff04bec7d2">lub_constrain</a> (const T &amp;x, const L &amp;lb, const U &amp;ub)</td></tr>
<tr class="memdesc:a185af85cbddb9968a661beff04bec7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower and upper-bounded matrix derived by transforming the specified free matrix given the specified lower and upper bounds.  <a href="namespacestan_1_1math_a185af85cbddb9968a661beff04bec7d2.html#a185af85cbddb9968a661beff04bec7d2">More...</a><br /></td></tr>
<tr class="separator:a185af85cbddb9968a661beff04bec7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018d8d8c78c73dd618e9a54e14874fd8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr, require_all_kernel_expressions_t&lt; L, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a018d8d8c78c73dd618e9a54e14874fd8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a018d8d8c78c73dd618e9a54e14874fd8.html#a018d8d8c78c73dd618e9a54e14874fd8">lub_constrain</a> (const T &amp;x, const L &amp;lb, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:a018d8d8c78c73dd618e9a54e14874fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower and upper-bounded matrix derived by transforming the specified free matrix given the specified lower and upper bounds.  <a href="namespacestan_1_1math_a018d8d8c78c73dd618e9a54e14874fd8.html#a018d8d8c78c73dd618e9a54e14874fd8">More...</a><br /></td></tr>
<tr class="separator:a018d8d8c78c73dd618e9a54e14874fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79436f8487300a268791503d481f0610"><td class="memTemplParams" colspan="2">template&lt;typename T_m , require_all_kernel_expressions_and_none_scalar_t&lt; T_m &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a79436f8487300a268791503d481f0610"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T_m &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a79436f8487300a268791503d481f0610.html#a79436f8487300a268791503d481f0610">matrix_power</a> (T_m &amp;&amp;M, const int n)</td></tr>
<tr class="memdesc:a79436f8487300a268791503d481f0610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth power of the specific matrix.  <a href="namespacestan_1_1math_a79436f8487300a268791503d481f0610.html#a79436f8487300a268791503d481f0610">More...</a><br /></td></tr>
<tr class="separator:a79436f8487300a268791503d481f0610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8af28e545f25c1abe37f8661523be11"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae8af28e545f25c1abe37f8661523be11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae8af28e545f25c1abe37f8661523be11.html#ae8af28e545f25c1abe37f8661523be11">mdivide_left_tri_low</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="memdesc:ae8af28e545f25c1abe37f8661523be11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is lower triangular.  <a href="namespacestan_1_1math_ae8af28e545f25c1abe37f8661523be11.html#ae8af28e545f25c1abe37f8661523be11">More...</a><br /></td></tr>
<tr class="separator:ae8af28e545f25c1abe37f8661523be11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c826435f034e08456ea633fe5bce7f"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a57c826435f034e08456ea633fe5bce7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a57c826435f034e08456ea633fe5bce7f.html#a57c826435f034e08456ea633fe5bce7f">mdivide_left_tri_low</a> (const T &amp;A)</td></tr>
<tr class="memdesc:a57c826435f034e08456ea633fe5bce7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is triangular and b=I.  <a href="namespacestan_1_1math_a57c826435f034e08456ea633fe5bce7f.html#a57c826435f034e08456ea633fe5bce7f">More...</a><br /></td></tr>
<tr class="separator:a57c826435f034e08456ea633fe5bce7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2acc51b685bdc3fe5c09b25f9986da"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_kernel_expressions_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adc2acc51b685bdc3fe5c09b25f9986da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adc2acc51b685bdc3fe5c09b25f9986da.html#adc2acc51b685bdc3fe5c09b25f9986da">mdivide_right_tri_low</a> (const T2 &amp;b, const T1 &amp;A)</td></tr>
<tr class="memdesc:adc2acc51b685bdc3fe5c09b25f9986da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b where A is a lower triangular matrix.  <a href="namespacestan_1_1math_adc2acc51b685bdc3fe5c09b25f9986da.html#adc2acc51b685bdc3fe5c09b25f9986da">More...</a><br /></td></tr>
<tr class="separator:adc2acc51b685bdc3fe5c09b25f9986da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac003e128417e908dcb8304fc0efc78c0"><td class="memTemplParams" colspan="2">template&lt;typename T , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac003e128417e908dcb8304fc0efc78c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac003e128417e908dcb8304fc0efc78c0.html#ac003e128417e908dcb8304fc0efc78c0">mean</a> (const T &amp;m)</td></tr>
<tr class="memdesc:ac003e128417e908dcb8304fc0efc78c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample mean (i.e., average) of the coefficients in the specified std vector, vector, row vector, or matrix.  <a href="namespacestan_1_1math_ac003e128417e908dcb8304fc0efc78c0.html#ac003e128417e908dcb8304fc0efc78c0">More...</a><br /></td></tr>
<tr class="separator:ac003e128417e908dcb8304fc0efc78c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dbda02859731a08444a98d74777f846"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_covar_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_covar_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3dbda02859731a08444a98d74777f846"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_covar_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3dbda02859731a08444a98d74777f846.html#ga3dbda02859731a08444a98d74777f846">multi_normal_cholesky_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_covar_cl &amp;L)</td></tr>
<tr class="separator:ga3dbda02859731a08444a98d74777f846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed19f70ae3520d9ef8c982dace013e8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga6ed19f70ae3520d9ef8c982dace013e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6ed19f70ae3520d9ef8c982dace013e8.html#ga6ed19f70ae3520d9ef8c982dace013e8">multiply</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="separator:ga6ed19f70ae3520d9ef8c982dace013e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e622447be0f346c8c47e0542640572"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_a, T_b&gt;&gt; </td></tr>
<tr class="memitem:a10e622447be0f346c8c47e0542640572"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_a, T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a10e622447be0f346c8c47e0542640572.html#a10e622447be0f346c8c47e0542640572">operator*</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="memdesc:a10e622447be0f346c8c47e0542640572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiplication of two kernel generator expressions.  <a href="namespacestan_1_1math_a10e622447be0f346c8c47e0542640572.html#a10e622447be0f346c8c47e0542640572">More...</a><br /></td></tr>
<tr class="separator:a10e622447be0f346c8c47e0542640572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c648981200e8dc2bde05ceb3486a2e"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_stan_scalar_t&lt; T_a &gt; *  = nullptr, require_all_kernel_expressions_and_none_scalar_t&lt; T_b &gt; *  = nullptr, require_all_not_var_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a03c648981200e8dc2bde05ceb3486a2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_a, T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a03c648981200e8dc2bde05ceb3486a2e.html#a03c648981200e8dc2bde05ceb3486a2e">multiply</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="memdesc:a03c648981200e8dc2bde05ceb3486a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiplication of a scalar and a kernel generator expressions.  <a href="namespacestan_1_1math_a03c648981200e8dc2bde05ceb3486a2e.html#a03c648981200e8dc2bde05ceb3486a2e">More...</a><br /></td></tr>
<tr class="separator:a03c648981200e8dc2bde05ceb3486a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdeb05a3864eec83b057c15c5343ad6c"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_all_kernel_expressions_and_none_scalar_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abdeb05a3864eec83b057c15c5343ad6c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abdeb05a3864eec83b057c15c5343ad6c.html#abdeb05a3864eec83b057c15c5343ad6c">multiply_lower_tri_self_transpose</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:abdeb05a3864eec83b057c15c5343ad6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of multiplying the lower triangular portion of the input matrix by its own transpose.  <a href="namespacestan_1_1math_abdeb05a3864eec83b057c15c5343ad6c.html#abdeb05a3864eec83b057c15c5343ad6c">More...</a><br /></td></tr>
<tr class="separator:abdeb05a3864eec83b057c15c5343ad6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb16f794da8d9e6341f2543fbab56237"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , typename T_phi_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_x_cl, T_y_cl, T_alpha_cl, T_beta_cl, T_phi_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacb16f794da8d9e6341f2543fbab56237"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x_cl, T_alpha_cl, T_beta_cl, T_phi_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gacb16f794da8d9e6341f2543fbab56237.html#gacb16f794da8d9e6341f2543fbab56237">neg_binomial_2_log_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_phi_cl &amp;phi)</td></tr>
<tr class="separator:gacb16f794da8d9e6341f2543fbab56237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c1c0e8c6edb035b297e73193f8cd820"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_log_location_cl , typename T_precision_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7c1c0e8c6edb035b297e73193f8cd820"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7c1c0e8c6edb035b297e73193f8cd820.html#ga7c1c0e8c6edb035b297e73193f8cd820">neg_binomial_2_log_lpmf</a> (const T_n_cl &amp;n, const T_log_location_cl &amp;eta, const T_precision_cl &amp;phi)</td></tr>
<tr class="separator:ga7c1c0e8c6edb035b297e73193f8cd820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f3956bcf1b6e3aac673b7b89f2f9b4d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_location_cl , typename T_precision_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_location_cl, T_precision_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_location_cl, T_precision_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0f3956bcf1b6e3aac673b7b89f2f9b4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_location_cl, T_precision_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0f3956bcf1b6e3aac673b7b89f2f9b4d.html#ga0f3956bcf1b6e3aac673b7b89f2f9b4d">neg_binomial_2_lpmf</a> (const T_n_cl &amp;n, const T_location_cl &amp;mu, const T_precision_cl &amp;phi)</td></tr>
<tr class="separator:ga0f3956bcf1b6e3aac673b7b89f2f9b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacb77966b5ca780cac193dfeb6e7dc7f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_shape_cl , typename T_inv_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaacb77966b5ca780cac193dfeb6e7dc7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaacb77966b5ca780cac193dfeb6e7dc7f.html#gaacb77966b5ca780cac193dfeb6e7dc7f">neg_binomial_lpmf</a> (const T_n_cl &amp;n, const T_shape_cl &amp;alpha, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaacb77966b5ca780cac193dfeb6e7dc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5778a9ae4790a5fe723a4d963f721df0"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5778a9ae4790a5fe723a4d963f721df0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5778a9ae4790a5fe723a4d963f721df0.html#ga5778a9ae4790a5fe723a4d963f721df0">normal_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga5778a9ae4790a5fe723a4d963f721df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c799735f974356f8d1ab7743960a65"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , typename T_sigma_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_x_cl, T_y_cl, T_alpha_cl, T_beta_cl, T_sigma_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf3c799735f974356f8d1ab7743960a65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl, T_sigma_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaf3c799735f974356f8d1ab7743960a65.html#gaf3c799735f974356f8d1ab7743960a65">normal_id_glm_lpdf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_sigma_cl &amp;sigma)</td></tr>
<tr class="separator:gaf3c799735f974356f8d1ab7743960a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ffb7c87522de6e24c7c95fa71b2e116"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4ffb7c87522de6e24c7c95fa71b2e116"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga4ffb7c87522de6e24c7c95fa71b2e116.html#ga4ffb7c87522de6e24c7c95fa71b2e116">normal_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga4ffb7c87522de6e24c7c95fa71b2e116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7b2d28bf1c40f0f9ec609d73f1011b2"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa7b2d28bf1c40f0f9ec609d73f1011b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaa7b2d28bf1c40f0f9ec609d73f1011b2.html#gaa7b2d28bf1c40f0f9ec609d73f1011b2">normal_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gaa7b2d28bf1c40f0f9ec609d73f1011b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab98a15165135ddb986e4f74cb66817ba"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab98a15165135ddb986e4f74cb66817ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gab98a15165135ddb986e4f74cb66817ba.html#gab98a15165135ddb986e4f74cb66817ba">normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gab98a15165135ddb986e4f74cb66817ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceaaf4e676449ddf7639d7ae626c8f38"><td class="memTemplParams" colspan="2">template&lt;typename T , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aceaaf4e676449ddf7639d7ae626c8f38"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aceaaf4e676449ddf7639d7ae626c8f38.html#aceaaf4e676449ddf7639d7ae626c8f38">num_elements</a> (const T &amp;m)</td></tr>
<tr class="memdesc:aceaaf4e676449ddf7639d7ae626c8f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of the elements of a <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> or <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;<a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;T&gt;&gt;</code>.  <a href="namespacestan_1_1math_aceaaf4e676449ddf7639d7ae626c8f38.html#aceaaf4e676449ddf7639d7ae626c8f38">More...</a><br /></td></tr>
<tr class="separator:aceaaf4e676449ddf7639d7ae626c8f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a19c333f7166115c84c8e572024190"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , require_all_kernel_expressions_t&lt; T, M, S &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T, M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a84a19c333f7166115c84c8e572024190"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a84a19c333f7166115c84c8e572024190.html#a84a19c333f7166115c84c8e572024190">offset_multiplier_constrain</a> (const T &amp;x, const M &amp;mu, const S &amp;sigma)</td></tr>
<tr class="memdesc:a84a19c333f7166115c84c8e572024190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearly transformed value for the specified unconstrained input and specified offset and multiplier.  <a href="namespacestan_1_1math_a84a19c333f7166115c84c8e572024190.html#a84a19c333f7166115c84c8e572024190">More...</a><br /></td></tr>
<tr class="separator:a84a19c333f7166115c84c8e572024190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ce36845aba7dd406c468cadd1bf4c8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , require_all_kernel_expressions_t&lt; T, M, S &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T, M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae0ce36845aba7dd406c468cadd1bf4c8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae0ce36845aba7dd406c468cadd1bf4c8.html#ae0ce36845aba7dd406c468cadd1bf4c8">offset_multiplier_constrain</a> (const T &amp;x, const M &amp;mu, const S &amp;sigma, double &amp;lp)</td></tr>
<tr class="memdesc:ae0ce36845aba7dd406c468cadd1bf4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearly transformed value for the specified unconstrained input and specified offset and multiplier.  <a href="namespacestan_1_1math_ae0ce36845aba7dd406c468cadd1bf4c8.html#ae0ce36845aba7dd406c468cadd1bf4c8">More...</a><br /></td></tr>
<tr class="separator:ae0ce36845aba7dd406c468cadd1bf4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga363eead878eb45fb01517e94ac7d4f4b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_beta , typename T_cuts , require_all_prim_or_rev_kernel_expression_t&lt; T_y, T_x, T_beta, T_cuts &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga363eead878eb45fb01517e94ac7d4f4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_beta, T_cuts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga363eead878eb45fb01517e94ac7d4f4b.html#ga363eead878eb45fb01517e94ac7d4f4b">ordered_logistic_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_cuts &amp;cuts)</td></tr>
<tr class="separator:ga363eead878eb45fb01517e94ac7d4f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2fa71e9871a9b2f6f720de72177c1f3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_cuts_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_cuts_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa2fa71e9871a9b2f6f720de72177c1f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_cuts_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaa2fa71e9871a9b2f6f720de72177c1f3.html#gaa2fa71e9871a9b2f6f720de72177c1f3">ordered_logistic_lpmf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;lambda, const T_cuts_cl &amp;cuts)</td></tr>
<tr class="separator:gaa2fa71e9871a9b2f6f720de72177c1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99ac10a703e5d01d02700b4effea8d05"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga99ac10a703e5d01d02700b4effea8d05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga99ac10a703e5d01d02700b4effea8d05.html#ga99ac10a703e5d01d02700b4effea8d05">pareto_cdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:ga99ac10a703e5d01d02700b4effea8d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4792e29b438cf1e3a244d26734ec5c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaab4792e29b438cf1e3a244d26734ec5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaab4792e29b438cf1e3a244d26734ec5c.html#gaab4792e29b438cf1e3a244d26734ec5c">pareto_lccdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:gaab4792e29b438cf1e3a244d26734ec5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab314951f2c8314308e593e4c23b8d601"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab314951f2c8314308e593e4c23b8d601"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gab314951f2c8314308e593e4c23b8d601.html#gab314951f2c8314308e593e4c23b8d601">pareto_lcdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:gab314951f2c8314308e593e4c23b8d601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b5e8eec1c27b30ea994f94070adc148"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7b5e8eec1c27b30ea994f94070adc148"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7b5e8eec1c27b30ea994f94070adc148.html#ga7b5e8eec1c27b30ea994f94070adc148">pareto_lpdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:ga7b5e8eec1c27b30ea994f94070adc148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17f33022936713376f9d3e19daaf9430"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga17f33022936713376f9d3e19daaf9430"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga17f33022936713376f9d3e19daaf9430.html#ga17f33022936713376f9d3e19daaf9430">pareto_type_2_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:ga17f33022936713376f9d3e19daaf9430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d34272be0ff43f1e882232ac4af9c0"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga72d34272be0ff43f1e882232ac4af9c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga72d34272be0ff43f1e882232ac4af9c0.html#ga72d34272be0ff43f1e882232ac4af9c0">pareto_type_2_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:ga72d34272be0ff43f1e882232ac4af9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac04043a4074079cda307e5bc219cb4be"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac04043a4074079cda307e5bc219cb4be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac04043a4074079cda307e5bc219cb4be.html#gac04043a4074079cda307e5bc219cb4be">pareto_type_2_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:gac04043a4074079cda307e5bc219cb4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a333811247fce0ea707ce959dffa38"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga83a333811247fce0ea707ce959dffa38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga83a333811247fce0ea707ce959dffa38.html#ga83a333811247fce0ea707ce959dffa38">pareto_type_2_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:ga83a333811247fce0ea707ce959dffa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd6c49794202989a029ff70567f55479"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacd6c49794202989a029ff70567f55479"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x_cl, T_alpha_cl, T_beta_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gacd6c49794202989a029ff70567f55479.html#gacd6c49794202989a029ff70567f55479">poisson_log_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gacd6c49794202989a029ff70567f55479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b1dba179f6258a2e07a30bdbe97255a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_log_rate_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_log_rate_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_log_rate_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5b1dba179f6258a2e07a30bdbe97255a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_log_rate_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5b1dba179f6258a2e07a30bdbe97255a.html#ga5b1dba179f6258a2e07a30bdbe97255a">poisson_log_lpmf</a> (const T_n_cl &amp;n, const T_log_rate_cl &amp;alpha)</td></tr>
<tr class="separator:ga5b1dba179f6258a2e07a30bdbe97255a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfdbbaacbab1d90d71290edc806bace3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_rate_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_n_cl, T_rate_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_n_cl, T_rate_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabfdbbaacbab1d90d71290edc806bace3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gabfdbbaacbab1d90d71290edc806bace3.html#gabfdbbaacbab1d90d71290edc806bace3">poisson_lpmf</a> (const T_n_cl &amp;n, const T_rate_cl &amp;lambda)</td></tr>
<tr class="separator:gabfdbbaacbab1d90d71290edc806bace3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406e4c17e77ece0ecafba9f33ccecbf1"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a406e4c17e77ece0ecafba9f33ccecbf1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a406e4c17e77ece0ecafba9f33ccecbf1.html#a406e4c17e77ece0ecafba9f33ccecbf1">prod</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a406e4c17e77ece0ecafba9f33ccecbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates product of given kernel generator expression elements.  <a href="namespacestan_1_1math_a406e4c17e77ece0ecafba9f33ccecbf1.html#a406e4c17e77ece0ecafba9f33ccecbf1">More...</a><br /></td></tr>
<tr class="separator:a406e4c17e77ece0ecafba9f33ccecbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59156cdbed17be14f15094029f83763b"><td class="memTemplParams" colspan="2">template&lt;typename T_m , require_all_kernel_expressions_and_none_scalar_t&lt; T_m &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a59156cdbed17be14f15094029f83763b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a59156cdbed17be14f15094029f83763b.html#a59156cdbed17be14f15094029f83763b">qr_Q</a> (T_m &amp;&amp;m)</td></tr>
<tr class="memdesc:a59156cdbed17be14f15094029f83763b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orthogonal factor of the fat QR decomposition.  <a href="namespacestan_1_1math_a59156cdbed17be14f15094029f83763b.html#a59156cdbed17be14f15094029f83763b">More...</a><br /></td></tr>
<tr class="separator:a59156cdbed17be14f15094029f83763b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd79ecfc80808107403f665dc0b28add"><td class="memTemplParams" colspan="2">template&lt;typename T_m , require_all_kernel_expressions_and_none_scalar_t&lt; T_m &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abd79ecfc80808107403f665dc0b28add"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abd79ecfc80808107403f665dc0b28add.html#abd79ecfc80808107403f665dc0b28add">qr_R</a> (T_m &amp;&amp;m)</td></tr>
<tr class="memdesc:abd79ecfc80808107403f665dc0b28add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orthogonal factor of the fat QR decomposition.  <a href="namespacestan_1_1math_abd79ecfc80808107403f665dc0b28add.html#abd79ecfc80808107403f665dc0b28add">More...</a><br /></td></tr>
<tr class="separator:abd79ecfc80808107403f665dc0b28add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b942cf03ccf700e8f0ec48ee30bf81"><td class="memTemplParams" colspan="2">template&lt;typename T_m , require_all_kernel_expressions_and_none_scalar_t&lt; T_m &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab0b942cf03ccf700e8f0ec48ee30bf81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab0b942cf03ccf700e8f0ec48ee30bf81.html#ab0b942cf03ccf700e8f0ec48ee30bf81">qr_thin_Q</a> (T_m &amp;&amp;m)</td></tr>
<tr class="memdesc:ab0b942cf03ccf700e8f0ec48ee30bf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orthogonal factor of the fat QR decomposition.  <a href="namespacestan_1_1math_ab0b942cf03ccf700e8f0ec48ee30bf81.html#ab0b942cf03ccf700e8f0ec48ee30bf81">More...</a><br /></td></tr>
<tr class="separator:ab0b942cf03ccf700e8f0ec48ee30bf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3945653cb3c8246552a23b74a32e922a"><td class="memTemplParams" colspan="2">template&lt;typename T_m , require_all_kernel_expressions_and_none_scalar_t&lt; T_m &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3945653cb3c8246552a23b74a32e922a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3945653cb3c8246552a23b74a32e922a.html#a3945653cb3c8246552a23b74a32e922a">qr_thin_R</a> (T_m &amp;&amp;m)</td></tr>
<tr class="memdesc:a3945653cb3c8246552a23b74a32e922a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orthogonal factor of the thin QR decomposition.  <a href="namespacestan_1_1math_a3945653cb3c8246552a23b74a32e922a.html#a3945653cb3c8246552a23b74a32e922a">More...</a><br /></td></tr>
<tr class="separator:a3945653cb3c8246552a23b74a32e922a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a266242d0e44eb92a734faaa8a291fd"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4a266242d0e44eb92a734faaa8a291fd"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a266242d0e44eb92a734faaa8a291fd.html#a4a266242d0e44eb92a734faaa8a291fd">rank</a> (const T &amp;v, int s)</td></tr>
<tr class="memdesc:a4a266242d0e44eb92a734faaa8a291fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of components of v less than v[s].  <a href="namespacestan_1_1math_a4a266242d0e44eb92a734faaa8a291fd.html#a4a266242d0e44eb92a734faaa8a291fd">More...</a><br /></td></tr>
<tr class="separator:a4a266242d0e44eb92a734faaa8a291fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab91408855ed53a17cd6f385acb2f43fc"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab91408855ed53a17cd6f385acb2f43fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gab91408855ed53a17cd6f385acb2f43fc.html#gab91408855ed53a17cd6f385acb2f43fc">rayleigh_cdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:gab91408855ed53a17cd6f385acb2f43fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26d27cf0c3966c101f0ea1c271f560d1"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga26d27cf0c3966c101f0ea1c271f560d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga26d27cf0c3966c101f0ea1c271f560d1.html#ga26d27cf0c3966c101f0ea1c271f560d1">rayleigh_lccdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga26d27cf0c3966c101f0ea1c271f560d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b4eb053f40231980929911c9cb2f7b7"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1b4eb053f40231980929911c9cb2f7b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga1b4eb053f40231980929911c9cb2f7b7.html#ga1b4eb053f40231980929911c9cb2f7b7">rayleigh_lcdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga1b4eb053f40231980929911c9cb2f7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga601d163c824e05147660da53e4099bd9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga601d163c824e05147660da53e4099bd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga601d163c824e05147660da53e4099bd9.html#ga601d163c824e05147660da53e4099bd9">rayleigh_lpdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga601d163c824e05147660da53e4099bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bbe5a508d5789497afc2cbd03f8004c"><td class="memTemplParams" colspan="2">template&lt;typename T , require_any_t&lt; is_matrix_cl&lt; T &gt;, math::conjunction&lt; is_var&lt; T &gt;, is_matrix_cl&lt; value_type_t&lt; T &gt;&gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3bbe5a508d5789497afc2cbd03f8004c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3bbe5a508d5789497afc2cbd03f8004c.html#ga3bbe5a508d5789497afc2cbd03f8004c">rep_array</a> (const <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="separator:ga3bbe5a508d5789497afc2cbd03f8004c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e2c7f71203a6ba2b93d5372ed6cf01e"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e2c7f71203a6ba2b93d5372ed6cf01e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5e2c7f71203a6ba2b93d5372ed6cf01e.html#ga5e2c7f71203a6ba2b93d5372ed6cf01e">rep_matrix</a> (const <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &amp;x, int n, int m)</td></tr>
<tr class="separator:ga5e2c7f71203a6ba2b93d5372ed6cf01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f19ec991d6f0ed60695ef33003868d"><td class="memTemplParams" colspan="2">template&lt;typename T , require_arithmetic_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga78f19ec991d6f0ed60695ef33003868d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga78f19ec991d6f0ed60695ef33003868d.html#ga78f19ec991d6f0ed60695ef33003868d">rep_matrix</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;x, int m)</td></tr>
<tr class="separator:ga78f19ec991d6f0ed60695ef33003868d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbac6d303d27c8ee22511862dce6c565"><td class="memTemplParams" colspan="2">template&lt;typename T , require_any_t&lt; is_matrix_cl&lt; T &gt;, math::conjunction&lt; is_var&lt; T &gt;, is_matrix_cl&lt; value_type_t&lt; T &gt;&gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabbac6d303d27c8ee22511862dce6c565"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gabbac6d303d27c8ee22511862dce6c565.html#gabbac6d303d27c8ee22511862dce6c565">rep_row_vector</a> (const <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="separator:gabbac6d303d27c8ee22511862dce6c565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd9fbe441671cf2a2f88cd3e8d9b8ca8"><td class="memTemplParams" colspan="2">template&lt;typename T , require_any_t&lt; is_matrix_cl&lt; T &gt;, math::conjunction&lt; is_var&lt; T &gt;, is_matrix_cl&lt; value_type_t&lt; T &gt;&gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabd9fbe441671cf2a2f88cd3e8d9b8ca8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gabd9fbe441671cf2a2f88cd3e8d9b8ca8.html#gabd9fbe441671cf2a2f88cd3e8d9b8ca8">rep_vector</a> (const <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="separator:gabd9fbe441671cf2a2f88cd3e8d9b8ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab410d6bac0f13c2db48a05491f17e47c"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_all_kernel_expressions_and_none_scalar_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab410d6bac0f13c2db48a05491f17e47c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab410d6bac0f13c2db48a05491f17e47c.html#ab410d6bac0f13c2db48a05491f17e47c">reverse</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:ab410d6bac0f13c2db48a05491f17e47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reversed view into the specified vector or row vector.  <a href="namespacestan_1_1math_ab410d6bac0f13c2db48a05491f17e47c.html#ab410d6bac0f13c2db48a05491f17e47c">More...</a><br /></td></tr>
<tr class="separator:ab410d6bac0f13c2db48a05491f17e47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80392ae5670adea53e79770aa29c816a"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:ga80392ae5670adea53e79770aa29c816a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga80392ae5670adea53e79770aa29c816a.html#ga80392ae5670adea53e79770aa29c816a">row</a> (T_x &amp;&amp;x, size_t j)</td></tr>
<tr class="separator:ga80392ae5670adea53e79770aa29c816a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61254f29c1520f4bffe4ab4e5bbd0e0e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga61254f29c1520f4bffe4ab4e5bbd0e0e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga61254f29c1520f4bffe4ab4e5bbd0e0e.html#ga61254f29c1520f4bffe4ab4e5bbd0e0e">rows</a> (const T_x &amp;x)</td></tr>
<tr class="separator:ga61254f29c1520f4bffe4ab4e5bbd0e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505bfc1d8164c6ab561fe30088869296"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_and_none_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a505bfc1d8164c6ab561fe30088869296"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a505bfc1d8164c6ab561fe30088869296.html#a505bfc1d8164c6ab561fe30088869296">rows_dot_product</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a505bfc1d8164c6ab561fe30088869296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of rows of the specified matrices.  <a href="namespacestan_1_1math_a505bfc1d8164c6ab561fe30088869296.html#a505bfc1d8164c6ab561fe30088869296">More...</a><br /></td></tr>
<tr class="separator:a505bfc1d8164c6ab561fe30088869296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fa659f7ee2c514a95d79d5f22c337c"><td class="memTemplParams" colspan="2">template&lt;typename T_a , require_all_kernel_expressions_and_none_scalar_t&lt; T_a &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a24fa659f7ee2c514a95d79d5f22c337c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a24fa659f7ee2c514a95d79d5f22c337c.html#a24fa659f7ee2c514a95d79d5f22c337c">rows_dot_self</a> (T_a &amp;&amp;a)</td></tr>
<tr class="memdesc:a24fa659f7ee2c514a95d79d5f22c337c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each row of a matrix with itself.  <a href="namespacestan_1_1math_a24fa659f7ee2c514a95d79d5f22c337c.html#a24fa659f7ee2c514a95d79d5f22c337c">More...</a><br /></td></tr>
<tr class="separator:a24fa659f7ee2c514a95d79d5f22c337c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga106d028bb360d5c31554ec3495cc41d0"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga106d028bb360d5c31554ec3495cc41d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga106d028bb360d5c31554ec3495cc41d0.html#ga106d028bb360d5c31554ec3495cc41d0">scaled_inv_chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu, const T_scale_cl &amp;s)</td></tr>
<tr class="separator:ga106d028bb360d5c31554ec3495cc41d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50e43583115511ae33ca69c4b4c7ab2"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae50e43583115511ae33ca69c4b4c7ab2"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae50e43583115511ae33ca69c4b4c7ab2.html#ae50e43583115511ae33ca69c4b4c7ab2">sd</a> (const T &amp;a)</td></tr>
<tr class="memdesc:ae50e43583115511ae33ca69c4b4c7ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unbiased sample standard deviation of the coefficients in the specified std vector, column vector, row vector, or matrix.  <a href="namespacestan_1_1math_ae50e43583115511ae33ca69c4b4c7ab2.html#ae50e43583115511ae33ca69c4b4c7ab2">More...</a><br /></td></tr>
<tr class="separator:ae50e43583115511ae33ca69c4b4c7ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d39ed84d314b4ac918e64818f79469"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a69d39ed84d314b4ac918e64818f79469"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a69d39ed84d314b4ac918e64818f79469.html#a69d39ed84d314b4ac918e64818f79469">segment</a> (T_x &amp;&amp;x, size_t i, size_t n)</td></tr>
<tr class="memdesc:a69d39ed84d314b4ac918e64818f79469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a row/column vector starting from the specified element - 1 of the specified row/column vector.  <a href="namespacestan_1_1math_a69d39ed84d314b4ac918e64818f79469.html#a69d39ed84d314b4ac918e64818f79469">More...</a><br /></td></tr>
<tr class="separator:a69d39ed84d314b4ac918e64818f79469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490231ac3d0382d97667cc0711f5b3af"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a490231ac3d0382d97667cc0711f5b3af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a490231ac3d0382d97667cc0711f5b3af.html#a490231ac3d0382d97667cc0711f5b3af">sign</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a490231ac3d0382d97667cc0711f5b3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns signs of the arguments.  <a href="namespacestan_1_1math_a490231ac3d0382d97667cc0711f5b3af.html#a490231ac3d0382d97667cc0711f5b3af">More...</a><br /></td></tr>
<tr class="separator:a490231ac3d0382d97667cc0711f5b3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98afb6ae5281b82b30caa793e205f6ae"><td class="memTemplParams" colspan="2">template&lt;typename T , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga98afb6ae5281b82b30caa793e205f6ae"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga98afb6ae5281b82b30caa793e205f6ae.html#ga98afb6ae5281b82b30caa793e205f6ae">size</a> (const T &amp;m)</td></tr>
<tr class="memdesc:ga98afb6ae5281b82b30caa793e205f6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size (number of the elements) of a <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> or <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;<a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;T&gt;&gt;</code>.  <a href="group__type__trait_ga98afb6ae5281b82b30caa793e205f6ae.html#ga98afb6ae5281b82b30caa793e205f6ae">More...</a><br /></td></tr>
<tr class="separator:ga98afb6ae5281b82b30caa793e205f6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadacfcfb973fe5c0ab2dac931e50b511e"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadacfcfb973fe5c0ab2dac931e50b511e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gadacfcfb973fe5c0ab2dac931e50b511e.html#gadacfcfb973fe5c0ab2dac931e50b511e">skew_double_exponential_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="separator:gadacfcfb973fe5c0ab2dac931e50b511e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36ec8f9f1a5acb9c6dc9e3640a204bda"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga36ec8f9f1a5acb9c6dc9e3640a204bda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga36ec8f9f1a5acb9c6dc9e3640a204bda.html#ga36ec8f9f1a5acb9c6dc9e3640a204bda">skew_double_exponential_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="separator:ga36ec8f9f1a5acb9c6dc9e3640a204bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f57073fbf4146f1b66cd5ea4336af7d"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9f57073fbf4146f1b66cd5ea4336af7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9f57073fbf4146f1b66cd5ea4336af7d.html#ga9f57073fbf4146f1b66cd5ea4336af7d">skew_double_exponential_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="separator:ga9f57073fbf4146f1b66cd5ea4336af7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga354bf670629966ea8ff1397c3ea6a6a6"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga354bf670629966ea8ff1397c3ea6a6a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga354bf670629966ea8ff1397c3ea6a6a6.html#ga354bf670629966ea8ff1397c3ea6a6a6">skew_double_exponential_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="separator:ga354bf670629966ea8ff1397c3ea6a6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac950822e01ad7173a9f42c571933eb06"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac950822e01ad7173a9f42c571933eb06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac950822e01ad7173a9f42c571933eb06.html#gac950822e01ad7173a9f42c571933eb06">skew_normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_shape_cl &amp;alpha)</td></tr>
<tr class="separator:gac950822e01ad7173a9f42c571933eb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6389c7c70247d32e52315682a1374c0f"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6389c7c70247d32e52315682a1374c0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6389c7c70247d32e52315682a1374c0f.html#a6389c7c70247d32e52315682a1374c0f">softmax</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a6389c7c70247d32e52315682a1374c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the softmax of the specified vector.  <a href="namespacestan_1_1math_a6389c7c70247d32e52315682a1374c0f.html#a6389c7c70247d32e52315682a1374c0f">More...</a><br /></td></tr>
<tr class="separator:a6389c7c70247d32e52315682a1374c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd03b3243ee5064d4cf410a390963b6"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aebd03b3243ee5064d4cf410a390963b6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aebd03b3243ee5064d4cf410a390963b6.html#aebd03b3243ee5064d4cf410a390963b6">sort_asc</a> (T &amp;&amp;input)</td></tr>
<tr class="memdesc:aebd03b3243ee5064d4cf410a390963b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the (row)vector in ascending order.  <a href="namespacestan_1_1math_aebd03b3243ee5064d4cf410a390963b6.html#aebd03b3243ee5064d4cf410a390963b6">More...</a><br /></td></tr>
<tr class="separator:aebd03b3243ee5064d4cf410a390963b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a286fd588e6e95c58b8156aaf8e605"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a49a286fd588e6e95c58b8156aaf8e605"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a49a286fd588e6e95c58b8156aaf8e605.html#a49a286fd588e6e95c58b8156aaf8e605">sort_desc</a> (T &amp;&amp;input)</td></tr>
<tr class="memdesc:a49a286fd588e6e95c58b8156aaf8e605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the (row)vector in ascending order.  <a href="namespacestan_1_1math_a49a286fd588e6e95c58b8156aaf8e605.html#a49a286fd588e6e95c58b8156aaf8e605">More...</a><br /></td></tr>
<tr class="separator:a49a286fd588e6e95c58b8156aaf8e605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6950d3d0f5cc2d11bffe95fb0214c46"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_and_none_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad6950d3d0f5cc2d11bffe95fb0214c46"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad6950d3d0f5cc2d11bffe95fb0214c46.html#ad6950d3d0f5cc2d11bffe95fb0214c46">squared_distance</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="memdesc:ad6950d3d0f5cc2d11bffe95fb0214c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance.  <a href="namespacestan_1_1math_ad6950d3d0f5cc2d11bffe95fb0214c46.html#ad6950d3d0f5cc2d11bffe95fb0214c46">More...</a><br /></td></tr>
<tr class="separator:ad6950d3d0f5cc2d11bffe95fb0214c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38acf71383b36f5db4ed878c9415b7d4"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga38acf71383b36f5db4ed878c9415b7d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga38acf71383b36f5db4ed878c9415b7d4.html#ga38acf71383b36f5db4ed878c9415b7d4">std_normal_cdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="separator:ga38acf71383b36f5db4ed878c9415b7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d733b180253da7249ae23e4e9bda790"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3d733b180253da7249ae23e4e9bda790"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3d733b180253da7249ae23e4e9bda790.html#ga3d733b180253da7249ae23e4e9bda790">std_normal_lccdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="separator:ga3d733b180253da7249ae23e4e9bda790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c94cfff116dc2477617f242e356ede"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac4c94cfff116dc2477617f242e356ede"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac4c94cfff116dc2477617f242e356ede.html#gac4c94cfff116dc2477617f242e356ede">std_normal_lcdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="separator:gac4c94cfff116dc2477617f242e356ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48200e7b64861fad93fcdf7b24c8cac4"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga48200e7b64861fad93fcdf7b24c8cac4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga48200e7b64861fad93fcdf7b24c8cac4.html#ga48200e7b64861fad93fcdf7b24c8cac4">std_normal_lpdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="separator:ga48200e7b64861fad93fcdf7b24c8cac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a3e85cdcb831735bf845adf1c42e234"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , typename T_loc_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8a3e85cdcb831735bf845adf1c42e234"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga8a3e85cdcb831735bf845adf1c42e234.html#ga8a3e85cdcb831735bf845adf1c42e234">student_t_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga8a3e85cdcb831735bf845adf1c42e234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab003c1d58214fbb73fab106a86dfeb7"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:aab003c1d58214fbb73fab106a86dfeb7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab003c1d58214fbb73fab106a86dfeb7.html#aab003c1d58214fbb73fab106a86dfeb7">sub_col</a> (T_x &amp;&amp;x, size_t i, size_t j, size_t nrows)</td></tr>
<tr class="memdesc:aab003c1d58214fbb73fab106a86dfeb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a 1 x ncols subrow starting at (i-1, j-1).  <a href="namespacestan_1_1math_aab003c1d58214fbb73fab106a86dfeb7.html#aab003c1d58214fbb73fab106a86dfeb7">More...</a><br /></td></tr>
<tr class="separator:aab003c1d58214fbb73fab106a86dfeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe43aa6192833ef6d978a53453cbfb6"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:a1fe43aa6192833ef6d978a53453cbfb6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1fe43aa6192833ef6d978a53453cbfb6.html#a1fe43aa6192833ef6d978a53453cbfb6">sub_row</a> (T_x &amp;&amp;x, size_t i, size_t j, size_t ncols)</td></tr>
<tr class="memdesc:a1fe43aa6192833ef6d978a53453cbfb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a 1 x ncols subrow starting at (i-1, j-1).  <a href="namespacestan_1_1math_a1fe43aa6192833ef6d978a53453cbfb6.html#a1fe43aa6192833ef6d978a53453cbfb6">More...</a><br /></td></tr>
<tr class="separator:a1fe43aa6192833ef6d978a53453cbfb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2f60b73ec6870212c8b4e4ceed0038"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_all_kernel_expressions_and_none_scalar_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aab2f60b73ec6870212c8b4e4ceed0038"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab2f60b73ec6870212c8b4e4ceed0038.html#aab2f60b73ec6870212c8b4e4ceed0038">symmetrize_from_lower_tri</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:aab2f60b73ec6870212c8b4e4ceed0038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a symmetric matrix using elements from the upper triangular part of the input matrix.  <a href="namespacestan_1_1math_aab2f60b73ec6870212c8b4e4ceed0038.html#aab2f60b73ec6870212c8b4e4ceed0038">More...</a><br /></td></tr>
<tr class="separator:aab2f60b73ec6870212c8b4e4ceed0038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98546423dee6fab291c2cdfcbb6be64c"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_all_kernel_expressions_and_none_scalar_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a98546423dee6fab291c2cdfcbb6be64c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a98546423dee6fab291c2cdfcbb6be64c.html#a98546423dee6fab291c2cdfcbb6be64c">symmetrize_from_upper_tri</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:a98546423dee6fab291c2cdfcbb6be64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a symmetric matrix using elements from the lower triangular part of the input matrix.  <a href="namespacestan_1_1math_a98546423dee6fab291c2cdfcbb6be64c.html#a98546423dee6fab291c2cdfcbb6be64c">More...</a><br /></td></tr>
<tr class="separator:a98546423dee6fab291c2cdfcbb6be64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b9d342c24240d2459e5d661c0aa88e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a84b9d342c24240d2459e5d661c0aa88e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a84b9d342c24240d2459e5d661c0aa88e.html#a84b9d342c24240d2459e5d661c0aa88e">tail</a> (T_x &amp;&amp;x, size_t n)</td></tr>
<tr class="memdesc:a84b9d342c24240d2459e5d661c0aa88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a vector or row vector (same as input) from the back of the specified vector or row vector.  <a href="namespacestan_1_1math_a84b9d342c24240d2459e5d661c0aa88e.html#a84b9d342c24240d2459e5d661c0aa88e">More...</a><br /></td></tr>
<tr class="separator:a84b9d342c24240d2459e5d661c0aa88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a96d10cbf6d1ae28078e15ac801a874"><td class="memTemplParams" colspan="2">template&lt;typename T_A , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_A&gt;&gt; </td></tr>
<tr class="memitem:a7a96d10cbf6d1ae28078e15ac801a874"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; typename std::decay_t&lt; T_A &gt;::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7a96d10cbf6d1ae28078e15ac801a874.html#a7a96d10cbf6d1ae28078e15ac801a874">tcrossprod</a> (T_A &amp;&amp;A)</td></tr>
<tr class="memdesc:a7a96d10cbf6d1ae28078e15ac801a874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of post-multiplying a matrix by its own transpose.  <a href="namespacestan_1_1math_a7a96d10cbf6d1ae28078e15ac801a874.html#a7a96d10cbf6d1ae28078e15ac801a874">More...</a><br /></td></tr>
<tr class="separator:a7a96d10cbf6d1ae28078e15ac801a874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccde2dd41ea6e10cce3f5fd53dbfa0ea"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaccde2dd41ea6e10cce3f5fd53dbfa0ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaccde2dd41ea6e10cce3f5fd53dbfa0ea.html#gaccde2dd41ea6e10cce3f5fd53dbfa0ea">to_array_1d</a> (T_x &amp;&amp;x)</td></tr>
<tr class="separator:gaccde2dd41ea6e10cce3f5fd53dbfa0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58346dcff1afcdf893e0c0e2ab7fbe3"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae58346dcff1afcdf893e0c0e2ab7fbe3"><td class="memTemplItemLeft" align="right" valign="top">T_x&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae58346dcff1afcdf893e0c0e2ab7fbe3.html#gae58346dcff1afcdf893e0c0e2ab7fbe3">to_array_2d</a> (T_x &amp;&amp;x)</td></tr>
<tr class="separator:gae58346dcff1afcdf893e0c0e2ab7fbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aabc784b5f56edb079f21a48efdad54"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0aabc784b5f56edb079f21a48efdad54"><td class="memTemplItemLeft" align="right" valign="top">T_x&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0aabc784b5f56edb079f21a48efdad54.html#ga0aabc784b5f56edb079f21a48efdad54">to_matrix</a> (T_x &amp;&amp;x)</td></tr>
<tr class="separator:ga0aabc784b5f56edb079f21a48efdad54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae365269b3abcdd13f51a4a903de908d5"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_all_kernel_expressions_and_none_scalar_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae365269b3abcdd13f51a4a903de908d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae365269b3abcdd13f51a4a903de908d5.html#ae365269b3abcdd13f51a4a903de908d5">to_matrix</a> (const T_x &amp;x, int m, int n)</td></tr>
<tr class="memdesc:ae365269b3abcdd13f51a4a903de908d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of a vector or matrix in column-major order with the specified number of rows and columns.  <a href="namespacestan_1_1math_ae365269b3abcdd13f51a4a903de908d5.html#ae365269b3abcdd13f51a4a903de908d5">More...</a><br /></td></tr>
<tr class="separator:ae365269b3abcdd13f51a4a903de908d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9020fbbcd9293dbf728d60c3cb7d6917"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9020fbbcd9293dbf728d60c3cb7d6917"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9020fbbcd9293dbf728d60c3cb7d6917.html#a9020fbbcd9293dbf728d60c3cb7d6917">to_matrix</a> (const T_x &amp;x, int m, int n, bool col_major) -&gt; decltype(to_matrix(x, m, n))</td></tr>
<tr class="memdesc:a9020fbbcd9293dbf728d60c3cb7d6917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of the vector or matrix in column-major or row major order with the specified number of rows and columns.  <a href="namespacestan_1_1math_a9020fbbcd9293dbf728d60c3cb7d6917.html#a9020fbbcd9293dbf728d60c3cb7d6917">More...</a><br /></td></tr>
<tr class="separator:a9020fbbcd9293dbf728d60c3cb7d6917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a3715205cf6c1564a87de73c13c22a"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga08a3715205cf6c1564a87de73c13c22a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga08a3715205cf6c1564a87de73c13c22a.html#ga08a3715205cf6c1564a87de73c13c22a">to_row_vector</a> (T_x &amp;&amp;x)</td></tr>
<tr class="separator:ga08a3715205cf6c1564a87de73c13c22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0026608053df548f73f9556ffa94dc03"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_nonscalar_prim_or_rev_kernel_expression_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0026608053df548f73f9556ffa94dc03"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0026608053df548f73f9556ffa94dc03.html#ga0026608053df548f73f9556ffa94dc03">to_vector</a> (T_x &amp;&amp;x)</td></tr>
<tr class="separator:ga0026608053df548f73f9556ffa94dc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d46a81f6abbe21848f100a28445b288"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0d46a81f6abbe21848f100a28445b288"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0d46a81f6abbe21848f100a28445b288.html#a0d46a81f6abbe21848f100a28445b288">trace</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a0d46a81f6abbe21848f100a28445b288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates trace (sum of diagonal) of given kernel generator expression.  <a href="namespacestan_1_1math_a0d46a81f6abbe21848f100a28445b288.html#a0d46a81f6abbe21848f100a28445b288">More...</a><br /></td></tr>
<tr class="separator:a0d46a81f6abbe21848f100a28445b288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7fb6c2b6644f9037eb82172cf6193b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr, require_all_kernel_expressions_t&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abe7fb6c2b6644f9037eb82172cf6193b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abe7fb6c2b6644f9037eb82172cf6193b.html#abe7fb6c2b6644f9037eb82172cf6193b">ub_constrain</a> (T &amp;&amp;x, U &amp;&amp;ub)</td></tr>
<tr class="memdesc:abe7fb6c2b6644f9037eb82172cf6193b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper-bounded value for the specified unconstrained matrix and upper bound.  <a href="namespacestan_1_1math_abe7fb6c2b6644f9037eb82172cf6193b.html#abe7fb6c2b6644f9037eb82172cf6193b">More...</a><br /></td></tr>
<tr class="separator:abe7fb6c2b6644f9037eb82172cf6193b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f42613664a16b7fcc43d2f83d9e94c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr, require_all_kernel_expressions_t&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac3f42613664a16b7fcc43d2f83d9e94c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac3f42613664a16b7fcc43d2f83d9e94c.html#ac3f42613664a16b7fcc43d2f83d9e94c">ub_constrain</a> (const T &amp;x, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:ac3f42613664a16b7fcc43d2f83d9e94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper-bounded value for the specified unconstrained matrix and upper bound.  <a href="namespacestan_1_1math_ac3f42613664a16b7fcc43d2f83d9e94c.html#ac3f42613664a16b7fcc43d2f83d9e94c">More...</a><br /></td></tr>
<tr class="separator:ac3f42613664a16b7fcc43d2f83d9e94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e86538bd3a160cb58989ff68aa81456"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0e86538bd3a160cb58989ff68aa81456"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0e86538bd3a160cb58989ff68aa81456.html#ga0e86538bd3a160cb58989ff68aa81456">uniform_cdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga0e86538bd3a160cb58989ff68aa81456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2dacadd5737ffbb65288cef66d1cfb7"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab2dacadd5737ffbb65288cef66d1cfb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gab2dacadd5737ffbb65288cef66d1cfb7.html#gab2dacadd5737ffbb65288cef66d1cfb7">uniform_lccdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gab2dacadd5737ffbb65288cef66d1cfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga260dc4fb650cc809b40e338144ccbf1e"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga260dc4fb650cc809b40e338144ccbf1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga260dc4fb650cc809b40e338144ccbf1e.html#ga260dc4fb650cc809b40e338144ccbf1e">uniform_lcdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga260dc4fb650cc809b40e338144ccbf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c081c9922500bedd293b98080c246a9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_low_cl , typename T_high_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8c081c9922500bedd293b98080c246a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga8c081c9922500bedd293b98080c246a9.html#ga8c081c9922500bedd293b98080c246a9">uniform_lpdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga8c081c9922500bedd293b98080c246a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079cf546b247c376fb3b9a59ae29236e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_all_kernel_expressions_and_none_scalar_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a079cf546b247c376fb3b9a59ae29236e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a079cf546b247c376fb3b9a59ae29236e.html#a079cf546b247c376fb3b9a59ae29236e">unit_vector_constrain</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:a079cf546b247c376fb3b9a59ae29236e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the given free vector.  <a href="namespacestan_1_1math_a079cf546b247c376fb3b9a59ae29236e.html#a079cf546b247c376fb3b9a59ae29236e">More...</a><br /></td></tr>
<tr class="separator:a079cf546b247c376fb3b9a59ae29236e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cfcede7ee2b3c895c9fdc6622f8876"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_all_kernel_expressions_and_none_scalar_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac7cfcede7ee2b3c895c9fdc6622f8876"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac7cfcede7ee2b3c895c9fdc6622f8876.html#ac7cfcede7ee2b3c895c9fdc6622f8876">unit_vector_constrain</a> (T_x &amp;&amp;x, double &amp;lp)</td></tr>
<tr class="memdesc:ac7cfcede7ee2b3c895c9fdc6622f8876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the given free vector.  <a href="namespacestan_1_1math_ac7cfcede7ee2b3c895c9fdc6622f8876.html#ac7cfcede7ee2b3c895c9fdc6622f8876">More...</a><br /></td></tr>
<tr class="separator:ac7cfcede7ee2b3c895c9fdc6622f8876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3720810fa541e8a4b88e0b3f2f2b3a56"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3720810fa541e8a4b88e0b3f2f2b3a56"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3720810fa541e8a4b88e0b3f2f2b3a56.html#a3720810fa541e8a4b88e0b3f2f2b3a56">variance</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a3720810fa541e8a4b88e0b3f2f2b3a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample variance of the <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a> matrix Raise domain error if size is not greater than zero.  <a href="namespacestan_1_1math_a3720810fa541e8a4b88e0b3f2f2b3a56.html#a3720810fa541e8a4b88e0b3f2f2b3a56">More...</a><br /></td></tr>
<tr class="separator:a3720810fa541e8a4b88e0b3f2f2b3a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02f96945c94514afc7c296e5ed4f461e"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga02f96945c94514afc7c296e5ed4f461e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga02f96945c94514afc7c296e5ed4f461e.html#ga02f96945c94514afc7c296e5ed4f461e">weibull_cdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga02f96945c94514afc7c296e5ed4f461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga143c39f3c5b17a11b8fac657716a1ca8"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga143c39f3c5b17a11b8fac657716a1ca8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga143c39f3c5b17a11b8fac657716a1ca8.html#ga143c39f3c5b17a11b8fac657716a1ca8">weibull_lccdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga143c39f3c5b17a11b8fac657716a1ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77ff0157eda0b5a11c6cacd5bcc07e42"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga77ff0157eda0b5a11c6cacd5bcc07e42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga77ff0157eda0b5a11c6cacd5bcc07e42.html#ga77ff0157eda0b5a11c6cacd5bcc07e42">weibull_lcdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga77ff0157eda0b5a11c6cacd5bcc07e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ecf070a86a3bb30c08ced16a1c1bb32"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , require_all_prim_or_rev_kernel_expression_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9ecf070a86a3bb30c08ced16a1c1bb32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9ecf070a86a3bb30c08ced16a1c1bb32.html#ga9ecf070a86a3bb30c08ced16a1c1bb32">weibull_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="separator:ga9ecf070a86a3bb30c08ced16a1c1bb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec09b5ad85be5223ff11bc9682bc87a"><td class="memTemplParams" colspan="2">template&lt;bool need_Q = true&gt; </td></tr>
<tr class="memitem:a9ec09b5ad85be5223ff11bc9682bc87a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ec09b5ad85be5223ff11bc9682bc87a.html#a9ec09b5ad85be5223ff11bc9682bc87a">qr_decomposition_cl</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;A, <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;Q, <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;R, int r=100)</td></tr>
<tr class="memdesc:a9ec09b5ad85be5223ff11bc9682bc87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates QR decomposition of A using the block Householder algorithm.  <a href="namespacestan_1_1math_a9ec09b5ad85be5223ff11bc9682bc87a.html#a9ec09b5ad85be5223ff11bc9682bc87a">More...</a><br /></td></tr>
<tr class="separator:a9ec09b5ad85be5223ff11bc9682bc87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73ecdad23b91e6bc055d46fea1ebf6b"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af73ecdad23b91e6bc055d46fea1ebf6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af73ecdad23b91e6bc055d46fea1ebf6b.html#af73ecdad23b91e6bc055d46fea1ebf6b">acos</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:af73ecdad23b91e6bc055d46fea1ebf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a6952d8c23d69dc891dbe78e7d4ea7a80.html#a6952d8c23d69dc891dbe78e7d4ea7a80">acos()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt; in radians.  <a href="namespacestan_1_1math_af73ecdad23b91e6bc055d46fea1ebf6b.html#af73ecdad23b91e6bc055d46fea1ebf6b">More...</a><br /></td></tr>
<tr class="separator:af73ecdad23b91e6bc055d46fea1ebf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515ca40c9ba5080ecf5cfc75e4a280ed"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a515ca40c9ba5080ecf5cfc75e4a280ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a515ca40c9ba5080ecf5cfc75e4a280ed.html#a515ca40c9ba5080ecf5cfc75e4a280ed">acosh</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a515ca40c9ba5080ecf5cfc75e4a280ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ae033720f1a26c44aa9d7fb4dcf547155.html#ae033720f1a26c44aa9d7fb4dcf547155">acosh()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt; in radians.  <a href="namespacestan_1_1math_a515ca40c9ba5080ecf5cfc75e4a280ed.html#a515ca40c9ba5080ecf5cfc75e4a280ed">More...</a><br /></td></tr>
<tr class="separator:a515ca40c9ba5080ecf5cfc75e4a280ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc6edb6b52ed3dc3920a17744c4d92d"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5dc6edb6b52ed3dc3920a17744c4d92d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5dc6edb6b52ed3dc3920a17744c4d92d.html#a5dc6edb6b52ed3dc3920a17744c4d92d">add</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a5dc6edb6b52ed3dc3920a17744c4d92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two reverse mode matrices and/or kernel generator expressions.  <a href="namespacestan_1_1math_a5dc6edb6b52ed3dc3920a17744c4d92d.html#a5dc6edb6b52ed3dc3920a17744c4d92d">More...</a><br /></td></tr>
<tr class="separator:a5dc6edb6b52ed3dc3920a17744c4d92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1835808a69fe7b739b99fc14d948462e"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1835808a69fe7b739b99fc14d948462e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1835808a69fe7b739b99fc14d948462e.html#a1835808a69fe7b739b99fc14d948462e">operator+</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="memdesc:a1835808a69fe7b739b99fc14d948462e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two reverse mode matrices and/or kernel generator expressions.  <a href="namespacestan_1_1math_a1835808a69fe7b739b99fc14d948462e.html#a1835808a69fe7b739b99fc14d948462e">More...</a><br /></td></tr>
<tr class="separator:a1835808a69fe7b739b99fc14d948462e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af574b9c824ba2da7f03a056955a9e23d"><td class="memTemplParams" colspan="2">template&lt;typename T_m , typename T_a , require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T_m &gt; *  = nullptr, require_all_prim_or_rev_kernel_expression_t&lt; T_a &gt; *  = nullptr, require_any_var_t&lt; T_m, T_a &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af574b9c824ba2da7f03a056955a9e23d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af574b9c824ba2da7f03a056955a9e23d.html#af574b9c824ba2da7f03a056955a9e23d">add_diag</a> (const T_m &amp;mat, const T_a &amp;to_add)</td></tr>
<tr class="memdesc:af574b9c824ba2da7f03a056955a9e23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matrix with values added along the main diagonal.  <a href="namespacestan_1_1math_af574b9c824ba2da7f03a056955a9e23d.html#af574b9c824ba2da7f03a056955a9e23d">More...</a><br /></td></tr>
<tr class="separator:af574b9c824ba2da7f03a056955a9e23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b19fff9377137e108c8df082e2bfcb9"><td class="memTemplParams" colspan="2">template&lt;typename... T_results&gt; </td></tr>
<tr class="memitem:a2b19fff9377137e108c8df082e2bfcb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1adjoint__results__cl.html">adjoint_results_cl</a>&lt; T_results... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2b19fff9377137e108c8df082e2bfcb9.html#a2b19fff9377137e108c8df082e2bfcb9">adjoint_results</a> (T_results &amp;&amp;... <a class="el" href="group__opencl__kernel__generator_ga7a446e25c0da21a49dfe45e21c0bcd19.html#ga7a446e25c0da21a49dfe45e21c0bcd19">results</a>)</td></tr>
<tr class="memdesc:a2b19fff9377137e108c8df082e2bfcb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces types for constructing <code><a class="el" href="classstan_1_1math_1_1adjoint__results__cl.html" title="Represents results that are adjoints of vars in kernel generrator expressions.">adjoint_results_cl</a></code> object.  <a href="namespacestan_1_1math_a2b19fff9377137e108c8df082e2bfcb9.html#a2b19fff9377137e108c8df082e2bfcb9">More...</a><br /></td></tr>
<tr class="separator:a2b19fff9377137e108c8df082e2bfcb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57c0f8ea87aeb70333e6bb52ecec937"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac57c0f8ea87aeb70333e6bb52ecec937"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac57c0f8ea87aeb70333e6bb52ecec937.html#ac57c0f8ea87aeb70333e6bb52ecec937">append_col</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:ac57c0f8ea87aeb70333e6bb52ecec937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of appending the second argument matrix after the first argument matrix, that is, putting them side by side, with the first matrix followed by the second matrix.  <a href="namespacestan_1_1math_ac57c0f8ea87aeb70333e6bb52ecec937.html#ac57c0f8ea87aeb70333e6bb52ecec937">More...</a><br /></td></tr>
<tr class="separator:ac57c0f8ea87aeb70333e6bb52ecec937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b81fc3a028a622c7b55decd82f2e72"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a51b81fc3a028a622c7b55decd82f2e72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a51b81fc3a028a622c7b55decd82f2e72.html#a51b81fc3a028a622c7b55decd82f2e72">append_row</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a51b81fc3a028a622c7b55decd82f2e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking the rows of the first argument matrix on top of the second argument matrix.  <a href="namespacestan_1_1math_a51b81fc3a028a622c7b55decd82f2e72.html#a51b81fc3a028a622c7b55decd82f2e72">More...</a><br /></td></tr>
<tr class="separator:a51b81fc3a028a622c7b55decd82f2e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95daff22a06bf3668baee75c287e92a"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr, require_any_var_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad95daff22a06bf3668baee75c287e92a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad95daff22a06bf3668baee75c287e92a.html#ad95daff22a06bf3668baee75c287e92a">as_column_vector_or_scalar</a> (const T &amp;m)</td></tr>
<tr class="memdesc:ad95daff22a06bf3668baee75c287e92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts kernel generator expression row or column vector to a column vector.  <a href="namespacestan_1_1math_ad95daff22a06bf3668baee75c287e92a.html#ad95daff22a06bf3668baee75c287e92a">More...</a><br /></td></tr>
<tr class="separator:ad95daff22a06bf3668baee75c287e92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c79856fd3d7c8533bd682c013fbd52"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a68c79856fd3d7c8533bd682c013fbd52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a68c79856fd3d7c8533bd682c013fbd52.html#a68c79856fd3d7c8533bd682c013fbd52">asin</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a68c79856fd3d7c8533bd682c013fbd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a1ab75d0165599717cfd1e90f7edcf250.html#a1ab75d0165599717cfd1e90f7edcf250">asin()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt; in radians.  <a href="namespacestan_1_1math_a68c79856fd3d7c8533bd682c013fbd52.html#a68c79856fd3d7c8533bd682c013fbd52">More...</a><br /></td></tr>
<tr class="separator:a68c79856fd3d7c8533bd682c013fbd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf0f19ec49e19ed3c5790c37ef44941"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abaf0f19ec49e19ed3c5790c37ef44941"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abaf0f19ec49e19ed3c5790c37ef44941.html#abaf0f19ec49e19ed3c5790c37ef44941">asinh</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:abaf0f19ec49e19ed3c5790c37ef44941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a68af8aec6bd04b4d40e5bce59f82b97c.html#a68af8aec6bd04b4d40e5bce59f82b97c">asinh()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt; in radians.  <a href="namespacestan_1_1math_abaf0f19ec49e19ed3c5790c37ef44941.html#abaf0f19ec49e19ed3c5790c37ef44941">More...</a><br /></td></tr>
<tr class="separator:abaf0f19ec49e19ed3c5790c37ef44941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bae71741b96629685b0db63ef7f5880"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4bae71741b96629685b0db63ef7f5880"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4bae71741b96629685b0db63ef7f5880.html#a4bae71741b96629685b0db63ef7f5880">atan</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a4bae71741b96629685b0db63ef7f5880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a6f0398656b862b1b2eb80145f4877b11.html#a6f0398656b862b1b2eb80145f4877b11">atan()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt; in radians.  <a href="namespacestan_1_1math_a4bae71741b96629685b0db63ef7f5880.html#a4bae71741b96629685b0db63ef7f5880">More...</a><br /></td></tr>
<tr class="separator:a4bae71741b96629685b0db63ef7f5880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367fea289906910a4a02f0a026fe493a"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a367fea289906910a4a02f0a026fe493a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a367fea289906910a4a02f0a026fe493a.html#a367fea289906910a4a02f0a026fe493a">atanh</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a367fea289906910a4a02f0a026fe493a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a9e31606b2cbc69573ec0d7693c8b2a2c.html#a9e31606b2cbc69573ec0d7693c8b2a2c" title="Return inverse hyperbolic tangent of specified value.">atanh()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt; in radians.  <a href="namespacestan_1_1math_a367fea289906910a4a02f0a026fe493a.html#a367fea289906910a4a02f0a026fe493a">More...</a><br /></td></tr>
<tr class="separator:a367fea289906910a4a02f0a026fe493a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c2af773527d49db469e8353dd8c0a0"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab8c2af773527d49db469e8353dd8c0a0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab8c2af773527d49db469e8353dd8c0a0.html#ab8c2af773527d49db469e8353dd8c0a0">beta</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:ab8c2af773527d49db469e8353dd8c0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise <code><a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a" title="Return fvar with the beta function applied to the specified arguments and its gradient.">beta()</a></code> on two input kernel generator expression.  <a href="namespacestan_1_1math_ab8c2af773527d49db469e8353dd8c0a0.html#ab8c2af773527d49db469e8353dd8c0a0">More...</a><br /></td></tr>
<tr class="separator:ab8c2af773527d49db469e8353dd8c0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8754931c24e20cda18a5acf2486a53"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr, require_any_var_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8d8754931c24e20cda18a5acf2486a53"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8d8754931c24e20cda18a5acf2486a53.html#a8d8754931c24e20cda18a5acf2486a53">block</a> (const T &amp;m, size_t i, size_t j, size_t nrows, size_t ncols)</td></tr>
<tr class="memdesc:a8d8754931c24e20cda18a5acf2486a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a nrows x ncols submatrix starting at (i-1, j-1).  <a href="namespacestan_1_1math_a8d8754931c24e20cda18a5acf2486a53.html#a8d8754931c24e20cda18a5acf2486a53">More...</a><br /></td></tr>
<tr class="separator:a8d8754931c24e20cda18a5acf2486a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabceea0d20da4d8726bfe7cef0179eaa"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aabceea0d20da4d8726bfe7cef0179eaa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aabceea0d20da4d8726bfe7cef0179eaa.html#aabceea0d20da4d8726bfe7cef0179eaa">cbrt</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aabceea0d20da4d8726bfe7cef0179eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a64c0dfe5862fc53f1a18d76f14a1dc7e.html#a64c0dfe5862fc53f1a18d76f14a1dc7e" title="Return cube root of specified argument.">cbrt()</a></code> of the input <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;<a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;double&gt;&gt;</code>.  <a href="namespacestan_1_1math_aabceea0d20da4d8726bfe7cef0179eaa.html#aabceea0d20da4d8726bfe7cef0179eaa">More...</a><br /></td></tr>
<tr class="separator:aabceea0d20da4d8726bfe7cef0179eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6619b7879b2a5567ec37bc57a4a651"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5c6619b7879b2a5567ec37bc57a4a651"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5c6619b7879b2a5567ec37bc57a4a651.html#a5c6619b7879b2a5567ec37bc57a4a651">ceil</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a5c6619b7879b2a5567ec37bc57a4a651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ab1b2e9b4a947b81917612a8d1d547afb.html#ab1b2e9b4a947b81917612a8d1d547afb">ceil()</a></code> of the specified variable.  <a href="namespacestan_1_1math_a5c6619b7879b2a5567ec37bc57a4a651.html#a5c6619b7879b2a5567ec37bc57a4a651">More...</a><br /></td></tr>
<tr class="separator:a5c6619b7879b2a5567ec37bc57a4a651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51eab64c09bc6717eaed5b5603c9c883"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a51eab64c09bc6717eaed5b5603c9c883"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a51eab64c09bc6717eaed5b5603c9c883.html#a51eab64c09bc6717eaed5b5603c9c883">cholesky_decompose</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a51eab64c09bc6717eaed5b5603c9c883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric reverse mode matrix on the OpenCL device.  <a href="namespacestan_1_1math_a51eab64c09bc6717eaed5b5603c9c883.html#a51eab64c09bc6717eaed5b5603c9c883">More...</a><br /></td></tr>
<tr class="separator:a51eab64c09bc6717eaed5b5603c9c883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bfab7a8f1d1d601bc6f14aff2f397f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_var_t&lt; T1, T2 &gt; *  = nullptr, require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a00bfab7a8f1d1d601bc6f14aff2f397f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a00bfab7a8f1d1d601bc6f14aff2f397f.html#a00bfab7a8f1d1d601bc6f14aff2f397f">columns_dot_product</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a00bfab7a8f1d1d601bc6f14aff2f397f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of columns of the specified matrices.  <a href="namespacestan_1_1math_a00bfab7a8f1d1d601bc6f14aff2f397f.html#a00bfab7a8f1d1d601bc6f14aff2f397f">More...</a><br /></td></tr>
<tr class="separator:a00bfab7a8f1d1d601bc6f14aff2f397f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ffb60bbb164085127dbe33967ac74f"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a93ffb60bbb164085127dbe33967ac74f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a93ffb60bbb164085127dbe33967ac74f.html#a93ffb60bbb164085127dbe33967ac74f">columns_dot_self</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a93ffb60bbb164085127dbe33967ac74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each column of a matrix with itself.  <a href="namespacestan_1_1math_a93ffb60bbb164085127dbe33967ac74f.html#a93ffb60bbb164085127dbe33967ac74f">More...</a><br /></td></tr>
<tr class="separator:a93ffb60bbb164085127dbe33967ac74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46313382ff3fae62c662662f93290572"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga46313382ff3fae62c662662f93290572"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga46313382ff3fae62c662662f93290572.html#ga46313382ff3fae62c662662f93290572">to_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:ga46313382ff3fae62c662662f93290572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a35989520c40a236b8870762dd0db0"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga34a35989520c40a236b8870762dd0db0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga34a35989520c40a236b8870762dd0db0.html#ga34a35989520c40a236b8870762dd0db0">to_matrix_cl</a> (const std::vector&lt; <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt;&gt; &amp;a)</td></tr>
<tr class="separator:ga34a35989520c40a236b8870762dd0db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga095903e22c477b60e69e174c307bd423"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vt&lt; is_var, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga095903e22c477b60e69e174c307bd423"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga095903e22c477b60e69e174c307bd423.html#ga095903e22c477b60e69e174c307bd423">to_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="separator:ga095903e22c477b60e69e174c307bd423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga824d07dfec68229d759d260c865e9747"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vt&lt; is_var, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga824d07dfec68229d759d260c865e9747"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga824d07dfec68229d759d260c865e9747.html#ga824d07dfec68229d759d260c865e9747">to_matrix_cl</a> (const std::vector&lt; T &gt; &amp;src)</td></tr>
<tr class="separator:ga824d07dfec68229d759d260c865e9747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf3e76a11e9efeae4a1215bfb67c8be"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T , require_var_vt&lt; is_eigen, T_dst &gt; *  = nullptr, require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaedf3e76a11e9efeae4a1215bfb67c8be"><td class="memTemplItemLeft" align="right" valign="top">T_dst&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaedf3e76a11e9efeae4a1215bfb67c8be.html#gaedf3e76a11e9efeae4a1215bfb67c8be">from_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:gaedf3e76a11e9efeae4a1215bfb67c8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga016b4e7e4fd48ee3333c5c37507e3d01"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T , require_std_vector_vt&lt; is_var, T_dst &gt; *  = nullptr, require_all_stan_scalar_t&lt; value_type_t&lt; T_dst &gt;&gt; *  = nullptr, require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga016b4e7e4fd48ee3333c5c37507e3d01"><td class="memTemplItemLeft" align="right" valign="top">T_dst&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga016b4e7e4fd48ee3333c5c37507e3d01.html#ga016b4e7e4fd48ee3333c5c37507e3d01">from_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:ga016b4e7e4fd48ee3333c5c37507e3d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeefdbbf87e96786f8460982c80c5c06f"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaeefdbbf87e96786f8460982c80c5c06f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaeefdbbf87e96786f8460982c80c5c06f.html#gaeefdbbf87e96786f8460982c80c5c06f">from_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="separator:gaeefdbbf87e96786f8460982c80c5c06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68de648f21bb7434a96cde5981c54a38"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a68de648f21bb7434a96cde5981c54a38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a68de648f21bb7434a96cde5981c54a38.html#a68de648f21bb7434a96cde5981c54a38">cos</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a68de648f21bb7434a96cde5981c54a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ae6cb3a9041ae0b7855b398c3e11cda48.html#ae6cb3a9041ae0b7855b398c3e11cda48">cos()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt; in radians.  <a href="namespacestan_1_1math_a68de648f21bb7434a96cde5981c54a38.html#a68de648f21bb7434a96cde5981c54a38">More...</a><br /></td></tr>
<tr class="separator:a68de648f21bb7434a96cde5981c54a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433deed8d835ffb9a1dff707a3d4099a"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a433deed8d835ffb9a1dff707a3d4099a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a433deed8d835ffb9a1dff707a3d4099a.html#a433deed8d835ffb9a1dff707a3d4099a">cosh</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a433deed8d835ffb9a1dff707a3d4099a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aee4fa5213b343a52756c138107ac180b.html#aee4fa5213b343a52756c138107ac180b">cosh()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt; in radians.  <a href="namespacestan_1_1math_a433deed8d835ffb9a1dff707a3d4099a.html#a433deed8d835ffb9a1dff707a3d4099a">More...</a><br /></td></tr>
<tr class="separator:a433deed8d835ffb9a1dff707a3d4099a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbac7943f76278bd0a2ef11fe54e1604"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adbac7943f76278bd0a2ef11fe54e1604"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adbac7943f76278bd0a2ef11fe54e1604.html#adbac7943f76278bd0a2ef11fe54e1604">crossprod</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;M)</td></tr>
<tr class="memdesc:adbac7943f76278bd0a2ef11fe54e1604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of pre-multiplying a matrix by its own transpose.  <a href="namespacestan_1_1math_adbac7943f76278bd0a2ef11fe54e1604.html#adbac7943f76278bd0a2ef11fe54e1604">More...</a><br /></td></tr>
<tr class="separator:adbac7943f76278bd0a2ef11fe54e1604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bb5b0da47029537981899237a48324"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a60bb5b0da47029537981899237a48324"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a60bb5b0da47029537981899237a48324.html#a60bb5b0da47029537981899237a48324">cumulative_sum</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a60bb5b0da47029537981899237a48324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cumulative sum of the specified vector.  <a href="namespacestan_1_1math_a60bb5b0da47029537981899237a48324.html#a60bb5b0da47029537981899237a48324">More...</a><br /></td></tr>
<tr class="separator:a60bb5b0da47029537981899237a48324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ed6894149d338926e65d412aa6eeb6"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a04ed6894149d338926e65d412aa6eeb6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a04ed6894149d338926e65d412aa6eeb6.html#a04ed6894149d338926e65d412aa6eeb6">diag_matrix</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a04ed6894149d338926e65d412aa6eeb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a square diagonal matrix with the specified vector of coefficients as the diagonal values.  <a href="namespacestan_1_1math_a04ed6894149d338926e65d412aa6eeb6.html#a04ed6894149d338926e65d412aa6eeb6">More...</a><br /></td></tr>
<tr class="separator:a04ed6894149d338926e65d412aa6eeb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d1d0e0fd7d649a31d63de03382440a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_var_t&lt; T1, T2 &gt; *  = nullptr, require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a26d1d0e0fd7d649a31d63de03382440a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a26d1d0e0fd7d649a31d63de03382440a.html#a26d1d0e0fd7d649a31d63de03382440a">diag_post_multiply</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a26d1d0e0fd7d649a31d63de03382440a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of a matrix and the diagonal matrix formed from the vector or row_vector.  <a href="namespacestan_1_1math_a26d1d0e0fd7d649a31d63de03382440a.html#a26d1d0e0fd7d649a31d63de03382440a">More...</a><br /></td></tr>
<tr class="separator:a26d1d0e0fd7d649a31d63de03382440a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ff6eb89c408302cfa2f929ea70bc1c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_var_t&lt; T1, T2 &gt; *  = nullptr, require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a01ff6eb89c408302cfa2f929ea70bc1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a01ff6eb89c408302cfa2f929ea70bc1c.html#a01ff6eb89c408302cfa2f929ea70bc1c">diag_pre_multiply</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a01ff6eb89c408302cfa2f929ea70bc1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the diagonal matrix formed from the vector or row_vector and a matrix.  <a href="namespacestan_1_1math_a01ff6eb89c408302cfa2f929ea70bc1c.html#a01ff6eb89c408302cfa2f929ea70bc1c">More...</a><br /></td></tr>
<tr class="separator:a01ff6eb89c408302cfa2f929ea70bc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7852a3cd97d696ce64889c61b03307de"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7852a3cd97d696ce64889c61b03307de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7852a3cd97d696ce64889c61b03307de.html#a7852a3cd97d696ce64889c61b03307de">diagonal</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;M)</td></tr>
<tr class="memdesc:a7852a3cd97d696ce64889c61b03307de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column vector of the diagonal elements of the specified matrix.  <a href="namespacestan_1_1math_a7852a3cd97d696ce64889c61b03307de.html#a7852a3cd97d696ce64889c61b03307de">More...</a><br /></td></tr>
<tr class="separator:a7852a3cd97d696ce64889c61b03307de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac011c75616319d4c8986a3b6255f580d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac011c75616319d4c8986a3b6255f580d.html#ac011c75616319d4c8986a3b6255f580d">digamma</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&gt; &amp;A)</td></tr>
<tr class="memdesc:ac011c75616319d4c8986a3b6255f580d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a69702aaa101bf602072fa7bf5fccb48a.html#a69702aaa101bf602072fa7bf5fccb48a" title="Return the derivative of the log gamma function at the specified argument.">digamma()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_ac011c75616319d4c8986a3b6255f580d.html#ac011c75616319d4c8986a3b6255f580d">More...</a><br /></td></tr>
<tr class="separator:ac011c75616319d4c8986a3b6255f580d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04136af19ff20a3a8864c654618a19c5"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_stan_scalar_t&lt; T_b &gt; *  = nullptr, require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T_a &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a04136af19ff20a3a8864c654618a19c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a04136af19ff20a3a8864c654618a19c5.html#a04136af19ff20a3a8864c654618a19c5">divide</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a04136af19ff20a3a8864c654618a19c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise division of a kernel generator expression and a scalar.  <a href="namespacestan_1_1math_a04136af19ff20a3a8864c654618a19c5.html#a04136af19ff20a3a8864c654618a19c5">More...</a><br /></td></tr>
<tr class="separator:a04136af19ff20a3a8864c654618a19c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3cf0b4bd2ef470aa7fa69318c4ec3f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_var_t&lt; T1, T2 &gt; *  = nullptr, require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9c3cf0b4bd2ef470aa7fa69318c4ec3f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9c3cf0b4bd2ef470aa7fa69318c4ec3f.html#a9c3cf0b4bd2ef470aa7fa69318c4ec3f">dot_product</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a9c3cf0b4bd2ef470aa7fa69318c4ec3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product.  <a href="namespacestan_1_1math_a9c3cf0b4bd2ef470aa7fa69318c4ec3f.html#a9c3cf0b4bd2ef470aa7fa69318c4ec3f">More...</a><br /></td></tr>
<tr class="separator:a9c3cf0b4bd2ef470aa7fa69318c4ec3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0286957300fdd1828e2cc90fd49eb12"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae0286957300fdd1828e2cc90fd49eb12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae0286957300fdd1828e2cc90fd49eb12.html#ae0286957300fdd1828e2cc90fd49eb12">dot_self</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ae0286957300fdd1828e2cc90fd49eb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of a vector of var with itself.  <a href="namespacestan_1_1math_ae0286957300fdd1828e2cc90fd49eb12.html#ae0286957300fdd1828e2cc90fd49eb12">More...</a><br /></td></tr>
<tr class="separator:ae0286957300fdd1828e2cc90fd49eb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ced098511979e0c4b31aee32a05731d"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4ced098511979e0c4b31aee32a05731d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4ced098511979e0c4b31aee32a05731d.html#a4ced098511979e0c4b31aee32a05731d">elt_divide</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a4ced098511979e0c4b31aee32a05731d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise division of two reverse mode matrices and/or kernel generator expressions.  <a href="namespacestan_1_1math_a4ced098511979e0c4b31aee32a05731d.html#a4ced098511979e0c4b31aee32a05731d">More...</a><br /></td></tr>
<tr class="separator:a4ced098511979e0c4b31aee32a05731d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f52576a2341e45cac1b9f30045e176b"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2f52576a2341e45cac1b9f30045e176b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f52576a2341e45cac1b9f30045e176b.html#a2f52576a2341e45cac1b9f30045e176b">elt_multiply</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a2f52576a2341e45cac1b9f30045e176b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiplication of two reverse mode matrices and/or kernel generator expressions.  <a href="namespacestan_1_1math_a2f52576a2341e45cac1b9f30045e176b.html#a2f52576a2341e45cac1b9f30045e176b">More...</a><br /></td></tr>
<tr class="separator:a2f52576a2341e45cac1b9f30045e176b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8758f7d9e51dbf15583c393a0be978d8"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8758f7d9e51dbf15583c393a0be978d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8758f7d9e51dbf15583c393a0be978d8.html#a8758f7d9e51dbf15583c393a0be978d8">erf</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a8758f7d9e51dbf15583c393a0be978d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aa283efca22c0544054a6534443e6e762.html#aa283efca22c0544054a6534443e6e762">erf()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_a8758f7d9e51dbf15583c393a0be978d8.html#a8758f7d9e51dbf15583c393a0be978d8">More...</a><br /></td></tr>
<tr class="separator:a8758f7d9e51dbf15583c393a0be978d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5f703c0fd7a88609777e041db46193"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aff5f703c0fd7a88609777e041db46193"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aff5f703c0fd7a88609777e041db46193.html#aff5f703c0fd7a88609777e041db46193">erfc</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aff5f703c0fd7a88609777e041db46193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ab4c763e4f09069eed96a4e96e33ea8ea.html#ab4c763e4f09069eed96a4e96e33ea8ea">erfc()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_aff5f703c0fd7a88609777e041db46193.html#aff5f703c0fd7a88609777e041db46193">More...</a><br /></td></tr>
<tr class="separator:aff5f703c0fd7a88609777e041db46193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705bd4fd968224a6a32cf224d229fdba"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a705bd4fd968224a6a32cf224d229fdba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a705bd4fd968224a6a32cf224d229fdba.html#a705bd4fd968224a6a32cf224d229fdba">exp</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a705bd4fd968224a6a32cf224d229fdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a11f31444e8584e4debf0d6b706d66880.html#a11f31444e8584e4debf0d6b706d66880">exp()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_a705bd4fd968224a6a32cf224d229fdba.html#a705bd4fd968224a6a32cf224d229fdba">More...</a><br /></td></tr>
<tr class="separator:a705bd4fd968224a6a32cf224d229fdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8612b95e935a3ed83b1b152363dde020"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8612b95e935a3ed83b1b152363dde020"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8612b95e935a3ed83b1b152363dde020.html#a8612b95e935a3ed83b1b152363dde020">exp2</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a8612b95e935a3ed83b1b152363dde020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a8c3a577694c8f584e56160580fe0821b.html#a8c3a577694c8f584e56160580fe0821b">exp2()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_a8612b95e935a3ed83b1b152363dde020.html#a8612b95e935a3ed83b1b152363dde020">More...</a><br /></td></tr>
<tr class="separator:a8612b95e935a3ed83b1b152363dde020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6d9f7e0eb96eedb00275de60da3d9b"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5e6d9f7e0eb96eedb00275de60da3d9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5e6d9f7e0eb96eedb00275de60da3d9b.html#a5e6d9f7e0eb96eedb00275de60da3d9b">expm1</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a5e6d9f7e0eb96eedb00275de60da3d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a8a76b658b94fcf8943f4fb41c586ec94.html#a8a76b658b94fcf8943f4fb41c586ec94">expm1()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_a5e6d9f7e0eb96eedb00275de60da3d9b.html#a5e6d9f7e0eb96eedb00275de60da3d9b">More...</a><br /></td></tr>
<tr class="separator:a5e6d9f7e0eb96eedb00275de60da3d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac53ba951aa4103b82f2d59e87b2cf8f"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aac53ba951aa4103b82f2d59e87b2cf8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aac53ba951aa4103b82f2d59e87b2cf8f.html#aac53ba951aa4103b82f2d59e87b2cf8f">fabs</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aac53ba951aa4103b82f2d59e87b2cf8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a6c79c9be5c64873b74f3c6924fef6911.html#a6c79c9be5c64873b74f3c6924fef6911">fabs()</a></code> of the input <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;<a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;double&gt;&gt;</code>.  <a href="namespacestan_1_1math_aac53ba951aa4103b82f2d59e87b2cf8f.html#aac53ba951aa4103b82f2d59e87b2cf8f">More...</a><br /></td></tr>
<tr class="separator:aac53ba951aa4103b82f2d59e87b2cf8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b83a7ab00591cd87dfe6755c049c1f"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a93b83a7ab00591cd87dfe6755c049c1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a93b83a7ab00591cd87dfe6755c049c1f.html#a93b83a7ab00591cd87dfe6755c049c1f">fdim</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a93b83a7ab00591cd87dfe6755c049c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference between the first variable's the value and the second's (C99, C++11).  <a href="namespacestan_1_1math_a93b83a7ab00591cd87dfe6755c049c1f.html#a93b83a7ab00591cd87dfe6755c049c1f">More...</a><br /></td></tr>
<tr class="separator:a93b83a7ab00591cd87dfe6755c049c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a1c4ac6916c14687b3726027a045fc"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a13a1c4ac6916c14687b3726027a045fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a13a1c4ac6916c14687b3726027a045fc.html#a13a1c4ac6916c14687b3726027a045fc">floor</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a13a1c4ac6916c14687b3726027a045fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a16e5a2666b377e37fe807765ba5f6aaf.html#a16e5a2666b377e37fe807765ba5f6aaf">floor()</a></code> of the input <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;<a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;double&gt;&gt;</code>.  <a href="namespacestan_1_1math_a13a1c4ac6916c14687b3726027a045fc.html#a13a1c4ac6916c14687b3726027a045fc">More...</a><br /></td></tr>
<tr class="separator:a13a1c4ac6916c14687b3726027a045fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ff172a4b26cf75eacc883de05fef24"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a06ff172a4b26cf75eacc883de05fef24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a06ff172a4b26cf75eacc883de05fef24.html#a06ff172a4b26cf75eacc883de05fef24">fmax</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a06ff172a4b26cf75eacc883de05fef24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greater of the two specified arguments.  <a href="namespacestan_1_1math_a06ff172a4b26cf75eacc883de05fef24.html#a06ff172a4b26cf75eacc883de05fef24">More...</a><br /></td></tr>
<tr class="separator:a06ff172a4b26cf75eacc883de05fef24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f4ff8a14dd3b7f5aef2372715b5926"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a96f4ff8a14dd3b7f5aef2372715b5926"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a96f4ff8a14dd3b7f5aef2372715b5926.html#a96f4ff8a14dd3b7f5aef2372715b5926">fmin</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a96f4ff8a14dd3b7f5aef2372715b5926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lesser of the two specified arguments.  <a href="namespacestan_1_1math_a96f4ff8a14dd3b7f5aef2372715b5926.html#a96f4ff8a14dd3b7f5aef2372715b5926">More...</a><br /></td></tr>
<tr class="separator:a96f4ff8a14dd3b7f5aef2372715b5926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f97c1c7df43fae0091fed2f3c77621"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a97f97c1c7df43fae0091fed2f3c77621"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a97f97c1c7df43fae0091fed2f3c77621.html#a97f97c1c7df43fae0091fed2f3c77621">fmod</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a97f97c1c7df43fae0091fed2f3c77621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floating point remainder after dividing the first variable by the second (cmath).  <a href="namespacestan_1_1math_a97f97c1c7df43fae0091fed2f3c77621.html#a97f97c1c7df43fae0091fed2f3c77621">More...</a><br /></td></tr>
<tr class="separator:a97f97c1c7df43fae0091fed2f3c77621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc62a35a25401815376b4dd231a6653"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5cc62a35a25401815376b4dd231a6653"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5cc62a35a25401815376b4dd231a6653.html#a5cc62a35a25401815376b4dd231a6653">hypot</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a5cc62a35a25401815376b4dd231a6653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_acd88cd5e3b00b9d099acd2482ca6fbf2.html#acd88cd5e3b00b9d099acd2482ca6fbf2" title="Return the length of the hypotenuse of a right triangle with opposite and adjacent side lengths given...">hypot()</a></code> of the input.  <a href="namespacestan_1_1math_a5cc62a35a25401815376b4dd231a6653.html#a5cc62a35a25401815376b4dd231a6653">More...</a><br /></td></tr>
<tr class="separator:a5cc62a35a25401815376b4dd231a6653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa412be39734b64a9ad4601fb6f0b4365"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa412be39734b64a9ad4601fb6f0b4365"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa412be39734b64a9ad4601fb6f0b4365.html#aa412be39734b64a9ad4601fb6f0b4365">inv</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aa412be39734b64a9ad4601fb6f0b4365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a2a5386561ba622e05cb64345fdad6a3b.html#a2a5386561ba622e05cb64345fdad6a3b">inv()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_aa412be39734b64a9ad4601fb6f0b4365.html#aa412be39734b64a9ad4601fb6f0b4365">More...</a><br /></td></tr>
<tr class="separator:aa412be39734b64a9ad4601fb6f0b4365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb633cb2cf4a8a20b2c0d50436da0cc7"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afb633cb2cf4a8a20b2c0d50436da0cc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afb633cb2cf4a8a20b2c0d50436da0cc7.html#afb633cb2cf4a8a20b2c0d50436da0cc7">inv_cloglog</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:afb633cb2cf4a8a20b2c0d50436da0cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aba00ed1e73c3a2366226aa4c83e4d8b9.html#aba00ed1e73c3a2366226aa4c83e4d8b9">inv_cloglog()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_afb633cb2cf4a8a20b2c0d50436da0cc7.html#afb633cb2cf4a8a20b2c0d50436da0cc7">More...</a><br /></td></tr>
<tr class="separator:afb633cb2cf4a8a20b2c0d50436da0cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456fabc02d75af58ac3d77a8356f6770"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a456fabc02d75af58ac3d77a8356f6770"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a456fabc02d75af58ac3d77a8356f6770.html#a456fabc02d75af58ac3d77a8356f6770">inv_logit</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a456fabc02d75af58ac3d77a8356f6770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a76a22ee34432be58edb4b6ed9469370a.html#a76a22ee34432be58edb4b6ed9469370a" title="Returns the inverse logit function applied to the argument.">inv_logit()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_a456fabc02d75af58ac3d77a8356f6770.html#a456fabc02d75af58ac3d77a8356f6770">More...</a><br /></td></tr>
<tr class="separator:a456fabc02d75af58ac3d77a8356f6770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3392ed3ebcfd2c39d51426a246feb21c"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3392ed3ebcfd2c39d51426a246feb21c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3392ed3ebcfd2c39d51426a246feb21c.html#a3392ed3ebcfd2c39d51426a246feb21c">inv_Phi</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a3392ed3ebcfd2c39d51426a246feb21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a91bcae4b6bdf262f91673bf7b15fea99.html#a91bcae4b6bdf262f91673bf7b15fea99">inv_Phi()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_a3392ed3ebcfd2c39d51426a246feb21c.html#a3392ed3ebcfd2c39d51426a246feb21c">More...</a><br /></td></tr>
<tr class="separator:a3392ed3ebcfd2c39d51426a246feb21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ae3acf5879349edf336519effc5587"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a00ae3acf5879349edf336519effc5587"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a00ae3acf5879349edf336519effc5587.html#a00ae3acf5879349edf336519effc5587">inv_sqrt</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a00ae3acf5879349edf336519effc5587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aca2d4971bfd22beacb304bdd5b9d3395.html#aca2d4971bfd22beacb304bdd5b9d3395">inv_sqrt()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_a00ae3acf5879349edf336519effc5587.html#a00ae3acf5879349edf336519effc5587">More...</a><br /></td></tr>
<tr class="separator:a00ae3acf5879349edf336519effc5587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44ddac9c7baf12f39074a90e7b0dd02"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab44ddac9c7baf12f39074a90e7b0dd02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab44ddac9c7baf12f39074a90e7b0dd02.html#ab44ddac9c7baf12f39074a90e7b0dd02">inv_square</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ab44ddac9c7baf12f39074a90e7b0dd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aa7c1f6b0f3c9f48fa30e09f2d929336d.html#aa7c1f6b0f3c9f48fa30e09f2d929336d">inv_square()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_ab44ddac9c7baf12f39074a90e7b0dd02.html#ab44ddac9c7baf12f39074a90e7b0dd02">More...</a><br /></td></tr>
<tr class="separator:ab44ddac9c7baf12f39074a90e7b0dd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c8bde53746b792203eab36d8f92f87"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_lb , require_all_prim_or_rev_kernel_expression_t&lt; T_x, T_lb &gt; *  = nullptr, require_any_var_t&lt; T_x, T_lb &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_x, T_lb &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a59c8bde53746b792203eab36d8f92f87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a59c8bde53746b792203eab36d8f92f87.html#a59c8bde53746b792203eab36d8f92f87">lb_constrain</a> (T_x &amp;&amp;x, T_lb &amp;&amp;lb)</td></tr>
<tr class="memdesc:a59c8bde53746b792203eab36d8f92f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-bounded value for the specified unconstrained input and specified lower bound.  <a href="namespacestan_1_1math_a59c8bde53746b792203eab36d8f92f87.html#a59c8bde53746b792203eab36d8f92f87">More...</a><br /></td></tr>
<tr class="separator:a59c8bde53746b792203eab36d8f92f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae058e9d76abda9cc9cecfb209f4ec429"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_lb , require_all_prim_or_rev_kernel_expression_t&lt; T_x, T_lb &gt; *  = nullptr, require_any_var_t&lt; T_x, T_lb &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_x, T_lb &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae058e9d76abda9cc9cecfb209f4ec429"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae058e9d76abda9cc9cecfb209f4ec429.html#ae058e9d76abda9cc9cecfb209f4ec429">lb_constrain</a> (T_x &amp;&amp;x, T_lb &amp;&amp;lb, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;lp)</td></tr>
<tr class="memdesc:ae058e9d76abda9cc9cecfb209f4ec429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-bounded value for the specified unconstrained input and specified lower bound.  <a href="namespacestan_1_1math_ae058e9d76abda9cc9cecfb209f4ec429.html#ae058e9d76abda9cc9cecfb209f4ec429">More...</a><br /></td></tr>
<tr class="separator:ae058e9d76abda9cc9cecfb209f4ec429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145cd3f9ec5c450897beb350e557152a"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a145cd3f9ec5c450897beb350e557152a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a145cd3f9ec5c450897beb350e557152a.html#a145cd3f9ec5c450897beb350e557152a">lbeta</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a145cd3f9ec5c450897beb350e557152a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise <code><a class="el" href="namespacestan_1_1math_ac51be9d210e223a8aa4241e2d725e295.html#ac51be9d210e223a8aa4241e2d725e295">lbeta()</a></code> on two input kernel generator expression.  <a href="namespacestan_1_1math_a145cd3f9ec5c450897beb350e557152a.html#a145cd3f9ec5c450897beb350e557152a">More...</a><br /></td></tr>
<tr class="separator:a145cd3f9ec5c450897beb350e557152a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb3979ced4f8e093c775efda5b43ac3"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_kernel_expressions_t&lt; T_a, T_b &gt; *  = nullptr, require_st_integral&lt; T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aadb3979ced4f8e093c775efda5b43ac3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aadb3979ced4f8e093c775efda5b43ac3.html#aadb3979ced4f8e093c775efda5b43ac3">ldexp</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T_a &gt; &amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:aadb3979ced4f8e093c775efda5b43ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a0285044dc46f4fb351a4048f39f53096.html#a0285044dc46f4fb351a4048f39f53096" title="Returns the product of a (the significand) times 2 to power b (the exponent).">ldexp()</a></code> of the input <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;<a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;double&gt;&gt;</code> and kernel generator expression.  <a href="namespacestan_1_1math_aadb3979ced4f8e093c775efda5b43ac3.html#aadb3979ced4f8e093c775efda5b43ac3">More...</a><br /></td></tr>
<tr class="separator:aadb3979ced4f8e093c775efda5b43ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07acd576d5a15d3f105a93a1fb9fc847"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a07acd576d5a15d3f105a93a1fb9fc847"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a07acd576d5a15d3f105a93a1fb9fc847.html#a07acd576d5a15d3f105a93a1fb9fc847">lgamma</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a07acd576d5a15d3f105a93a1fb9fc847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aead76f03bdbc60484ad760fc31bad40f.html#aead76f03bdbc60484ad760fc31bad40f" title="Return the natural logarithm of the gamma function applied to the specified argument.">lgamma()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_a07acd576d5a15d3f105a93a1fb9fc847.html#a07acd576d5a15d3f105a93a1fb9fc847">More...</a><br /></td></tr>
<tr class="separator:a07acd576d5a15d3f105a93a1fb9fc847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f145946af29838c8450a5775cf62b32"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5f145946af29838c8450a5775cf62b32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5f145946af29838c8450a5775cf62b32.html#a5f145946af29838c8450a5775cf62b32">lmultiply</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a5f145946af29838c8450a5775cf62b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a329536a85718ab3c9506b87a17bc7a8b.html#a329536a85718ab3c9506b87a17bc7a8b">lmultiply()</a></code> of the input.  <a href="namespacestan_1_1math_a5f145946af29838c8450a5775cf62b32.html#a5f145946af29838c8450a5775cf62b32">More...</a><br /></td></tr>
<tr class="separator:a5f145946af29838c8450a5775cf62b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9350c87a0eca56191b4fb36b5259e16c"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9350c87a0eca56191b4fb36b5259e16c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9350c87a0eca56191b4fb36b5259e16c.html#a9350c87a0eca56191b4fb36b5259e16c">log</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a9350c87a0eca56191b4fb36b5259e16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a915ada1e5971c467aa16ee926997a442.html#a915ada1e5971c467aa16ee926997a442">log()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_a9350c87a0eca56191b4fb36b5259e16c.html#a9350c87a0eca56191b4fb36b5259e16c">More...</a><br /></td></tr>
<tr class="separator:a9350c87a0eca56191b4fb36b5259e16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26c85ad5b6fc3886966594465665afd"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab26c85ad5b6fc3886966594465665afd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab26c85ad5b6fc3886966594465665afd.html#ab26c85ad5b6fc3886966594465665afd">log10</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ab26c85ad5b6fc3886966594465665afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a808cbb5ac4003f28e2538805ebe338ef.html#a808cbb5ac4003f28e2538805ebe338ef">log10()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_ab26c85ad5b6fc3886966594465665afd.html#ab26c85ad5b6fc3886966594465665afd">More...</a><br /></td></tr>
<tr class="separator:ab26c85ad5b6fc3886966594465665afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2afa4a2136ac9fb956aa1009b8d7ce"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2a2afa4a2136ac9fb956aa1009b8d7ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2a2afa4a2136ac9fb956aa1009b8d7ce.html#a2a2afa4a2136ac9fb956aa1009b8d7ce">log1m</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a2a2afa4a2136ac9fb956aa1009b8d7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a8d92a982acd829e77b3f5b975baa6aed.html#a8d92a982acd829e77b3f5b975baa6aed">log1m()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_a2a2afa4a2136ac9fb956aa1009b8d7ce.html#a2a2afa4a2136ac9fb956aa1009b8d7ce">More...</a><br /></td></tr>
<tr class="separator:a2a2afa4a2136ac9fb956aa1009b8d7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade031b0a14fbc98a6b2e0394dd83718c"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ade031b0a14fbc98a6b2e0394dd83718c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade031b0a14fbc98a6b2e0394dd83718c.html#ade031b0a14fbc98a6b2e0394dd83718c">log1m_exp</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ade031b0a14fbc98a6b2e0394dd83718c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a7760d28e8fddf268113469b44463de07.html#a7760d28e8fddf268113469b44463de07" title="Return the natural logarithm of one minus the exponentiation of the specified argument.">log1m_exp()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_ade031b0a14fbc98a6b2e0394dd83718c.html#ade031b0a14fbc98a6b2e0394dd83718c">More...</a><br /></td></tr>
<tr class="separator:ade031b0a14fbc98a6b2e0394dd83718c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6b64b2589a17d8f907fb27483c5d22"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aea6b64b2589a17d8f907fb27483c5d22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aea6b64b2589a17d8f907fb27483c5d22.html#aea6b64b2589a17d8f907fb27483c5d22">log1m_inv_logit</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aea6b64b2589a17d8f907fb27483c5d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a79f286f8a9043aee8a1a844493da0d55.html#a79f286f8a9043aee8a1a844493da0d55" title="Return the natural logarithm of one minus the inverse logit of the specified argument.">log1m_inv_logit()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_aea6b64b2589a17d8f907fb27483c5d22.html#aea6b64b2589a17d8f907fb27483c5d22">More...</a><br /></td></tr>
<tr class="separator:aea6b64b2589a17d8f907fb27483c5d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0da0f643d3608cc99ac1b5a8e4185b"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aec0da0f643d3608cc99ac1b5a8e4185b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aec0da0f643d3608cc99ac1b5a8e4185b.html#aec0da0f643d3608cc99ac1b5a8e4185b">log1p</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aec0da0f643d3608cc99ac1b5a8e4185b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aa16e57e82fb1e17f74ef43592748ff32.html#aa16e57e82fb1e17f74ef43592748ff32">log1p()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_aec0da0f643d3608cc99ac1b5a8e4185b.html#aec0da0f643d3608cc99ac1b5a8e4185b">More...</a><br /></td></tr>
<tr class="separator:aec0da0f643d3608cc99ac1b5a8e4185b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3758ccc144e2008ad245115ded733b6c"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3758ccc144e2008ad245115ded733b6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3758ccc144e2008ad245115ded733b6c.html#a3758ccc144e2008ad245115ded733b6c">log1p_exp</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a3758ccc144e2008ad245115ded733b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a0fe928ad2b96b802f6d488ba43167489.html#a0fe928ad2b96b802f6d488ba43167489">log1p_exp()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_a3758ccc144e2008ad245115ded733b6c.html#a3758ccc144e2008ad245115ded733b6c">More...</a><br /></td></tr>
<tr class="separator:a3758ccc144e2008ad245115ded733b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f110b578d74827b8ed4b88ffbec1f62"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7f110b578d74827b8ed4b88ffbec1f62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7f110b578d74827b8ed4b88ffbec1f62.html#a7f110b578d74827b8ed4b88ffbec1f62">log2</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a7f110b578d74827b8ed4b88ffbec1f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a4eea39b4ca603cff7518068499884364.html#a4eea39b4ca603cff7518068499884364" title="Return the base two logarithm of the specified argument.">log2()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_a7f110b578d74827b8ed4b88ffbec1f62.html#a7f110b578d74827b8ed4b88ffbec1f62">More...</a><br /></td></tr>
<tr class="separator:a7f110b578d74827b8ed4b88ffbec1f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ecf6c2ee93686a8d75333949334867"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_y , require_all_prim_or_rev_kernel_expression_t&lt; T_x, T_y &gt; *  = nullptr, require_any_var_t&lt; T_x, T_y &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_x, T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a10ecf6c2ee93686a8d75333949334867"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a10ecf6c2ee93686a8d75333949334867.html#a10ecf6c2ee93686a8d75333949334867">log_diff_exp</a> (T_x &amp;&amp;x, T_y &amp;&amp;y)</td></tr>
<tr class="memdesc:a10ecf6c2ee93686a8d75333949334867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the difference of the natural exponentiation of x and the natural exponentiation of y.  <a href="namespacestan_1_1math_a10ecf6c2ee93686a8d75333949334867.html#a10ecf6c2ee93686a8d75333949334867">More...</a><br /></td></tr>
<tr class="separator:a10ecf6c2ee93686a8d75333949334867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd25cb957cae911254303a07ca2f0a4d"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afd25cb957cae911254303a07ca2f0a4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afd25cb957cae911254303a07ca2f0a4d.html#afd25cb957cae911254303a07ca2f0a4d">log_inv_logit</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:afd25cb957cae911254303a07ca2f0a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_acd2fe56bce70a04dd11e8a5a32b1b51c.html#acd2fe56bce70a04dd11e8a5a32b1b51c">log_inv_logit()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_afd25cb957cae911254303a07ca2f0a4d.html#afd25cb957cae911254303a07ca2f0a4d">More...</a><br /></td></tr>
<tr class="separator:afd25cb957cae911254303a07ca2f0a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecdfb3ba67fedca0c6377c27471598d"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_y , require_all_prim_or_rev_kernel_expression_t&lt; T_x, T_y &gt; *  = nullptr, require_any_var_t&lt; T_x, T_y &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_x, T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afecdfb3ba67fedca0c6377c27471598d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afecdfb3ba67fedca0c6377c27471598d.html#afecdfb3ba67fedca0c6377c27471598d">log_inv_logit_diff</a> (T_x &amp;&amp;x, T_y &amp;&amp;y)</td></tr>
<tr class="memdesc:afecdfb3ba67fedca0c6377c27471598d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the difference of the inverse logits of the specified arguments.  <a href="namespacestan_1_1math_afecdfb3ba67fedca0c6377c27471598d.html#afecdfb3ba67fedca0c6377c27471598d">More...</a><br /></td></tr>
<tr class="separator:afecdfb3ba67fedca0c6377c27471598d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadc980ca7d270730b4f24eb9102ff92"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaadc980ca7d270730b4f24eb9102ff92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaadc980ca7d270730b4f24eb9102ff92.html#aaadc980ca7d270730b4f24eb9102ff92">log_softmax</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aaadc980ca7d270730b4f24eb9102ff92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return log of the softmax of the specified vector.  <a href="namespacestan_1_1math_aaadc980ca7d270730b4f24eb9102ff92.html#aaadc980ca7d270730b4f24eb9102ff92">More...</a><br /></td></tr>
<tr class="separator:aaadc980ca7d270730b4f24eb9102ff92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bbed3309d13b19e01cb7e3b9cf4b55"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a25bbed3309d13b19e01cb7e3b9cf4b55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a25bbed3309d13b19e01cb7e3b9cf4b55.html#a25bbed3309d13b19e01cb7e3b9cf4b55">log_sum_exp</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a25bbed3309d13b19e01cb7e3b9cf4b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the sum of the exponentiated values of the specified matrix of values.  <a href="namespacestan_1_1math_a25bbed3309d13b19e01cb7e3b9cf4b55.html#a25bbed3309d13b19e01cb7e3b9cf4b55">More...</a><br /></td></tr>
<tr class="separator:a25bbed3309d13b19e01cb7e3b9cf4b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990f0b0d065f492269e57011501166c3"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a990f0b0d065f492269e57011501166c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a990f0b0d065f492269e57011501166c3.html#a990f0b0d065f492269e57011501166c3">logit</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a990f0b0d065f492269e57011501166c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ab025eaf1e6f5c920f69c37e7a7f8b319.html#ab025eaf1e6f5c920f69c37e7a7f8b319">logit()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_a990f0b0d065f492269e57011501166c3.html#a990f0b0d065f492269e57011501166c3">More...</a><br /></td></tr>
<tr class="separator:a990f0b0d065f492269e57011501166c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0638be0501c5e77c63f8d7182e50977a"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_lb , typename T_ub , require_all_prim_or_rev_kernel_expression_t&lt; T_x, T_lb, T_ub &gt; *  = nullptr, require_any_var_t&lt; T_x, T_lb, T_ub &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_x, T_lb, T_ub &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0638be0501c5e77c63f8d7182e50977a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0638be0501c5e77c63f8d7182e50977a.html#a0638be0501c5e77c63f8d7182e50977a">lub_constrain</a> (T_x &amp;&amp;x, T_lb &amp;&amp;lb, T_ub &amp;&amp;ub)</td></tr>
<tr class="memdesc:a0638be0501c5e77c63f8d7182e50977a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bounded value for the specified unconstrained input and specified bounds.  <a href="namespacestan_1_1math_a0638be0501c5e77c63f8d7182e50977a.html#a0638be0501c5e77c63f8d7182e50977a">More...</a><br /></td></tr>
<tr class="separator:a0638be0501c5e77c63f8d7182e50977a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd0ff1a70478787f76df22247323988"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_lb , typename T_ub , require_all_prim_or_rev_kernel_expression_t&lt; T_x, T_lb, T_ub &gt; *  = nullptr, require_any_var_t&lt; T_x, T_lb, T_ub &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_x, T_lb, T_ub &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4cd0ff1a70478787f76df22247323988"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4cd0ff1a70478787f76df22247323988.html#a4cd0ff1a70478787f76df22247323988">lub_constrain</a> (T_x &amp;&amp;x, T_lb &amp;&amp;lb, T_ub &amp;&amp;ub, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;lp)</td></tr>
<tr class="memdesc:a4cd0ff1a70478787f76df22247323988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bounded value for the specified unconstrained input and specified bounds.  <a href="namespacestan_1_1math_a4cd0ff1a70478787f76df22247323988.html#a4cd0ff1a70478787f76df22247323988">More...</a><br /></td></tr>
<tr class="separator:a4cd0ff1a70478787f76df22247323988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bc1f4cc0d2b4587ddccf89ac3c9fd4"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a47bc1f4cc0d2b4587ddccf89ac3c9fd4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a47bc1f4cc0d2b4587ddccf89ac3c9fd4.html#a47bc1f4cc0d2b4587ddccf89ac3c9fd4">matrix_power</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;M, const int n)</td></tr>
<tr class="memdesc:a47bc1f4cc0d2b4587ddccf89ac3c9fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth power of the specific matrix.  <a href="namespacestan_1_1math_a47bc1f4cc0d2b4587ddccf89ac3c9fd4.html#a47bc1f4cc0d2b4587ddccf89ac3c9fd4">More...</a><br /></td></tr>
<tr class="separator:a47bc1f4cc0d2b4587ddccf89ac3c9fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe104ac35cd37b7aea268ccc456764ff"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T1, T2 &gt; *  = nullptr, require_any_var_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abe104ac35cd37b7aea268ccc456764ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abe104ac35cd37b7aea268ccc456764ff.html#abe104ac35cd37b7aea268ccc456764ff">mdivide_left_tri_low</a> (T1 &amp;&amp;A, T2 &amp;&amp;b)</td></tr>
<tr class="memdesc:abe104ac35cd37b7aea268ccc456764ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is lower triangular.  <a href="namespacestan_1_1math_abe104ac35cd37b7aea268ccc456764ff.html#abe104ac35cd37b7aea268ccc456764ff">More...</a><br /></td></tr>
<tr class="separator:abe104ac35cd37b7aea268ccc456764ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c78c553e2d8f48edd8e565fd8612a6"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a03c78c553e2d8f48edd8e565fd8612a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a03c78c553e2d8f48edd8e565fd8612a6.html#a03c78c553e2d8f48edd8e565fd8612a6">mdivide_left_tri_low</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a03c78c553e2d8f48edd8e565fd8612a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is triangular and b=I.  <a href="namespacestan_1_1math_a03c78c553e2d8f48edd8e565fd8612a6.html#a03c78c553e2d8f48edd8e565fd8612a6">More...</a><br /></td></tr>
<tr class="separator:a03c78c553e2d8f48edd8e565fd8612a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778e7bc4e8e8935d2f10778981067acb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T1, T2 &gt; *  = nullptr, require_any_var_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a778e7bc4e8e8935d2f10778981067acb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a778e7bc4e8e8935d2f10778981067acb.html#a778e7bc4e8e8935d2f10778981067acb">mdivide_right_tri_low</a> (T2 &amp;&amp;b, T1 &amp;&amp;A)</td></tr>
<tr class="memdesc:a778e7bc4e8e8935d2f10778981067acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is lower triangular.  <a href="namespacestan_1_1math_a778e7bc4e8e8935d2f10778981067acb.html#a778e7bc4e8e8935d2f10778981067acb">More...</a><br /></td></tr>
<tr class="separator:a778e7bc4e8e8935d2f10778981067acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c20cca427caf289a9770bd13ece1b8f"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6c20cca427caf289a9770bd13ece1b8f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6c20cca427caf289a9770bd13ece1b8f.html#a6c20cca427caf289a9770bd13ece1b8f">multiply</a> (T_a &amp;&amp;A, T_b &amp;&amp;B)</td></tr>
<tr class="memdesc:a6c20cca427caf289a9770bd13ece1b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiplication of two reverse mode matrices and/or kernel generator expressions.  <a href="namespacestan_1_1math_a6c20cca427caf289a9770bd13ece1b8f.html#a6c20cca427caf289a9770bd13ece1b8f">More...</a><br /></td></tr>
<tr class="separator:a6c20cca427caf289a9770bd13ece1b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e3f28cfcf809bbf1ba8ac90c3acd3f"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a77e3f28cfcf809bbf1ba8ac90c3acd3f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a77e3f28cfcf809bbf1ba8ac90c3acd3f.html#a77e3f28cfcf809bbf1ba8ac90c3acd3f">operator*</a> (const T_a &amp;A, const T_b &amp;B)</td></tr>
<tr class="memdesc:a77e3f28cfcf809bbf1ba8ac90c3acd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiplication of two reverse mode matrices and/or kernel generator expressions.  <a href="namespacestan_1_1math_a77e3f28cfcf809bbf1ba8ac90c3acd3f.html#a77e3f28cfcf809bbf1ba8ac90c3acd3f">More...</a><br /></td></tr>
<tr class="separator:a77e3f28cfcf809bbf1ba8ac90c3acd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf6123f0f01a7ceb2c39a08822076a6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_stan_scalar_t&lt; T1 &gt; *  = nullptr, require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T2 &gt; *  = nullptr, require_any_var_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaaf6123f0f01a7ceb2c39a08822076a6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaaf6123f0f01a7ceb2c39a08822076a6.html#aaaf6123f0f01a7ceb2c39a08822076a6">multiply</a> (const T1 &amp;A, T2 &amp;&amp;B)</td></tr>
<tr class="memdesc:aaaf6123f0f01a7ceb2c39a08822076a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return matrix multiplied by a scalar.  <a href="namespacestan_1_1math_aaaf6123f0f01a7ceb2c39a08822076a6.html#aaaf6123f0f01a7ceb2c39a08822076a6">More...</a><br /></td></tr>
<tr class="separator:aaaf6123f0f01a7ceb2c39a08822076a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2893c33058a11f28b8480e66863bcdb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_stan_scalar_t&lt; T2 &gt; *  = nullptr, require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T1 &gt; *  = nullptr, require_any_var_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac2893c33058a11f28b8480e66863bcdb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac2893c33058a11f28b8480e66863bcdb.html#ac2893c33058a11f28b8480e66863bcdb">multiply</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:ac2893c33058a11f28b8480e66863bcdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return matrix multiplied by a scalar.  <a href="namespacestan_1_1math_ac2893c33058a11f28b8480e66863bcdb.html#ac2893c33058a11f28b8480e66863bcdb">More...</a><br /></td></tr>
<tr class="separator:ac2893c33058a11f28b8480e66863bcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed66bb0307518f1b71467df2d50c78e"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeed66bb0307518f1b71467df2d50c78e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeed66bb0307518f1b71467df2d50c78e.html#aeed66bb0307518f1b71467df2d50c78e">multiply_log</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:aeed66bb0307518f1b71467df2d50c78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a055efd6bb49a1df5ea4da98d1078d0e6.html#a055efd6bb49a1df5ea4da98d1078d0e6">multiply_log()</a></code> of the input.  <a href="namespacestan_1_1math_aeed66bb0307518f1b71467df2d50c78e.html#aeed66bb0307518f1b71467df2d50c78e">More...</a><br /></td></tr>
<tr class="separator:aeed66bb0307518f1b71467df2d50c78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0d13df91bfaef0e6b719ad2b3c8dd6"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3c0d13df91bfaef0e6b719ad2b3c8dd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3c0d13df91bfaef0e6b719ad2b3c8dd6.html#a3c0d13df91bfaef0e6b719ad2b3c8dd6">multiply_lower_tri_self_transpose</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a3c0d13df91bfaef0e6b719ad2b3c8dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of multiplying the lower triangular portion of the input matrix by its own transpose.  <a href="namespacestan_1_1math_a3c0d13df91bfaef0e6b719ad2b3c8dd6.html#a3c0d13df91bfaef0e6b719ad2b3c8dd6">More...</a><br /></td></tr>
<tr class="separator:a3c0d13df91bfaef0e6b719ad2b3c8dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2232114c16cfea7d0f9dce46e5f9886c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , require_all_prim_or_rev_kernel_expression_t&lt; T, M, S &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T, M, S &gt; *  = nullptr, require_any_var_t&lt; T, M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2232114c16cfea7d0f9dce46e5f9886c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2232114c16cfea7d0f9dce46e5f9886c.html#a2232114c16cfea7d0f9dce46e5f9886c">offset_multiplier_constrain</a> (T &amp;&amp;A, M &amp;&amp;mu, S &amp;&amp;sigma)</td></tr>
<tr class="memdesc:a2232114c16cfea7d0f9dce46e5f9886c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearly transformed value for the specified unconstrained input and specified offset and multiplier.  <a href="namespacestan_1_1math_a2232114c16cfea7d0f9dce46e5f9886c.html#a2232114c16cfea7d0f9dce46e5f9886c">More...</a><br /></td></tr>
<tr class="separator:a2232114c16cfea7d0f9dce46e5f9886c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c3c1b1069360ccb444089cd63fe255"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , require_all_prim_or_rev_kernel_expression_t&lt; T, M, S &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T, M, S &gt; *  = nullptr, require_any_var_t&lt; T, M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab7c3c1b1069360ccb444089cd63fe255"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab7c3c1b1069360ccb444089cd63fe255.html#ab7c3c1b1069360ccb444089cd63fe255">offset_multiplier_constrain</a> (T &amp;&amp;A, M &amp;&amp;mu, S &amp;&amp;sigma, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;lp)</td></tr>
<tr class="memdesc:ab7c3c1b1069360ccb444089cd63fe255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearly transformed value for the specified unconstrained input and specified offset and multiplier.  <a href="namespacestan_1_1math_ab7c3c1b1069360ccb444089cd63fe255.html#ab7c3c1b1069360ccb444089cd63fe255">More...</a><br /></td></tr>
<tr class="separator:ab7c3c1b1069360ccb444089cd63fe255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2fe07fbe4f070291d892b13b64bdef"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5f2fe07fbe4f070291d892b13b64bdef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5f2fe07fbe4f070291d892b13b64bdef.html#a5f2fe07fbe4f070291d892b13b64bdef">operator-</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;M)</td></tr>
<tr class="memdesc:a5f2fe07fbe4f070291d892b13b64bdef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unary minus of the input.  <a href="namespacestan_1_1math_a5f2fe07fbe4f070291d892b13b64bdef.html#a5f2fe07fbe4f070291d892b13b64bdef">More...</a><br /></td></tr>
<tr class="separator:a5f2fe07fbe4f070291d892b13b64bdef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac638e90807b1a1eb852b648e1fbda93a"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_vt&lt; is_kernel_expression_and_not_scalar, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac638e90807b1a1eb852b648e1fbda93a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac638e90807b1a1eb852b648e1fbda93a.html#ac638e90807b1a1eb852b648e1fbda93a">operator+</a> (T &amp;&amp;M)</td></tr>
<tr class="memdesc:ac638e90807b1a1eb852b648e1fbda93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unary plus of the input.  <a href="namespacestan_1_1math_ac638e90807b1a1eb852b648e1fbda93a.html#ac638e90807b1a1eb852b648e1fbda93a">More...</a><br /></td></tr>
<tr class="separator:ac638e90807b1a1eb852b648e1fbda93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988909dc181edef7f5aa6799f7e6038e"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a988909dc181edef7f5aa6799f7e6038e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a988909dc181edef7f5aa6799f7e6038e.html#a988909dc181edef7f5aa6799f7e6038e">Phi</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a988909dc181edef7f5aa6799f7e6038e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ac73a2c7f20161172ffee17c7c880019f.html#ac73a2c7f20161172ffee17c7c880019f">Phi()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_a988909dc181edef7f5aa6799f7e6038e.html#a988909dc181edef7f5aa6799f7e6038e">More...</a><br /></td></tr>
<tr class="separator:a988909dc181edef7f5aa6799f7e6038e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5ec4739c0187d842bdc1e5137de31b"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5c5ec4739c0187d842bdc1e5137de31b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5c5ec4739c0187d842bdc1e5137de31b.html#a5c5ec4739c0187d842bdc1e5137de31b">Phi_approx</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a5c5ec4739c0187d842bdc1e5137de31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a628f13a708272b55a72684f3ea8dede5.html#a628f13a708272b55a72684f3ea8dede5" title="Return an approximation of the unit normal cumulative distribution function (CDF).">Phi_approx()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_a5c5ec4739c0187d842bdc1e5137de31b.html#a5c5ec4739c0187d842bdc1e5137de31b">More...</a><br /></td></tr>
<tr class="separator:a5c5ec4739c0187d842bdc1e5137de31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af008861ec4b8f8c2255c5f54024f7893"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af008861ec4b8f8c2255c5f54024f7893"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af008861ec4b8f8c2255c5f54024f7893.html#af008861ec4b8f8c2255c5f54024f7893">pow</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:af008861ec4b8f8c2255c5f54024f7893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_af008861ec4b8f8c2255c5f54024f7893.html#af008861ec4b8f8c2255c5f54024f7893">More...</a><br /></td></tr>
<tr class="separator:af008861ec4b8f8c2255c5f54024f7893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec080f3ad157218ab928e8b1e072c38"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2ec080f3ad157218ab928e8b1e072c38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2ec080f3ad157218ab928e8b1e072c38.html#a2ec080f3ad157218ab928e8b1e072c38">prod</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a2ec080f3ad157218ab928e8b1e072c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the prod of the coefficients of the specified matrix on the OpenCL device.  <a href="namespacestan_1_1math_a2ec080f3ad157218ab928e8b1e072c38.html#a2ec080f3ad157218ab928e8b1e072c38">More...</a><br /></td></tr>
<tr class="separator:a2ec080f3ad157218ab928e8b1e072c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5c33973a4c2311bf3f9284149208417"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , require_var_vt&lt; is_matrix_cl, T_ret &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf5c33973a4c2311bf3f9284149208417"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaf5c33973a4c2311bf3f9284149208417.html#gaf5c33973a4c2311bf3f9284149208417">rep_matrix</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;A, int n, int m)</td></tr>
<tr class="separator:gaf5c33973a4c2311bf3f9284149208417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57212223aca8e2c1999b268efacecf33"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga57212223aca8e2c1999b268efacecf33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga57212223aca8e2c1999b268efacecf33.html#ga57212223aca8e2c1999b268efacecf33">rep_matrix</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A, int m)</td></tr>
<tr class="separator:ga57212223aca8e2c1999b268efacecf33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1eeeb735647bf0b842756f4b8956d6"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr, require_any_var_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6b1eeeb735647bf0b842756f4b8956d6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6b1eeeb735647bf0b842756f4b8956d6.html#a6b1eeeb735647bf0b842756f4b8956d6">reverse</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a6b1eeeb735647bf0b842756f4b8956d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reversed view into the specified vector or row vector.  <a href="namespacestan_1_1math_a6b1eeeb735647bf0b842756f4b8956d6.html#a6b1eeeb735647bf0b842756f4b8956d6">More...</a><br /></td></tr>
<tr class="separator:a6b1eeeb735647bf0b842756f4b8956d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1638cc797e6083eb87025ab7b2932e22"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1638cc797e6083eb87025ab7b2932e22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1638cc797e6083eb87025ab7b2932e22.html#a1638cc797e6083eb87025ab7b2932e22">round</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a1638cc797e6083eb87025ab7b2932e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_adb73c37a4cec41a69516391a2336fb11.html#adb73c37a4cec41a69516391a2336fb11" title="Return the closest integer to the specified argument, with halfway cases rounded away from zero.">round()</a></code> of the input <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;<a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;double&gt;&gt;</code>.  <a href="namespacestan_1_1math_a1638cc797e6083eb87025ab7b2932e22.html#a1638cc797e6083eb87025ab7b2932e22">More...</a><br /></td></tr>
<tr class="separator:a1638cc797e6083eb87025ab7b2932e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43caa8511e26278b8d3a1f9c4277bec"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_var_t&lt; T1, T2 &gt; *  = nullptr, require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac43caa8511e26278b8d3a1f9c4277bec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac43caa8511e26278b8d3a1f9c4277bec.html#ac43caa8511e26278b8d3a1f9c4277bec">rows_dot_product</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:ac43caa8511e26278b8d3a1f9c4277bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of rows of the specified matrices.  <a href="namespacestan_1_1math_ac43caa8511e26278b8d3a1f9c4277bec.html#ac43caa8511e26278b8d3a1f9c4277bec">More...</a><br /></td></tr>
<tr class="separator:ac43caa8511e26278b8d3a1f9c4277bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae432cb232ca257ae10b0460165ab0f86"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae432cb232ca257ae10b0460165ab0f86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae432cb232ca257ae10b0460165ab0f86.html#ae432cb232ca257ae10b0460165ab0f86">rows_dot_self</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ae432cb232ca257ae10b0460165ab0f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each row of a matrix with itself.  <a href="namespacestan_1_1math_ae432cb232ca257ae10b0460165ab0f86.html#ae432cb232ca257ae10b0460165ab0f86">More...</a><br /></td></tr>
<tr class="separator:ae432cb232ca257ae10b0460165ab0f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab856c561a6611fe9e71ee4cf27c999b"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aab856c561a6611fe9e71ee4cf27c999b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab856c561a6611fe9e71ee4cf27c999b.html#aab856c561a6611fe9e71ee4cf27c999b">sd</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aab856c561a6611fe9e71ee4cf27c999b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample standard deviation of the <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a> matrix.  <a href="namespacestan_1_1math_aab856c561a6611fe9e71ee4cf27c999b.html#aab856c561a6611fe9e71ee4cf27c999b">More...</a><br /></td></tr>
<tr class="separator:aab856c561a6611fe9e71ee4cf27c999b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5203126bc856182df688ac884a277d9b"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5203126bc856182df688ac884a277d9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5203126bc856182df688ac884a277d9b.html#a5203126bc856182df688ac884a277d9b">sin</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a5203126bc856182df688ac884a277d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ae6cb3a9041ae0b7855b398c3e11cda48.html#ae6cb3a9041ae0b7855b398c3e11cda48">cos()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt; in radians.  <a href="namespacestan_1_1math_a5203126bc856182df688ac884a277d9b.html#a5203126bc856182df688ac884a277d9b">More...</a><br /></td></tr>
<tr class="separator:a5203126bc856182df688ac884a277d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b7599f4d8d92826808f185567ccc69"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a55b7599f4d8d92826808f185567ccc69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a55b7599f4d8d92826808f185567ccc69.html#a55b7599f4d8d92826808f185567ccc69">sinh</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a55b7599f4d8d92826808f185567ccc69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ae6cb3a9041ae0b7855b398c3e11cda48.html#ae6cb3a9041ae0b7855b398c3e11cda48">cos()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt; in radians.  <a href="namespacestan_1_1math_a55b7599f4d8d92826808f185567ccc69.html#a55b7599f4d8d92826808f185567ccc69">More...</a><br /></td></tr>
<tr class="separator:a55b7599f4d8d92826808f185567ccc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7eea76a7d6c0757836b58d845e0971"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4d7eea76a7d6c0757836b58d845e0971"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4d7eea76a7d6c0757836b58d845e0971.html#a4d7eea76a7d6c0757836b58d845e0971">softmax</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a4d7eea76a7d6c0757836b58d845e0971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns softmax of given argument.  <a href="namespacestan_1_1math_a4d7eea76a7d6c0757836b58d845e0971.html#a4d7eea76a7d6c0757836b58d845e0971">More...</a><br /></td></tr>
<tr class="separator:a4d7eea76a7d6c0757836b58d845e0971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17ec169c80246da69aebeeaece1fc9c"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac17ec169c80246da69aebeeaece1fc9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac17ec169c80246da69aebeeaece1fc9c.html#ac17ec169c80246da69aebeeaece1fc9c">sqrt</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ac17ec169c80246da69aebeeaece1fc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aa5231d132852d58cd3fe610221c9766f.html#aa5231d132852d58cd3fe610221c9766f">sqrt()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_ac17ec169c80246da69aebeeaece1fc9c.html#ac17ec169c80246da69aebeeaece1fc9c">More...</a><br /></td></tr>
<tr class="separator:ac17ec169c80246da69aebeeaece1fc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac873245b8166760406e5bf7ddc072f18"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac873245b8166760406e5bf7ddc072f18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac873245b8166760406e5bf7ddc072f18.html#ac873245b8166760406e5bf7ddc072f18">square</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ac873245b8166760406e5bf7ddc072f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ab1ed68bdfff9b340a187964ef7684091.html#ab1ed68bdfff9b340a187964ef7684091">square()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_ac873245b8166760406e5bf7ddc072f18.html#ac873245b8166760406e5bf7ddc072f18">More...</a><br /></td></tr>
<tr class="separator:ac873245b8166760406e5bf7ddc072f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026cd0f9b7a3a19d38740af0dbb5eb6e"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a026cd0f9b7a3a19d38740af0dbb5eb6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a026cd0f9b7a3a19d38740af0dbb5eb6e.html#a026cd0f9b7a3a19d38740af0dbb5eb6e">squared_distance</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a026cd0f9b7a3a19d38740af0dbb5eb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance.  <a href="namespacestan_1_1math_a026cd0f9b7a3a19d38740af0dbb5eb6e.html#a026cd0f9b7a3a19d38740af0dbb5eb6e">More...</a><br /></td></tr>
<tr class="separator:a026cd0f9b7a3a19d38740af0dbb5eb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bbb1bb36b78e354b1aaa13384fcabd"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a64bbb1bb36b78e354b1aaa13384fcabd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a64bbb1bb36b78e354b1aaa13384fcabd.html#a64bbb1bb36b78e354b1aaa13384fcabd">subtract</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a64bbb1bb36b78e354b1aaa13384fcabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two reverse mode matrices and/or kernel generator expressions.  <a href="namespacestan_1_1math_a64bbb1bb36b78e354b1aaa13384fcabd.html#a64bbb1bb36b78e354b1aaa13384fcabd">More...</a><br /></td></tr>
<tr class="separator:a64bbb1bb36b78e354b1aaa13384fcabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafad48f6bd9f872e3a45f3651ed0a33"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_nonscalar_prim_or_rev_kernel_expression_t&lt; T_a, T_b &gt; *  = nullptr, require_any_var_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afafad48f6bd9f872e3a45f3651ed0a33"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afafad48f6bd9f872e3a45f3651ed0a33.html#afafad48f6bd9f872e3a45f3651ed0a33">operator-</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="memdesc:afafad48f6bd9f872e3a45f3651ed0a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two reverse mode matrices and/or kernel generator expressions.  <a href="namespacestan_1_1math_afafad48f6bd9f872e3a45f3651ed0a33.html#afafad48f6bd9f872e3a45f3651ed0a33">More...</a><br /></td></tr>
<tr class="separator:afafad48f6bd9f872e3a45f3651ed0a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02baf58b0e78a95a7b8b84da2e1a911d"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a02baf58b0e78a95a7b8b84da2e1a911d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a02baf58b0e78a95a7b8b84da2e1a911d.html#a02baf58b0e78a95a7b8b84da2e1a911d">sum</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a02baf58b0e78a95a7b8b84da2e1a911d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of the coefficients of the specified matrix on the OpenCL device.  <a href="namespacestan_1_1math_a02baf58b0e78a95a7b8b84da2e1a911d.html#a02baf58b0e78a95a7b8b84da2e1a911d">More...</a><br /></td></tr>
<tr class="separator:a02baf58b0e78a95a7b8b84da2e1a911d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090d1437e84d45770632457284c63f13"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a090d1437e84d45770632457284c63f13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a090d1437e84d45770632457284c63f13.html#a090d1437e84d45770632457284c63f13">symmetrize_from_lower_tri</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a090d1437e84d45770632457284c63f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a symmetric matrix using elements from the upper triangular part of the input matrix.  <a href="namespacestan_1_1math_a090d1437e84d45770632457284c63f13.html#a090d1437e84d45770632457284c63f13">More...</a><br /></td></tr>
<tr class="separator:a090d1437e84d45770632457284c63f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac596d4f367ee5e2342af989446583e5e"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac596d4f367ee5e2342af989446583e5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac596d4f367ee5e2342af989446583e5e.html#ac596d4f367ee5e2342af989446583e5e">symmetrize_from_upper_tri</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ac596d4f367ee5e2342af989446583e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a symmetric matrix using elements from the upper triangular part of the input matrix.  <a href="namespacestan_1_1math_ac596d4f367ee5e2342af989446583e5e.html#ac596d4f367ee5e2342af989446583e5e">More...</a><br /></td></tr>
<tr class="separator:ac596d4f367ee5e2342af989446583e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614992c2fff9d96eabfaaab0effc9911"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a614992c2fff9d96eabfaaab0effc9911"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a614992c2fff9d96eabfaaab0effc9911.html#a614992c2fff9d96eabfaaab0effc9911">tan</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a614992c2fff9d96eabfaaab0effc9911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ae09b685b660830075f80caaf8a350676.html#ae09b685b660830075f80caaf8a350676">tan()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt; in radians.  <a href="namespacestan_1_1math_a614992c2fff9d96eabfaaab0effc9911.html#a614992c2fff9d96eabfaaab0effc9911">More...</a><br /></td></tr>
<tr class="separator:a614992c2fff9d96eabfaaab0effc9911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd43d7c5648c6a03bca97d29d376083"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1dd43d7c5648c6a03bca97d29d376083"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1dd43d7c5648c6a03bca97d29d376083.html#a1dd43d7c5648c6a03bca97d29d376083">tanh</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a1dd43d7c5648c6a03bca97d29d376083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ae11dc45fd471bec1a19462ce58f434b8.html#ae11dc45fd471bec1a19462ce58f434b8">tanh()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt; in radians.  <a href="namespacestan_1_1math_a1dd43d7c5648c6a03bca97d29d376083.html#a1dd43d7c5648c6a03bca97d29d376083">More...</a><br /></td></tr>
<tr class="separator:a1dd43d7c5648c6a03bca97d29d376083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7618c67ad400e17edd996abc3e4cd0d"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae7618c67ad400e17edd996abc3e4cd0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae7618c67ad400e17edd996abc3e4cd0d.html#ae7618c67ad400e17edd996abc3e4cd0d">tcrossprod</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;M)</td></tr>
<tr class="memdesc:ae7618c67ad400e17edd996abc3e4cd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of post-multiplying a matrix by its own transpose.  <a href="namespacestan_1_1math_ae7618c67ad400e17edd996abc3e4cd0d.html#ae7618c67ad400e17edd996abc3e4cd0d">More...</a><br /></td></tr>
<tr class="separator:ae7618c67ad400e17edd996abc3e4cd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d1ce50736f6b642c60b7f5de78970e"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a42d1ce50736f6b642c60b7f5de78970e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a42d1ce50736f6b642c60b7f5de78970e.html#a42d1ce50736f6b642c60b7f5de78970e">tgamma</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a42d1ce50736f6b642c60b7f5de78970e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a73eaf0a5d0593bb8610234e0d69e7cec.html#a73eaf0a5d0593bb8610234e0d69e7cec" title="Return the result of applying the gamma function to the specified argument.">tgamma()</a></code> of a <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;matrix_cl&lt;double&gt;&gt;.  <a href="namespacestan_1_1math_a42d1ce50736f6b642c60b7f5de78970e.html#a42d1ce50736f6b642c60b7f5de78970e">More...</a><br /></td></tr>
<tr class="separator:a42d1ce50736f6b642c60b7f5de78970e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713cc9385182249d547389028a723a1a"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a713cc9385182249d547389028a723a1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">arena_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a713cc9385182249d547389028a723a1a.html#a713cc9385182249d547389028a723a1a">to_arena</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a713cc9385182249d547389028a723a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts given argument into a type that either has any dynamic allocation on AD stack or schedules its destructor to be called when AD stack memory is recovered.  <a href="namespacestan_1_1math_a713cc9385182249d547389028a723a1a.html#a713cc9385182249d547389028a723a1a">More...</a><br /></td></tr>
<tr class="separator:a713cc9385182249d547389028a723a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629175f2b0fc9a24007bbdc27e68fce7"><td class="memTemplParams" colspan="2">template&lt;typename T_x , require_all_kernel_expressions_and_none_scalar_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a629175f2b0fc9a24007bbdc27e68fce7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a629175f2b0fc9a24007bbdc27e68fce7.html#a629175f2b0fc9a24007bbdc27e68fce7">to_matrix</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T_x &gt; &amp;x, int m, int n)</td></tr>
<tr class="memdesc:a629175f2b0fc9a24007bbdc27e68fce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of a vector or matrix in column-major order with the specified number of rows and columns.  <a href="namespacestan_1_1math_a629175f2b0fc9a24007bbdc27e68fce7.html#a629175f2b0fc9a24007bbdc27e68fce7">More...</a><br /></td></tr>
<tr class="separator:a629175f2b0fc9a24007bbdc27e68fce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fafbbd5a166667ae7dfe48e441d1a4f"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2fafbbd5a166667ae7dfe48e441d1a4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2fafbbd5a166667ae7dfe48e441d1a4f.html#a2fafbbd5a166667ae7dfe48e441d1a4f">trace</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a2fafbbd5a166667ae7dfe48e441d1a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trace (sum of diagonal) of the specified matrix on the OpenCL device.  <a href="namespacestan_1_1math_a2fafbbd5a166667ae7dfe48e441d1a4f.html#a2fafbbd5a166667ae7dfe48e441d1a4f">More...</a><br /></td></tr>
<tr class="separator:a2fafbbd5a166667ae7dfe48e441d1a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99eaf6cab2258d909e798de7b3f409ef"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a99eaf6cab2258d909e798de7b3f409ef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a99eaf6cab2258d909e798de7b3f409ef.html#a99eaf6cab2258d909e798de7b3f409ef">transpose</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;M)</td></tr>
<tr class="memdesc:a99eaf6cab2258d909e798de7b3f409ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a matrix.  <a href="namespacestan_1_1math_a99eaf6cab2258d909e798de7b3f409ef.html#a99eaf6cab2258d909e798de7b3f409ef">More...</a><br /></td></tr>
<tr class="separator:a99eaf6cab2258d909e798de7b3f409ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1494605067c9573eb941614e6674ac"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acd1494605067c9573eb941614e6674ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acd1494605067c9573eb941614e6674ac.html#acd1494605067c9573eb941614e6674ac">trunc</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:acd1494605067c9573eb941614e6674ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a79abc1d4f747b3c26c07b2b1e4871603.html#a79abc1d4f747b3c26c07b2b1e4871603" title="Return the nearest integral value that is not larger in magnitude than the specified argument.">trunc()</a></code> of the input <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;<a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;double&gt;&gt;</code>.  <a href="namespacestan_1_1math_acd1494605067c9573eb941614e6674ac.html#acd1494605067c9573eb941614e6674ac">More...</a><br /></td></tr>
<tr class="separator:acd1494605067c9573eb941614e6674ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d8756d188d0c8e3bd274acd73c9c15"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_ub , require_all_prim_or_rev_kernel_expression_t&lt; T_x, T_ub &gt; *  = nullptr, require_any_var_t&lt; T_x, T_ub &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_x, T_ub &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad3d8756d188d0c8e3bd274acd73c9c15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad3d8756d188d0c8e3bd274acd73c9c15.html#ad3d8756d188d0c8e3bd274acd73c9c15">ub_constrain</a> (T_x &amp;&amp;x, T_ub &amp;&amp;ub)</td></tr>
<tr class="memdesc:ad3d8756d188d0c8e3bd274acd73c9c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper-bounded value for the specified unconstrained input and specified upper bound.  <a href="namespacestan_1_1math_ad3d8756d188d0c8e3bd274acd73c9c15.html#ad3d8756d188d0c8e3bd274acd73c9c15">More...</a><br /></td></tr>
<tr class="separator:ad3d8756d188d0c8e3bd274acd73c9c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a03c5d99ff3228afc4833234e7c8f90"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_ub , require_all_prim_or_rev_kernel_expression_t&lt; T_x, T_ub &gt; *  = nullptr, require_any_var_t&lt; T_x, T_ub &gt; *  = nullptr, require_any_not_stan_scalar_t&lt; T_x, T_ub &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1a03c5d99ff3228afc4833234e7c8f90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1a03c5d99ff3228afc4833234e7c8f90.html#a1a03c5d99ff3228afc4833234e7c8f90">ub_constrain</a> (T_x &amp;&amp;x, T_ub &amp;&amp;ub, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;lp)</td></tr>
<tr class="memdesc:a1a03c5d99ff3228afc4833234e7c8f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper-bounded value for the specified unconstrained input and specified upper bound.  <a href="namespacestan_1_1math_a1a03c5d99ff3228afc4833234e7c8f90.html#a1a03c5d99ff3228afc4833234e7c8f90">More...</a><br /></td></tr>
<tr class="separator:a1a03c5d99ff3228afc4833234e7c8f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac336413219be96c2b8448c4c1d27b38b"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac336413219be96c2b8448c4c1d27b38b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac336413219be96c2b8448c4c1d27b38b.html#ac336413219be96c2b8448c4c1d27b38b">unit_vector_constrain</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ac336413219be96c2b8448c4c1d27b38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the free vector y.  <a href="namespacestan_1_1math_ac336413219be96c2b8448c4c1d27b38b.html#ac336413219be96c2b8448c4c1d27b38b">More...</a><br /></td></tr>
<tr class="separator:ac336413219be96c2b8448c4c1d27b38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfc2c3899493fb60bdd96766fbc84eb"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abbfc2c3899493fb60bdd96766fbc84eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abbfc2c3899493fb60bdd96766fbc84eb.html#abbfc2c3899493fb60bdd96766fbc84eb">unit_vector_constrain</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;lp)</td></tr>
<tr class="memdesc:abbfc2c3899493fb60bdd96766fbc84eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the free vector y.  <a href="namespacestan_1_1math_abbfc2c3899493fb60bdd96766fbc84eb.html#abbfc2c3899493fb60bdd96766fbc84eb">More...</a><br /></td></tr>
<tr class="separator:abbfc2c3899493fb60bdd96766fbc84eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bbd000b9b4558249d01c11994ddc93"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_kernel_expressions_and_none_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a12bbd000b9b4558249d01c11994ddc93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a12bbd000b9b4558249d01c11994ddc93.html#a12bbd000b9b4558249d01c11994ddc93">variance</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a12bbd000b9b4558249d01c11994ddc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample variance of the <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a> matrix Raise domain error if size is not greater than zero.  <a href="namespacestan_1_1math_a12bbd000b9b4558249d01c11994ddc93.html#a12bbd000b9b4558249d01c11994ddc93">More...</a><br /></td></tr>
<tr class="separator:a12bbd000b9b4558249d01c11994ddc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9df6723479e901d88b22325b4da6f3"><td class="memTemplParams" colspan="2">template&lt;bool need_eigenvectors = true&gt; </td></tr>
<tr class="memitem:abe9df6723479e901d88b22325b4da6f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abe9df6723479e901d88b22325b4da6f3.html#abe9df6723479e901d88b22325b4da6f3">symmetric_eigensolver</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;A, <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;<a class="el" href="namespacestan_1_1math_a2401d26ca0cb0e1cdd852a53cf845668.html#a2401d26ca0cb0e1cdd852a53cf845668">eigenvalues</a>, <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;<a class="el" href="namespacestan_1_1math_aa65f6e13c5996fe8327f16bf337b9712.html#aa65f6e13c5996fe8327f16bf337b9712">eigenvectors</a>)</td></tr>
<tr class="separator:abe9df6723479e901d88b22325b4da6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624eca726bdefcfd2eeec0fba338395c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a624eca726bdefcfd2eeec0fba338395c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a89fb6779eb99f22b6b0ce2662e630e78.html#a89fb6779eb99f22b6b0ce2662e630e78">ref_type_for_opencl_t</a>&lt; T &amp;&amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a624eca726bdefcfd2eeec0fba338395c.html#a624eca726bdefcfd2eeec0fba338395c">to_ref_for_opencl</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a624eca726bdefcfd2eeec0fba338395c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts given <a class="el" href="namespace_eigen.html">Eigen</a> expression into one that can be directly copied to an OpenCL device to create <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code>.  <a href="namespacestan_1_1math_a624eca726bdefcfd2eeec0fba338395c.html#a624eca726bdefcfd2eeec0fba338395c">More...</a><br /></td></tr>
<tr class="separator:a624eca726bdefcfd2eeec0fba338395c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ff9a795bfa5ae75421d00a95e8a6c0"><td class="memTemplParams" colspan="2">template&lt;matrix_cl_view matrix_view = matrix_cl_view::Entire, typename T , require_matrix_cl_st&lt; std::is_floating_point, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga57ff9a795bfa5ae75421d00a95e8a6c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga57ff9a795bfa5ae75421d00a95e8a6c0.html#ga57ff9a795bfa5ae75421d00a95e8a6c0">tri_inverse</a> (const T &amp;A)</td></tr>
<tr class="separator:ga57ff9a795bfa5ae75421d00a95e8a6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb3f73b57634dda5e904fc4c2e00864"><td class="memItemLeft" align="right" valign="top">tbb::task_arena &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2eb3f73b57634dda5e904fc4c2e00864.html#a2eb3f73b57634dda5e904fc4c2e00864">init_threadpool_tbb</a> (int n_threads=0)</td></tr>
<tr class="memdesc:a2eb3f73b57634dda5e904fc4c2e00864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Intel TBB threadpool and global scheduler through the tbb::task_arena object.  <a href="namespacestan_1_1math_a2eb3f73b57634dda5e904fc4c2e00864.html#a2eb3f73b57634dda5e904fc4c2e00864">More...</a><br /></td></tr>
<tr class="separator:a2eb3f73b57634dda5e904fc4c2e00864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570553db35e902ab3c3716ee875db227"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , require_all_stan_scalar_t&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a570553db35e902ab3c3716ee875db227"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a570553db35e902ab3c3716ee875db227.html#a570553db35e902ab3c3716ee875db227">operator+</a> (const std::complex&lt; U &gt; &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a570553db35e902ab3c3716ee875db227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the arguments.  <a href="namespacestan_1_1math_a570553db35e902ab3c3716ee875db227.html#a570553db35e902ab3c3716ee875db227">More...</a><br /></td></tr>
<tr class="separator:a570553db35e902ab3c3716ee875db227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e375acadbad9bcab8dea1f9f0a730b"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , require_all_stan_scalar_t&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa6e375acadbad9bcab8dea1f9f0a730b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa6e375acadbad9bcab8dea1f9f0a730b.html#aa6e375acadbad9bcab8dea1f9f0a730b">operator+</a> (const std::complex&lt; U &gt; &amp;x, const V &amp;y)</td></tr>
<tr class="memdesc:aa6e375acadbad9bcab8dea1f9f0a730b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the arguments.  <a href="namespacestan_1_1math_aa6e375acadbad9bcab8dea1f9f0a730b.html#aa6e375acadbad9bcab8dea1f9f0a730b">More...</a><br /></td></tr>
<tr class="separator:aa6e375acadbad9bcab8dea1f9f0a730b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579e72e7fbd66c3b8f4930b340c23c70"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , require_all_stan_scalar_t&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a579e72e7fbd66c3b8f4930b340c23c70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a579e72e7fbd66c3b8f4930b340c23c70.html#a579e72e7fbd66c3b8f4930b340c23c70">operator+</a> (const U &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a579e72e7fbd66c3b8f4930b340c23c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the arguments.  <a href="namespacestan_1_1math_a579e72e7fbd66c3b8f4930b340c23c70.html#a579e72e7fbd66c3b8f4930b340c23c70">More...</a><br /></td></tr>
<tr class="separator:a579e72e7fbd66c3b8f4930b340c23c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ecd75300416efda4a5946f047a3298"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , require_all_stan_scalar_t&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a77ecd75300416efda4a5946f047a3298"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a77ecd75300416efda4a5946f047a3298.html#a77ecd75300416efda4a5946f047a3298">operator/</a> (const std::complex&lt; U &gt; &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a77ecd75300416efda4a5946f047a3298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quotient of the arguments.  <a href="namespacestan_1_1math_a77ecd75300416efda4a5946f047a3298.html#a77ecd75300416efda4a5946f047a3298">More...</a><br /></td></tr>
<tr class="separator:a77ecd75300416efda4a5946f047a3298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e8deb74fdec44276be09591a3c804e"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , require_all_stan_scalar_t&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad6e8deb74fdec44276be09591a3c804e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad6e8deb74fdec44276be09591a3c804e.html#ad6e8deb74fdec44276be09591a3c804e">operator/</a> (const std::complex&lt; U &gt; &amp;x, const V &amp;y)</td></tr>
<tr class="memdesc:ad6e8deb74fdec44276be09591a3c804e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quotient of the arguments.  <a href="namespacestan_1_1math_ad6e8deb74fdec44276be09591a3c804e.html#ad6e8deb74fdec44276be09591a3c804e">More...</a><br /></td></tr>
<tr class="separator:ad6e8deb74fdec44276be09591a3c804e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5956e21d61d4bf990531a421ca2adb2"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , require_all_stan_scalar_t&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae5956e21d61d4bf990531a421ca2adb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae5956e21d61d4bf990531a421ca2adb2.html#ae5956e21d61d4bf990531a421ca2adb2">operator/</a> (const U &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:ae5956e21d61d4bf990531a421ca2adb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quotient of the arguments.  <a href="namespacestan_1_1math_ae5956e21d61d4bf990531a421ca2adb2.html#ae5956e21d61d4bf990531a421ca2adb2">More...</a><br /></td></tr>
<tr class="separator:ae5956e21d61d4bf990531a421ca2adb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195f15fbf20fbc98a2d2f57121159077"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , typename  = require_any_autodiff_t&lt;U, V&gt;&gt; </td></tr>
<tr class="memitem:a195f15fbf20fbc98a2d2f57121159077"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a195f15fbf20fbc98a2d2f57121159077.html#a195f15fbf20fbc98a2d2f57121159077">operator==</a> (const std::complex&lt; U &gt; &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a195f15fbf20fbc98a2d2f57121159077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the complex numbers have equal imaginary and complex parts.  <a href="namespacestan_1_1math_a195f15fbf20fbc98a2d2f57121159077.html#a195f15fbf20fbc98a2d2f57121159077">More...</a><br /></td></tr>
<tr class="separator:a195f15fbf20fbc98a2d2f57121159077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e199182f935e870d4cf241650deb6c"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , typename  = require_any_autodiff_t&lt;U, V&gt;&gt; </td></tr>
<tr class="memitem:af5e199182f935e870d4cf241650deb6c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af5e199182f935e870d4cf241650deb6c.html#af5e199182f935e870d4cf241650deb6c">operator==</a> (const std::complex&lt; U &gt; &amp;x, const V &amp;y)</td></tr>
<tr class="memdesc:af5e199182f935e870d4cf241650deb6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the first argument's real part is equal to the second argument and the first argument's imaginary part is zero.  <a href="namespacestan_1_1math_af5e199182f935e870d4cf241650deb6c.html#af5e199182f935e870d4cf241650deb6c">More...</a><br /></td></tr>
<tr class="separator:af5e199182f935e870d4cf241650deb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741f95136b479057bf320dd30d2a0c75"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , typename  = require_any_autodiff_t&lt;U, V&gt;&gt; </td></tr>
<tr class="memitem:a741f95136b479057bf320dd30d2a0c75"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a741f95136b479057bf320dd30d2a0c75.html#a741f95136b479057bf320dd30d2a0c75">operator==</a> (const U &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a741f95136b479057bf320dd30d2a0c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the first argument is equal to the real part of the second argument and the imaginary part of the second argument is zero.  <a href="namespacestan_1_1math_a741f95136b479057bf320dd30d2a0c75.html#a741f95136b479057bf320dd30d2a0c75">More...</a><br /></td></tr>
<tr class="separator:a741f95136b479057bf320dd30d2a0c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24950c0dc7071913dd7d4065dd5d2fc0"><td class="memTemplParams" colspan="2">template&lt;typename U , require_autodiff_t&lt; U &gt; &gt; </td></tr>
<tr class="memitem:a24950c0dc7071913dd7d4065dd5d2fc0"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a24950c0dc7071913dd7d4065dd5d2fc0.html#a24950c0dc7071913dd7d4065dd5d2fc0">operator-</a> (const std::complex&lt; U &gt; &amp;x)</td></tr>
<tr class="memdesc:a24950c0dc7071913dd7d4065dd5d2fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negation of the argument.  <a href="namespacestan_1_1math_a24950c0dc7071913dd7d4065dd5d2fc0.html#a24950c0dc7071913dd7d4065dd5d2fc0">More...</a><br /></td></tr>
<tr class="separator:a24950c0dc7071913dd7d4065dd5d2fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f837c38036be64604c99691549e863f"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , require_all_stan_scalar_t&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8f837c38036be64604c99691549e863f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8f837c38036be64604c99691549e863f.html#a8f837c38036be64604c99691549e863f">operator*</a> (const std::complex&lt; U &gt; &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a8f837c38036be64604c99691549e863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the arguments.  <a href="namespacestan_1_1math_a8f837c38036be64604c99691549e863f.html#a8f837c38036be64604c99691549e863f">More...</a><br /></td></tr>
<tr class="separator:a8f837c38036be64604c99691549e863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589ffeccfbf7eaf51d864816eaeaafcc"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , require_stan_scalar_t&lt; V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a589ffeccfbf7eaf51d864816eaeaafcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a589ffeccfbf7eaf51d864816eaeaafcc.html#a589ffeccfbf7eaf51d864816eaeaafcc">operator*</a> (const std::complex&lt; U &gt; &amp;x, const V &amp;y)</td></tr>
<tr class="memdesc:a589ffeccfbf7eaf51d864816eaeaafcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the arguments.  <a href="namespacestan_1_1math_a589ffeccfbf7eaf51d864816eaeaafcc.html#a589ffeccfbf7eaf51d864816eaeaafcc">More...</a><br /></td></tr>
<tr class="separator:a589ffeccfbf7eaf51d864816eaeaafcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c2cc29dd8ccaf8f8188727dcfa1954"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , require_stan_scalar_t&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a77c2cc29dd8ccaf8f8188727dcfa1954"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a77c2cc29dd8ccaf8f8188727dcfa1954.html#a77c2cc29dd8ccaf8f8188727dcfa1954">operator*</a> (const U &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a77c2cc29dd8ccaf8f8188727dcfa1954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the arguments.  <a href="namespacestan_1_1math_a77c2cc29dd8ccaf8f8188727dcfa1954.html#a77c2cc29dd8ccaf8f8188727dcfa1954">More...</a><br /></td></tr>
<tr class="separator:a77c2cc29dd8ccaf8f8188727dcfa1954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae989ec3ea8ef118937939696a28086d4"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , typename  = require_any_autodiff_t&lt;U, V&gt;&gt; </td></tr>
<tr class="memitem:ae989ec3ea8ef118937939696a28086d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae989ec3ea8ef118937939696a28086d4.html#ae989ec3ea8ef118937939696a28086d4">operator!=</a> (const std::complex&lt; U &gt; &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:ae989ec3ea8ef118937939696a28086d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the complex numbers have unequal imaginary or complex parts.  <a href="namespacestan_1_1math_ae989ec3ea8ef118937939696a28086d4.html#ae989ec3ea8ef118937939696a28086d4">More...</a><br /></td></tr>
<tr class="separator:ae989ec3ea8ef118937939696a28086d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0a408d5c595e9e8f866affd1484cfe"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , typename  = require_any_autodiff_t&lt;U, V&gt;&gt; </td></tr>
<tr class="memitem:a0f0a408d5c595e9e8f866affd1484cfe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0f0a408d5c595e9e8f866affd1484cfe.html#a0f0a408d5c595e9e8f866affd1484cfe">operator!=</a> (const std::complex&lt; U &gt; &amp;x, const V &amp;y)</td></tr>
<tr class="memdesc:a0f0a408d5c595e9e8f866affd1484cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the first argument's real part is unequal to the second argument or the first argument's imaginary part is unequal to zero.  <a href="namespacestan_1_1math_a0f0a408d5c595e9e8f866affd1484cfe.html#a0f0a408d5c595e9e8f866affd1484cfe">More...</a><br /></td></tr>
<tr class="separator:a0f0a408d5c595e9e8f866affd1484cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0f07626698e5b8b1aaffb5aaed36a5"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , typename  = require_any_autodiff_t&lt;U, V&gt;&gt; </td></tr>
<tr class="memitem:a3f0f07626698e5b8b1aaffb5aaed36a5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3f0f07626698e5b8b1aaffb5aaed36a5.html#a3f0f07626698e5b8b1aaffb5aaed36a5">operator!=</a> (const U &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a3f0f07626698e5b8b1aaffb5aaed36a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the first argument is unequal to the real part of the second argument or the imaginary part of the second argument is nonzero.  <a href="namespacestan_1_1math_a3f0f07626698e5b8b1aaffb5aaed36a5.html#a3f0f07626698e5b8b1aaffb5aaed36a5">More...</a><br /></td></tr>
<tr class="separator:a3f0f07626698e5b8b1aaffb5aaed36a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3370b366987ac9fc2ce05d1639e1e6ca"><td class="memTemplParams" colspan="2">template&lt;typename U , require_autodiff_t&lt; U &gt; &gt; </td></tr>
<tr class="memitem:a3370b366987ac9fc2ce05d1639e1e6ca"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3370b366987ac9fc2ce05d1639e1e6ca.html#a3370b366987ac9fc2ce05d1639e1e6ca">operator+</a> (const std::complex&lt; U &gt; &amp;x)</td></tr>
<tr class="memdesc:a3370b366987ac9fc2ce05d1639e1e6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the argument.  <a href="namespacestan_1_1math_a3370b366987ac9fc2ce05d1639e1e6ca.html#a3370b366987ac9fc2ce05d1639e1e6ca">More...</a><br /></td></tr>
<tr class="separator:a3370b366987ac9fc2ce05d1639e1e6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c73f7bad131e8dabda3a9662b80c784"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , require_all_stan_scalar_t&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0c73f7bad131e8dabda3a9662b80c784"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0c73f7bad131e8dabda3a9662b80c784.html#a0c73f7bad131e8dabda3a9662b80c784">operator-</a> (const std::complex&lt; U &gt; &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a0c73f7bad131e8dabda3a9662b80c784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of the arguments.  <a href="namespacestan_1_1math_a0c73f7bad131e8dabda3a9662b80c784.html#a0c73f7bad131e8dabda3a9662b80c784">More...</a><br /></td></tr>
<tr class="separator:a0c73f7bad131e8dabda3a9662b80c784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2bd67b83efe9d2aa18cc80752e0bb0"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , require_all_stan_scalar_t&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3c2bd67b83efe9d2aa18cc80752e0bb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3c2bd67b83efe9d2aa18cc80752e0bb0.html#a3c2bd67b83efe9d2aa18cc80752e0bb0">operator-</a> (const std::complex&lt; U &gt; &amp;x, const V &amp;y)</td></tr>
<tr class="memdesc:a3c2bd67b83efe9d2aa18cc80752e0bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of the arguments.  <a href="namespacestan_1_1math_a3c2bd67b83efe9d2aa18cc80752e0bb0.html#a3c2bd67b83efe9d2aa18cc80752e0bb0">More...</a><br /></td></tr>
<tr class="separator:a3c2bd67b83efe9d2aa18cc80752e0bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78865dd00d02de17b88416b8dec4cde3"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , require_all_stan_scalar_t&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a78865dd00d02de17b88416b8dec4cde3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a78865dd00d02de17b88416b8dec4cde3.html#a78865dd00d02de17b88416b8dec4cde3">operator-</a> (const U &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a78865dd00d02de17b88416b8dec4cde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of the arguments.  <a href="namespacestan_1_1math_a78865dd00d02de17b88416b8dec4cde3.html#a78865dd00d02de17b88416b8dec4cde3">More...</a><br /></td></tr>
<tr class="separator:a78865dd00d02de17b88416b8dec4cde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6af9d11f53a6f29c046f6115aa590df"><td class="memTemplParams" colspan="2">template&lt;typename T_a1 , typename T_a2 , typename T_b1 , typename T_z &gt; </td></tr>
<tr class="memitem:ac6af9d11f53a6f29c046f6115aa590df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac6af9d11f53a6f29c046f6115aa590df.html#ac6af9d11f53a6f29c046f6115aa590df">check_2F1_converges</a> (const char *function, const T_a1 &amp;a1, const T_a2 &amp;a2, const T_b1 &amp;b1, const T_z &amp;z)</td></tr>
<tr class="memdesc:ac6af9d11f53a6f29c046f6115aa590df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the hypergeometric function (2F1) called with supplied arguments will converge, assuming arguments are finite values.  <a href="namespacestan_1_1math_ac6af9d11f53a6f29c046f6115aa590df.html#ac6af9d11f53a6f29c046f6115aa590df">More...</a><br /></td></tr>
<tr class="separator:ac6af9d11f53a6f29c046f6115aa590df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22116acf47af3e2218f3be543a4ca12a"><td class="memTemplParams" colspan="2">template&lt;typename T_a1 , typename T_a2 , typename T_a3 , typename T_b1 , typename T_b2 , typename T_z &gt; </td></tr>
<tr class="memitem:a22116acf47af3e2218f3be543a4ca12a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a22116acf47af3e2218f3be543a4ca12a.html#a22116acf47af3e2218f3be543a4ca12a">check_3F2_converges</a> (const char *function, const T_a1 &amp;a1, const T_a2 &amp;a2, const T_a3 &amp;a3, const T_b1 &amp;b1, const T_b2 &amp;b2, const T_z &amp;z)</td></tr>
<tr class="memdesc:a22116acf47af3e2218f3be543a4ca12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the hypergeometric function (3F2) called with supplied arguments will converge, assuming arguments are finite values.  <a href="namespacestan_1_1math_a22116acf47af3e2218f3be543a4ca12a.html#a22116acf47af3e2218f3be543a4ca12a">More...</a><br /></td></tr>
<tr class="separator:a22116acf47af3e2218f3be543a4ca12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34458c3e7913f9144a493b53f2ae115c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:a34458c3e7913f9144a493b53f2ae115c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a34458c3e7913f9144a493b53f2ae115c.html#a34458c3e7913f9144a493b53f2ae115c">check_bounded</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low, const T_high &amp;high)</td></tr>
<tr class="memdesc:a34458c3e7913f9144a493b53f2ae115c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the value is between the low and high values, inclusively.  <a href="namespacestan_1_1math_a34458c3e7913f9144a493b53f2ae115c.html#a34458c3e7913f9144a493b53f2ae115c">More...</a><br /></td></tr>
<tr class="separator:a34458c3e7913f9144a493b53f2ae115c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeaa2aa71151491e1e3f19831b6bd8f8"><td class="memTemplParams" colspan="2">template&lt;typename Mat , require_matrix_t&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abeaa2aa71151491e1e3f19831b6bd8f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abeaa2aa71151491e1e3f19831b6bd8f8.html#abeaa2aa71151491e1e3f19831b6bd8f8">check_cholesky_factor</a> (const char *function, const char *name, const Mat &amp;y)</td></tr>
<tr class="memdesc:abeaa2aa71151491e1e3f19831b6bd8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a valid Cholesky factor.  <a href="namespacestan_1_1math_abeaa2aa71151491e1e3f19831b6bd8f8.html#abeaa2aa71151491e1e3f19831b6bd8f8">More...</a><br /></td></tr>
<tr class="separator:abeaa2aa71151491e1e3f19831b6bd8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85764c1169b4d0e2baba67e62236914a"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , require_std_vector_t&lt; StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a85764c1169b4d0e2baba67e62236914a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a85764c1169b4d0e2baba67e62236914a.html#a85764c1169b4d0e2baba67e62236914a">check_cholesky_factor</a> (const char *function, const char *name, const StdVec &amp;y)</td></tr>
<tr class="memdesc:a85764c1169b4d0e2baba67e62236914a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a valid Cholesky factor.  <a href="namespacestan_1_1math_a85764c1169b4d0e2baba67e62236914a.html#a85764c1169b4d0e2baba67e62236914a">More...</a><br /></td></tr>
<tr class="separator:a85764c1169b4d0e2baba67e62236914a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a7068a0736e3f680a8c122ae34c78e"><td class="memTemplParams" colspan="2">template&lt;typename Mat , require_matrix_t&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a40a7068a0736e3f680a8c122ae34c78e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a40a7068a0736e3f680a8c122ae34c78e.html#a40a7068a0736e3f680a8c122ae34c78e">check_cholesky_factor_corr</a> (const char *function, const char *name, const Mat &amp;y)</td></tr>
<tr class="memdesc:a40a7068a0736e3f680a8c122ae34c78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a valid Cholesky factor of a correlation matrix.  <a href="namespacestan_1_1math_a40a7068a0736e3f680a8c122ae34c78e.html#a40a7068a0736e3f680a8c122ae34c78e">More...</a><br /></td></tr>
<tr class="separator:a40a7068a0736e3f680a8c122ae34c78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d48f388adc59a512ae1d87e69c6a3db"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , require_std_vector_t&lt; StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5d48f388adc59a512ae1d87e69c6a3db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5d48f388adc59a512ae1d87e69c6a3db.html#a5d48f388adc59a512ae1d87e69c6a3db">check_cholesky_factor_corr</a> (const char *function, const char *name, const StdVec &amp;y)</td></tr>
<tr class="memdesc:a5d48f388adc59a512ae1d87e69c6a3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a valid Cholesky factor of a correlation matrix.  <a href="namespacestan_1_1math_a5d48f388adc59a512ae1d87e69c6a3db.html#a5d48f388adc59a512ae1d87e69c6a3db">More...</a><br /></td></tr>
<tr class="separator:a5d48f388adc59a512ae1d87e69c6a3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3ef7efe82fd0f280dbf50c08ef2b00"><td class="memTemplParams" colspan="2">template&lt;typename T_y , require_any_t&lt; is_matrix&lt; T_y &gt;, is_prim_or_rev_kernel_expression&lt; T_y &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9a3ef7efe82fd0f280dbf50c08ef2b00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9a3ef7efe82fd0f280dbf50c08ef2b00.html#a9a3ef7efe82fd0f280dbf50c08ef2b00">check_column_index</a> (const char *function, const char *name, const T_y &amp;y, size_t i)</td></tr>
<tr class="memdesc:a9a3ef7efe82fd0f280dbf50c08ef2b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified index is a valid column of the matrix.  <a href="namespacestan_1_1math_a9a3ef7efe82fd0f280dbf50c08ef2b00.html#a9a3ef7efe82fd0f280dbf50c08ef2b00">More...</a><br /></td></tr>
<tr class="separator:a9a3ef7efe82fd0f280dbf50c08ef2b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef521f8fa317b4a0d987968f27705af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ef521f8fa317b4a0d987968f27705af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4ef521f8fa317b4a0d987968f27705af.html#a4ef521f8fa317b4a0d987968f27705af">check_consistent_size</a> (const char *function, const char *name, const T &amp;x, size_t expected_size)</td></tr>
<tr class="memdesc:a4ef521f8fa317b4a0d987968f27705af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>x</code> is consistent with size <code>expected_size</code>.  <a href="namespacestan_1_1math_a4ef521f8fa317b4a0d987968f27705af.html#a4ef521f8fa317b4a0d987968f27705af">More...</a><br /></td></tr>
<tr class="separator:a4ef521f8fa317b4a0d987968f27705af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db1371ee167e2c301cef8e504efe8e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7db1371ee167e2c301cef8e504efe8e8.html#a7db1371ee167e2c301cef8e504efe8e8">check_consistent_sizes</a> (const char *)</td></tr>
<tr class="memdesc:a7db1371ee167e2c301cef8e504efe8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial no input case, this function is a no-op.  <a href="namespacestan_1_1math_a7db1371ee167e2c301cef8e504efe8e8.html#a7db1371ee167e2c301cef8e504efe8e8">More...</a><br /></td></tr>
<tr class="separator:a7db1371ee167e2c301cef8e504efe8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f3e6fa8b71cef479e1f2d762513951"><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr class="memitem:a92f3e6fa8b71cef479e1f2d762513951"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a92f3e6fa8b71cef479e1f2d762513951.html#a92f3e6fa8b71cef479e1f2d762513951">check_consistent_sizes</a> (const char *, const char *, const T1 &amp;)</td></tr>
<tr class="memdesc:a92f3e6fa8b71cef479e1f2d762513951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base case of recursion, this function is a no-op.  <a href="namespacestan_1_1math_a92f3e6fa8b71cef479e1f2d762513951.html#a92f3e6fa8b71cef479e1f2d762513951">More...</a><br /></td></tr>
<tr class="separator:a92f3e6fa8b71cef479e1f2d762513951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c7d015bdbb6657725165263c95d1ed"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename... Ts&gt; </td></tr>
<tr class="memitem:a63c7d015bdbb6657725165263c95d1ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a63c7d015bdbb6657725165263c95d1ed.html#a63c7d015bdbb6657725165263c95d1ed">check_consistent_sizes</a> (const char *function, const char *name1, const T1 &amp;x1, const char *name2, const T2 &amp;x2, const Ts &amp;... names_and_xs)</td></tr>
<tr class="memdesc:a63c7d015bdbb6657725165263c95d1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the inputs are of consistent size.  <a href="namespacestan_1_1math_a63c7d015bdbb6657725165263c95d1ed.html#a63c7d015bdbb6657725165263c95d1ed">More...</a><br /></td></tr>
<tr class="separator:a63c7d015bdbb6657725165263c95d1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cefb1de2214e2898471e0ef2ab47d08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4cefb1de2214e2898471e0ef2ab47d08.html#a4cefb1de2214e2898471e0ef2ab47d08">check_consistent_sizes_mvt</a> (const char *)</td></tr>
<tr class="memdesc:a4cefb1de2214e2898471e0ef2ab47d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial no input case, this function is a no-op.  <a href="namespacestan_1_1math_a4cefb1de2214e2898471e0ef2ab47d08.html#a4cefb1de2214e2898471e0ef2ab47d08">More...</a><br /></td></tr>
<tr class="separator:a4cefb1de2214e2898471e0ef2ab47d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3a5611179f5e3b05141f629f03e88d"><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr class="memitem:aea3a5611179f5e3b05141f629f03e88d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aea3a5611179f5e3b05141f629f03e88d.html#aea3a5611179f5e3b05141f629f03e88d">check_consistent_sizes_mvt</a> (const char *, const char *, const T1 &amp;)</td></tr>
<tr class="memdesc:aea3a5611179f5e3b05141f629f03e88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base case of recursion, this function is a no-op.  <a href="namespacestan_1_1math_aea3a5611179f5e3b05141f629f03e88d.html#aea3a5611179f5e3b05141f629f03e88d">More...</a><br /></td></tr>
<tr class="separator:aea3a5611179f5e3b05141f629f03e88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f7c6b17f763de357860ac814f16a74"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename... Ts&gt; </td></tr>
<tr class="memitem:a02f7c6b17f763de357860ac814f16a74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a02f7c6b17f763de357860ac814f16a74.html#a02f7c6b17f763de357860ac814f16a74">check_consistent_sizes_mvt</a> (const char *function, const char *name1, const T1 &amp;x1, const char *name2, const T2 &amp;x2, const Ts &amp;... names_and_xs)</td></tr>
<tr class="memdesc:a02f7c6b17f763de357860ac814f16a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the provided multivariate inputs are of consistent size with each other.  <a href="namespacestan_1_1math_a02f7c6b17f763de357860ac814f16a74.html#a02f7c6b17f763de357860ac814f16a74">More...</a><br /></td></tr>
<tr class="separator:a02f7c6b17f763de357860ac814f16a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289210bdbeec6c0cf6433157488dcafe"><td class="memTemplParams" colspan="2">template&lt;typename Mat , require_matrix_t&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a289210bdbeec6c0cf6433157488dcafe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a289210bdbeec6c0cf6433157488dcafe.html#a289210bdbeec6c0cf6433157488dcafe">check_corr_matrix</a> (const char *function, const char *name, const Mat &amp;y)</td></tr>
<tr class="memdesc:a289210bdbeec6c0cf6433157488dcafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a valid correlation matrix.  <a href="namespacestan_1_1math_a289210bdbeec6c0cf6433157488dcafe.html#a289210bdbeec6c0cf6433157488dcafe">More...</a><br /></td></tr>
<tr class="separator:a289210bdbeec6c0cf6433157488dcafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45db96b659f82150a91f778505e2f353"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , require_std_vector_t&lt; StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a45db96b659f82150a91f778505e2f353"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a45db96b659f82150a91f778505e2f353.html#a45db96b659f82150a91f778505e2f353">check_corr_matrix</a> (const char *function, const char *name, const StdVec &amp;y)</td></tr>
<tr class="memdesc:a45db96b659f82150a91f778505e2f353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a valid correlation matrix.  <a href="namespacestan_1_1math_a45db96b659f82150a91f778505e2f353.html#a45db96b659f82150a91f778505e2f353">More...</a><br /></td></tr>
<tr class="separator:a45db96b659f82150a91f778505e2f353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82c3dc057cd933677de364ffaada0f8"><td class="memTemplParams" colspan="2">template&lt;typename Mat , require_matrix_t&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa82c3dc057cd933677de364ffaada0f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa82c3dc057cd933677de364ffaada0f8.html#aa82c3dc057cd933677de364ffaada0f8">check_cov_matrix</a> (const char *function, const char *name, const Mat &amp;y)</td></tr>
<tr class="memdesc:aa82c3dc057cd933677de364ffaada0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a valid covariance matrix.  <a href="namespacestan_1_1math_aa82c3dc057cd933677de364ffaada0f8.html#aa82c3dc057cd933677de364ffaada0f8">More...</a><br /></td></tr>
<tr class="separator:aa82c3dc057cd933677de364ffaada0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0e0ceeb3451c42005ac13f515e9a4f"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , require_std_vector_t&lt; StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acc0e0ceeb3451c42005ac13f515e9a4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acc0e0ceeb3451c42005ac13f515e9a4f.html#acc0e0ceeb3451c42005ac13f515e9a4f">check_cov_matrix</a> (const char *function, const char *name, const StdVec &amp;y)</td></tr>
<tr class="memdesc:acc0e0ceeb3451c42005ac13f515e9a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a valid covariance matrix.  <a href="namespacestan_1_1math_acc0e0ceeb3451c42005ac13f515e9a4f.html#acc0e0ceeb3451c42005ac13f515e9a4f">More...</a><br /></td></tr>
<tr class="separator:acc0e0ceeb3451c42005ac13f515e9a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c784e47c32e15cf4f1fa56c017e211"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:aa4c784e47c32e15cf4f1fa56c017e211"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa4c784e47c32e15cf4f1fa56c017e211.html#aa4c784e47c32e15cf4f1fa56c017e211">check_finite</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:aa4c784e47c32e15cf4f1fa56c017e211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if all values in <code>y</code> are finite.  <a href="namespacestan_1_1math_aa4c784e47c32e15cf4f1fa56c017e211.html#aa4c784e47c32e15cf4f1fa56c017e211">More...</a><br /></td></tr>
<tr class="separator:aa4c784e47c32e15cf4f1fa56c017e211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93977cc2ce858e59cb217d308d873e71"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::string, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a93977cc2ce858e59cb217d308d873e71.html#a93977cc2ce858e59cb217d308d873e71">cvodes_flag_msg</a> (int flag)</td></tr>
<tr class="memdesc:a93977cc2ce858e59cb217d308d873e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map cvodes error flag to acutally error msg.  <a href="namespacestan_1_1math_a93977cc2ce858e59cb217d308d873e71.html#a93977cc2ce858e59cb217d308d873e71">More...</a><br /></td></tr>
<tr class="separator:a93977cc2ce858e59cb217d308d873e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a189a6f9f65509a96a398f5cbb9feb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8a189a6f9f65509a96a398f5cbb9feb3.html#a8a189a6f9f65509a96a398f5cbb9feb3">cvodes_check</a> (int flag, const char *func_name)</td></tr>
<tr class="memdesc:a8a189a6f9f65509a96a398f5cbb9feb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws a std::runtime_error exception when a Sundial function fails (i.e.  <a href="namespacestan_1_1math_a8a189a6f9f65509a96a398f5cbb9feb3.html#a8a189a6f9f65509a96a398f5cbb9feb3">More...</a><br /></td></tr>
<tr class="separator:a8a189a6f9f65509a96a398f5cbb9feb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfa05c1b5d5ae11bb625b06b897045e"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::string, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9cfa05c1b5d5ae11bb625b06b897045e.html#a9cfa05c1b5d5ae11bb625b06b897045e">idas_flag_msg</a> (int flag)</td></tr>
<tr class="separator:a9cfa05c1b5d5ae11bb625b06b897045e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7b82dfbef07fb24f6439779517c636"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7a7b82dfbef07fb24f6439779517c636.html#a7a7b82dfbef07fb24f6439779517c636">idas_check</a> (int flag, const char *func_name)</td></tr>
<tr class="separator:a7a7b82dfbef07fb24f6439779517c636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cfb35c1d6c9d2b09f6bc76dc8778cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae5cfb35c1d6c9d2b09f6bc76dc8778cb.html#ae5cfb35c1d6c9d2b09f6bc76dc8778cb">kinsol_check</a> (int flag, const char *func_name)</td></tr>
<tr class="memdesc:ae5cfb35c1d6c9d2b09f6bc76dc8778cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws an exception message when the functions in KINSOL fails.  <a href="namespacestan_1_1math_ae5cfb35c1d6c9d2b09f6bc76dc8778cb.html#ae5cfb35c1d6c9d2b09f6bc76dc8778cb">More...</a><br /></td></tr>
<tr class="separator:ae5cfb35c1d6c9d2b09f6bc76dc8778cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8414d0b66b586bd9cbe2dc2f54905d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad8414d0b66b586bd9cbe2dc2f54905d0.html#ad8414d0b66b586bd9cbe2dc2f54905d0">kinsol_check</a> (int flag, const char *func_name, long int max_num_steps)</td></tr>
<tr class="memdesc:ad8414d0b66b586bd9cbe2dc2f54905d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws an exception message when the KINSol() call fails.  <a href="namespacestan_1_1math_ad8414d0b66b586bd9cbe2dc2f54905d0.html#ad8414d0b66b586bd9cbe2dc2f54905d0">More...</a><br /></td></tr>
<tr class="separator:ad8414d0b66b586bd9cbe2dc2f54905d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7b33ead3d2e8fa165f48e8029b6c5a"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , require_all_stan_scalar_t&lt; T_y, T_low &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:aec7b33ead3d2e8fa165f48e8029b6c5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aec7b33ead3d2e8fa165f48e8029b6c5a.html#aec7b33ead3d2e8fa165f48e8029b6c5a">check_greater</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low, Idxs... idxs)</td></tr>
<tr class="memdesc:aec7b33ead3d2e8fa165f48e8029b6c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not strictly greater than <code>low</code>.  <a href="namespacestan_1_1math_aec7b33ead3d2e8fa165f48e8029b6c5a.html#aec7b33ead3d2e8fa165f48e8029b6c5a">More...</a><br /></td></tr>
<tr class="separator:aec7b33ead3d2e8fa165f48e8029b6c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af344c2eef90d9a1820ee583c2fcb7052"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , require_stan_scalar_t&lt; T_y &gt; *  = nullptr, require_vector_t&lt; T_low &gt; *  = nullptr, require_not_std_vector_vt&lt; is_container_or_var_matrix, T_low &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:af344c2eef90d9a1820ee583c2fcb7052"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af344c2eef90d9a1820ee583c2fcb7052.html#af344c2eef90d9a1820ee583c2fcb7052">check_greater</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low, Idxs... idxs)</td></tr>
<tr class="memdesc:af344c2eef90d9a1820ee583c2fcb7052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not strictly greater than each element of <code>low</code>.  <a href="namespacestan_1_1math_af344c2eef90d9a1820ee583c2fcb7052.html#af344c2eef90d9a1820ee583c2fcb7052">More...</a><br /></td></tr>
<tr class="separator:af344c2eef90d9a1820ee583c2fcb7052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf22dcca757704f99564b57793e997ed"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , require_stan_scalar_t&lt; T_y &gt; *  = nullptr, require_dense_dynamic_t&lt; T_low &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:adf22dcca757704f99564b57793e997ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adf22dcca757704f99564b57793e997ed.html#adf22dcca757704f99564b57793e997ed">check_greater</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low, Idxs... idxs)</td></tr>
<tr class="memdesc:adf22dcca757704f99564b57793e997ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not strictly greater than each element of <code>low</code>.  <a href="namespacestan_1_1math_adf22dcca757704f99564b57793e997ed.html#adf22dcca757704f99564b57793e997ed">More...</a><br /></td></tr>
<tr class="separator:adf22dcca757704f99564b57793e997ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79080c1879ec04f4080745175b057cfe"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , require_all_stan_scalar_t&lt; T_y, T_low &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:a79080c1879ec04f4080745175b057cfe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a79080c1879ec04f4080745175b057cfe.html#a79080c1879ec04f4080745175b057cfe">check_greater_or_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low, Idxs... idxs)</td></tr>
<tr class="memdesc:a79080c1879ec04f4080745175b057cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not greater or equal than <code>low</code>.  <a href="namespacestan_1_1math_a79080c1879ec04f4080745175b057cfe.html#a79080c1879ec04f4080745175b057cfe">More...</a><br /></td></tr>
<tr class="separator:a79080c1879ec04f4080745175b057cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23634f18ecf38b127b984052e8914776"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , require_stan_scalar_t&lt; T_y &gt; *  = nullptr, require_vector_t&lt; T_low &gt; *  = nullptr, require_not_std_vector_vt&lt; is_container_or_var_matrix, T_low &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:a23634f18ecf38b127b984052e8914776"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a23634f18ecf38b127b984052e8914776.html#a23634f18ecf38b127b984052e8914776">check_greater_or_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low, Idxs... idxs)</td></tr>
<tr class="memdesc:a23634f18ecf38b127b984052e8914776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not greater or equal than each element of <code>low</code>.  <a href="namespacestan_1_1math_a23634f18ecf38b127b984052e8914776.html#a23634f18ecf38b127b984052e8914776">More...</a><br /></td></tr>
<tr class="separator:a23634f18ecf38b127b984052e8914776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f5f261e00d79dd6c6c2590be188c0d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , require_stan_scalar_t&lt; T_y &gt; *  = nullptr, require_dense_dynamic_t&lt; T_low &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:a27f5f261e00d79dd6c6c2590be188c0d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a27f5f261e00d79dd6c6c2590be188c0d.html#a27f5f261e00d79dd6c6c2590be188c0d">check_greater_or_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low, Idxs... idxs)</td></tr>
<tr class="memdesc:a27f5f261e00d79dd6c6c2590be188c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not greater or equal than each element of <code>low</code>.  <a href="namespacestan_1_1math_a27f5f261e00d79dd6c6c2590be188c0d.html#a27f5f261e00d79dd6c6c2590be188c0d">More...</a><br /></td></tr>
<tr class="separator:a27f5f261e00d79dd6c6c2590be188c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa540aa6dc103b789e700523514ba18db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa540aa6dc103b789e700523514ba18db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa540aa6dc103b789e700523514ba18db.html#aa540aa6dc103b789e700523514ba18db">check_ldlt_factor</a> (const char *function, const char *name, <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aa540aa6dc103b789e700523514ba18db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise domain error if the specified LDLT factor is invalid.  <a href="namespacestan_1_1math_aa540aa6dc103b789e700523514ba18db.html#aa540aa6dc103b789e700523514ba18db">More...</a><br /></td></tr>
<tr class="separator:aa540aa6dc103b789e700523514ba18db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbdcf963962d1aff5d424d9868a5ce9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high , require_all_stan_scalar_t&lt; T_y, T_high &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:adfbdcf963962d1aff5d424d9868a5ce9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adfbdcf963962d1aff5d424d9868a5ce9.html#adfbdcf963962d1aff5d424d9868a5ce9">check_less</a> (const char *function, const char *name, const T_y &amp;y, const T_high &amp;high, Idxs... idxs)</td></tr>
<tr class="memdesc:adfbdcf963962d1aff5d424d9868a5ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not strictly less than <code>high</code>.  <a href="namespacestan_1_1math_adfbdcf963962d1aff5d424d9868a5ce9.html#adfbdcf963962d1aff5d424d9868a5ce9">More...</a><br /></td></tr>
<tr class="separator:adfbdcf963962d1aff5d424d9868a5ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4767c5f3e1c7b7453358fbe913b17a30"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high , require_stan_scalar_t&lt; T_y &gt; *  = nullptr, require_vector_t&lt; T_high &gt; *  = nullptr, require_not_std_vector_vt&lt; is_container_or_var_matrix, T_high &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:a4767c5f3e1c7b7453358fbe913b17a30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4767c5f3e1c7b7453358fbe913b17a30.html#a4767c5f3e1c7b7453358fbe913b17a30">check_less</a> (const char *function, const char *name, const T_y &amp;y, const T_high &amp;high, Idxs... idxs)</td></tr>
<tr class="memdesc:a4767c5f3e1c7b7453358fbe913b17a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not strictly less than each element of <code>high</code>.  <a href="namespacestan_1_1math_a4767c5f3e1c7b7453358fbe913b17a30.html#a4767c5f3e1c7b7453358fbe913b17a30">More...</a><br /></td></tr>
<tr class="separator:a4767c5f3e1c7b7453358fbe913b17a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17983b17bfff0b43a0ed526971decc9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high , require_stan_scalar_t&lt; T_y &gt; *  = nullptr, require_dense_dynamic_t&lt; T_high &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:aa17983b17bfff0b43a0ed526971decc9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa17983b17bfff0b43a0ed526971decc9.html#aa17983b17bfff0b43a0ed526971decc9">check_less</a> (const char *function, const char *name, const T_y &amp;y, const T_high &amp;high, Idxs... idxs)</td></tr>
<tr class="memdesc:aa17983b17bfff0b43a0ed526971decc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not strictly less than each element of <code>high</code>.  <a href="namespacestan_1_1math_aa17983b17bfff0b43a0ed526971decc9.html#aa17983b17bfff0b43a0ed526971decc9">More...</a><br /></td></tr>
<tr class="separator:aa17983b17bfff0b43a0ed526971decc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098e29ee53a15aeaf276ddc8969708bb"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high , require_all_stan_scalar_t&lt; T_y, T_high &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:a098e29ee53a15aeaf276ddc8969708bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a098e29ee53a15aeaf276ddc8969708bb.html#a098e29ee53a15aeaf276ddc8969708bb">check_less_or_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_high &amp;high, Idxs... idxs)</td></tr>
<tr class="memdesc:a098e29ee53a15aeaf276ddc8969708bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not less than <code>high</code>.  <a href="namespacestan_1_1math_a098e29ee53a15aeaf276ddc8969708bb.html#a098e29ee53a15aeaf276ddc8969708bb">More...</a><br /></td></tr>
<tr class="separator:a098e29ee53a15aeaf276ddc8969708bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ecf5297a3b509b8c32484bb22e0446"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high , require_stan_scalar_t&lt; T_y &gt; *  = nullptr, require_vector_t&lt; T_high &gt; *  = nullptr, require_not_std_vector_vt&lt; is_container_or_var_matrix, T_high &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:ae2ecf5297a3b509b8c32484bb22e0446"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae2ecf5297a3b509b8c32484bb22e0446.html#ae2ecf5297a3b509b8c32484bb22e0446">check_less_or_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_high &amp;high, Idxs... idxs)</td></tr>
<tr class="memdesc:ae2ecf5297a3b509b8c32484bb22e0446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not less than each element of <code>high</code>.  <a href="namespacestan_1_1math_ae2ecf5297a3b509b8c32484bb22e0446.html#ae2ecf5297a3b509b8c32484bb22e0446">More...</a><br /></td></tr>
<tr class="separator:ae2ecf5297a3b509b8c32484bb22e0446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b71290d36f2cf80b26cbffded281df3"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high , require_stan_scalar_t&lt; T_y &gt; *  = nullptr, require_dense_dynamic_t&lt; T_high &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:a9b71290d36f2cf80b26cbffded281df3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9b71290d36f2cf80b26cbffded281df3.html#a9b71290d36f2cf80b26cbffded281df3">check_less_or_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_high &amp;high, Idxs... idxs)</td></tr>
<tr class="memdesc:a9b71290d36f2cf80b26cbffded281df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not less than each element of <code>high</code>.  <a href="namespacestan_1_1math_a9b71290d36f2cf80b26cbffded281df3.html#a9b71290d36f2cf80b26cbffded281df3">More...</a><br /></td></tr>
<tr class="separator:a9b71290d36f2cf80b26cbffded281df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80f3ad0788da11a47219300bd99c96f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , require_eigen_t&lt; T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae80f3ad0788da11a47219300bd99c96f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae80f3ad0788da11a47219300bd99c96f.html#ae80f3ad0788da11a47219300bd99c96f">check_lower_triangular</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:ae80f3ad0788da11a47219300bd99c96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified matrix is lower triangular.  <a href="namespacestan_1_1math_ae80f3ad0788da11a47219300bd99c96f.html#ae80f3ad0788da11a47219300bd99c96f">More...</a><br /></td></tr>
<tr class="separator:ae80f3ad0788da11a47219300bd99c96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c7e3cfd234ccbfede7d785c4955e81"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_not_matrix_t&lt; T1, T2 &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a72c7e3cfd234ccbfede7d785c4955e81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a72c7e3cfd234ccbfede7d785c4955e81.html#a72c7e3cfd234ccbfede7d785c4955e81">check_matching_dims</a> (const char *function, const char *name1, const T1 &amp;y1, const char *name2, const T2 &amp;y2)</td></tr>
<tr class="memdesc:a72c7e3cfd234ccbfede7d785c4955e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the two containers have the same dimensions.  <a href="namespacestan_1_1math_a72c7e3cfd234ccbfede7d785c4955e81.html#a72c7e3cfd234ccbfede7d785c4955e81">More...</a><br /></td></tr>
<tr class="separator:a72c7e3cfd234ccbfede7d785c4955e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1c74b68967574a4ca09238967292ab"><td class="memTemplParams" colspan="2">template&lt;bool check_compile, typename Mat1 , typename Mat2 , typename  = require_all_eigen_t&lt;Mat1, Mat2&gt;&gt; </td></tr>
<tr class="memitem:a2c1c74b68967574a4ca09238967292ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2c1c74b68967574a4ca09238967292ab.html#a2c1c74b68967574a4ca09238967292ab">check_matching_dims</a> (const char *function, const char *name1, const Mat1 &amp;y1, const char *name2, const Mat2 &amp;y2)</td></tr>
<tr class="memdesc:a2c1c74b68967574a4ca09238967292ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the two matrices are of the same size.  <a href="namespacestan_1_1math_a2c1c74b68967574a4ca09238967292ab.html#a2c1c74b68967574a4ca09238967292ab">More...</a><br /></td></tr>
<tr class="separator:a2c1c74b68967574a4ca09238967292ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2be3873d1e10f865a00e5eab361913"><td class="memTemplParams" colspan="2">template&lt;typename T_y1 , typename T_y2 &gt; </td></tr>
<tr class="memitem:a7b2be3873d1e10f865a00e5eab361913"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7b2be3873d1e10f865a00e5eab361913.html#a7b2be3873d1e10f865a00e5eab361913">check_matching_sizes</a> (const char *function, const char *name1, const T_y1 &amp;y1, const char *name2, const T_y2 &amp;y2)</td></tr>
<tr class="memdesc:a7b2be3873d1e10f865a00e5eab361913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two structures at the same size.  <a href="namespacestan_1_1math_a7b2be3873d1e10f865a00e5eab361913.html#a7b2be3873d1e10f865a00e5eab361913">More...</a><br /></td></tr>
<tr class="separator:a7b2be3873d1e10f865a00e5eab361913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2faef6c23d17402e88aa758bd7b04c82"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a2faef6c23d17402e88aa758bd7b04c82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2faef6c23d17402e88aa758bd7b04c82.html#a2faef6c23d17402e88aa758bd7b04c82">check_multiplicable</a> (const char *function, const char *name1, const T1 &amp;y1, const char *name2, const T2 &amp;y2)</td></tr>
<tr class="memdesc:a2faef6c23d17402e88aa758bd7b04c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the matrices can be multiplied.  <a href="namespacestan_1_1math_a2faef6c23d17402e88aa758bd7b04c82.html#a2faef6c23d17402e88aa758bd7b04c82">More...</a><br /></td></tr>
<tr class="separator:a2faef6c23d17402e88aa758bd7b04c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275a219041e4baa51d8ea4c415d5297e"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a275a219041e4baa51d8ea4c415d5297e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a275a219041e4baa51d8ea4c415d5297e.html#a275a219041e4baa51d8ea4c415d5297e">check_nonnegative</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:a275a219041e4baa51d8ea4c415d5297e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>y</code> is non-negative.  <a href="namespacestan_1_1math_a275a219041e4baa51d8ea4c415d5297e.html#a275a219041e4baa51d8ea4c415d5297e">More...</a><br /></td></tr>
<tr class="separator:a275a219041e4baa51d8ea4c415d5297e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7df68f2df1ee2432e7ffd5935f974c"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:abf7df68f2df1ee2432e7ffd5935f974c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abf7df68f2df1ee2432e7ffd5935f974c.html#abf7df68f2df1ee2432e7ffd5935f974c">check_nonzero_size</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:abf7df68f2df1ee2432e7ffd5935f974c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified matrix/vector is of non-zero size.  <a href="namespacestan_1_1math_abf7df68f2df1ee2432e7ffd5935f974c.html#abf7df68f2df1ee2432e7ffd5935f974c">More...</a><br /></td></tr>
<tr class="separator:abf7df68f2df1ee2432e7ffd5935f974c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab61c29fb78bd02ac380156c065beefe"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:aab61c29fb78bd02ac380156c065beefe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab61c29fb78bd02ac380156c065beefe.html#aab61c29fb78bd02ac380156c065beefe">check_not_nan</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:aab61c29fb78bd02ac380156c065beefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>y</code> is not <code>NaN</code>.  <a href="namespacestan_1_1math_aab61c29fb78bd02ac380156c065beefe.html#aab61c29fb78bd02ac380156c065beefe">More...</a><br /></td></tr>
<tr class="separator:aab61c29fb78bd02ac380156c065beefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9027241b2af63e33791267e79982d2a"><td class="memTemplParams" colspan="2">template&lt;typename T_y , require_vector_t&lt; T_y &gt; *  = nullptr, require_not_std_vector_t&lt; T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad9027241b2af63e33791267e79982d2a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad9027241b2af63e33791267e79982d2a.html#ad9027241b2af63e33791267e79982d2a">check_ordered</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:ad9027241b2af63e33791267e79982d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified vector is not sorted into strictly increasing order.  <a href="namespacestan_1_1math_ad9027241b2af63e33791267e79982d2a.html#ad9027241b2af63e33791267e79982d2a">More...</a><br /></td></tr>
<tr class="separator:ad9027241b2af63e33791267e79982d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593be410033a216c0a4b649ca8fb3a1b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , require_std_vector_vt&lt; is_stan_scalar, T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a593be410033a216c0a4b649ca8fb3a1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a593be410033a216c0a4b649ca8fb3a1b.html#a593be410033a216c0a4b649ca8fb3a1b">check_ordered</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:a593be410033a216c0a4b649ca8fb3a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified vector is not sorted into strictly increasing order.  <a href="namespacestan_1_1math_a593be410033a216c0a4b649ca8fb3a1b.html#a593be410033a216c0a4b649ca8fb3a1b">More...</a><br /></td></tr>
<tr class="separator:a593be410033a216c0a4b649ca8fb3a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5942cb9fb5c93f58161490a2dfe5db39"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_matrix_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5942cb9fb5c93f58161490a2dfe5db39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5942cb9fb5c93f58161490a2dfe5db39.html#a5942cb9fb5c93f58161490a2dfe5db39">check_pos_definite</a> (const char *function, const char *name, const EigMat &amp;y)</td></tr>
<tr class="memdesc:a5942cb9fb5c93f58161490a2dfe5db39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified square, symmetric matrix is positive definite.  <a href="namespacestan_1_1math_a5942cb9fb5c93f58161490a2dfe5db39.html#a5942cb9fb5c93f58161490a2dfe5db39">More...</a><br /></td></tr>
<tr class="separator:a5942cb9fb5c93f58161490a2dfe5db39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72abfa604ccb66c78756223c58139143"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a72abfa604ccb66c78756223c58139143"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a72abfa604ccb66c78756223c58139143.html#a72abfa604ccb66c78756223c58139143">check_pos_definite</a> (const char *function, const char *name, const Eigen::LDLT&lt; Derived &gt; &amp;cholesky)</td></tr>
<tr class="memdesc:a72abfa604ccb66c78756223c58139143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified LDLT decomposition of a matrix is positive definite.  <a href="namespacestan_1_1math_a72abfa604ccb66c78756223c58139143.html#a72abfa604ccb66c78756223c58139143">More...</a><br /></td></tr>
<tr class="separator:a72abfa604ccb66c78756223c58139143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f502596899ce08b68992f1798800a0a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1f502596899ce08b68992f1798800a0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1f502596899ce08b68992f1798800a0a.html#a1f502596899ce08b68992f1798800a0a">check_pos_definite</a> (const char *function, const char *name, const Eigen::LLT&lt; Derived &gt; &amp;cholesky)</td></tr>
<tr class="memdesc:a1f502596899ce08b68992f1798800a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified LLT decomposition was successful.  <a href="namespacestan_1_1math_a1f502596899ce08b68992f1798800a0a.html#a1f502596899ce08b68992f1798800a0a">More...</a><br /></td></tr>
<tr class="separator:a1f502596899ce08b68992f1798800a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d7a60e23b3572f9a6f38978e73aa41"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_matrix_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a36d7a60e23b3572f9a6f38978e73aa41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a36d7a60e23b3572f9a6f38978e73aa41.html#a36d7a60e23b3572f9a6f38978e73aa41">check_pos_semidefinite</a> (const char *function, const char *name, const EigMat &amp;y)</td></tr>
<tr class="memdesc:a36d7a60e23b3572f9a6f38978e73aa41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified matrix is positive definite.  <a href="namespacestan_1_1math_a36d7a60e23b3572f9a6f38978e73aa41.html#a36d7a60e23b3572f9a6f38978e73aa41">More...</a><br /></td></tr>
<tr class="separator:a36d7a60e23b3572f9a6f38978e73aa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdab2383f63a63688b771d9996dff2e"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1fdab2383f63a63688b771d9996dff2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1fdab2383f63a63688b771d9996dff2e.html#a1fdab2383f63a63688b771d9996dff2e">check_pos_semidefinite</a> (const char *function, const char *name, const Eigen::LDLT&lt; Derived &gt; &amp;cholesky)</td></tr>
<tr class="memdesc:a1fdab2383f63a63688b771d9996dff2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified matrix is positive semidefinite.  <a href="namespacestan_1_1math_a1fdab2383f63a63688b771d9996dff2e.html#a1fdab2383f63a63688b771d9996dff2e">More...</a><br /></td></tr>
<tr class="separator:a1fdab2383f63a63688b771d9996dff2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac089cbbe398dec189a188017c61ee154"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:ac089cbbe398dec189a188017c61ee154"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac089cbbe398dec189a188017c61ee154.html#ac089cbbe398dec189a188017c61ee154">check_positive</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:ac089cbbe398dec189a188017c61ee154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>y</code> is positive.  <a href="namespacestan_1_1math_ac089cbbe398dec189a188017c61ee154.html#ac089cbbe398dec189a188017c61ee154">More...</a><br /></td></tr>
<tr class="separator:ac089cbbe398dec189a188017c61ee154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89de6a3f7f216285d4ce46fd9efe76b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae89de6a3f7f216285d4ce46fd9efe76b.html#ae89de6a3f7f216285d4ce46fd9efe76b">check_positive</a> (const char *function, const char *name, const char *expr, int <a class="el" href="group__type__trait_ga98afb6ae5281b82b30caa793e205f6ae.html#ga98afb6ae5281b82b30caa793e205f6ae">size</a>)</td></tr>
<tr class="memdesc:ae89de6a3f7f216285d4ce46fd9efe76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>size</code> is positive.  <a href="namespacestan_1_1math_ae89de6a3f7f216285d4ce46fd9efe76b.html#ae89de6a3f7f216285d4ce46fd9efe76b">More...</a><br /></td></tr>
<tr class="separator:ae89de6a3f7f216285d4ce46fd9efe76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12b463f25bbf05264cc9361ad484eec"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:af12b463f25bbf05264cc9361ad484eec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af12b463f25bbf05264cc9361ad484eec.html#af12b463f25bbf05264cc9361ad484eec">check_positive_finite</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:af12b463f25bbf05264cc9361ad484eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>y</code> is positive and finite.  <a href="namespacestan_1_1math_af12b463f25bbf05264cc9361ad484eec.html#af12b463f25bbf05264cc9361ad484eec">More...</a><br /></td></tr>
<tr class="separator:af12b463f25bbf05264cc9361ad484eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d2fecce959317ff652e1cb20f15ee1"><td class="memTemplParams" colspan="2">template&lt;typename Vec , require_vector_t&lt; Vec &gt; *  = nullptr, require_not_std_vector_t&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a08d2fecce959317ff652e1cb20f15ee1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a08d2fecce959317ff652e1cb20f15ee1.html#a08d2fecce959317ff652e1cb20f15ee1">check_positive_ordered</a> (const char *function, const char *name, const Vec &amp;y)</td></tr>
<tr class="memdesc:a08d2fecce959317ff652e1cb20f15ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified the vector contains negative values or is not sorted into strictly increasing order.  <a href="namespacestan_1_1math_a08d2fecce959317ff652e1cb20f15ee1.html#a08d2fecce959317ff652e1cb20f15ee1">More...</a><br /></td></tr>
<tr class="separator:a08d2fecce959317ff652e1cb20f15ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad590546f446ae73eb8e982cb15c0b081"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , require_std_vector_t&lt; StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad590546f446ae73eb8e982cb15c0b081"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad590546f446ae73eb8e982cb15c0b081.html#ad590546f446ae73eb8e982cb15c0b081">check_positive_ordered</a> (const char *function, const char *name, const StdVec &amp;y)</td></tr>
<tr class="memdesc:ad590546f446ae73eb8e982cb15c0b081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if any of the vectors in a standard vector contains negative values or is not sorted into strictly increasing order.  <a href="namespacestan_1_1math_ad590546f446ae73eb8e982cb15c0b081.html#ad590546f446ae73eb8e982cb15c0b081">More...</a><br /></td></tr>
<tr class="separator:ad590546f446ae73eb8e982cb15c0b081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaacd79b85845a32f656187bfe47332f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adaacd79b85845a32f656187bfe47332f.html#adaacd79b85845a32f656187bfe47332f">check_range</a> (const char *function, const char *name, int <a class="el" href="namespacestan_1_1math_aeff33af49e42875a07f600583adb4940.html#aeff33af49e42875a07f600583adb4940">max</a>, int index, int nested_level, const char *error_msg)</td></tr>
<tr class="memdesc:adaacd79b85845a32f656187bfe47332f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if specified index is within range.  <a href="namespacestan_1_1math_adaacd79b85845a32f656187bfe47332f.html#adaacd79b85845a32f656187bfe47332f">More...</a><br /></td></tr>
<tr class="separator:adaacd79b85845a32f656187bfe47332f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0241a8524dc37b8b04280c2e93f9d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aff0241a8524dc37b8b04280c2e93f9d0.html#aff0241a8524dc37b8b04280c2e93f9d0">check_range</a> (const char *function, const char *name, int <a class="el" href="namespacestan_1_1math_aeff33af49e42875a07f600583adb4940.html#aeff33af49e42875a07f600583adb4940">max</a>, int index, const char *error_msg)</td></tr>
<tr class="memdesc:aff0241a8524dc37b8b04280c2e93f9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if specified index is within range.  <a href="namespacestan_1_1math_aff0241a8524dc37b8b04280c2e93f9d0.html#aff0241a8524dc37b8b04280c2e93f9d0">More...</a><br /></td></tr>
<tr class="separator:aff0241a8524dc37b8b04280c2e93f9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4229825590b1a0f35df380b9e44b829a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4229825590b1a0f35df380b9e44b829a.html#a4229825590b1a0f35df380b9e44b829a">check_range</a> (const char *function, const char *name, int <a class="el" href="namespacestan_1_1math_aeff33af49e42875a07f600583adb4940.html#aeff33af49e42875a07f600583adb4940">max</a>, int index)</td></tr>
<tr class="memdesc:a4229825590b1a0f35df380b9e44b829a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if specified index is within range.  <a href="namespacestan_1_1math_a4229825590b1a0f35df380b9e44b829a.html#a4229825590b1a0f35df380b9e44b829a">More...</a><br /></td></tr>
<tr class="separator:a4229825590b1a0f35df380b9e44b829a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdab326874d0654d6972019bb5f987e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename  = require_matrix_t&lt;T_y&gt;&gt; </td></tr>
<tr class="memitem:a2bdab326874d0654d6972019bb5f987e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2bdab326874d0654d6972019bb5f987e.html#a2bdab326874d0654d6972019bb5f987e">check_row_index</a> (const char *function, const char *name, const T_y &amp;y, size_t i)</td></tr>
<tr class="memdesc:a2bdab326874d0654d6972019bb5f987e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified index is a valid row of the matrix This check is 1-indexed by default.  <a href="namespacestan_1_1math_a2bdab326874d0654d6972019bb5f987e.html#a2bdab326874d0654d6972019bb5f987e">More...</a><br /></td></tr>
<tr class="separator:a2bdab326874d0654d6972019bb5f987e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8834d287c248a6895057711fb4582cfa"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8834d287c248a6895057711fb4582cfa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8834d287c248a6895057711fb4582cfa.html#a8834d287c248a6895057711fb4582cfa">check_simplex</a> (const char *function, const char *name, const T &amp;theta)</td></tr>
<tr class="memdesc:a8834d287c248a6895057711fb4582cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified vector is not a simplex.  <a href="namespacestan_1_1math_a8834d287c248a6895057711fb4582cfa.html#a8834d287c248a6895057711fb4582cfa">More...</a><br /></td></tr>
<tr class="separator:a8834d287c248a6895057711fb4582cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf85220664649c7ba7c9c893e013c20a"><td class="memTemplParams" colspan="2">template&lt;typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:adf85220664649c7ba7c9c893e013c20a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adf85220664649c7ba7c9c893e013c20a.html#adf85220664649c7ba7c9c893e013c20a">check_size_match</a> (const char *function, const char *name_i, T_size1 i, const char *name_j, T_size2 j)</td></tr>
<tr class="memdesc:adf85220664649c7ba7c9c893e013c20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the provided sizes match.  <a href="namespacestan_1_1math_adf85220664649c7ba7c9c893e013c20a.html#adf85220664649c7ba7c9c893e013c20a">More...</a><br /></td></tr>
<tr class="separator:adf85220664649c7ba7c9c893e013c20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b84e9fbd00dbc41f75290f7292930b"><td class="memTemplParams" colspan="2">template&lt;typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:ad8b84e9fbd00dbc41f75290f7292930b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad8b84e9fbd00dbc41f75290f7292930b.html#ad8b84e9fbd00dbc41f75290f7292930b">check_size_match</a> (const char *function, const char *expr_i, const char *name_i, T_size1 i, const char *expr_j, const char *name_j, T_size2 j)</td></tr>
<tr class="memdesc:ad8b84e9fbd00dbc41f75290f7292930b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the provided sizes match.  <a href="namespacestan_1_1math_ad8b84e9fbd00dbc41f75290f7292930b.html#ad8b84e9fbd00dbc41f75290f7292930b">More...</a><br /></td></tr>
<tr class="separator:ad8b84e9fbd00dbc41f75290f7292930b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73586e43b125a5a563e184c637c3b56"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_eigen_vector_t&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac73586e43b125a5a563e184c637c3b56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac73586e43b125a5a563e184c637c3b56.html#ac73586e43b125a5a563e184c637c3b56">check_sorted</a> (const char *function, const char *name, const EigVec &amp;y)</td></tr>
<tr class="memdesc:ac73586e43b125a5a563e184c637c3b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified vector is sorted into increasing order (repeated values are okay).  <a href="namespacestan_1_1math_ac73586e43b125a5a563e184c637c3b56.html#ac73586e43b125a5a563e184c637c3b56">More...</a><br /></td></tr>
<tr class="separator:ac73586e43b125a5a563e184c637c3b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a695a2405a12d74f294585898d4d610"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a6a695a2405a12d74f294585898d4d610"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6a695a2405a12d74f294585898d4d610.html#a6a695a2405a12d74f294585898d4d610">check_sorted</a> (const char *function, const char *name, const std::vector&lt; T_y &gt; &amp;y)</td></tr>
<tr class="memdesc:a6a695a2405a12d74f294585898d4d610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified vector is sorted into increasing order (repeated values are okay).  <a href="namespacestan_1_1math_a6a695a2405a12d74f294585898d4d610.html#a6a695a2405a12d74f294585898d4d610">More...</a><br /></td></tr>
<tr class="separator:a6a695a2405a12d74f294585898d4d610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220c970623ee44ebe8d9b1d7a0765988"><td class="memTemplParams" colspan="2">template&lt;typename T_y , require_any_t&lt; is_matrix&lt; T_y &gt;, is_prim_or_rev_kernel_expression&lt; T_y &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a220c970623ee44ebe8d9b1d7a0765988"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a220c970623ee44ebe8d9b1d7a0765988.html#a220c970623ee44ebe8d9b1d7a0765988">check_square</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:a220c970623ee44ebe8d9b1d7a0765988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified matrix is square.  <a href="namespacestan_1_1math_a220c970623ee44ebe8d9b1d7a0765988.html#a220c970623ee44ebe8d9b1d7a0765988">More...</a><br /></td></tr>
<tr class="separator:a220c970623ee44ebe8d9b1d7a0765988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab244b2c1234824cd1775482124e0f199"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab244b2c1234824cd1775482124e0f199"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab244b2c1234824cd1775482124e0f199.html#ab244b2c1234824cd1775482124e0f199">check_std_vector_index</a> (const char *function, const char *name, const std::vector&lt; T &gt; &amp;y, int i)</td></tr>
<tr class="memdesc:ab244b2c1234824cd1775482124e0f199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified index is valid in std vector This check is 1-indexed by default.  <a href="namespacestan_1_1math_ab244b2c1234824cd1775482124e0f199.html#ab244b2c1234824cd1775482124e0f199">More...</a><br /></td></tr>
<tr class="separator:ab244b2c1234824cd1775482124e0f199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d7fdfe43e28dc099680e9b9307cf53"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_matrix_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a95d7fdfe43e28dc099680e9b9307cf53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a95d7fdfe43e28dc099680e9b9307cf53.html#a95d7fdfe43e28dc099680e9b9307cf53">check_symmetric</a> (const char *function, const char *name, const EigMat &amp;y)</td></tr>
<tr class="memdesc:a95d7fdfe43e28dc099680e9b9307cf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified matrix is symmetric.  <a href="namespacestan_1_1math_a95d7fdfe43e28dc099680e9b9307cf53.html#a95d7fdfe43e28dc099680e9b9307cf53">More...</a><br /></td></tr>
<tr class="separator:a95d7fdfe43e28dc099680e9b9307cf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247c2f25b04b848181f1f2440630a6a9"><td class="memTemplParams" colspan="2">template&lt;typename Vec , require_vector_t&lt; Vec &gt; *  = nullptr, require_not_std_vector_t&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a247c2f25b04b848181f1f2440630a6a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a247c2f25b04b848181f1f2440630a6a9.html#a247c2f25b04b848181f1f2440630a6a9">check_unit_vector</a> (const char *function, const char *name, const Vec &amp;theta)</td></tr>
<tr class="memdesc:a247c2f25b04b848181f1f2440630a6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified vector does not have unit Euclidiean length.  <a href="namespacestan_1_1math_a247c2f25b04b848181f1f2440630a6a9.html#a247c2f25b04b848181f1f2440630a6a9">More...</a><br /></td></tr>
<tr class="separator:a247c2f25b04b848181f1f2440630a6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabc68dd678bb36922d47631f2a8aa4e"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , require_std_vector_t&lt; StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acabc68dd678bb36922d47631f2a8aa4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acabc68dd678bb36922d47631f2a8aa4e.html#acabc68dd678bb36922d47631f2a8aa4e">check_unit_vector</a> (const char *function, const char *name, const StdVec &amp;theta)</td></tr>
<tr class="memdesc:acabc68dd678bb36922d47631f2a8aa4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the each element in a standard vector does not have unit Euclidiean length.  <a href="namespacestan_1_1math_acabc68dd678bb36922d47631f2a8aa4e.html#acabc68dd678bb36922d47631f2a8aa4e">More...</a><br /></td></tr>
<tr class="separator:acabc68dd678bb36922d47631f2a8aa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cc69726215f6f8f0559a938948f199"><td class="memTemplParams" colspan="2">template&lt;typename Mat , require_any_t&lt; is_matrix&lt; Mat &gt;, is_prim_or_rev_kernel_expression&lt; Mat &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a54cc69726215f6f8f0559a938948f199"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a54cc69726215f6f8f0559a938948f199.html#a54cc69726215f6f8f0559a938948f199">check_vector</a> (const char *function, const char *name, const Mat &amp;x)</td></tr>
<tr class="memdesc:a54cc69726215f6f8f0559a938948f199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the input is either a row vector or column vector or a matrix with a single row or column.  <a href="namespacestan_1_1math_a54cc69726215f6f8f0559a938948f199.html#a54cc69726215f6f8f0559a938948f199">More...</a><br /></td></tr>
<tr class="separator:a54cc69726215f6f8f0559a938948f199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4c490bd9d17e3f9c3908a3ab7c3f0d"><td class="memTemplParams" colspan="2">template&lt;typename T , require_any_t&lt; is_vector&lt; T &gt;, is_prim_or_rev_kernel_expression&lt; T &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0d4c490bd9d17e3f9c3908a3ab7c3f0d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0d4c490bd9d17e3f9c3908a3ab7c3f0d.html#a0d4c490bd9d17e3f9c3908a3ab7c3f0d">check_vector_index</a> (const char *function, const char *name, const T &amp;y, size_t i)</td></tr>
<tr class="memdesc:a0d4c490bd9d17e3f9c3908a3ab7c3f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified index is a valid element of the row or column vector This check is 1-indexed by default.  <a href="namespacestan_1_1math_a0d4c490bd9d17e3f9c3908a3ab7c3f0d.html#a0d4c490bd9d17e3f9c3908a3ab7c3f0d">More...</a><br /></td></tr>
<tr class="separator:a0d4c490bd9d17e3f9c3908a3ab7c3f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebafad688145fc64353e4f455d014bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeebafad688145fc64353e4f455d014bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeebafad688145fc64353e4f455d014bd.html#aeebafad688145fc64353e4f455d014bd">domain_error</a> (const char *function, const char *name, const T &amp;y, const char *msg1, const char *msg2)</td></tr>
<tr class="separator:aeebafad688145fc64353e4f455d014bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d489a4a749c8e429b519d9e26c157"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a108d489a4a749c8e429b519d9e26c157"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a108d489a4a749c8e429b519d9e26c157.html#a108d489a4a749c8e429b519d9e26c157">domain_error</a> (const char *function, const char *name, const T &amp;y, const char *msg1)</td></tr>
<tr class="separator:a108d489a4a749c8e429b519d9e26c157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25639b3c27a227e1606ca917267c05c8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a25639b3c27a227e1606ca917267c05c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a25639b3c27a227e1606ca917267c05c8.html#a25639b3c27a227e1606ca917267c05c8">domain_error_vec</a> (const char *function, const char *name, const T &amp;y, size_t i, const char *msg1, const char *msg2)</td></tr>
<tr class="separator:a25639b3c27a227e1606ca917267c05c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2202974eb2454de5028673d5f5bee3c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2202974eb2454de5028673d5f5bee3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad2202974eb2454de5028673d5f5bee3c.html#ad2202974eb2454de5028673d5f5bee3c">domain_error_vec</a> (const char *function, const char *name, const T &amp;y, size_t i, const char *msg1)</td></tr>
<tr class="separator:ad2202974eb2454de5028673d5f5bee3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2470c81512e623b9316a51310a97b661"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... Indexings, require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2470c81512e623b9316a51310a97b661"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2470c81512e623b9316a51310a97b661.html#a2470c81512e623b9316a51310a97b661">elementwise_check</a> (const F &amp;is_good, const char *function, const char *name, const T &amp;x, const char *must_be, const Indexings &amp;... indexings)</td></tr>
<tr class="memdesc:a2470c81512e623b9316a51310a97b661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the predicate holds for the value of <code>x</code>.  <a href="namespacestan_1_1math_a2470c81512e623b9316a51310a97b661.html#a2470c81512e623b9316a51310a97b661">More...</a><br /></td></tr>
<tr class="separator:a2470c81512e623b9316a51310a97b661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2554ade8de85253b7d1a233ef5c055f8"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... Indexings, require_eigen_t&lt; T &gt; *  = nullptr, std::enable_if_t&lt;(Eigen::internal::traits&lt; T &gt;::Flags &amp;Eigen::LinearAccessBit)||T::IsVectorAtCompileTime &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2554ade8de85253b7d1a233ef5c055f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2554ade8de85253b7d1a233ef5c055f8.html#a2554ade8de85253b7d1a233ef5c055f8">elementwise_check</a> (const F &amp;is_good, const char *function, const char *name, const T &amp;x, const char *must_be, const Indexings &amp;... indexings)</td></tr>
<tr class="memdesc:a2554ade8de85253b7d1a233ef5c055f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the predicate holds for all elements of the value of <code>x</code>.  <a href="namespacestan_1_1math_a2554ade8de85253b7d1a233ef5c055f8.html#a2554ade8de85253b7d1a233ef5c055f8">More...</a><br /></td></tr>
<tr class="separator:a2554ade8de85253b7d1a233ef5c055f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86d43ff9f966275e35193a884b3d6bd"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:ae86d43ff9f966275e35193a884b3d6bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae86d43ff9f966275e35193a884b3d6bd.html#ae86d43ff9f966275e35193a884b3d6bd">elementwise_is</a> (const F &amp;is_good, const T &amp;x)</td></tr>
<tr class="memdesc:ae86d43ff9f966275e35193a884b3d6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the predicate holds for the value of <code>x</code>, working elementwise on containers.  <a href="namespacestan_1_1math_ae86d43ff9f966275e35193a884b3d6bd.html#ae86d43ff9f966275e35193a884b3d6bd">More...</a><br /></td></tr>
<tr class="separator:ae86d43ff9f966275e35193a884b3d6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd0fcf9983d0e2b18a0770263e552f0"><td class="memTemplParams" colspan="2">template&lt;typename T_omega , typename T_Gamma , typename T_rho , require_all_eigen_t&lt; T_omega, T_Gamma &gt; *  = nullptr, require_eigen_col_vector_t&lt; T_rho &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5dd0fcf9983d0e2b18a0770263e552f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5dd0fcf9983d0e2b18a0770263e552f0.html#a5dd0fcf9983d0e2b18a0770263e552f0">hmm_check</a> (const T_omega &amp;log_omegas, const T_Gamma &amp;Gamma, const T_rho &amp;rho, const char *function)</td></tr>
<tr class="memdesc:a5dd0fcf9983d0e2b18a0770263e552f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check arguments for hidden Markov model functions with a discrete latent state (lpdf, rng for latent states, and marginal probabilities for latent sates).  <a href="namespacestan_1_1math_a5dd0fcf9983d0e2b18a0770263e552f0.html#a5dd0fcf9983d0e2b18a0770263e552f0">More...</a><br /></td></tr>
<tr class="separator:a5dd0fcf9983d0e2b18a0770263e552f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcb1af5657f92ccadf5204fc43377fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bcb1af5657f92ccadf5204fc43377fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9bcb1af5657f92ccadf5204fc43377fd.html#a9bcb1af5657f92ccadf5204fc43377fd">invalid_argument</a> (const char *function, const char *name, const T &amp;y, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:a9bcb1af5657f92ccadf5204fc43377fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an invalid_argument exception with a consistently formatted message.  <a href="namespacestan_1_1math_a9bcb1af5657f92ccadf5204fc43377fd.html#a9bcb1af5657f92ccadf5204fc43377fd">More...</a><br /></td></tr>
<tr class="separator:a9bcb1af5657f92ccadf5204fc43377fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf5709c614035ef60053a348e18554c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aacf5709c614035ef60053a348e18554c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aacf5709c614035ef60053a348e18554c.html#aacf5709c614035ef60053a348e18554c">invalid_argument</a> (const char *function, const char *name, const T &amp;y, const char *msg1)</td></tr>
<tr class="memdesc:aacf5709c614035ef60053a348e18554c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an invalid_argument exception with a consistently formatted message.  <a href="namespacestan_1_1math_aacf5709c614035ef60053a348e18554c.html#aacf5709c614035ef60053a348e18554c">More...</a><br /></td></tr>
<tr class="separator:aacf5709c614035ef60053a348e18554c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209852214945630472cc47bf3343aed6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a209852214945630472cc47bf3343aed6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a209852214945630472cc47bf3343aed6.html#a209852214945630472cc47bf3343aed6">invalid_argument_vec</a> (const char *function, const char *name, const T &amp;y, size_t i, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:a209852214945630472cc47bf3343aed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an invalid argument exception with a consistently formatted message.  <a href="namespacestan_1_1math_a209852214945630472cc47bf3343aed6.html#a209852214945630472cc47bf3343aed6">More...</a><br /></td></tr>
<tr class="separator:a209852214945630472cc47bf3343aed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c23881a8bf6f759b5b3ae828a29174"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a10c23881a8bf6f759b5b3ae828a29174"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a10c23881a8bf6f759b5b3ae828a29174.html#a10c23881a8bf6f759b5b3ae828a29174">invalid_argument_vec</a> (const char *function, const char *name, const T &amp;y, size_t i, const char *msg)</td></tr>
<tr class="memdesc:a10c23881a8bf6f759b5b3ae828a29174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an invalid argument exception with a consistently formatted message.  <a href="namespacestan_1_1math_a10c23881a8bf6f759b5b3ae828a29174.html#a10c23881a8bf6f759b5b3ae828a29174">More...</a><br /></td></tr>
<tr class="separator:a10c23881a8bf6f759b5b3ae828a29174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53c6253d8f01c64ab5297abc3f6d5cf"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_matrix_dynamic_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae53c6253d8f01c64ab5297abc3f6d5cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae53c6253d8f01c64ab5297abc3f6d5cf.html#ae53c6253d8f01c64ab5297abc3f6d5cf">is_cholesky_factor</a> (const EigMat &amp;y)</td></tr>
<tr class="memdesc:ae53c6253d8f01c64ab5297abc3f6d5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if y is a valid Cholesky factor, if number of rows is not less than the number of columns, if there are no 0 columns, and no element in matrix is <code>NaN</code>.  <a href="namespacestan_1_1math_ae53c6253d8f01c64ab5297abc3f6d5cf.html#ae53c6253d8f01c64ab5297abc3f6d5cf">More...</a><br /></td></tr>
<tr class="separator:ae53c6253d8f01c64ab5297abc3f6d5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05185216846e8217c1eb775d0da64df6"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_matrix_dynamic_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a05185216846e8217c1eb775d0da64df6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a05185216846e8217c1eb775d0da64df6.html#a05185216846e8217c1eb775d0da64df6">is_cholesky_factor_corr</a> (const EigMat &amp;y)</td></tr>
<tr class="memdesc:a05185216846e8217c1eb775d0da64df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if y is a valid Cholesky factor, if the number of rows is not less than the number of columns, if there are no zero columns, and no element in matrix is <code>NaN</code>.  <a href="namespacestan_1_1math_a05185216846e8217c1eb775d0da64df6.html#a05185216846e8217c1eb775d0da64df6">More...</a><br /></td></tr>
<tr class="separator:a05185216846e8217c1eb775d0da64df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabaf856f95d85b217e9d2b3a02a62ad5"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aabaf856f95d85b217e9d2b3a02a62ad5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aabaf856f95d85b217e9d2b3a02a62ad5.html#aabaf856f95d85b217e9d2b3a02a62ad5">is_column_index</a> (const EigMat &amp;y, size_t i)</td></tr>
<tr class="memdesc:aabaf856f95d85b217e9d2b3a02a62ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if column index is in bounds.  <a href="namespacestan_1_1math_aabaf856f95d85b217e9d2b3a02a62ad5.html#aabaf856f95d85b217e9d2b3a02a62ad5">More...</a><br /></td></tr>
<tr class="separator:aabaf856f95d85b217e9d2b3a02a62ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6b0e3fd8a1ff1aa6de5f7c5cf163e4"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_matrix_dynamic_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3b6b0e3fd8a1ff1aa6de5f7c5cf163e4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3b6b0e3fd8a1ff1aa6de5f7c5cf163e4.html#a3b6b0e3fd8a1ff1aa6de5f7c5cf163e4">is_corr_matrix</a> (const EigMat &amp;y)</td></tr>
<tr class="memdesc:a3b6b0e3fd8a1ff1aa6de5f7c5cf163e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the matrix is square and not 0x0, if the matrix is symmetric, diagonals are near 1, positive definite, and no elements are <code>NaN</code> A valid correlation matrix is symmetric, has a unit diagonal (all 1 values), and has all values between -1 and 1 (inclusive).  <a href="namespacestan_1_1math_a3b6b0e3fd8a1ff1aa6de5f7c5cf163e4.html#a3b6b0e3fd8a1ff1aa6de5f7c5cf163e4">More...</a><br /></td></tr>
<tr class="separator:a3b6b0e3fd8a1ff1aa6de5f7c5cf163e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca158bca2a5b85725322415d3bb8ba51"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca158bca2a5b85725322415d3bb8ba51"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aca158bca2a5b85725322415d3bb8ba51.html#aca158bca2a5b85725322415d3bb8ba51">is_ldlt_factor</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aca158bca2a5b85725322415d3bb8ba51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified LDLT factor is invalid.  <a href="namespacestan_1_1math_aca158bca2a5b85725322415d3bb8ba51.html#aca158bca2a5b85725322415d3bb8ba51">More...</a><br /></td></tr>
<tr class="separator:aca158bca2a5b85725322415d3bb8ba51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10ba2a92f57f7eb363bcd19cdbfc787"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high &gt; </td></tr>
<tr class="memitem:ab10ba2a92f57f7eb363bcd19cdbfc787"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab10ba2a92f57f7eb363bcd19cdbfc787.html#ab10ba2a92f57f7eb363bcd19cdbfc787">is_less_or_equal</a> (const T_y &amp;y, const T_high &amp;high)</td></tr>
<tr class="memdesc:ab10ba2a92f57f7eb363bcd19cdbfc787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is less or equal to <code>high</code>.  <a href="namespacestan_1_1math_ab10ba2a92f57f7eb363bcd19cdbfc787.html#ab10ba2a92f57f7eb363bcd19cdbfc787">More...</a><br /></td></tr>
<tr class="separator:ab10ba2a92f57f7eb363bcd19cdbfc787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fb017de750ad730599ebd773e66f9e"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_matrix_dynamic_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a05fb017de750ad730599ebd773e66f9e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a05fb017de750ad730599ebd773e66f9e.html#a05fb017de750ad730599ebd773e66f9e">is_lower_triangular</a> (const EigMat &amp;y)</td></tr>
<tr class="memdesc:a05fb017de750ad730599ebd773e66f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> is matrix is lower triangular.  <a href="namespacestan_1_1math_a05fb017de750ad730599ebd773e66f9e.html#a05fb017de750ad730599ebd773e66f9e">More...</a><br /></td></tr>
<tr class="separator:a05fb017de750ad730599ebd773e66f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba95167c5f88966d693fb184834aa348"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aba95167c5f88966d693fb184834aa348"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aba95167c5f88966d693fb184834aa348.html#aba95167c5f88966d693fb184834aa348">is_mat_finite</a> (const EigMat &amp;y)</td></tr>
<tr class="memdesc:aba95167c5f88966d693fb184834aa348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> is the specified matrix is finite.  <a href="namespacestan_1_1math_aba95167c5f88966d693fb184834aa348.html#aba95167c5f88966d693fb184834aa348">More...</a><br /></td></tr>
<tr class="separator:aba95167c5f88966d693fb184834aa348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cc752292974b72118a947ed3de43b9"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_matrix_t&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a86cc752292974b72118a947ed3de43b9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a86cc752292974b72118a947ed3de43b9.html#a86cc752292974b72118a947ed3de43b9">is_matching_dims</a> (const EigMat1 &amp;y1, const EigMat2 &amp;y2)</td></tr>
<tr class="memdesc:a86cc752292974b72118a947ed3de43b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the two matrices are of the same size.  <a href="namespacestan_1_1math_a86cc752292974b72118a947ed3de43b9.html#a86cc752292974b72118a947ed3de43b9">More...</a><br /></td></tr>
<tr class="separator:a86cc752292974b72118a947ed3de43b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f459940fac3b35996b1300b421c5d6"><td class="memTemplParams" colspan="2">template&lt;bool check_compile, typename EigMat1 , typename EigMat2 , require_all_matrix_t&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a57f459940fac3b35996b1300b421c5d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a57f459940fac3b35996b1300b421c5d6.html#a57f459940fac3b35996b1300b421c5d6">is_matching_dims</a> (const EigMat1 &amp;y1, const EigMat2 &amp;y2)</td></tr>
<tr class="memdesc:a57f459940fac3b35996b1300b421c5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the two matrices are of the same size.  <a href="namespacestan_1_1math_a57f459940fac3b35996b1300b421c5d6.html#a57f459940fac3b35996b1300b421c5d6">More...</a><br /></td></tr>
<tr class="separator:a57f459940fac3b35996b1300b421c5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d7452b15202e5ce4b827cf9134d6f6"><td class="memTemplParams" colspan="2">template&lt;typename T_y1 , typename T_y2 &gt; </td></tr>
<tr class="memitem:ac6d7452b15202e5ce4b827cf9134d6f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac6d7452b15202e5ce4b827cf9134d6f6.html#ac6d7452b15202e5ce4b827cf9134d6f6">is_matching_size</a> (const T_y1 &amp;y1, const T_y2 &amp;y2)</td></tr>
<tr class="memdesc:ac6d7452b15202e5ce4b827cf9134d6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if two structures are the same size.  <a href="namespacestan_1_1math_ac6d7452b15202e5ce4b827cf9134d6f6.html#ac6d7452b15202e5ce4b827cf9134d6f6">More...</a><br /></td></tr>
<tr class="separator:ac6d7452b15202e5ce4b827cf9134d6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2baf0164adba5ea75db788fcedf860b1"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a2baf0164adba5ea75db788fcedf860b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2baf0164adba5ea75db788fcedf860b1.html#a2baf0164adba5ea75db788fcedf860b1">is_nonzero_size</a> (const T_y &amp;y)</td></tr>
<tr class="memdesc:a2baf0164adba5ea75db788fcedf860b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the specified matrix/vector is size nonzero.  <a href="namespacestan_1_1math_a2baf0164adba5ea75db788fcedf860b1.html#a2baf0164adba5ea75db788fcedf860b1">More...</a><br /></td></tr>
<tr class="separator:a2baf0164adba5ea75db788fcedf860b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c311652e0937cd84b11ba88d8dbd240"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a5c311652e0937cd84b11ba88d8dbd240"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5c311652e0937cd84b11ba88d8dbd240.html#a5c311652e0937cd84b11ba88d8dbd240">is_not_nan</a> (const T_y &amp;y)</td></tr>
<tr class="memdesc:a5c311652e0937cd84b11ba88d8dbd240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is not <code>NaN</code>.  <a href="namespacestan_1_1math_a5c311652e0937cd84b11ba88d8dbd240.html#a5c311652e0937cd84b11ba88d8dbd240">More...</a><br /></td></tr>
<tr class="separator:a5c311652e0937cd84b11ba88d8dbd240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86254326bddb7f24566e72378f275854"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a86254326bddb7f24566e72378f275854"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a86254326bddb7f24566e72378f275854.html#a86254326bddb7f24566e72378f275854">is_ordered</a> (const std::vector&lt; T_y &gt; &amp;y)</td></tr>
<tr class="memdesc:a86254326bddb7f24566e72378f275854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the vector is sorted into strictly increasing order.  <a href="namespacestan_1_1math_a86254326bddb7f24566e72378f275854.html#a86254326bddb7f24566e72378f275854">More...</a><br /></td></tr>
<tr class="separator:a86254326bddb7f24566e72378f275854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4876270d9070852f35f8afca5835c4"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_matrix_dynamic_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b4876270d9070852f35f8afca5835c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4b4876270d9070852f35f8afca5835c4.html#a4b4876270d9070852f35f8afca5835c4">is_pos_definite</a> (const EigMat &amp;y)</td></tr>
<tr class="memdesc:a4b4876270d9070852f35f8afca5835c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the matrix is square or if the matrix has non-zero size, or if the matrix is symmetric, or if it is positive definite, or if no element is <code>NaN</code>.  <a href="namespacestan_1_1math_a4b4876270d9070852f35f8afca5835c4.html#a4b4876270d9070852f35f8afca5835c4">More...</a><br /></td></tr>
<tr class="separator:a4b4876270d9070852f35f8afca5835c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b82c4cdfa68f929e71f1e8bc8c10722"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4b82c4cdfa68f929e71f1e8bc8c10722"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4b82c4cdfa68f929e71f1e8bc8c10722.html#a4b82c4cdfa68f929e71f1e8bc8c10722">is_pos_definite</a> (const Eigen::LDLT&lt; Derived &gt; &amp;cholesky)</td></tr>
<tr class="memdesc:a4b82c4cdfa68f929e71f1e8bc8c10722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the matrix is positive definite.  <a href="namespacestan_1_1math_a4b82c4cdfa68f929e71f1e8bc8c10722.html#a4b82c4cdfa68f929e71f1e8bc8c10722">More...</a><br /></td></tr>
<tr class="separator:a4b82c4cdfa68f929e71f1e8bc8c10722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac927547ad8dbc285bbd19ac3988f2b6f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ac927547ad8dbc285bbd19ac3988f2b6f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac927547ad8dbc285bbd19ac3988f2b6f.html#ac927547ad8dbc285bbd19ac3988f2b6f">is_pos_definite</a> (const Eigen::LLT&lt; Derived &gt; &amp;cholesky)</td></tr>
<tr class="memdesc:ac927547ad8dbc285bbd19ac3988f2b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if diagonal of the L matrix is positive.  <a href="namespacestan_1_1math_ac927547ad8dbc285bbd19ac3988f2b6f.html#ac927547ad8dbc285bbd19ac3988f2b6f">More...</a><br /></td></tr>
<tr class="separator:ac927547ad8dbc285bbd19ac3988f2b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ad78d848a53f979c6e4d8d951e9292"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a10ad78d848a53f979c6e4d8d951e9292"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a10ad78d848a53f979c6e4d8d951e9292.html#a10ad78d848a53f979c6e4d8d951e9292">is_positive</a> (const T_y &amp;y)</td></tr>
<tr class="memdesc:a10ad78d848a53f979c6e4d8d951e9292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is positive.  <a href="namespacestan_1_1math_a10ad78d848a53f979c6e4d8d951e9292.html#a10ad78d848a53f979c6e4d8d951e9292">More...</a><br /></td></tr>
<tr class="separator:a10ad78d848a53f979c6e4d8d951e9292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c592ebba72cdd2e46f30626023fe6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a38c592ebba72cdd2e46f30626023fe6d.html#a38c592ebba72cdd2e46f30626023fe6d">is_positive</a> (int <a class="el" href="group__type__trait_ga98afb6ae5281b82b30caa793e205f6ae.html#ga98afb6ae5281b82b30caa793e205f6ae">size</a>)</td></tr>
<tr class="memdesc:a38c592ebba72cdd2e46f30626023fe6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>size</code> is positive.  <a href="namespacestan_1_1math_a38c592ebba72cdd2e46f30626023fe6d.html#a38c592ebba72cdd2e46f30626023fe6d">More...</a><br /></td></tr>
<tr class="separator:a38c592ebba72cdd2e46f30626023fe6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d702502d965415bbb987eccd72125a2"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a7d702502d965415bbb987eccd72125a2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7d702502d965415bbb987eccd72125a2.html#a7d702502d965415bbb987eccd72125a2">is_scal_finite</a> (const T_y &amp;y)</td></tr>
<tr class="memdesc:a7d702502d965415bbb987eccd72125a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is finite.  <a href="namespacestan_1_1math_a7d702502d965415bbb987eccd72125a2.html#a7d702502d965415bbb987eccd72125a2">More...</a><br /></td></tr>
<tr class="separator:a7d702502d965415bbb987eccd72125a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a56f8ba229dcc646d363dcdf1263fd1"><td class="memTemplParams" colspan="2">template&lt;typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:a0a56f8ba229dcc646d363dcdf1263fd1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0a56f8ba229dcc646d363dcdf1263fd1.html#a0a56f8ba229dcc646d363dcdf1263fd1">is_size_match</a> (T_size1 i, T_size2 j)</td></tr>
<tr class="memdesc:a0a56f8ba229dcc646d363dcdf1263fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the provided sizes match.  <a href="namespacestan_1_1math_a0a56f8ba229dcc646d363dcdf1263fd1.html#a0a56f8ba229dcc646d363dcdf1263fd1">More...</a><br /></td></tr>
<tr class="separator:a0a56f8ba229dcc646d363dcdf1263fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61d8b9b7d80a5e5a54d50350a97484a"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa61d8b9b7d80a5e5a54d50350a97484a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa61d8b9b7d80a5e5a54d50350a97484a.html#aa61d8b9b7d80a5e5a54d50350a97484a">is_square</a> (const EigMat &amp;y)</td></tr>
<tr class="memdesc:aa61d8b9b7d80a5e5a54d50350a97484a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the matrix is square.  <a href="namespacestan_1_1math_aa61d8b9b7d80a5e5a54d50350a97484a.html#aa61d8b9b7d80a5e5a54d50350a97484a">More...</a><br /></td></tr>
<tr class="separator:aa61d8b9b7d80a5e5a54d50350a97484a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad398e9ef773c65631be32dc4c1783858"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_matrix_dynamic_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad398e9ef773c65631be32dc4c1783858"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad398e9ef773c65631be32dc4c1783858.html#ad398e9ef773c65631be32dc4c1783858">is_symmetric</a> (const EigMat &amp;y)</td></tr>
<tr class="memdesc:ad398e9ef773c65631be32dc4c1783858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the matrix is square, and no element not on the main diagonal is <code>NaN</code>.  <a href="namespacestan_1_1math_ad398e9ef773c65631be32dc4c1783858.html#ad398e9ef773c65631be32dc4c1783858">More...</a><br /></td></tr>
<tr class="separator:ad398e9ef773c65631be32dc4c1783858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2175afacde47ea5df67a1825070eb40"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_eigen_vector_t&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac2175afacde47ea5df67a1825070eb40"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac2175afacde47ea5df67a1825070eb40.html#ac2175afacde47ea5df67a1825070eb40">is_unit_vector</a> (const EigVec &amp;theta)</td></tr>
<tr class="memdesc:ac2175afacde47ea5df67a1825070eb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the vector is not a unit vector or if any element is <code>NaN</code>.  <a href="namespacestan_1_1math_ac2175afacde47ea5df67a1825070eb40.html#ac2175afacde47ea5df67a1825070eb40">More...</a><br /></td></tr>
<tr class="separator:ac2175afacde47ea5df67a1825070eb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa602fa10662532ef73edfa70ed3add15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa602fa10662532ef73edfa70ed3add15.html#aa602fa10662532ef73edfa70ed3add15">out_of_range</a> (const char *function, int <a class="el" href="namespacestan_1_1math_aeff33af49e42875a07f600583adb4940.html#aeff33af49e42875a07f600583adb4940">max</a>, int index, const char *msg1=&quot;&quot;, const char *msg2=&quot;&quot;)</td></tr>
<tr class="memdesc:aa602fa10662532ef73edfa70ed3add15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an out_of_range exception with a consistently formatted message.  <a href="namespacestan_1_1math_aa602fa10662532ef73edfa70ed3add15.html#aa602fa10662532ef73edfa70ed3add15">More...</a><br /></td></tr>
<tr class="separator:aa602fa10662532ef73edfa70ed3add15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2cc1d83b9b3fb48327fe40c2351748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aad2cc1d83b9b3fb48327fe40c2351748.html#aad2cc1d83b9b3fb48327fe40c2351748">system_error</a> (const char *function, const char *name, const int &amp;y, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:aad2cc1d83b9b3fb48327fe40c2351748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a system error with a consistently formatted message.  <a href="namespacestan_1_1math_aad2cc1d83b9b3fb48327fe40c2351748.html#aad2cc1d83b9b3fb48327fe40c2351748">More...</a><br /></td></tr>
<tr class="separator:aad2cc1d83b9b3fb48327fe40c2351748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f1f064431dcb4830a8eba52c91984c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac9f1f064431dcb4830a8eba52c91984c.html#ac9f1f064431dcb4830a8eba52c91984c">system_error</a> (const char *function, const char *name, const int &amp;y, const char *msg1)</td></tr>
<tr class="memdesc:ac9f1f064431dcb4830a8eba52c91984c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a system error with a consistently formatted message.  <a href="namespacestan_1_1math_ac9f1f064431dcb4830a8eba52c91984c.html#ac9f1f064431dcb4830a8eba52c91984c">More...</a><br /></td></tr>
<tr class="separator:ac9f1f064431dcb4830a8eba52c91984c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6557b18ff1a176110eaf2bb8525cfd79"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6557b18ff1a176110eaf2bb8525cfd79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6557b18ff1a176110eaf2bb8525cfd79.html#a6557b18ff1a176110eaf2bb8525cfd79">throw_domain_error</a> (const char *function, const char *name, const T &amp;y, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:a6557b18ff1a176110eaf2bb8525cfd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message.  <a href="namespacestan_1_1math_a6557b18ff1a176110eaf2bb8525cfd79.html#a6557b18ff1a176110eaf2bb8525cfd79">More...</a><br /></td></tr>
<tr class="separator:a6557b18ff1a176110eaf2bb8525cfd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fdf72914cfd30bf02bee182e91a3a4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a35fdf72914cfd30bf02bee182e91a3a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a35fdf72914cfd30bf02bee182e91a3a4.html#a35fdf72914cfd30bf02bee182e91a3a4">throw_domain_error</a> (const char *function, const char *name, const T &amp;y, const char *msg1)</td></tr>
<tr class="memdesc:a35fdf72914cfd30bf02bee182e91a3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message.  <a href="namespacestan_1_1math_a35fdf72914cfd30bf02bee182e91a3a4.html#a35fdf72914cfd30bf02bee182e91a3a4">More...</a><br /></td></tr>
<tr class="separator:a35fdf72914cfd30bf02bee182e91a3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2ad924a3b27fdab414ab0d16933263"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaa2ad924a3b27fdab414ab0d16933263"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaa2ad924a3b27fdab414ab0d16933263.html#aaa2ad924a3b27fdab414ab0d16933263">throw_domain_error_mat</a> (const char *function, const char *name, const T &amp;y, size_t i, size_t j, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:aaa2ad924a3b27fdab414ab0d16933263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message for matrices.  <a href="namespacestan_1_1math_aaa2ad924a3b27fdab414ab0d16933263.html#aaa2ad924a3b27fdab414ab0d16933263">More...</a><br /></td></tr>
<tr class="separator:aaa2ad924a3b27fdab414ab0d16933263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84268e48d0b96aa703552cd03a3d443"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa84268e48d0b96aa703552cd03a3d443"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa84268e48d0b96aa703552cd03a3d443.html#aa84268e48d0b96aa703552cd03a3d443">throw_domain_error_mat</a> (const char *function, const char *name, const T &amp;y, size_t i, size_t j, const char *msg)</td></tr>
<tr class="memdesc:aa84268e48d0b96aa703552cd03a3d443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message for matrices.  <a href="namespacestan_1_1math_aa84268e48d0b96aa703552cd03a3d443.html#aa84268e48d0b96aa703552cd03a3d443">More...</a><br /></td></tr>
<tr class="separator:aa84268e48d0b96aa703552cd03a3d443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5e893a0678c908c5a1e86a63210c84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d5e893a0678c908c5a1e86a63210c84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6d5e893a0678c908c5a1e86a63210c84.html#a6d5e893a0678c908c5a1e86a63210c84">throw_domain_error_vec</a> (const char *function, const char *name, const T &amp;y, size_t i, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:a6d5e893a0678c908c5a1e86a63210c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message.  <a href="namespacestan_1_1math_a6d5e893a0678c908c5a1e86a63210c84.html#a6d5e893a0678c908c5a1e86a63210c84">More...</a><br /></td></tr>
<tr class="separator:a6d5e893a0678c908c5a1e86a63210c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac793a7337c8524d9dec12628a3c80c5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac793a7337c8524d9dec12628a3c80c5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac793a7337c8524d9dec12628a3c80c5a.html#ac793a7337c8524d9dec12628a3c80c5a">throw_domain_error_vec</a> (const char *function, const char *name, const T &amp;y, size_t i, const char *msg)</td></tr>
<tr class="memdesc:ac793a7337c8524d9dec12628a3c80c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message.  <a href="namespacestan_1_1math_ac793a7337c8524d9dec12628a3c80c5a.html#ac793a7337c8524d9dec12628a3c80c5a">More...</a><br /></td></tr>
<tr class="separator:ac793a7337c8524d9dec12628a3c80c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb591fca3d88d2a5d587ce6172b62bf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abb591fca3d88d2a5d587ce6172b62bf4.html#abb591fca3d88d2a5d587ce6172b62bf4">validate_non_negative_index</a> (const char *var_name, const char *expr, int val)</td></tr>
<tr class="separator:abb591fca3d88d2a5d587ce6172b62bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff3e5c89073f1d7c03662a819c2c5ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaff3e5c89073f1d7c03662a819c2c5ed.html#aaff3e5c89073f1d7c03662a819c2c5ed">validate_positive_index</a> (const char *var_name, const char *expr, int val)</td></tr>
<tr class="memdesc:aaff3e5c89073f1d7c03662a819c2c5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that simplex is at least size 1.  <a href="namespacestan_1_1math_aaff3e5c89073f1d7c03662a819c2c5ed.html#aaff3e5c89073f1d7c03662a819c2c5ed">More...</a><br /></td></tr>
<tr class="separator:aaff3e5c89073f1d7c03662a819c2c5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dbb8756693eaa5fea075f2fabc58be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a54dbb8756693eaa5fea075f2fabc58be.html#a54dbb8756693eaa5fea075f2fabc58be">validate_unit_vector_index</a> (const char *var_name, const char *expr, int val)</td></tr>
<tr class="memdesc:a54dbb8756693eaa5fea075f2fabc58be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that unit vector is at least size 2.  <a href="namespacestan_1_1math_a54dbb8756693eaa5fea075f2fabc58be.html#a54dbb8756693eaa5fea075f2fabc58be">More...</a><br /></td></tr>
<tr class="separator:a54dbb8756693eaa5fea075f2fabc58be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519418e20b7c5246f9e3e5d59eb86303"><td class="memTemplParams" colspan="2">template&lt;typename T , require_arithmetic_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a519418e20b7c5246f9e3e5d59eb86303"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a519418e20b7c5246f9e3e5d59eb86303.html#a519418e20b7c5246f9e3e5d59eb86303">abs</a> (T x)</td></tr>
<tr class="memdesc:a519418e20b7c5246f9e3e5d59eb86303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute value of the specified arithmetic argument.  <a href="namespacestan_1_1math_a519418e20b7c5246f9e3e5d59eb86303.html#a519418e20b7c5246f9e3e5d59eb86303">More...</a><br /></td></tr>
<tr class="separator:a519418e20b7c5246f9e3e5d59eb86303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202d2bb838b566a1fe623915816ad474"><td class="memTemplParams" colspan="2">template&lt;typename T , require_complex_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a202d2bb838b566a1fe623915816ad474"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a202d2bb838b566a1fe623915816ad474.html#a202d2bb838b566a1fe623915816ad474">abs</a> (T x)</td></tr>
<tr class="memdesc:a202d2bb838b566a1fe623915816ad474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute value (also known as the norm, modulus, or magnitude) of the specified complex argument.  <a href="namespacestan_1_1math_a202d2bb838b566a1fe623915816ad474.html#a202d2bb838b566a1fe623915816ad474">More...</a><br /></td></tr>
<tr class="separator:a202d2bb838b566a1fe623915816ad474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba237eabb909363cad20cc0774438647"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr, require_not_stan_scalar_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aba237eabb909363cad20cc0774438647"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aba237eabb909363cad20cc0774438647.html#aba237eabb909363cad20cc0774438647">abs</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:aba237eabb909363cad20cc0774438647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ae560b842e3ed6e5939dc2177bf158265.html#ae560b842e3ed6e5939dc2177bf158265">abs()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_aba237eabb909363cad20cc0774438647.html#aba237eabb909363cad20cc0774438647">More...</a><br /></td></tr>
<tr class="separator:aba237eabb909363cad20cc0774438647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa978affc4b1834c9b2dc8104ff9c629b"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa978affc4b1834c9b2dc8104ff9c629b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa978affc4b1834c9b2dc8104ff9c629b.html#aa978affc4b1834c9b2dc8104ff9c629b">abs</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:aa978affc4b1834c9b2dc8104ff9c629b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_ae560b842e3ed6e5939dc2177bf158265.html#ae560b842e3ed6e5939dc2177bf158265">abs()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_aa978affc4b1834c9b2dc8104ff9c629b.html#aa978affc4b1834c9b2dc8104ff9c629b">More...</a><br /></td></tr>
<tr class="separator:aa978affc4b1834c9b2dc8104ff9c629b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3214a6d2fbe0deb6b11e3ca7a9b2e7d5"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3214a6d2fbe0deb6b11e3ca7a9b2e7d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3214a6d2fbe0deb6b11e3ca7a9b2e7d5.html#a3214a6d2fbe0deb6b11e3ca7a9b2e7d5">acos</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a3214a6d2fbe0deb6b11e3ca7a9b2e7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a6952d8c23d69dc891dbe78e7d4ea7a80.html#a6952d8c23d69dc891dbe78e7d4ea7a80">acos()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_a3214a6d2fbe0deb6b11e3ca7a9b2e7d5.html#a3214a6d2fbe0deb6b11e3ca7a9b2e7d5">More...</a><br /></td></tr>
<tr class="separator:a3214a6d2fbe0deb6b11e3ca7a9b2e7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac600a0f0bcec739358becbc52c5ce71b"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac600a0f0bcec739358becbc52c5ce71b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac600a0f0bcec739358becbc52c5ce71b.html#ac600a0f0bcec739358becbc52c5ce71b">acos</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ac600a0f0bcec739358becbc52c5ce71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_a6952d8c23d69dc891dbe78e7d4ea7a80.html#a6952d8c23d69dc891dbe78e7d4ea7a80">acos()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_ac600a0f0bcec739358becbc52c5ce71b.html#ac600a0f0bcec739358becbc52c5ce71b">More...</a><br /></td></tr>
<tr class="separator:ac600a0f0bcec739358becbc52c5ce71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33101f7bb942c64fa840c28a1f091c3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af33101f7bb942c64fa840c28a1f091c3.html#af33101f7bb942c64fa840c28a1f091c3">acosh</a> (double x)</td></tr>
<tr class="memdesc:af33101f7bb942c64fa840c28a1f091c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse hyperbolic cosine of the specified value.  <a href="namespacestan_1_1math_af33101f7bb942c64fa840c28a1f091c3.html#af33101f7bb942c64fa840c28a1f091c3">More...</a><br /></td></tr>
<tr class="separator:af33101f7bb942c64fa840c28a1f091c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012aba01a2bab7e310b782d0130cce13"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a012aba01a2bab7e310b782d0130cce13.html#a012aba01a2bab7e310b782d0130cce13">acosh</a> (int x)</td></tr>
<tr class="memdesc:a012aba01a2bab7e310b782d0130cce13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer version of acosh.  <a href="namespacestan_1_1math_a012aba01a2bab7e310b782d0130cce13.html#a012aba01a2bab7e310b782d0130cce13">More...</a><br /></td></tr>
<tr class="separator:a012aba01a2bab7e310b782d0130cce13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4b113a9103fc55d0923094028da220"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_var_matrix_t&lt; T &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4a4b113a9103fc55d0923094028da220"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a4b113a9103fc55d0923094028da220.html#a4a4b113a9103fc55d0923094028da220">acosh</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a4a4b113a9103fc55d0923094028da220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_ae033720f1a26c44aa9d7fb4dcf547155.html#ae033720f1a26c44aa9d7fb4dcf547155">acosh()</a></code> to specified argument container.  <a href="namespacestan_1_1math_a4a4b113a9103fc55d0923094028da220.html#a4a4b113a9103fc55d0923094028da220">More...</a><br /></td></tr>
<tr class="separator:a4a4b113a9103fc55d0923094028da220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9647cd8003dcccd3c677644c8f62131c"><td class="memTemplParams" colspan="2">template&lt;typename ScalarA , typename ScalarB , require_all_stan_scalar_t&lt; ScalarA, ScalarB &gt; *  = nullptr, require_all_not_var_t&lt; ScalarA, ScalarB &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9647cd8003dcccd3c677644c8f62131c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; ScalarA, ScalarB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9647cd8003dcccd3c677644c8f62131c.html#a9647cd8003dcccd3c677644c8f62131c">add</a> (const ScalarA &amp;a, const ScalarB &amp;b)</td></tr>
<tr class="memdesc:a9647cd8003dcccd3c677644c8f62131c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified scalars.  <a href="namespacestan_1_1math_a9647cd8003dcccd3c677644c8f62131c.html#a9647cd8003dcccd3c677644c8f62131c">More...</a><br /></td></tr>
<tr class="separator:a9647cd8003dcccd3c677644c8f62131c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7279e3b054d2f3d7135d4ceeb2f8cc6f"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , require_all_eigen_t&lt; Mat1, Mat2 &gt; *  = nullptr, require_all_not_st_var&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7279e3b054d2f3d7135d4ceeb2f8cc6f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7279e3b054d2f3d7135d4ceeb2f8cc6f.html#a7279e3b054d2f3d7135d4ceeb2f8cc6f">add</a> (const Mat1 &amp;m1, const Mat2 &amp;m2)</td></tr>
<tr class="memdesc:a7279e3b054d2f3d7135d4ceeb2f8cc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified matrices.  <a href="namespacestan_1_1math_a7279e3b054d2f3d7135d4ceeb2f8cc6f.html#a7279e3b054d2f3d7135d4ceeb2f8cc6f">More...</a><br /></td></tr>
<tr class="separator:a7279e3b054d2f3d7135d4ceeb2f8cc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74920b4f0a49580341bf01614081c2af"><td class="memTemplParams" colspan="2">template&lt;typename Mat , typename Scal , require_eigen_t&lt; Mat &gt; *  = nullptr, require_stan_scalar_t&lt; Scal &gt; *  = nullptr, require_all_not_st_var&lt; Mat, Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a74920b4f0a49580341bf01614081c2af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a74920b4f0a49580341bf01614081c2af.html#a74920b4f0a49580341bf01614081c2af">add</a> (const Mat &amp;m, const Scal c)</td></tr>
<tr class="memdesc:a74920b4f0a49580341bf01614081c2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified matrix and specified scalar.  <a href="namespacestan_1_1math_a74920b4f0a49580341bf01614081c2af.html#a74920b4f0a49580341bf01614081c2af">More...</a><br /></td></tr>
<tr class="separator:a74920b4f0a49580341bf01614081c2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642c0a40cebcd708b737eaacae63333a"><td class="memTemplParams" colspan="2">template&lt;typename Scal , typename Mat , require_stan_scalar_t&lt; Scal &gt; *  = nullptr, require_eigen_t&lt; Mat &gt; *  = nullptr, require_all_not_st_var&lt; Scal, Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a642c0a40cebcd708b737eaacae63333a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a642c0a40cebcd708b737eaacae63333a.html#a642c0a40cebcd708b737eaacae63333a">add</a> (const Scal c, const Mat &amp;m)</td></tr>
<tr class="memdesc:a642c0a40cebcd708b737eaacae63333a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified scalar and specified matrix.  <a href="namespacestan_1_1math_a642c0a40cebcd708b737eaacae63333a.html#a642c0a40cebcd708b737eaacae63333a">More...</a><br /></td></tr>
<tr class="separator:a642c0a40cebcd708b737eaacae63333a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6003ecd09ce63590c97659c60315da7d"><td class="memTemplParams" colspan="2">template&lt;typename T_m , typename T_a , typename  = require_eigen_t&lt;T_m&gt;, typename  = require_any_t&lt;is_eigen_vector&lt;T_a&gt;, is_stan_scalar&lt;T_a&gt;&gt;&gt; </td></tr>
<tr class="memitem:a6003ecd09ce63590c97659c60315da7d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_m, T_a &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6003ecd09ce63590c97659c60315da7d.html#a6003ecd09ce63590c97659c60315da7d">add_diag</a> (const T_m &amp;mat, const T_a &amp;to_add)</td></tr>
<tr class="memdesc:a6003ecd09ce63590c97659c60315da7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matrix with values added along the main diagonal.  <a href="namespacestan_1_1math_a6003ecd09ce63590c97659c60315da7d.html#a6003ecd09ce63590c97659c60315da7d">More...</a><br /></td></tr>
<tr class="separator:a6003ecd09ce63590c97659c60315da7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352114d7f71f8d643045e66e304c86cf"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a352114d7f71f8d643045e66e304c86cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1append__return__type.html">append_return_type</a>&lt; std::vector&lt; T1 &gt;, std::vector&lt; T2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a352114d7f71f8d643045e66e304c86cf.html#a352114d7f71f8d643045e66e304c86cf">append_array</a> (const std::vector&lt; T1 &gt; &amp;x, const std::vector&lt; T2 &gt; &amp;y)</td></tr>
<tr class="memdesc:a352114d7f71f8d643045e66e304c86cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the concatenation of two specified vectors in the order of the arguments.  <a href="namespacestan_1_1math_a352114d7f71f8d643045e66e304c86cf.html#a352114d7f71f8d643045e66e304c86cf">More...</a><br /></td></tr>
<tr class="separator:a352114d7f71f8d643045e66e304c86cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfa1465776a539c8c9be20c2063f6f3"><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr class="memitem:a3dfa1465776a539c8c9be20c2063f6f3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3dfa1465776a539c8c9be20c2063f6f3.html#a3dfa1465776a539c8c9be20c2063f6f3">append_array</a> (const std::vector&lt; T1 &gt; &amp;x, const std::vector&lt; T1 &gt; &amp;y)</td></tr>
<tr class="memdesc:a3dfa1465776a539c8c9be20c2063f6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the concatenation of two specified vectors in the order of the arguments.  <a href="namespacestan_1_1math_a3dfa1465776a539c8c9be20c2063f6f3.html#a3dfa1465776a539c8c9be20c2063f6f3">More...</a><br /></td></tr>
<tr class="separator:a3dfa1465776a539c8c9be20c2063f6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e15d49d5577954a54aacf4b7a4a92a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_eigen_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:a38e15d49d5577954a54aacf4b7a4a92a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a38e15d49d5577954a54aacf4b7a4a92a.html#a38e15d49d5577954a54aacf4b7a4a92a">append_col</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:a38e15d49d5577954a54aacf4b7a4a92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of appending the second argument matrix after the first argument matrix, that is, putting them side by side, with the first matrix followed by the second matrix.  <a href="namespacestan_1_1math_a38e15d49d5577954a54aacf4b7a4a92a.html#a38e15d49d5577954a54aacf4b7a4a92a">More...</a><br /></td></tr>
<tr class="separator:a38e15d49d5577954a54aacf4b7a4a92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca55057d5f1679f34b4a4eb64387c3b5"><td class="memTemplParams" colspan="2">template&lt;typename Scal , typename RowVec , require_stan_scalar_t&lt; Scal &gt; *  = nullptr, require_t&lt; is_eigen_row_vector&lt; RowVec &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aca55057d5f1679f34b4a4eb64387c3b5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Scal, RowVec &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aca55057d5f1679f34b4a4eb64387c3b5.html#aca55057d5f1679f34b4a4eb64387c3b5">append_col</a> (const Scal &amp;A, const RowVec &amp;B)</td></tr>
<tr class="memdesc:aca55057d5f1679f34b4a4eb64387c3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking an scalar on top of the a row vector, with the result being a row vector.  <a href="namespacestan_1_1math_aca55057d5f1679f34b4a4eb64387c3b5.html#aca55057d5f1679f34b4a4eb64387c3b5">More...</a><br /></td></tr>
<tr class="separator:aca55057d5f1679f34b4a4eb64387c3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66b8959465f8f82dee201c7ccfa5418"><td class="memTemplParams" colspan="2">template&lt;typename RowVec , typename Scal , require_t&lt; is_eigen_row_vector&lt; RowVec &gt;&gt; *  = nullptr, require_stan_scalar_t&lt; Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae66b8959465f8f82dee201c7ccfa5418"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; RowVec, Scal &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae66b8959465f8f82dee201c7ccfa5418.html#ae66b8959465f8f82dee201c7ccfa5418">append_col</a> (const RowVec &amp;A, const Scal &amp;B)</td></tr>
<tr class="memdesc:ae66b8959465f8f82dee201c7ccfa5418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking a row vector on top of the an scalar, with the result being a row vector.  <a href="namespacestan_1_1math_ae66b8959465f8f82dee201c7ccfa5418.html#ae66b8959465f8f82dee201c7ccfa5418">More...</a><br /></td></tr>
<tr class="separator:ae66b8959465f8f82dee201c7ccfa5418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728b7a3f1a99f8bded1c0c65e4d234b6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_eigen_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a728b7a3f1a99f8bded1c0c65e4d234b6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a728b7a3f1a99f8bded1c0c65e4d234b6.html#a728b7a3f1a99f8bded1c0c65e4d234b6">append_row</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:a728b7a3f1a99f8bded1c0c65e4d234b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking the rows of the first argument matrix on top of the second argument matrix.  <a href="namespacestan_1_1math_a728b7a3f1a99f8bded1c0c65e4d234b6.html#a728b7a3f1a99f8bded1c0c65e4d234b6">More...</a><br /></td></tr>
<tr class="separator:a728b7a3f1a99f8bded1c0c65e4d234b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ca80d2c41933d45f5de4c37db3e539"><td class="memTemplParams" colspan="2">template&lt;typename Scal , typename ColVec , require_stan_scalar_t&lt; Scal &gt; *  = nullptr, require_t&lt; is_eigen_col_vector&lt; ColVec &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a54ca80d2c41933d45f5de4c37db3e539"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Scal, ColVec &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a54ca80d2c41933d45f5de4c37db3e539.html#a54ca80d2c41933d45f5de4c37db3e539">append_row</a> (const Scal &amp;A, const ColVec &amp;B)</td></tr>
<tr class="memdesc:a54ca80d2c41933d45f5de4c37db3e539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking an scalar on top of the a vector, with the result being a vector.  <a href="namespacestan_1_1math_a54ca80d2c41933d45f5de4c37db3e539.html#a54ca80d2c41933d45f5de4c37db3e539">More...</a><br /></td></tr>
<tr class="separator:a54ca80d2c41933d45f5de4c37db3e539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7062123617e5df987341cbe19a949f5f"><td class="memTemplParams" colspan="2">template&lt;typename ColVec , typename Scal , require_t&lt; is_eigen_col_vector&lt; ColVec &gt;&gt; *  = nullptr, require_stan_scalar_t&lt; Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7062123617e5df987341cbe19a949f5f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; ColVec, Scal &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7062123617e5df987341cbe19a949f5f.html#a7062123617e5df987341cbe19a949f5f">append_row</a> (const ColVec &amp;A, const Scal &amp;B)</td></tr>
<tr class="memdesc:a7062123617e5df987341cbe19a949f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking a vector on top of the an scalar, with the result being a vector.  <a href="namespacestan_1_1math_a7062123617e5df987341cbe19a949f5f.html#a7062123617e5df987341cbe19a949f5f">More...</a><br /></td></tr>
<tr class="separator:a7062123617e5df987341cbe19a949f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e7baa689841d26e7b0a32b4af5bd6a"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:aa1e7baa689841d26e7b0a32b4af5bd6a"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa1e7baa689841d26e7b0a32b4af5bd6a.html#aa1e7baa689841d26e7b0a32b4af5bd6a">arg</a> (const std::complex&lt; V &gt; &amp;z)</td></tr>
<tr class="memdesc:aa1e7baa689841d26e7b0a32b4af5bd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the phase angle of the complex argument.  <a href="namespacestan_1_1math_aa1e7baa689841d26e7b0a32b4af5bd6a.html#aa1e7baa689841d26e7b0a32b4af5bd6a">More...</a><br /></td></tr>
<tr class="separator:aa1e7baa689841d26e7b0a32b4af5bd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d68c4271b3143131e6526963c3ebde"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a24d68c4271b3143131e6526963c3ebde"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a24d68c4271b3143131e6526963c3ebde.html#a24d68c4271b3143131e6526963c3ebde">as_array_or_scalar</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:a24d68c4271b3143131e6526963c3ebde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns specified input value.  <a href="namespacestan_1_1math_a24d68c4271b3143131e6526963c3ebde.html#a24d68c4271b3143131e6526963c3ebde">More...</a><br /></td></tr>
<tr class="separator:a24d68c4271b3143131e6526963c3ebde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93eeeaf8c711c0a3c66634c64ebb9622"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a93eeeaf8c711c0a3c66634c64ebb9622"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a93eeeaf8c711c0a3c66634c64ebb9622.html#a93eeeaf8c711c0a3c66634c64ebb9622">as_array_or_scalar</a> (T &amp;v)</td></tr>
<tr class="memdesc:a93eeeaf8c711c0a3c66634c64ebb9622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to rvalue specified input value.  <a href="namespacestan_1_1math_a93eeeaf8c711c0a3c66634c64ebb9622.html#a93eeeaf8c711c0a3c66634c64ebb9622">More...</a><br /></td></tr>
<tr class="separator:a93eeeaf8c711c0a3c66634c64ebb9622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d0af937ab5e14191ba11b00bb4d937"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_eigen_t&lt;T&gt;, require_not_eigen_array_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac5d0af937ab5e14191ba11b00bb4d937"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac5d0af937ab5e14191ba11b00bb4d937.html#ac5d0af937ab5e14191ba11b00bb4d937">as_array_or_scalar</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:ac5d0af937ab5e14191ba11b00bb4d937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a matrix type to an array.  <a href="namespacestan_1_1math_ac5d0af937ab5e14191ba11b00bb4d937.html#ac5d0af937ab5e14191ba11b00bb4d937">More...</a><br /></td></tr>
<tr class="separator:ac5d0af937ab5e14191ba11b00bb4d937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54acb5711b02ac0e6fcc604101453174"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a54acb5711b02ac0e6fcc604101453174"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a54acb5711b02ac0e6fcc604101453174.html#a54acb5711b02ac0e6fcc604101453174">as_bool</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a54acb5711b02ac0e6fcc604101453174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the argument is not equal to zero (in the <code>!=</code> operator sense) and false otherwise.  <a href="namespacestan_1_1math_a54acb5711b02ac0e6fcc604101453174.html#a54acb5711b02ac0e6fcc604101453174">More...</a><br /></td></tr>
<tr class="separator:a54acb5711b02ac0e6fcc604101453174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9cd6c829a22e39e5b937e20efcb808"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acb9cd6c829a22e39e5b937e20efcb808"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acb9cd6c829a22e39e5b937e20efcb808.html#acb9cd6c829a22e39e5b937e20efcb808">as_column_vector_or_scalar</a> (const T &amp;a)</td></tr>
<tr class="memdesc:acb9cd6c829a22e39e5b937e20efcb808"><td class="mdescLeft">&#160;</td><td class="mdescRight">no-op that passes the scalar  <a href="namespacestan_1_1math_acb9cd6c829a22e39e5b937e20efcb808.html#acb9cd6c829a22e39e5b937e20efcb808">More...</a><br /></td></tr>
<tr class="separator:acb9cd6c829a22e39e5b937e20efcb808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd2304a1ab8e6429c3de3e3c8145530"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a0bd2304a1ab8e6429c3de3e3c8145530"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">internal::empty_broadcast_array</a>&lt; T, S, void &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0bd2304a1ab8e6429c3de3e3c8145530.html#a0bd2304a1ab8e6429c3de3e3c8145530">as_column_vector_or_scalar</a> (<a class="el" href="classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">internal::empty_broadcast_array</a>&lt; T, S, void &gt; &amp;a)</td></tr>
<tr class="memdesc:a0bd2304a1ab8e6429c3de3e3c8145530"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-op used when working with operands and partials.  <a href="namespacestan_1_1math_a0bd2304a1ab8e6429c3de3e3c8145530.html#a0bd2304a1ab8e6429c3de3e3c8145530">More...</a><br /></td></tr>
<tr class="separator:a0bd2304a1ab8e6429c3de3e3c8145530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b241f7451f05cab4d94cf5d5e47add"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_col_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a28b241f7451f05cab4d94cf5d5e47add"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a28b241f7451f05cab4d94cf5d5e47add.html#a28b241f7451f05cab4d94cf5d5e47add">as_column_vector_or_scalar</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a28b241f7451f05cab4d94cf5d5e47add"><td class="mdescLeft">&#160;</td><td class="mdescRight">no-op that returns a column vector.  <a href="namespacestan_1_1math_a28b241f7451f05cab4d94cf5d5e47add.html#a28b241f7451f05cab4d94cf5d5e47add">More...</a><br /></td></tr>
<tr class="separator:a28b241f7451f05cab4d94cf5d5e47add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9826957b0a219361ed809e1f33beec62"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_row_vector_t&lt; T &gt; *  = nullptr, require_not_eigen_col_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9826957b0a219361ed809e1f33beec62"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9826957b0a219361ed809e1f33beec62.html#a9826957b0a219361ed809e1f33beec62">as_column_vector_or_scalar</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a9826957b0a219361ed809e1f33beec62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a row vector to an eigen column vector.  <a href="namespacestan_1_1math_a9826957b0a219361ed809e1f33beec62.html#a9826957b0a219361ed809e1f33beec62">More...</a><br /></td></tr>
<tr class="separator:a9826957b0a219361ed809e1f33beec62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ce84bcf144e49cdd2acc52b890609f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1ce84bcf144e49cdd2acc52b890609f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae1ce84bcf144e49cdd2acc52b890609f.html#ae1ce84bcf144e49cdd2acc52b890609f">as_value_array_or_scalar</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:ae1ce84bcf144e49cdd2acc52b890609f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the value from an object.  <a href="namespacestan_1_1math_ae1ce84bcf144e49cdd2acc52b890609f.html#ae1ce84bcf144e49cdd2acc52b890609f">More...</a><br /></td></tr>
<tr class="separator:ae1ce84bcf144e49cdd2acc52b890609f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcf09bcc2f0aca1ddaf667bd2c8c7c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7bcf09bcc2f0aca1ddaf667bd2c8c7c9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7bcf09bcc2f0aca1ddaf667bd2c8c7c9.html#a7bcf09bcc2f0aca1ddaf667bd2c8c7c9">as_value_column_array_or_scalar</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a7bcf09bcc2f0aca1ddaf667bd2c8c7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the value from an object and for eigen vectors and <code>std::vectors</code> convert to an eigen column array and for scalars return a scalar.  <a href="namespacestan_1_1math_a7bcf09bcc2f0aca1ddaf667bd2c8c7c9.html#a7bcf09bcc2f0aca1ddaf667bd2c8c7c9">More...</a><br /></td></tr>
<tr class="separator:a7bcf09bcc2f0aca1ddaf667bd2c8c7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae722b5cc0e6f35fb93ab35349d9a01e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae722b5cc0e6f35fb93ab35349d9a01e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae722b5cc0e6f35fb93ab35349d9a01e5.html#ae722b5cc0e6f35fb93ab35349d9a01e5">as_value_column_vector_or_scalar</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ae722b5cc0e6f35fb93ab35349d9a01e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract values from input argument and transform to a column vector.  <a href="namespacestan_1_1math_ae722b5cc0e6f35fb93ab35349d9a01e5.html#ae722b5cc0e6f35fb93ab35349d9a01e5">More...</a><br /></td></tr>
<tr class="separator:ae722b5cc0e6f35fb93ab35349d9a01e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1de6ae93aebb57433a03efc0a7701d4"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad1de6ae93aebb57433a03efc0a7701d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad1de6ae93aebb57433a03efc0a7701d4.html#ad1de6ae93aebb57433a03efc0a7701d4">asin</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ad1de6ae93aebb57433a03efc0a7701d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a1ab75d0165599717cfd1e90f7edcf250.html#a1ab75d0165599717cfd1e90f7edcf250">asin()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_ad1de6ae93aebb57433a03efc0a7701d4.html#ad1de6ae93aebb57433a03efc0a7701d4">More...</a><br /></td></tr>
<tr class="separator:ad1de6ae93aebb57433a03efc0a7701d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414186b19197138e9fd7349f90510bc4"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a414186b19197138e9fd7349f90510bc4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a414186b19197138e9fd7349f90510bc4.html#a414186b19197138e9fd7349f90510bc4">asin</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a414186b19197138e9fd7349f90510bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_a1ab75d0165599717cfd1e90f7edcf250.html#a1ab75d0165599717cfd1e90f7edcf250">asin()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects, or expressions, and containers of these.  <a href="namespacestan_1_1math_a414186b19197138e9fd7349f90510bc4.html#a414186b19197138e9fd7349f90510bc4">More...</a><br /></td></tr>
<tr class="separator:a414186b19197138e9fd7349f90510bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0061dc917e6daac99d0da90fc8913eee"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_var_matrix_t&lt; T &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0061dc917e6daac99d0da90fc8913eee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0061dc917e6daac99d0da90fc8913eee.html#a0061dc917e6daac99d0da90fc8913eee">asinh</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a0061dc917e6daac99d0da90fc8913eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a68af8aec6bd04b4d40e5bce59f82b97c.html#a68af8aec6bd04b4d40e5bce59f82b97c">asinh()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_a0061dc917e6daac99d0da90fc8913eee.html#a0061dc917e6daac99d0da90fc8913eee">More...</a><br /></td></tr>
<tr class="separator:a0061dc917e6daac99d0da90fc8913eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cdc003ece270393c367aba1f09b749"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:af5cdc003ece270393c367aba1f09b749"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af5cdc003ece270393c367aba1f09b749.html#af5cdc003ece270393c367aba1f09b749">print_mat_size</a> (std::ostream &amp;o)</td></tr>
<tr class="memdesc:af5cdc003ece270393c367aba1f09b749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to return the matrix size as either "dynamic" or "1".  <a href="namespacestan_1_1math_af5cdc003ece270393c367aba1f09b749.html#af5cdc003ece270393c367aba1f09b749">More...</a><br /></td></tr>
<tr class="separator:af5cdc003ece270393c367aba1f09b749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e46ec6cfc6f6fecad8e2b9847cc64d"><td class="memTemplParams" colspan="2">template&lt;typename T_lhs , typename T_rhs , require_all_stan_scalar_t&lt; T_lhs, T_rhs &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a16e46ec6cfc6f6fecad8e2b9847cc64d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a16e46ec6cfc6f6fecad8e2b9847cc64d.html#a16e46ec6cfc6f6fecad8e2b9847cc64d">assign</a> (T_lhs &amp;x, const T_rhs &amp;y)</td></tr>
<tr class="memdesc:a16e46ec6cfc6f6fecad8e2b9847cc64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="namespacestan_1_1math_a16e46ec6cfc6f6fecad8e2b9847cc64d.html#a16e46ec6cfc6f6fecad8e2b9847cc64d">More...</a><br /></td></tr>
<tr class="separator:a16e46ec6cfc6f6fecad8e2b9847cc64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7560afa1d2eb67c656e3eba06af0ab1e"><td class="memTemplParams" colspan="2">template&lt;typename T_lhs , typename T_rhs , require_all_eigen_t&lt; T_lhs, T_rhs &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7560afa1d2eb67c656e3eba06af0ab1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7560afa1d2eb67c656e3eba06af0ab1e.html#a7560afa1d2eb67c656e3eba06af0ab1e">assign</a> (T_lhs &amp;&amp;x, const T_rhs &amp;y)</td></tr>
<tr class="memdesc:a7560afa1d2eb67c656e3eba06af0ab1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="namespacestan_1_1math_a7560afa1d2eb67c656e3eba06af0ab1e.html#a7560afa1d2eb67c656e3eba06af0ab1e">More...</a><br /></td></tr>
<tr class="separator:a7560afa1d2eb67c656e3eba06af0ab1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097bc5818c82364e91167bfe757f4418"><td class="memTemplParams" colspan="2">template&lt;typename T_lhs , typename T_rhs &gt; </td></tr>
<tr class="memitem:a097bc5818c82364e91167bfe757f4418"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a097bc5818c82364e91167bfe757f4418.html#a097bc5818c82364e91167bfe757f4418">assign</a> (std::vector&lt; T_lhs &gt; &amp;x, const std::vector&lt; T_rhs &gt; &amp;y)</td></tr>
<tr class="memdesc:a097bc5818c82364e91167bfe757f4418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <a href="namespacestan_1_1math_a097bc5818c82364e91167bfe757f4418.html#a097bc5818c82364e91167bfe757f4418">More...</a><br /></td></tr>
<tr class="separator:a097bc5818c82364e91167bfe757f4418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97ec19b3a5e50249e6ebec1db4edaed"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae97ec19b3a5e50249e6ebec1db4edaed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae97ec19b3a5e50249e6ebec1db4edaed.html#ae97ec19b3a5e50249e6ebec1db4edaed">atan</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ae97ec19b3a5e50249e6ebec1db4edaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a6f0398656b862b1b2eb80145f4877b11.html#a6f0398656b862b1b2eb80145f4877b11">atan()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_ae97ec19b3a5e50249e6ebec1db4edaed.html#ae97ec19b3a5e50249e6ebec1db4edaed">More...</a><br /></td></tr>
<tr class="separator:ae97ec19b3a5e50249e6ebec1db4edaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691f3ae86b778c0ee01a013bbafa9dcb"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a691f3ae86b778c0ee01a013bbafa9dcb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a691f3ae86b778c0ee01a013bbafa9dcb.html#a691f3ae86b778c0ee01a013bbafa9dcb">atan</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a691f3ae86b778c0ee01a013bbafa9dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="namespacestan_1_1math_a6f0398656b862b1b2eb80145f4877b11.html#a6f0398656b862b1b2eb80145f4877b11">atan()</a> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects, or expressions, and containers of these.  <a href="namespacestan_1_1math_a691f3ae86b778c0ee01a013bbafa9dcb.html#a691f3ae86b778c0ee01a013bbafa9dcb">More...</a><br /></td></tr>
<tr class="separator:a691f3ae86b778c0ee01a013bbafa9dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426e7dc185ddbee64526d44f47f5cd7b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_arithmetic_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a426e7dc185ddbee64526d44f47f5cd7b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a426e7dc185ddbee64526d44f47f5cd7b.html#a426e7dc185ddbee64526d44f47f5cd7b">atan2</a> (T1 y, T2 x)</td></tr>
<tr class="memdesc:a426e7dc185ddbee64526d44f47f5cd7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant.  <a href="namespacestan_1_1math_a426e7dc185ddbee64526d44f47f5cd7b.html#a426e7dc185ddbee64526d44f47f5cd7b">More...</a><br /></td></tr>
<tr class="separator:a426e7dc185ddbee64526d44f47f5cd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed226407b57b7d29406229c94981ee2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ed226407b57b7d29406229c94981ee2.html#a9ed226407b57b7d29406229c94981ee2">atanh</a> (double x)</td></tr>
<tr class="memdesc:a9ed226407b57b7d29406229c94981ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse hyperbolic tangent of the specified value.  <a href="namespacestan_1_1math_a9ed226407b57b7d29406229c94981ee2.html#a9ed226407b57b7d29406229c94981ee2">More...</a><br /></td></tr>
<tr class="separator:a9ed226407b57b7d29406229c94981ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa244a13e97da9306e5915b7b78f1b914"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa244a13e97da9306e5915b7b78f1b914.html#aa244a13e97da9306e5915b7b78f1b914">atanh</a> (int x)</td></tr>
<tr class="memdesc:aa244a13e97da9306e5915b7b78f1b914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer version of atanh.  <a href="namespacestan_1_1math_aa244a13e97da9306e5915b7b78f1b914.html#aa244a13e97da9306e5915b7b78f1b914">More...</a><br /></td></tr>
<tr class="separator:aa244a13e97da9306e5915b7b78f1b914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe41b883f2f2a9a0b53819558663efbc"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_var_matrix_t&lt; T &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afe41b883f2f2a9a0b53819558663efbc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afe41b883f2f2a9a0b53819558663efbc.html#afe41b883f2f2a9a0b53819558663efbc">atanh</a> (const T &amp;x)</td></tr>
<tr class="memdesc:afe41b883f2f2a9a0b53819558663efbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a9e31606b2cbc69573ec0d7693c8b2a2c.html#a9e31606b2cbc69573ec0d7693c8b2a2c" title="Return inverse hyperbolic tangent of specified value.">atanh()</a></code> to specified argument container.  <a href="namespacestan_1_1math_afe41b883f2f2a9a0b53819558663efbc.html#afe41b883f2f2a9a0b53819558663efbc">More...</a><br /></td></tr>
<tr class="separator:afe41b883f2f2a9a0b53819558663efbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7c65ea100e48abc72f3c1e96fcdbe9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd7c65ea100e48abc72f3c1e96fcdbe9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afd7c65ea100e48abc72f3c1e96fcdbe9.html#afd7c65ea100e48abc72f3c1e96fcdbe9">autocorrelation</a> (const std::vector&lt; T &gt; &amp;y, std::vector&lt; T &gt; &amp;ac, Eigen::FFT&lt; T &gt; &amp;<a class="el" href="namespacestan_1_1math_a63eb24cc02a87c3437616797cec6cf4d.html#a63eb24cc02a87c3437616797cec6cf4d">fft</a>)</td></tr>
<tr class="memdesc:afd7c65ea100e48abc72f3c1e96fcdbe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocorrelation estimates for every lag for the specified input sequence into the specified result using the specified FFT engine.  <a href="namespacestan_1_1math_afd7c65ea100e48abc72f3c1e96fcdbe9.html#afd7c65ea100e48abc72f3c1e96fcdbe9">More...</a><br /></td></tr>
<tr class="separator:afd7c65ea100e48abc72f3c1e96fcdbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedea144e2c485e558eb949cca99e8c77"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:aedea144e2c485e558eb949cca99e8c77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aedea144e2c485e558eb949cca99e8c77.html#aedea144e2c485e558eb949cca99e8c77">autocorrelation</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;y, Eigen::MatrixBase&lt; DerivedB &gt; &amp;ac, Eigen::FFT&lt; T &gt; &amp;<a class="el" href="namespacestan_1_1math_a63eb24cc02a87c3437616797cec6cf4d.html#a63eb24cc02a87c3437616797cec6cf4d">fft</a>)</td></tr>
<tr class="memdesc:aedea144e2c485e558eb949cca99e8c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocorrelation estimates for every lag for the specified input sequence into the specified result using the specified FFT engine.  <a href="namespacestan_1_1math_aedea144e2c485e558eb949cca99e8c77.html#aedea144e2c485e558eb949cca99e8c77">More...</a><br /></td></tr>
<tr class="separator:aedea144e2c485e558eb949cca99e8c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999404b2520dcd466c62c6ba3ca61f89"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a999404b2520dcd466c62c6ba3ca61f89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a999404b2520dcd466c62c6ba3ca61f89.html#a999404b2520dcd466c62c6ba3ca61f89">autocorrelation</a> (const std::vector&lt; T &gt; &amp;y, std::vector&lt; T &gt; &amp;ac)</td></tr>
<tr class="memdesc:a999404b2520dcd466c62c6ba3ca61f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocorrelation estimates for every lag for the specified input sequence into the specified result.  <a href="namespacestan_1_1math_a999404b2520dcd466c62c6ba3ca61f89.html#a999404b2520dcd466c62c6ba3ca61f89">More...</a><br /></td></tr>
<tr class="separator:a999404b2520dcd466c62c6ba3ca61f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf836199717572fdda79720523b1d42"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:aeaf836199717572fdda79720523b1d42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeaf836199717572fdda79720523b1d42.html#aeaf836199717572fdda79720523b1d42">autocorrelation</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;y, Eigen::MatrixBase&lt; DerivedB &gt; &amp;ac)</td></tr>
<tr class="memdesc:aeaf836199717572fdda79720523b1d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocorrelation estimates for every lag for the specified input sequence into the specified result.  <a href="namespacestan_1_1math_aeaf836199717572fdda79720523b1d42.html#aeaf836199717572fdda79720523b1d42">More...</a><br /></td></tr>
<tr class="separator:aeaf836199717572fdda79720523b1d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab515e37311a3070dbc66e69d31359a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab515e37311a3070dbc66e69d31359a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab515e37311a3070dbc66e69d31359a5.html#aab515e37311a3070dbc66e69d31359a5">autocovariance</a> (const std::vector&lt; T &gt; &amp;y, std::vector&lt; T &gt; &amp;acov, Eigen::FFT&lt; T &gt; &amp;<a class="el" href="namespacestan_1_1math_a63eb24cc02a87c3437616797cec6cf4d.html#a63eb24cc02a87c3437616797cec6cf4d">fft</a>)</td></tr>
<tr class="memdesc:aab515e37311a3070dbc66e69d31359a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocovariance estimates for every lag for the specified input sequence into the specified result using the specified FFT engine.  <a href="namespacestan_1_1math_aab515e37311a3070dbc66e69d31359a5.html#aab515e37311a3070dbc66e69d31359a5">More...</a><br /></td></tr>
<tr class="separator:aab515e37311a3070dbc66e69d31359a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141ceb38cf2fad0a49c99af720ffc4d2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a141ceb38cf2fad0a49c99af720ffc4d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a141ceb38cf2fad0a49c99af720ffc4d2.html#a141ceb38cf2fad0a49c99af720ffc4d2">autocovariance</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;y, Eigen::MatrixBase&lt; DerivedB &gt; &amp;acov, Eigen::FFT&lt; T &gt; &amp;<a class="el" href="namespacestan_1_1math_a63eb24cc02a87c3437616797cec6cf4d.html#a63eb24cc02a87c3437616797cec6cf4d">fft</a>)</td></tr>
<tr class="memdesc:a141ceb38cf2fad0a49c99af720ffc4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocovariance estimates for every lag for the specified input sequence into the specified result using the specified FFT engine.  <a href="namespacestan_1_1math_a141ceb38cf2fad0a49c99af720ffc4d2.html#a141ceb38cf2fad0a49c99af720ffc4d2">More...</a><br /></td></tr>
<tr class="separator:a141ceb38cf2fad0a49c99af720ffc4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfe56505f9cbe96a18fc00f76fe79fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdfe56505f9cbe96a18fc00f76fe79fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acdfe56505f9cbe96a18fc00f76fe79fd.html#acdfe56505f9cbe96a18fc00f76fe79fd">autocovariance</a> (const std::vector&lt; T &gt; &amp;y, std::vector&lt; T &gt; &amp;acov)</td></tr>
<tr class="memdesc:acdfe56505f9cbe96a18fc00f76fe79fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocovariance estimates for every lag for the specified input sequence into the specified result.  <a href="namespacestan_1_1math_acdfe56505f9cbe96a18fc00f76fe79fd.html#acdfe56505f9cbe96a18fc00f76fe79fd">More...</a><br /></td></tr>
<tr class="separator:acdfe56505f9cbe96a18fc00f76fe79fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba016ad24cda70a732fccad2cd0abf8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:abba016ad24cda70a732fccad2cd0abf8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abba016ad24cda70a732fccad2cd0abf8.html#abba016ad24cda70a732fccad2cd0abf8">autocovariance</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;y, Eigen::MatrixBase&lt; DerivedB &gt; &amp;acov)</td></tr>
<tr class="memdesc:abba016ad24cda70a732fccad2cd0abf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocovariance estimates for every lag for the specified input sequence into the specified result.  <a href="namespacestan_1_1math_abba016ad24cda70a732fccad2cd0abf8.html#abba016ad24cda70a732fccad2cd0abf8">More...</a><br /></td></tr>
<tr class="separator:abba016ad24cda70a732fccad2cd0abf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f66e5165eed5fc69926e5545e81d55c"><td class="memTemplParams" colspan="2">template&lt;typename T2 , require_arithmetic_t&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6f66e5165eed5fc69926e5545e81d55c"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6f66e5165eed5fc69926e5545e81d55c.html#a6f66e5165eed5fc69926e5545e81d55c">bessel_first_kind</a> (int v, const T2 z)</td></tr>
<tr class="separator:a6f66e5165eed5fc69926e5545e81d55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa642040393baf26c0560573b0d497d8d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr, require_not_var_matrix_t&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa642040393baf26c0560573b0d497d8d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa642040393baf26c0560573b0d497d8d.html#aa642040393baf26c0560573b0d497d8d">bessel_first_kind</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:aa642040393baf26c0560573b0d497d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the bessel first kind function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_aa642040393baf26c0560573b0d497d8d.html#aa642040393baf26c0560573b0d497d8d">More...</a><br /></td></tr>
<tr class="separator:aa642040393baf26c0560573b0d497d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab462d0d4b2e1d74769156563802ab23"><td class="memTemplParams" colspan="2">template&lt;typename T2 , require_arithmetic_t&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aab462d0d4b2e1d74769156563802ab23"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab462d0d4b2e1d74769156563802ab23.html#aab462d0d4b2e1d74769156563802ab23">bessel_second_kind</a> (int v, const T2 z)</td></tr>
<tr class="separator:aab462d0d4b2e1d74769156563802ab23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362f9cb7bd515c0b315b99fe39f25c91"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a362f9cb7bd515c0b315b99fe39f25c91"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a362f9cb7bd515c0b315b99fe39f25c91.html#a362f9cb7bd515c0b315b99fe39f25c91">bessel_second_kind</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a362f9cb7bd515c0b315b99fe39f25c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the bessel second kind function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_a362f9cb7bd515c0b315b99fe39f25c91.html#a362f9cb7bd515c0b315b99fe39f25c91">More...</a><br /></td></tr>
<tr class="separator:a362f9cb7bd515c0b315b99fe39f25c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba15453b2528de5b518463f58ee22f7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_arithmetic_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abba15453b2528de5b518463f58ee22f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abba15453b2528de5b518463f58ee22f7.html#abba15453b2528de5b518463f58ee22f7">beta</a> (const T1 a, const T2 b)</td></tr>
<tr class="memdesc:abba15453b2528de5b518463f58ee22f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the beta function applied to the specified arguments.  <a href="namespacestan_1_1math_abba15453b2528de5b518463f58ee22f7.html#abba15453b2528de5b518463f58ee22f7">More...</a><br /></td></tr>
<tr class="separator:abba15453b2528de5b518463f58ee22f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924e1e727e97def79c4fbdbfe2052623"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr, require_all_not_var_matrix_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a924e1e727e97def79c4fbdbfe2052623"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a924e1e727e97def79c4fbdbfe2052623.html#a924e1e727e97def79c4fbdbfe2052623">beta</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a924e1e727e97def79c4fbdbfe2052623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the beta function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_a924e1e727e97def79c4fbdbfe2052623.html#a924e1e727e97def79c4fbdbfe2052623">More...</a><br /></td></tr>
<tr class="separator:a924e1e727e97def79c4fbdbfe2052623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0838fc113de27636f1be3c4183e0b36"><td class="memTemplParams" colspan="2">template&lt;typename T , require_arithmetic_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa0838fc113de27636f1be3c4183e0b36"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa0838fc113de27636f1be3c4183e0b36.html#aa0838fc113de27636f1be3c4183e0b36">binary_log_loss</a> (int y, const T &amp;y_hat)</td></tr>
<tr class="memdesc:aa0838fc113de27636f1be3c4183e0b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log loss function for binary classification with specified reference and response values.  <a href="namespacestan_1_1math_aa0838fc113de27636f1be3c4183e0b36.html#aa0838fc113de27636f1be3c4183e0b36">More...</a><br /></td></tr>
<tr class="separator:aa0838fc113de27636f1be3c4183e0b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1d2ef4e3e5e5ccff976cc57f6f362d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr, require_not_var_matrix_t&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4e1d2ef4e3e5e5ccff976cc57f6f362d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4e1d2ef4e3e5e5ccff976cc57f6f362d.html#a4e1d2ef4e3e5e5ccff976cc57f6f362d">binary_log_loss</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a4e1d2ef4e3e5e5ccff976cc57f6f362d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the binary log loss function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_a4e1d2ef4e3e5e5ccff976cc57f6f362d.html#a4e1d2ef4e3e5e5ccff976cc57f6f362d">More...</a><br /></td></tr>
<tr class="separator:a4e1d2ef4e3e5e5ccff976cc57f6f362d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ccb45eeb8e2115da65151f0cf972f8"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_k , require_all_stan_scalar_t&lt; T_n, T_k &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a08ccb45eeb8e2115da65151f0cf972f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n, T_k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a08ccb45eeb8e2115da65151f0cf972f8.html#a08ccb45eeb8e2115da65151f0cf972f8">binomial_coefficient_log</a> (const T_n n, const T_k k)</td></tr>
<tr class="memdesc:a08ccb45eeb8e2115da65151f0cf972f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the binomial coefficient for the specified arguments.  <a href="namespacestan_1_1math_a08ccb45eeb8e2115da65151f0cf972f8.html#a08ccb45eeb8e2115da65151f0cf972f8">More...</a><br /></td></tr>
<tr class="separator:a08ccb45eeb8e2115da65151f0cf972f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8617588af9e9bf173b1ef5ab4a724f4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac8617588af9e9bf173b1ef5ab4a724f4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac8617588af9e9bf173b1ef5ab4a724f4.html#ac8617588af9e9bf173b1ef5ab4a724f4">binomial_coefficient_log</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ac8617588af9e9bf173b1ef5ab4a724f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the binomial coefficient log function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_ac8617588af9e9bf173b1ef5ab4a724f4.html#ac8617588af9e9bf173b1ef5ab4a724f4">More...</a><br /></td></tr>
<tr class="separator:ac8617588af9e9bf173b1ef5ab4a724f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02a2af29800cfd98de4d5e6bd401517"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae02a2af29800cfd98de4d5e6bd401517"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae02a2af29800cfd98de4d5e6bd401517.html#ae02a2af29800cfd98de4d5e6bd401517">block</a> (const T &amp;m, size_t i, size_t j, size_t nrows, size_t ncols)</td></tr>
<tr class="memdesc:ae02a2af29800cfd98de4d5e6bd401517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a nrows x ncols submatrix starting at (i-1, j-1).  <a href="namespacestan_1_1math_ae02a2af29800cfd98de4d5e6bd401517.html#ae02a2af29800cfd98de4d5e6bd401517">More...</a><br /></td></tr>
<tr class="separator:ae02a2af29800cfd98de4d5e6bd401517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5fbf40d8568ff9470ac4d43e580efc"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_var_matrix_t&lt; T &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adf5fbf40d8568ff9470ac4d43e580efc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adf5fbf40d8568ff9470ac4d43e580efc.html#adf5fbf40d8568ff9470ac4d43e580efc">cbrt</a> (const T &amp;x)</td></tr>
<tr class="memdesc:adf5fbf40d8568ff9470ac4d43e580efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a64c0dfe5862fc53f1a18d76f14a1dc7e.html#a64c0dfe5862fc53f1a18d76f14a1dc7e" title="Return cube root of specified argument.">cbrt()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_adf5fbf40d8568ff9470ac4d43e580efc.html#adf5fbf40d8568ff9470ac4d43e580efc">More...</a><br /></td></tr>
<tr class="separator:adf5fbf40d8568ff9470ac4d43e580efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d245dddcfd6f06addb3e64f75dc9c6"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae0d245dddcfd6f06addb3e64f75dc9c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae0d245dddcfd6f06addb3e64f75dc9c6.html#ae0d245dddcfd6f06addb3e64f75dc9c6">ceil</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ae0d245dddcfd6f06addb3e64f75dc9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ab1b2e9b4a947b81917612a8d1d547afb.html#ab1b2e9b4a947b81917612a8d1d547afb">ceil()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_ae0d245dddcfd6f06addb3e64f75dc9c6.html#ae0d245dddcfd6f06addb3e64f75dc9c6">More...</a><br /></td></tr>
<tr class="separator:ae0d245dddcfd6f06addb3e64f75dc9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402e03f337a7b472d3697e51a970a28e"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a402e03f337a7b472d3697e51a970a28e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a402e03f337a7b472d3697e51a970a28e.html#a402e03f337a7b472d3697e51a970a28e">chol2inv</a> (const T &amp;L)</td></tr>
<tr class="memdesc:a402e03f337a7b472d3697e51a970a28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of the matrix whose Cholesky factor is L.  <a href="namespacestan_1_1math_a402e03f337a7b472d3697e51a970a28e.html#a402e03f337a7b472d3697e51a970a28e">More...</a><br /></td></tr>
<tr class="separator:a402e03f337a7b472d3697e51a970a28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac189900040a25267b17a06ef4fd987c9"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_eigen_col_vector_t&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac189900040a25267b17a06ef4fd987c9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigVec &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac189900040a25267b17a06ef4fd987c9.html#ac189900040a25267b17a06ef4fd987c9">cholesky_corr_constrain</a> (const EigVec &amp;y, int K)</td></tr>
<tr class="separator:ac189900040a25267b17a06ef4fd987c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26662c9227d6fdb081dd8c5b08cbe22e"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_eigen_vector_t&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a26662c9227d6fdb081dd8c5b08cbe22e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigVec &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a26662c9227d6fdb081dd8c5b08cbe22e.html#a26662c9227d6fdb081dd8c5b08cbe22e">cholesky_corr_constrain</a> (const EigVec &amp;y, int K, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigVec &gt; &amp;lp)</td></tr>
<tr class="separator:a26662c9227d6fdb081dd8c5b08cbe22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336435c8562f3ebc68691898f1530cb7"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , require_not_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a336435c8562f3ebc68691898f1530cb7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a336435c8562f3ebc68691898f1530cb7.html#a336435c8562f3ebc68691898f1530cb7">cholesky_corr_constrain</a> (const T &amp;y, int K, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a336435c8562f3ebc68691898f1530cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return The cholesky of a <code>KxK</code> correlation matrix.  <a href="namespacestan_1_1math_a336435c8562f3ebc68691898f1530cb7.html#a336435c8562f3ebc68691898f1530cb7">More...</a><br /></td></tr>
<tr class="separator:a336435c8562f3ebc68691898f1530cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac170f5d0dc6969c674af9217bc062a"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2ac170f5d0dc6969c674af9217bc062a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2ac170f5d0dc6969c674af9217bc062a.html#a2ac170f5d0dc6969c674af9217bc062a">cholesky_corr_free</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a2ac170f5d0dc6969c674af9217bc062a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_a2ac170f5d0dc6969c674af9217bc062a.html#a2ac170f5d0dc6969c674af9217bc062a" title="Overload of cholesky_corr_free() to untransform each matrix in a standard vector.">cholesky_corr_free()</a></code> to untransform each matrix in a standard vector.  <a href="namespacestan_1_1math_a2ac170f5d0dc6969c674af9217bc062a.html#a2ac170f5d0dc6969c674af9217bc062a">More...</a><br /></td></tr>
<tr class="separator:a2ac170f5d0dc6969c674af9217bc062a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbd0a1b27793c70407bc318eeddda2c"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_not_eigen_vt&lt; is_var, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1fbd0a1b27793c70407bc318eeddda2c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, EigMat::RowsAtCompileTime, EigMat::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1fbd0a1b27793c70407bc318eeddda2c.html#a1fbd0a1b27793c70407bc318eeddda2c">cholesky_decompose</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a1fbd0a1b27793c70407bc318eeddda2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric matrix.  <a href="namespacestan_1_1math_a1fbd0a1b27793c70407bc318eeddda2c.html#a1fbd0a1b27793c70407bc318eeddda2c">More...</a><br /></td></tr>
<tr class="separator:a1fbd0a1b27793c70407bc318eeddda2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d0d03e9b3db1199d583e8244af4f1e"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_col_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a10d0d03e9b3db1199d583e8244af4f1e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a10d0d03e9b3db1199d583e8244af4f1e.html#a10d0d03e9b3db1199d583e8244af4f1e">cholesky_factor_constrain</a> (const T &amp;x, int M, int N)</td></tr>
<tr class="memdesc:a10d0d03e9b3db1199d583e8244af4f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the specified size read from the specified vector.  <a href="namespacestan_1_1math_a10d0d03e9b3db1199d583e8244af4f1e.html#a10d0d03e9b3db1199d583e8244af4f1e">More...</a><br /></td></tr>
<tr class="separator:a10d0d03e9b3db1199d583e8244af4f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74734f7dfd0587137ae281f8c0de7559"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a74734f7dfd0587137ae281f8c0de7559"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a74734f7dfd0587137ae281f8c0de7559.html#a74734f7dfd0587137ae281f8c0de7559">cholesky_factor_constrain</a> (const T &amp;x, int M, int N, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a74734f7dfd0587137ae281f8c0de7559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the specified size read from the specified vector and increment the specified log probability reference with the log absolute Jacobian determinant adjustment of the transform.  <a href="namespacestan_1_1math_a74734f7dfd0587137ae281f8c0de7559.html#a74734f7dfd0587137ae281f8c0de7559">More...</a><br /></td></tr>
<tr class="separator:a74734f7dfd0587137ae281f8c0de7559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae206753e64823b15baa539f1fa34eacb"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , require_not_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae206753e64823b15baa539f1fa34eacb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae206753e64823b15baa539f1fa34eacb.html#ae206753e64823b15baa539f1fa34eacb">cholesky_factor_constrain</a> (const T &amp;x, int M, int N, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:ae206753e64823b15baa539f1fa34eacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the specified size read from the specified vector.  <a href="namespacestan_1_1math_ae206753e64823b15baa539f1fa34eacb.html#ae206753e64823b15baa539f1fa34eacb">More...</a><br /></td></tr>
<tr class="separator:ae206753e64823b15baa539f1fa34eacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865e69dc6026e5c8f0cac91d228a989d"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a865e69dc6026e5c8f0cac91d228a989d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a865e69dc6026e5c8f0cac91d228a989d.html#a865e69dc6026e5c8f0cac91d228a989d">cholesky_factor_free</a> (const T &amp;y)</td></tr>
<tr class="memdesc:a865e69dc6026e5c8f0cac91d228a989d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unconstrained vector of parameters corresponding to the specified Cholesky factor.  <a href="namespacestan_1_1math_a865e69dc6026e5c8f0cac91d228a989d.html#a865e69dc6026e5c8f0cac91d228a989d">More...</a><br /></td></tr>
<tr class="separator:a865e69dc6026e5c8f0cac91d228a989d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3e3eac6538ed168d365c46fbe4d81c"><td class="memTemplParams" colspan="2">template&lt;typename T , require_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aee3e3eac6538ed168d365c46fbe4d81c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aee3e3eac6538ed168d365c46fbe4d81c.html#aee3e3eac6538ed168d365c46fbe4d81c">cholesky_factor_free</a> (const T &amp;x)</td></tr>
<tr class="memdesc:aee3e3eac6538ed168d365c46fbe4d81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_a865e69dc6026e5c8f0cac91d228a989d.html#a865e69dc6026e5c8f0cac91d228a989d" title="Return the unconstrained vector of parameters corresponding to the specified Cholesky factor.">cholesky_factor_free()</a></code> to untransform each matrix in a standard vector.  <a href="namespacestan_1_1math_aee3e3eac6538ed168d365c46fbe4d81c.html#aee3e3eac6538ed168d365c46fbe4d81c">More...</a><br /></td></tr>
<tr class="separator:aee3e3eac6538ed168d365c46fbe4d81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660f7e5239385475db0bc58a0803ab07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a660f7e5239385475db0bc58a0803ab07.html#a660f7e5239385475db0bc58a0803ab07">choose</a> (int n, int k)</td></tr>
<tr class="memdesc:a660f7e5239385475db0bc58a0803ab07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the binomial coefficient for the specified integer arguments.  <a href="namespacestan_1_1math_a660f7e5239385475db0bc58a0803ab07.html#a660f7e5239385475db0bc58a0803ab07">More...</a><br /></td></tr>
<tr class="separator:a660f7e5239385475db0bc58a0803ab07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f76b4ab65565378fde5270f078b840"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa8f76b4ab65565378fde5270f078b840"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa8f76b4ab65565378fde5270f078b840.html#aa8f76b4ab65565378fde5270f078b840">choose</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:aa8f76b4ab65565378fde5270f078b840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the binomial coefficient function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_aa8f76b4ab65565378fde5270f078b840.html#aa8f76b4ab65565378fde5270f078b840">More...</a><br /></td></tr>
<tr class="separator:aa8f76b4ab65565378fde5270f078b840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0790d26b4eba96a0bc1261dd80fa22"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeb0790d26b4eba96a0bc1261dd80fa22"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeb0790d26b4eba96a0bc1261dd80fa22.html#aeb0790d26b4eba96a0bc1261dd80fa22">col</a> (const T &amp;m, size_t j)</td></tr>
<tr class="memdesc:aeb0790d26b4eba96a0bc1261dd80fa22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified column of the specified matrix using start-at-1 indexing.  <a href="namespacestan_1_1math_aeb0790d26b4eba96a0bc1261dd80fa22.html#aeb0790d26b4eba96a0bc1261dd80fa22">More...</a><br /></td></tr>
<tr class="separator:aeb0790d26b4eba96a0bc1261dd80fa22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f16fa1157077781a83ce7e90b01601f"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7f16fa1157077781a83ce7e90b01601f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7f16fa1157077781a83ce7e90b01601f.html#a7f16fa1157077781a83ce7e90b01601f">cols</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a7f16fa1157077781a83ce7e90b01601f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of columns in the specified matrix, vector, or row vector.  <a href="namespacestan_1_1math_a7f16fa1157077781a83ce7e90b01601f.html#a7f16fa1157077781a83ce7e90b01601f">More...</a><br /></td></tr>
<tr class="separator:a7f16fa1157077781a83ce7e90b01601f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b5c6bb55c9da736211b7a220e89ca7"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , require_all_eigen_t&lt; Mat1, Mat2 &gt; *  = nullptr, require_all_not_eigen_vt&lt; is_var, Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a91b5c6bb55c9da736211b7a220e89ca7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Mat1, Mat2 &gt;, 1, Mat1::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a91b5c6bb55c9da736211b7a220e89ca7.html#a91b5c6bb55c9da736211b7a220e89ca7">columns_dot_product</a> (const Mat1 &amp;v1, const Mat2 &amp;v2)</td></tr>
<tr class="memdesc:a91b5c6bb55c9da736211b7a220e89ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of columns of the specified matrices.  <a href="namespacestan_1_1math_a91b5c6bb55c9da736211b7a220e89ca7.html#a91b5c6bb55c9da736211b7a220e89ca7">More...</a><br /></td></tr>
<tr class="separator:a91b5c6bb55c9da736211b7a220e89ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a63c002d8156e94241ca44714e3e3f"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr, require_not_eigen_vt&lt; is_var, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac8a63c002d8156e94241ca44714e3e3f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, 1, T::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac8a63c002d8156e94241ca44714e3e3f.html#ac8a63c002d8156e94241ca44714e3e3f">columns_dot_self</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ac8a63c002d8156e94241ca44714e3e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each column of a matrix with itself.  <a href="namespacestan_1_1math_ac8a63c002d8156e94241ca44714e3e3f.html#ac8a63c002d8156e94241ca44714e3e3f">More...</a><br /></td></tr>
<tr class="separator:ac8a63c002d8156e94241ca44714e3e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc78ebea92f0cf6e134ad925f5c2acc6"><td class="memTemplParams" colspan="2">template&lt;typename M , require_eigen_dense_dynamic_t&lt; M &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abc78ebea92f0cf6e134ad925f5c2acc6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; M &gt; &gt;, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abc78ebea92f0cf6e134ad925f5c2acc6.html#abc78ebea92f0cf6e134ad925f5c2acc6">complex_schur_decompose_u</a> (const M &amp;m)</td></tr>
<tr class="memdesc:abc78ebea92f0cf6e134ad925f5c2acc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unitary matrix of the complex Schur decomposition of the specified square matrix.  <a href="namespacestan_1_1math_abc78ebea92f0cf6e134ad925f5c2acc6.html#abc78ebea92f0cf6e134ad925f5c2acc6">More...</a><br /></td></tr>
<tr class="separator:abc78ebea92f0cf6e134ad925f5c2acc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d82bd1aef61bb740a28a305d6e1999"><td class="memTemplParams" colspan="2">template&lt;typename M , require_eigen_dense_dynamic_t&lt; M &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a26d82bd1aef61bb740a28a305d6e1999"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; M &gt; &gt;, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a26d82bd1aef61bb740a28a305d6e1999.html#a26d82bd1aef61bb740a28a305d6e1999">complex_schur_decompose_t</a> (const M &amp;m)</td></tr>
<tr class="memdesc:a26d82bd1aef61bb740a28a305d6e1999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Schur form matrix of the complex Schur decomposition of the specified square matrix.  <a href="namespacestan_1_1math_a26d82bd1aef61bb740a28a305d6e1999.html#a26d82bd1aef61bb740a28a305d6e1999">More...</a><br /></td></tr>
<tr class="separator:a26d82bd1aef61bb740a28a305d6e1999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa3ae5999f10835eec8555848e9b35c"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a8fa3ae5999f10835eec8555848e9b35c"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8fa3ae5999f10835eec8555848e9b35c.html#a8fa3ae5999f10835eec8555848e9b35c">conj</a> (const std::complex&lt; V &gt; &amp;z)</td></tr>
<tr class="memdesc:a8fa3ae5999f10835eec8555848e9b35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the complex conjugate the complex argument.  <a href="namespacestan_1_1math_a8fa3ae5999f10835eec8555848e9b35c.html#a8fa3ae5999f10835eec8555848e9b35c">More...</a><br /></td></tr>
<tr class="separator:a8fa3ae5999f10835eec8555848e9b35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df9aadd05bb984d7c5266da75b2e8a4"><td class="memTemplParams" colspan="2">template&lt;typename Eig , require_eigen_vt&lt; is_complex, Eig &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3df9aadd05bb984d7c5266da75b2e8a4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3df9aadd05bb984d7c5266da75b2e8a4.html#a3df9aadd05bb984d7c5266da75b2e8a4">conj</a> (const Eig &amp;z)</td></tr>
<tr class="memdesc:a3df9aadd05bb984d7c5266da75b2e8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the complex conjugate the <a class="el" href="namespace_eigen.html">Eigen</a> object.  <a href="namespacestan_1_1math_a3df9aadd05bb984d7c5266da75b2e8a4.html#a3df9aadd05bb984d7c5266da75b2e8a4">More...</a><br /></td></tr>
<tr class="separator:a3df9aadd05bb984d7c5266da75b2e8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc9077a0fc91e15a66749d251c2480c"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , require_std_vector_st&lt; is_complex, StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8fc9077a0fc91e15a66749d251c2480c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8fc9077a0fc91e15a66749d251c2480c.html#a8fc9077a0fc91e15a66749d251c2480c">conj</a> (const StdVec &amp;z)</td></tr>
<tr class="memdesc:a8fc9077a0fc91e15a66749d251c2480c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the complex conjugate the vector with complex scalar components.  <a href="namespacestan_1_1math_a8fc9077a0fc91e15a66749d251c2480c.html#a8fc9077a0fc91e15a66749d251c2480c">More...</a><br /></td></tr>
<tr class="separator:a8fc9077a0fc91e15a66749d251c2480c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7127a28f51e5042f0bc4301409dd2f"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a> ()</td></tr>
<tr class="memdesc:a3a7127a28f51e5042f0bc4301409dd2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base of the natural logarithm.  <a href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">More...</a><br /></td></tr>
<tr class="separator:a3a7127a28f51e5042f0bc4301409dd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34f4bd29068f15850660695c8d3c6a9"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad34f4bd29068f15850660695c8d3c6a9.html#ad34f4bd29068f15850660695c8d3c6a9">egamma</a> ()</td></tr>
<tr class="memdesc:ad34f4bd29068f15850660695c8d3c6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Euler's gamma constant.  <a href="namespacestan_1_1math_ad34f4bd29068f15850660695c8d3c6a9.html#ad34f4bd29068f15850660695c8d3c6a9">More...</a><br /></td></tr>
<tr class="separator:ad34f4bd29068f15850660695c8d3c6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30268675d705278387b7019a50431a9"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac30268675d705278387b7019a50431a9.html#ac30268675d705278387b7019a50431a9">pi</a> ()</td></tr>
<tr class="memdesc:ac30268675d705278387b7019a50431a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of pi.  <a href="namespacestan_1_1math_ac30268675d705278387b7019a50431a9.html#ac30268675d705278387b7019a50431a9">More...</a><br /></td></tr>
<tr class="separator:ac30268675d705278387b7019a50431a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2fd43f776374fd4637cb484765e3d1"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1f2fd43f776374fd4637cb484765e3d1.html#a1f2fd43f776374fd4637cb484765e3d1">positive_infinity</a> ()</td></tr>
<tr class="memdesc:a1f2fd43f776374fd4637cb484765e3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return positive infinity.  <a href="namespacestan_1_1math_a1f2fd43f776374fd4637cb484765e3d1.html#a1f2fd43f776374fd4637cb484765e3d1">More...</a><br /></td></tr>
<tr class="separator:a1f2fd43f776374fd4637cb484765e3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c927d2a7364efe3190f1cc18f1b4ff0"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0c927d2a7364efe3190f1cc18f1b4ff0.html#a0c927d2a7364efe3190f1cc18f1b4ff0">negative_infinity</a> ()</td></tr>
<tr class="memdesc:a0c927d2a7364efe3190f1cc18f1b4ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return negative infinity.  <a href="namespacestan_1_1math_a0c927d2a7364efe3190f1cc18f1b4ff0.html#a0c927d2a7364efe3190f1cc18f1b4ff0">More...</a><br /></td></tr>
<tr class="separator:a0c927d2a7364efe3190f1cc18f1b4ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b72006d415b528fb08d0d3b25576a0"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a47b72006d415b528fb08d0d3b25576a0.html#a47b72006d415b528fb08d0d3b25576a0">not_a_number</a> ()</td></tr>
<tr class="memdesc:a47b72006d415b528fb08d0d3b25576a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return (quiet) not-a-number.  <a href="namespacestan_1_1math_a47b72006d415b528fb08d0d3b25576a0.html#a47b72006d415b528fb08d0d3b25576a0">More...</a><br /></td></tr>
<tr class="separator:a47b72006d415b528fb08d0d3b25576a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d4cbc42c67843660d461872731ced4"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a61d4cbc42c67843660d461872731ced4.html#a61d4cbc42c67843660d461872731ced4">machine_precision</a> ()</td></tr>
<tr class="memdesc:a61d4cbc42c67843660d461872731ced4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the difference between 1.0 and the next value representable.  <a href="namespacestan_1_1math_a61d4cbc42c67843660d461872731ced4.html#a61d4cbc42c67843660d461872731ced4">More...</a><br /></td></tr>
<tr class="separator:a61d4cbc42c67843660d461872731ced4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadc90acda3e608b200fc3eb6188c486"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaadc90acda3e608b200fc3eb6188c486.html#aaadc90acda3e608b200fc3eb6188c486">log10</a> ()</td></tr>
<tr class="memdesc:aaadc90acda3e608b200fc3eb6188c486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of ten.  <a href="namespacestan_1_1math_aaadc90acda3e608b200fc3eb6188c486.html#aaadc90acda3e608b200fc3eb6188c486">More...</a><br /></td></tr>
<tr class="separator:aaadc90acda3e608b200fc3eb6188c486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60490076953c38e94eb3f414efea7689"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a60490076953c38e94eb3f414efea7689.html#a60490076953c38e94eb3f414efea7689">sqrt2</a> ()</td></tr>
<tr class="memdesc:a60490076953c38e94eb3f414efea7689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the square root of two.  <a href="namespacestan_1_1math_a60490076953c38e94eb3f414efea7689.html#a60490076953c38e94eb3f414efea7689">More...</a><br /></td></tr>
<tr class="separator:a60490076953c38e94eb3f414efea7689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae967a11a7998af790caf8432f9e1d13c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae967a11a7998af790caf8432f9e1d13c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae967a11a7998af790caf8432f9e1d13c.html#ae967a11a7998af790caf8432f9e1d13c">copysign</a> (const T &amp;x, const U &amp;y)</td></tr>
<tr class="memdesc:ae967a11a7998af790caf8432f9e1d13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negation of the first argument if the first and second argument have different signs, otherwise return a copy of the first argument.  <a href="namespacestan_1_1math_ae967a11a7998af790caf8432f9e1d13c.html#ae967a11a7998af790caf8432f9e1d13c">More...</a><br /></td></tr>
<tr class="separator:ae967a11a7998af790caf8432f9e1d13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41d7a0277d65992621cedd9147afb78"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae41d7a0277d65992621cedd9147afb78"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae41d7a0277d65992621cedd9147afb78.html#ae41d7a0277d65992621cedd9147afb78">copysign_non_zero</a> (const T &amp;x, const U &amp;y)</td></tr>
<tr class="memdesc:ae41d7a0277d65992621cedd9147afb78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negation of the first argument if the first and second arguments have different signs and the first argument is not zero, otherwise return a copy of the first argument.  <a href="namespacestan_1_1math_ae41d7a0277d65992621cedd9147afb78.html#ae41d7a0277d65992621cedd9147afb78">More...</a><br /></td></tr>
<tr class="separator:ae41d7a0277d65992621cedd9147afb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a0f05488724312e33e72f7d1f5386d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a76a0f05488724312e33e72f7d1f5386d"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a76a0f05488724312e33e72f7d1f5386d.html#a76a0f05488724312e33e72f7d1f5386d">copysign</a> (const std::complex&lt; T &gt; &amp;x, const std::complex&lt; U &gt; &amp;y)</td></tr>
<tr class="memdesc:a76a0f05488724312e33e72f7d1f5386d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the complex number composed of the real and complex parts with signs copied from the real and complex parts of the first arguments to the real and complex parts of the second.  <a href="namespacestan_1_1math_a76a0f05488724312e33e72f7d1f5386d.html#a76a0f05488724312e33e72f7d1f5386d">More...</a><br /></td></tr>
<tr class="separator:a76a0f05488724312e33e72f7d1f5386d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f066b8f71129a02b3b08c97c88f8710"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f066b8f71129a02b3b08c97c88f8710"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7f066b8f71129a02b3b08c97c88f8710.html#a7f066b8f71129a02b3b08c97c88f8710">corr_constrain</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a7f066b8f71129a02b3b08c97c88f8710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of transforming the specified scalar or container of values to have a valid correlation value between -1 and 1 (inclusive).  <a href="namespacestan_1_1math_a7f066b8f71129a02b3b08c97c88f8710.html#a7f066b8f71129a02b3b08c97c88f8710">More...</a><br /></td></tr>
<tr class="separator:a7f066b8f71129a02b3b08c97c88f8710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f09b7a228b46122223b3024f45f3318"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_lp &gt; </td></tr>
<tr class="memitem:a5f09b7a228b46122223b3024f45f3318"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5f09b7a228b46122223b3024f45f3318.html#a5f09b7a228b46122223b3024f45f3318">corr_constrain</a> (const T_x &amp;x, T_lp &amp;lp)</td></tr>
<tr class="memdesc:a5f09b7a228b46122223b3024f45f3318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of transforming the specified scalar or container of values to have a valid correlation value between -1 and 1 (inclusive).  <a href="namespacestan_1_1math_a5f09b7a228b46122223b3024f45f3318.html#a5f09b7a228b46122223b3024f45f3318">More...</a><br /></td></tr>
<tr class="separator:a5f09b7a228b46122223b3024f45f3318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54ab33cad65d7075ebab9a030faa0a6"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T_x , typename T_lp &gt; </td></tr>
<tr class="memitem:aa54ab33cad65d7075ebab9a030faa0a6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa54ab33cad65d7075ebab9a030faa0a6.html#aa54ab33cad65d7075ebab9a030faa0a6">corr_constrain</a> (const T_x &amp;x, T_lp &amp;lp)</td></tr>
<tr class="memdesc:aa54ab33cad65d7075ebab9a030faa0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of transforming the specified scalar or container of values to have a valid correlation value between -1 and 1 (inclusive).  <a href="namespacestan_1_1math_aa54ab33cad65d7075ebab9a030faa0a6.html#aa54ab33cad65d7075ebab9a030faa0a6">More...</a><br /></td></tr>
<tr class="separator:aa54ab33cad65d7075ebab9a030faa0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e9bd8757c3eff7092879c1ae68874a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0e9bd8757c3eff7092879c1ae68874a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab0e9bd8757c3eff7092879c1ae68874a.html#ab0e9bd8757c3eff7092879c1ae68874a">corr_free</a> (const T &amp;y)</td></tr>
<tr class="memdesc:ab0e9bd8757c3eff7092879c1ae68874a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unconstrained scalar that when transformed to a valid correlation produces the specified value.  <a href="namespacestan_1_1math_ab0e9bd8757c3eff7092879c1ae68874a.html#ab0e9bd8757c3eff7092879c1ae68874a">More...</a><br /></td></tr>
<tr class="separator:ab0e9bd8757c3eff7092879c1ae68874a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dd8a672ad075281dbee4d226ab8547"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_col_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a99dd8a672ad075281dbee4d226ab8547"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a99dd8a672ad075281dbee4d226ab8547.html#a99dd8a672ad075281dbee4d226ab8547">corr_matrix_constrain</a> (const T &amp;x, Eigen::Index k)</td></tr>
<tr class="memdesc:a99dd8a672ad075281dbee4d226ab8547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality derived from the specified vector of unconstrained values.  <a href="namespacestan_1_1math_a99dd8a672ad075281dbee4d226ab8547.html#a99dd8a672ad075281dbee4d226ab8547">More...</a><br /></td></tr>
<tr class="separator:a99dd8a672ad075281dbee4d226ab8547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e5f2c10bd3628e2f1acf15f14eddec"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_col_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a52e5f2c10bd3628e2f1acf15f14eddec"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a52e5f2c10bd3628e2f1acf15f14eddec.html#a52e5f2c10bd3628e2f1acf15f14eddec">corr_matrix_constrain</a> (const T &amp;x, Eigen::Index k, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a52e5f2c10bd3628e2f1acf15f14eddec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality derived from the specified vector of unconstrained values.  <a href="namespacestan_1_1math_a52e5f2c10bd3628e2f1acf15f14eddec.html#a52e5f2c10bd3628e2f1acf15f14eddec">More...</a><br /></td></tr>
<tr class="separator:a52e5f2c10bd3628e2f1acf15f14eddec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7a6b4c2fa77e5b291bce0761820a45"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , require_not_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3b7a6b4c2fa77e5b291bce0761820a45"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3b7a6b4c2fa77e5b291bce0761820a45.html#a3b7a6b4c2fa77e5b291bce0761820a45">corr_matrix_constrain</a> (const T &amp;x, Eigen::Index k, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a3b7a6b4c2fa77e5b291bce0761820a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality derived from the specified vector of unconstrained values.  <a href="namespacestan_1_1math_a3b7a6b4c2fa77e5b291bce0761820a45.html#a3b7a6b4c2fa77e5b291bce0761820a45">More...</a><br /></td></tr>
<tr class="separator:a3b7a6b4c2fa77e5b291bce0761820a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65529c4df91a6a16123009b658fd0de"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , require_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab65529c4df91a6a16123009b658fd0de"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab65529c4df91a6a16123009b658fd0de.html#ab65529c4df91a6a16123009b658fd0de">corr_matrix_constrain</a> (const T &amp;y, int K, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:ab65529c4df91a6a16123009b658fd0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality derived from the specified vector of unconstrained values.  <a href="namespacestan_1_1math_ab65529c4df91a6a16123009b658fd0de.html#ab65529c4df91a6a16123009b658fd0de">More...</a><br /></td></tr>
<tr class="separator:ab65529c4df91a6a16123009b658fd0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ef0fee1b0f3e603c59dabcc3b065b7"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a67ef0fee1b0f3e603c59dabcc3b065b7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a67ef0fee1b0f3e603c59dabcc3b065b7.html#a67ef0fee1b0f3e603c59dabcc3b065b7">corr_matrix_free</a> (const T &amp;y)</td></tr>
<tr class="memdesc:a67ef0fee1b0f3e603c59dabcc3b065b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of unconstrained partial correlations that define the specified correlation matrix when transformed.  <a href="namespacestan_1_1math_a67ef0fee1b0f3e603c59dabcc3b065b7.html#a67ef0fee1b0f3e603c59dabcc3b065b7">More...</a><br /></td></tr>
<tr class="separator:a67ef0fee1b0f3e603c59dabcc3b065b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436b4931d3327185d9bdc14f6322b2d3"><td class="memTemplParams" colspan="2">template&lt;typename T , require_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a436b4931d3327185d9bdc14f6322b2d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a436b4931d3327185d9bdc14f6322b2d3.html#a436b4931d3327185d9bdc14f6322b2d3">corr_matrix_free</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a436b4931d3327185d9bdc14f6322b2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_a67ef0fee1b0f3e603c59dabcc3b065b7.html#a67ef0fee1b0f3e603c59dabcc3b065b7" title="Return the vector of unconstrained partial correlations that define the specified correlation matrix ...">corr_matrix_free()</a></code> to untransform each matrix in a standard vector.  <a href="namespacestan_1_1math_a436b4931d3327185d9bdc14f6322b2d3.html#a436b4931d3327185d9bdc14f6322b2d3">More...</a><br /></td></tr>
<tr class="separator:a436b4931d3327185d9bdc14f6322b2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b43383a049e43a600f0cb77f6fc66b"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a62b43383a049e43a600f0cb77f6fc66b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a62b43383a049e43a600f0cb77f6fc66b.html#a62b43383a049e43a600f0cb77f6fc66b">cos</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a62b43383a049e43a600f0cb77f6fc66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ae6cb3a9041ae0b7855b398c3e11cda48.html#ae6cb3a9041ae0b7855b398c3e11cda48">cos()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_a62b43383a049e43a600f0cb77f6fc66b.html#a62b43383a049e43a600f0cb77f6fc66b">More...</a><br /></td></tr>
<tr class="separator:a62b43383a049e43a600f0cb77f6fc66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c03ba9024e3e7013d26a23a38157592"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1c03ba9024e3e7013d26a23a38157592"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c03ba9024e3e7013d26a23a38157592.html#a1c03ba9024e3e7013d26a23a38157592">cos</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a1c03ba9024e3e7013d26a23a38157592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_ae6cb3a9041ae0b7855b398c3e11cda48.html#ae6cb3a9041ae0b7855b398c3e11cda48">cos()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_a1c03ba9024e3e7013d26a23a38157592.html#a1c03ba9024e3e7013d26a23a38157592">More...</a><br /></td></tr>
<tr class="separator:a1c03ba9024e3e7013d26a23a38157592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2dab5c7ed983cb142f46bef6cb68f6"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aea2dab5c7ed983cb142f46bef6cb68f6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aea2dab5c7ed983cb142f46bef6cb68f6.html#aea2dab5c7ed983cb142f46bef6cb68f6">cosh</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:aea2dab5c7ed983cb142f46bef6cb68f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aee4fa5213b343a52756c138107ac180b.html#aee4fa5213b343a52756c138107ac180b">cosh()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_aea2dab5c7ed983cb142f46bef6cb68f6.html#aea2dab5c7ed983cb142f46bef6cb68f6">More...</a><br /></td></tr>
<tr class="separator:aea2dab5c7ed983cb142f46bef6cb68f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6295934fc1ca551047eb78d1845d685"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae6295934fc1ca551047eb78d1845d685"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae6295934fc1ca551047eb78d1845d685.html#ae6295934fc1ca551047eb78d1845d685">cosh</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ae6295934fc1ca551047eb78d1845d685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_aee4fa5213b343a52756c138107ac180b.html#aee4fa5213b343a52756c138107ac180b">cosh()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_ae6295934fc1ca551047eb78d1845d685.html#ae6295934fc1ca551047eb78d1845d685">More...</a><br /></td></tr>
<tr class="separator:ae6295934fc1ca551047eb78d1845d685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15020fc6e0161b8912611f2b895a7456"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , typename T_l &gt; </td></tr>
<tr class="memitem:a15020fc6e0161b8912611f2b895a7456"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_sigma, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a15020fc6e0161b8912611f2b895a7456.html#a15020fc6e0161b8912611f2b895a7456">cov_exp_quad</a> (const std::vector&lt; T_x &gt; &amp;x, const T_sigma &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="separator:a15020fc6e0161b8912611f2b895a7456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a441278631981ed6a09b8db4b1698f"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , typename T_l &gt; </td></tr>
<tr class="memitem:ac2a441278631981ed6a09b8db4b1698f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_sigma, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac2a441278631981ed6a09b8db4b1698f.html#ac2a441278631981ed6a09b8db4b1698f">cov_exp_quad</a> (const std::vector&lt; T_x &gt; &amp;x, const T_sigma &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="separator:ac2a441278631981ed6a09b8db4b1698f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7367a3af9019acc0d5414ce2c1d04bb"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_sigma , typename T_l &gt; </td></tr>
<tr class="memitem:ac7367a3af9019acc0d5414ce2c1d04bb"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_sigma, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac7367a3af9019acc0d5414ce2c1d04bb.html#ac7367a3af9019acc0d5414ce2c1d04bb">cov_exp_quad</a> (const std::vector&lt; T_x1 &gt; &amp;x1, const std::vector&lt; T_x2 &gt; &amp;x2, const T_sigma &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="separator:ac7367a3af9019acc0d5414ce2c1d04bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2328f2173841e81ea1562fa4d7251398"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_sigma , typename T_l &gt; </td></tr>
<tr class="memitem:a2328f2173841e81ea1562fa4d7251398"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_sigma, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2328f2173841e81ea1562fa4d7251398.html#a2328f2173841e81ea1562fa4d7251398">cov_exp_quad</a> (const std::vector&lt; T_x1 &gt; &amp;x1, const std::vector&lt; T_x2 &gt; &amp;x2, const T_sigma &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="separator:a2328f2173841e81ea1562fa4d7251398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3687019296bab7fa7e86e7346559e960"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_col_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3687019296bab7fa7e86e7346559e960"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3687019296bab7fa7e86e7346559e960.html#a3687019296bab7fa7e86e7346559e960">cov_matrix_constrain</a> (const T &amp;x, Eigen::Index K)</td></tr>
<tr class="memdesc:a3687019296bab7fa7e86e7346559e960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the symmetric, positive-definite matrix of dimensions K by K resulting from transforming the specified finite vector of size K plus (K choose 2).  <a href="namespacestan_1_1math_a3687019296bab7fa7e86e7346559e960.html#a3687019296bab7fa7e86e7346559e960">More...</a><br /></td></tr>
<tr class="separator:a3687019296bab7fa7e86e7346559e960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0975d1fac8d1a1d23284e9981108b4"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_col_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8b0975d1fac8d1a1d23284e9981108b4"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8b0975d1fac8d1a1d23284e9981108b4.html#a8b0975d1fac8d1a1d23284e9981108b4">cov_matrix_constrain</a> (const T &amp;x, Eigen::Index K, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a8b0975d1fac8d1a1d23284e9981108b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the symmetric, positive-definite matrix of dimensions K by K resulting from transforming the specified finite vector of size K plus (K choose 2).  <a href="namespacestan_1_1math_a8b0975d1fac8d1a1d23284e9981108b4.html#a8b0975d1fac8d1a1d23284e9981108b4">More...</a><br /></td></tr>
<tr class="separator:a8b0975d1fac8d1a1d23284e9981108b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55def76bb303b2b7777387ecd821d2c7"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , require_not_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a55def76bb303b2b7777387ecd821d2c7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a55def76bb303b2b7777387ecd821d2c7.html#a55def76bb303b2b7777387ecd821d2c7">cov_matrix_constrain</a> (const T &amp;x, Eigen::Index K, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a55def76bb303b2b7777387ecd821d2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the symmetric, positive-definite matrix of dimensions K by K resulting from transforming the specified finite vector of size K plus (K choose 2).  <a href="namespacestan_1_1math_a55def76bb303b2b7777387ecd821d2c7.html#a55def76bb303b2b7777387ecd821d2c7">More...</a><br /></td></tr>
<tr class="separator:a55def76bb303b2b7777387ecd821d2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bf3d40bcb8f2f58bce0bf73d3809c6"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a81bf3d40bcb8f2f58bce0bf73d3809c6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a81bf3d40bcb8f2f58bce0bf73d3809c6.html#a81bf3d40bcb8f2f58bce0bf73d3809c6">cov_matrix_constrain_lkj</a> (const T &amp;x, size_t k)</td></tr>
<tr class="memdesc:a81bf3d40bcb8f2f58bce0bf73d3809c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the covariance matrix of the specified dimensionality derived from constraining the specified vector of unconstrained values.  <a href="namespacestan_1_1math_a81bf3d40bcb8f2f58bce0bf73d3809c6.html#a81bf3d40bcb8f2f58bce0bf73d3809c6">More...</a><br /></td></tr>
<tr class="separator:a81bf3d40bcb8f2f58bce0bf73d3809c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bde4207bc2f2db4fede562ffaab7bae"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6bde4207bc2f2db4fede562ffaab7bae"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6bde4207bc2f2db4fede562ffaab7bae.html#a6bde4207bc2f2db4fede562ffaab7bae">cov_matrix_constrain_lkj</a> (const T &amp;x, size_t k, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a6bde4207bc2f2db4fede562ffaab7bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the covariance matrix of the specified dimensionality derived from constraining the specified vector of unconstrained values and increment the specified log probability reference with the log absolute Jacobian determinant.  <a href="namespacestan_1_1math_a6bde4207bc2f2db4fede562ffaab7bae.html#a6bde4207bc2f2db4fede562ffaab7bae">More...</a><br /></td></tr>
<tr class="separator:a6bde4207bc2f2db4fede562ffaab7bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbca43eddb9d9de0e15d91633b4d2a9"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , require_not_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afdbca43eddb9d9de0e15d91633b4d2a9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afdbca43eddb9d9de0e15d91633b4d2a9.html#afdbca43eddb9d9de0e15d91633b4d2a9">cov_matrix_constrain_lkj</a> (const T &amp;x, size_t k, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:afdbca43eddb9d9de0e15d91633b4d2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the covariance matrix of the specified dimensionality derived from constraining the specified vector of unconstrained values.  <a href="namespacestan_1_1math_afdbca43eddb9d9de0e15d91633b4d2a9.html#afdbca43eddb9d9de0e15d91633b4d2a9">More...</a><br /></td></tr>
<tr class="separator:afdbca43eddb9d9de0e15d91633b4d2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9727dd3a6f6e66df9721fc743c01a90"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac9727dd3a6f6e66df9721fc743c01a90"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac9727dd3a6f6e66df9721fc743c01a90.html#ac9727dd3a6f6e66df9721fc743c01a90">cov_matrix_free</a> (const T &amp;y)</td></tr>
<tr class="memdesc:ac9727dd3a6f6e66df9721fc743c01a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">The covariance matrix derived from the symmetric view of the lower-triangular view of the K by K specified matrix is freed to return a vector of size K + (K choose 2).  <a href="namespacestan_1_1math_ac9727dd3a6f6e66df9721fc743c01a90.html#ac9727dd3a6f6e66df9721fc743c01a90">More...</a><br /></td></tr>
<tr class="separator:ac9727dd3a6f6e66df9721fc743c01a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4663b97f2144560c7557a8b21c26bb"><td class="memTemplParams" colspan="2">template&lt;typename T , require_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afa4663b97f2144560c7557a8b21c26bb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afa4663b97f2144560c7557a8b21c26bb.html#afa4663b97f2144560c7557a8b21c26bb">cov_matrix_free</a> (const T &amp;x)</td></tr>
<tr class="memdesc:afa4663b97f2144560c7557a8b21c26bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_ac9727dd3a6f6e66df9721fc743c01a90.html#ac9727dd3a6f6e66df9721fc743c01a90" title="The covariance matrix derived from the symmetric view of the lower-triangular view of the K by K spec...">cov_matrix_free()</a></code> to untransform each matrix in a standard vector.  <a href="namespacestan_1_1math_afa4663b97f2144560c7557a8b21c26bb.html#afa4663b97f2144560c7557a8b21c26bb">More...</a><br /></td></tr>
<tr class="separator:afa4663b97f2144560c7557a8b21c26bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5832b37bae28aaaf64c805f2968f1f5"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af5832b37bae28aaaf64c805f2968f1f5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af5832b37bae28aaaf64c805f2968f1f5.html#af5832b37bae28aaaf64c805f2968f1f5">cov_matrix_free_lkj</a> (const T &amp;y)</td></tr>
<tr class="memdesc:af5832b37bae28aaaf64c805f2968f1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of unconstrained partial correlations and deviations that transform to the specified covariance matrix.  <a href="namespacestan_1_1math_af5832b37bae28aaaf64c805f2968f1f5.html#af5832b37bae28aaaf64c805f2968f1f5">More...</a><br /></td></tr>
<tr class="separator:af5832b37bae28aaaf64c805f2968f1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7cdf85a78d99a3f52955b35fe78d24"><td class="memTemplParams" colspan="2">template&lt;typename T , require_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acd7cdf85a78d99a3f52955b35fe78d24"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acd7cdf85a78d99a3f52955b35fe78d24.html#acd7cdf85a78d99a3f52955b35fe78d24">cov_matrix_free_lkj</a> (const T &amp;x)</td></tr>
<tr class="memdesc:acd7cdf85a78d99a3f52955b35fe78d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_af5832b37bae28aaaf64c805f2968f1f5.html#af5832b37bae28aaaf64c805f2968f1f5" title="Return the vector of unconstrained partial correlations and deviations that transform to the specifie...">cov_matrix_free_lkj()</a></code> to untransform each matrix in a standard vector.  <a href="namespacestan_1_1math_acd7cdf85a78d99a3f52955b35fe78d24.html#acd7cdf85a78d99a3f52955b35fe78d24">More...</a><br /></td></tr>
<tr class="separator:acd7cdf85a78d99a3f52955b35fe78d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b31a929a9bd689de9060838976303b"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a57b31a929a9bd689de9060838976303b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a57b31a929a9bd689de9060838976303b.html#a57b31a929a9bd689de9060838976303b">crossprod</a> (const EigMat &amp;M)</td></tr>
<tr class="memdesc:a57b31a929a9bd689de9060838976303b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of pre-multiplying a matrix by its own transpose.  <a href="namespacestan_1_1math_a57b31a929a9bd689de9060838976303b.html#a57b31a929a9bd689de9060838976303b">More...</a><br /></td></tr>
<tr class="separator:a57b31a929a9bd689de9060838976303b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga989f196379081c782be06612b5731dcb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga989f196379081c782be06612b5731dcb"><td class="memTemplItemLeft" align="right" valign="top">const std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csr__format_ga989f196379081c782be06612b5731dcb.html#ga989f196379081c782be06612b5731dcb">csr_extract_u</a> (const Eigen::SparseMatrix&lt; T, Eigen::RowMajor &gt; &amp;A)</td></tr>
<tr class="memdesc:ga989f196379081c782be06612b5731dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the NZE index for each entry from a sparse matrix.  <a href="group__csr__format_ga989f196379081c782be06612b5731dcb.html#ga989f196379081c782be06612b5731dcb">More...</a><br /></td></tr>
<tr class="separator:ga989f196379081c782be06612b5731dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75392a6a26056523defdd14f175797eb"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_dense_base_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga75392a6a26056523defdd14f175797eb"><td class="memTemplItemLeft" align="right" valign="top">const std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csr__format_ga75392a6a26056523defdd14f175797eb.html#ga75392a6a26056523defdd14f175797eb">csr_extract_u</a> (const T &amp;A)</td></tr>
<tr class="memdesc:ga75392a6a26056523defdd14f175797eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the NZE index for each entry from a sparse matrix.  <a href="group__csr__format_ga75392a6a26056523defdd14f175797eb.html#ga75392a6a26056523defdd14f175797eb">More...</a><br /></td></tr>
<tr class="separator:ga75392a6a26056523defdd14f175797eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade78a62d0fd64b0d5da2370256cbb6e0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gade78a62d0fd64b0d5da2370256cbb6e0"><td class="memTemplItemLeft" align="right" valign="top">const std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csr__format_gade78a62d0fd64b0d5da2370256cbb6e0.html#gade78a62d0fd64b0d5da2370256cbb6e0">csr_extract_v</a> (const Eigen::SparseMatrix&lt; T, Eigen::RowMajor &gt; &amp;A)</td></tr>
<tr class="memdesc:gade78a62d0fd64b0d5da2370256cbb6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the column indexes for non-zero value from a sparse matrix.  <a href="group__csr__format_gade78a62d0fd64b0d5da2370256cbb6e0.html#gade78a62d0fd64b0d5da2370256cbb6e0">More...</a><br /></td></tr>
<tr class="separator:gade78a62d0fd64b0d5da2370256cbb6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2196016d940bde40e3883d260f96f3f"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_dense_base_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab2196016d940bde40e3883d260f96f3f"><td class="memTemplItemLeft" align="right" valign="top">const std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csr__format_gab2196016d940bde40e3883d260f96f3f.html#gab2196016d940bde40e3883d260f96f3f">csr_extract_v</a> (const T &amp;A)</td></tr>
<tr class="memdesc:gab2196016d940bde40e3883d260f96f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the column indexes for non-zero values from a dense matrix by converting to sparse and calling the sparse matrix extractor.  <a href="group__csr__format_gab2196016d940bde40e3883d260f96f3f.html#gab2196016d940bde40e3883d260f96f3f">More...</a><br /></td></tr>
<tr class="separator:gab2196016d940bde40e3883d260f96f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae45bfd671760b4f442d272456b2ae01c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae45bfd671760b4f442d272456b2ae01c"><td class="memTemplItemLeft" align="right" valign="top">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csr__format_gae45bfd671760b4f442d272456b2ae01c.html#gae45bfd671760b4f442d272456b2ae01c">csr_extract_w</a> (const Eigen::SparseMatrix&lt; T, Eigen::RowMajor &gt; &amp;A)</td></tr>
<tr class="separator:gae45bfd671760b4f442d272456b2ae01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga618592da2a6ee94c693d1c2bf0d7cfe0"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_dense_base_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga618592da2a6ee94c693d1c2bf0d7cfe0"><td class="memTemplItemLeft" align="right" valign="top">const Eigen::Matrix&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csr__format_ga618592da2a6ee94c693d1c2bf0d7cfe0.html#ga618592da2a6ee94c693d1c2bf0d7cfe0">csr_extract_w</a> (const T &amp;A)</td></tr>
<tr class="separator:ga618592da2a6ee94c693d1c2bf0d7cfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744e6c162ae7f13e4ae1f02890a96ccd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_not_rev_matrix_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a744e6c162ae7f13e4ae1f02890a96ccd"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a744e6c162ae7f13e4ae1f02890a96ccd.html#a744e6c162ae7f13e4ae1f02890a96ccd">csr_matrix_times_vector</a> (int m, int n, const T1 &amp;w, const std::vector&lt; int &gt; &amp;v, const std::vector&lt; int &gt; &amp;u, const T2 &amp;b)</td></tr>
<tr class="separator:a744e6c162ae7f13e4ae1f02890a96ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3639c2135cc7e4c3f67e145609d346b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3639c2135cc7e4c3f67e145609d346b7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csr__format_ga3639c2135cc7e4c3f67e145609d346b7.html#ga3639c2135cc7e4c3f67e145609d346b7">csr_to_dense_matrix</a> (int m, int n, const T &amp;w, const std::vector&lt; int &gt; &amp;v, const std::vector&lt; int &gt; &amp;u)</td></tr>
<tr class="memdesc:ga3639c2135cc7e4c3f67e145609d346b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a dense <a class="el" href="namespace_eigen.html">Eigen</a> matrix from the CSR format components.  <a href="group__csr__format_ga3639c2135cc7e4c3f67e145609d346b7.html#ga3639c2135cc7e4c3f67e145609d346b7">More...</a><br /></td></tr>
<tr class="separator:ga3639c2135cc7e4c3f67e145609d346b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e1bf7c971d0b9eb931654ea309a2bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__csr__format_gaf4e1bf7c971d0b9eb931654ea309a2bf.html#gaf4e1bf7c971d0b9eb931654ea309a2bf">csr_u_to_z</a> (const std::vector&lt; int &gt; &amp;u, int i)</td></tr>
<tr class="memdesc:gaf4e1bf7c971d0b9eb931654ea309a2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the z vector computed from the specified u vector at the index for the z vector.  <a href="group__csr__format_gaf4e1bf7c971d0b9eb931654ea309a2bf.html#gaf4e1bf7c971d0b9eb931654ea309a2bf">More...</a><br /></td></tr>
<tr class="separator:gaf4e1bf7c971d0b9eb931654ea309a2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7340f6be8ae1e121c6d854005560fef5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7340f6be8ae1e121c6d854005560fef5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7340f6be8ae1e121c6d854005560fef5.html#a7340f6be8ae1e121c6d854005560fef5">cumulative_sum</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a7340f6be8ae1e121c6d854005560fef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cumulative sum of the specified vector.  <a href="namespacestan_1_1math_a7340f6be8ae1e121c6d854005560fef5.html#a7340f6be8ae1e121c6d854005560fef5">More...</a><br /></td></tr>
<tr class="separator:a7340f6be8ae1e121c6d854005560fef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6268ac0dc45da2fc6db09f16a193010"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_eigen_vector_t&lt; EigVec &gt; *  = nullptr, require_not_st_var&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab6268ac0dc45da2fc6db09f16a193010"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab6268ac0dc45da2fc6db09f16a193010.html#ab6268ac0dc45da2fc6db09f16a193010">cumulative_sum</a> (const EigVec &amp;m)</td></tr>
<tr class="memdesc:ab6268ac0dc45da2fc6db09f16a193010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cumulative sum of the specified vector.  <a href="namespacestan_1_1math_ab6268ac0dc45da2fc6db09f16a193010.html#ab6268ac0dc45da2fc6db09f16a193010">More...</a><br /></td></tr>
<tr class="separator:ab6268ac0dc45da2fc6db09f16a193010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f783ba0ba9d5c4c6e592340545a1a3"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vt&lt; std::is_arithmetic, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a30f783ba0ba9d5c4c6e592340545a1a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a30f783ba0ba9d5c4c6e592340545a1a3.html#a30f783ba0ba9d5c4c6e592340545a1a3">determinant</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a30f783ba0ba9d5c4c6e592340545a1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the determinant of the specified square matrix.  <a href="namespacestan_1_1math_a30f783ba0ba9d5c4c6e592340545a1a3.html#a30f783ba0ba9d5c4c6e592340545a1a3">More...</a><br /></td></tr>
<tr class="separator:a30f783ba0ba9d5c4c6e592340545a1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5531faea14b8e1030a109ded802237"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_eigen_vector_t&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aec5531faea14b8e1030a109ded802237"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigVec &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aec5531faea14b8e1030a109ded802237.html#aec5531faea14b8e1030a109ded802237">diag_matrix</a> (const EigVec &amp;v)</td></tr>
<tr class="memdesc:aec5531faea14b8e1030a109ded802237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a square diagonal matrix with the specified vector of coefficients as the diagonal values.  <a href="namespacestan_1_1math_aec5531faea14b8e1030a109ded802237.html#aec5531faea14b8e1030a109ded802237">More...</a><br /></td></tr>
<tr class="separator:aec5531faea14b8e1030a109ded802237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ef527eaeba71a77857bd000a9afa91"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_eigen_t&lt; T1 &gt; *  = nullptr, require_eigen_vector_t&lt; T2 &gt; *  = nullptr, require_all_not_st_var&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a23ef527eaeba71a77857bd000a9afa91"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a23ef527eaeba71a77857bd000a9afa91.html#a23ef527eaeba71a77857bd000a9afa91">diag_post_multiply</a> (const T1 &amp;m1, const T2 &amp;m2)</td></tr>
<tr class="memdesc:a23ef527eaeba71a77857bd000a9afa91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the matrix and the diagonal matrix formed from the vector or row_vector.  <a href="namespacestan_1_1math_a23ef527eaeba71a77857bd000a9afa91.html#a23ef527eaeba71a77857bd000a9afa91">More...</a><br /></td></tr>
<tr class="separator:a23ef527eaeba71a77857bd000a9afa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e95b1d74d4bdd6f8818769c0cdb6aa0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_eigen_vector_t&lt; T1 &gt; *  = nullptr, require_eigen_t&lt; T2 &gt; *  = nullptr, require_all_not_st_var&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0e95b1d74d4bdd6f8818769c0cdb6aa0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0e95b1d74d4bdd6f8818769c0cdb6aa0.html#a0e95b1d74d4bdd6f8818769c0cdb6aa0">diag_pre_multiply</a> (const T1 &amp;m1, const T2 &amp;m2)</td></tr>
<tr class="memdesc:a0e95b1d74d4bdd6f8818769c0cdb6aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the diagonal matrix formed from the vector or row_vector and a matrix.  <a href="namespacestan_1_1math_a0e95b1d74d4bdd6f8818769c0cdb6aa0.html#a0e95b1d74d4bdd6f8818769c0cdb6aa0">More...</a><br /></td></tr>
<tr class="separator:a0e95b1d74d4bdd6f8818769c0cdb6aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53985a3f02de2d737ce7dec24570b2e0"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a53985a3f02de2d737ce7dec24570b2e0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a53985a3f02de2d737ce7dec24570b2e0.html#a53985a3f02de2d737ce7dec24570b2e0">diagonal</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a53985a3f02de2d737ce7dec24570b2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column vector of the diagonal elements of the specified matrix.  <a href="namespacestan_1_1math_a53985a3f02de2d737ce7dec24570b2e0.html#a53985a3f02de2d737ce7dec24570b2e0">More...</a><br /></td></tr>
<tr class="separator:a53985a3f02de2d737ce7dec24570b2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb54ce92709046c6d168e851d2481c7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5eb54ce92709046c6d168e851d2481c7.html#a5eb54ce92709046c6d168e851d2481c7">digamma</a> (double x)</td></tr>
<tr class="memdesc:a5eb54ce92709046c6d168e851d2481c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the derivative of the log gamma function at the specified value.  <a href="namespacestan_1_1math_a5eb54ce92709046c6d168e851d2481c7.html#a5eb54ce92709046c6d168e851d2481c7">More...</a><br /></td></tr>
<tr class="separator:a5eb54ce92709046c6d168e851d2481c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1eee5e3089a975168788ce273b9d012"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr, require_not_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad1eee5e3089a975168788ce273b9d012"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad1eee5e3089a975168788ce273b9d012.html#ad1eee5e3089a975168788ce273b9d012">digamma</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ad1eee5e3089a975168788ce273b9d012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a69702aaa101bf602072fa7bf5fccb48a.html#a69702aaa101bf602072fa7bf5fccb48a" title="Return the derivative of the log gamma function at the specified argument.">digamma()</a>.  <a href="namespacestan_1_1math_ad1eee5e3089a975168788ce273b9d012.html#ad1eee5e3089a975168788ce273b9d012">More...</a><br /></td></tr>
<tr class="separator:ad1eee5e3089a975168788ce273b9d012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb33bfd47d4df471d4abad9b090fc79a"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acb33bfd47d4df471d4abad9b090fc79a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acb33bfd47d4df471d4abad9b090fc79a.html#acb33bfd47d4df471d4abad9b090fc79a">dims</a> (const T &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="memdesc:acb33bfd47d4df471d4abad9b090fc79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes dimensions of given argument into given result vector.  <a href="namespacestan_1_1math_acb33bfd47d4df471d4abad9b090fc79a.html#acb33bfd47d4df471d4abad9b090fc79a">More...</a><br /></td></tr>
<tr class="separator:acb33bfd47d4df471d4abad9b090fc79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0650159b7274f5001be98ff417ee9de"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc &gt; </td></tr>
<tr class="memitem:ac0650159b7274f5001be98ff417ee9de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac0650159b7274f5001be98ff417ee9de.html#ac0650159b7274f5001be98ff417ee9de">dims</a> (const std::vector&lt; T, Alloc &gt; &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="memdesc:ac0650159b7274f5001be98ff417ee9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes dimensions of given argument into given result vector.  <a href="namespacestan_1_1math_ac0650159b7274f5001be98ff417ee9de.html#ac0650159b7274f5001be98ff417ee9de">More...</a><br /></td></tr>
<tr class="separator:ac0650159b7274f5001be98ff417ee9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33777ee768c7032331ca8b92e5323384"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a33777ee768c7032331ca8b92e5323384"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a33777ee768c7032331ca8b92e5323384.html#a33777ee768c7032331ca8b92e5323384">dims</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a33777ee768c7032331ca8b92e5323384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines dimensions of an argument.  <a href="namespacestan_1_1math_a33777ee768c7032331ca8b92e5323384.html#a33777ee768c7032331ca8b92e5323384">More...</a><br /></td></tr>
<tr class="separator:a33777ee768c7032331ca8b92e5323384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8236d7207fe3b5c29d0520c861b22dc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af8236d7207fe3b5c29d0520c861b22dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af8236d7207fe3b5c29d0520c861b22dc.html#af8236d7207fe3b5c29d0520c861b22dc">distance</a> (const T1 &amp;x1, const T2 &amp;x2)</td></tr>
<tr class="memdesc:af8236d7207fe3b5c29d0520c861b22dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between two scalars.  <a href="namespacestan_1_1math_af8236d7207fe3b5c29d0520c861b22dc.html#af8236d7207fe3b5c29d0520c861b22dc">More...</a><br /></td></tr>
<tr class="separator:af8236d7207fe3b5c29d0520c861b22dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55caee304da6db02f71f6c057c0d20d7"><td class="memTemplParams" colspan="2">template&lt;typename Scal1 , typename Scal2 , require_all_stan_scalar_t&lt; Scal1, Scal2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a55caee304da6db02f71f6c057c0d20d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Scal1, Scal2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a55caee304da6db02f71f6c057c0d20d7.html#a55caee304da6db02f71f6c057c0d20d7">divide</a> (const Scal1 &amp;x, const Scal2 &amp;y)</td></tr>
<tr class="memdesc:a55caee304da6db02f71f6c057c0d20d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the division of the first scalar by the second scalar.  <a href="namespacestan_1_1math_a55caee304da6db02f71f6c057c0d20d7.html#a55caee304da6db02f71f6c057c0d20d7">More...</a><br /></td></tr>
<tr class="separator:a55caee304da6db02f71f6c057c0d20d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1e1b387939d34b8dc29e6d062530e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1d1e1b387939d34b8dc29e6d062530e8.html#a1d1e1b387939d34b8dc29e6d062530e8">divide</a> (int x, int y)</td></tr>
<tr class="separator:a1d1e1b387939d34b8dc29e6d062530e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb611f1fe008351a5e57bd8bbd7e4187"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_eigen_t&lt; T1, T2 &gt; *  = nullptr, require_all_not_st_var&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adb611f1fe008351a5e57bd8bbd7e4187"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adb611f1fe008351a5e57bd8bbd7e4187.html#adb611f1fe008351a5e57bd8bbd7e4187">divide</a> (const T1 &amp;m, const T2 &amp;c)</td></tr>
<tr class="memdesc:adb611f1fe008351a5e57bd8bbd7e4187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return matrix divided by scalar.  <a href="namespacestan_1_1math_adb611f1fe008351a5e57bd8bbd7e4187.html#adb611f1fe008351a5e57bd8bbd7e4187">More...</a><br /></td></tr>
<tr class="separator:adb611f1fe008351a5e57bd8bbd7e4187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d516f634eca86257e2dc3a62e037837"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_v &gt; </td></tr>
<tr class="memitem:a5d516f634eca86257e2dc3a62e037837"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_v, double &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5d516f634eca86257e2dc3a62e037837.html#a5d516f634eca86257e2dc3a62e037837">divide_columns</a> (const std::vector&lt; Eigen::Matrix&lt; T_x, Eigen::Dynamic, 1 &gt;&gt; &amp;x, const std::vector&lt; T_v &gt; &amp;vec)</td></tr>
<tr class="memdesc:a5d516f634eca86257e2dc3a62e037837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes Stan data type vector[n] x[D] and divides column vector in x element-wise by the values in vec.  <a href="namespacestan_1_1math_a5d516f634eca86257e2dc3a62e037837.html#a5d516f634eca86257e2dc3a62e037837">More...</a><br /></td></tr>
<tr class="separator:a5d516f634eca86257e2dc3a62e037837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3b73319bd8df9dad1d3902997d8e89"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afd3b73319bd8df9dad1d3902997d8e89.html#afd3b73319bd8df9dad1d3902997d8e89">dot</a> (const std::vector&lt; double &gt; &amp;x, const std::vector&lt; double &gt; &amp;y)</td></tr>
<tr class="separator:afd3b73319bd8df9dad1d3902997d8e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de31eb86abc14bc55329668faef12d9"><td class="memTemplParams" colspan="2">template&lt;typename Vec1 , typename Vec2 , require_all_eigen_vector_t&lt; Vec1, Vec2 &gt; *  = nullptr, require_not_var_t&lt; return_type_t&lt; Vec1, Vec2 &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4de31eb86abc14bc55329668faef12d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4de31eb86abc14bc55329668faef12d9.html#a4de31eb86abc14bc55329668faef12d9">dot_product</a> (const Vec1 &amp;v1, const Vec2 &amp;v2)</td></tr>
<tr class="memdesc:a4de31eb86abc14bc55329668faef12d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified vectors.  <a href="namespacestan_1_1math_a4de31eb86abc14bc55329668faef12d9.html#a4de31eb86abc14bc55329668faef12d9">More...</a><br /></td></tr>
<tr class="separator:a4de31eb86abc14bc55329668faef12d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0847bcd2ea9599de5e091222e8aea48a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 , require_all_stan_scalar_t&lt; Scalar1, Scalar2 &gt; *  = nullptr, require_all_not_var_t&lt; Scalar1, Scalar2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0847bcd2ea9599de5e091222e8aea48a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0847bcd2ea9599de5e091222e8aea48a.html#a0847bcd2ea9599de5e091222e8aea48a">dot_product</a> (const Scalar1 *v1, const Scalar2 *v2, size_t length)</td></tr>
<tr class="memdesc:a0847bcd2ea9599de5e091222e8aea48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified arrays.  <a href="namespacestan_1_1math_a0847bcd2ea9599de5e091222e8aea48a.html#a0847bcd2ea9599de5e091222e8aea48a">More...</a><br /></td></tr>
<tr class="separator:a0847bcd2ea9599de5e091222e8aea48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7000c2cac097623640ea35cdba21f8"><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 , typename Alloc1 , typename Alloc2 , require_all_stan_scalar_t&lt; Scalar1, Scalar2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aed7000c2cac097623640ea35cdba21f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Scalar1, Scalar2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aed7000c2cac097623640ea35cdba21f8.html#aed7000c2cac097623640ea35cdba21f8">dot_product</a> (const std::vector&lt; Scalar1, Alloc1 &gt; &amp;v1, const std::vector&lt; Scalar2, Alloc2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:aed7000c2cac097623640ea35cdba21f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified arrays.  <a href="namespacestan_1_1math_aed7000c2cac097623640ea35cdba21f8.html#aed7000c2cac097623640ea35cdba21f8">More...</a><br /></td></tr>
<tr class="separator:aed7000c2cac097623640ea35cdba21f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6a4ef7c701db7984297d153580c8d4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8a6a4ef7c701db7984297d153580c8d4.html#a8a6a4ef7c701db7984297d153580c8d4">dot_self</a> (const std::vector&lt; double &gt; &amp;x)</td></tr>
<tr class="separator:a8a6a4ef7c701db7984297d153580c8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a45136ec1d7bc53efc82aacaed5888"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr, require_not_eigen_vt&lt; is_var, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac9a45136ec1d7bc53efc82aacaed5888"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac9a45136ec1d7bc53efc82aacaed5888.html#ac9a45136ec1d7bc53efc82aacaed5888">dot_self</a> (const T &amp;v)</td></tr>
<tr class="memdesc:ac9a45136ec1d7bc53efc82aacaed5888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns squared norm of a vector or matrix.  <a href="namespacestan_1_1math_ac9a45136ec1d7bc53efc82aacaed5888.html#ac9a45136ec1d7bc53efc82aacaed5888">More...</a><br /></td></tr>
<tr class="separator:ac9a45136ec1d7bc53efc82aacaed5888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455d128c299b5d3f05a2059bfea4e4c8"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_any_eigen_t&lt; T_a, T_b &gt; *  = nullptr, require_any_st_autodiff&lt; T_a, T_b &gt; *  = nullptr, require_not_st_same&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a455d128c299b5d3f05a2059bfea4e4c8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a455d128c299b5d3f05a2059bfea4e4c8.html#a455d128c299b5d3f05a2059bfea4e4c8">operator&lt;</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:a455d128c299b5d3f05a2059bfea4e4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285412b12de2a0dbfca8b55769dd609f"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_any_eigen_t&lt; T_a, T_b &gt; *  = nullptr, require_any_st_autodiff&lt; T_a, T_b &gt; *  = nullptr, require_not_st_same&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a285412b12de2a0dbfca8b55769dd609f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a285412b12de2a0dbfca8b55769dd609f.html#a285412b12de2a0dbfca8b55769dd609f">operator&lt;=</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:a285412b12de2a0dbfca8b55769dd609f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bf925369261729a0aa9cfc0188c766"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_any_eigen_t&lt; T_a, T_b &gt; *  = nullptr, require_any_st_autodiff&lt; T_a, T_b &gt; *  = nullptr, require_not_st_same&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae1bf925369261729a0aa9cfc0188c766"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae1bf925369261729a0aa9cfc0188c766.html#ae1bf925369261729a0aa9cfc0188c766">operator&gt;</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:ae1bf925369261729a0aa9cfc0188c766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5be855ba2abf476e627a889d1780979"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_any_eigen_t&lt; T_a, T_b &gt; *  = nullptr, require_any_st_autodiff&lt; T_a, T_b &gt; *  = nullptr, require_not_st_same&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac5be855ba2abf476e627a889d1780979"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac5be855ba2abf476e627a889d1780979.html#ac5be855ba2abf476e627a889d1780979">operator&gt;=</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:ac5be855ba2abf476e627a889d1780979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315cb73b27c5043e63957dca3e98dfab"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_any_eigen_t&lt; T_a, T_b &gt; *  = nullptr, require_any_st_autodiff&lt; T_a, T_b &gt; *  = nullptr, require_not_st_same&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a315cb73b27c5043e63957dca3e98dfab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a315cb73b27c5043e63957dca3e98dfab.html#a315cb73b27c5043e63957dca3e98dfab">operator==</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:a315cb73b27c5043e63957dca3e98dfab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e8d772959e81830b0314afff76fbcb"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_any_eigen_t&lt; T_a, T_b &gt; *  = nullptr, require_any_st_autodiff&lt; T_a, T_b &gt; *  = nullptr, require_not_st_same&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a52e8d772959e81830b0314afff76fbcb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a52e8d772959e81830b0314afff76fbcb.html#a52e8d772959e81830b0314afff76fbcb">operator!=</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:a52e8d772959e81830b0314afff76fbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2401d26ca0cb0e1cdd852a53cf845668"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_matrix_dynamic_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2401d26ca0cb0e1cdd852a53cf845668"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2401d26ca0cb0e1cdd852a53cf845668.html#a2401d26ca0cb0e1cdd852a53cf845668">eigenvalues</a> (const EigMat &amp;m)</td></tr>
<tr class="separator:a2401d26ca0cb0e1cdd852a53cf845668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c2fdb8b96faa720cf4bdd4ff3b3be9"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_matrix_dynamic_t&lt; EigMat &gt; *  = nullptr, require_not_st_var&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a76c2fdb8b96faa720cf4bdd4ff3b3be9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a76c2fdb8b96faa720cf4bdd4ff3b3be9.html#a76c2fdb8b96faa720cf4bdd4ff3b3be9">eigenvalues_sym</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a76c2fdb8b96faa720cf4bdd4ff3b3be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eigenvalues of the specified symmetric matrix in descending order of magnitude.  <a href="namespacestan_1_1math_a76c2fdb8b96faa720cf4bdd4ff3b3be9.html#a76c2fdb8b96faa720cf4bdd4ff3b3be9">More...</a><br /></td></tr>
<tr class="separator:a76c2fdb8b96faa720cf4bdd4ff3b3be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65f6e13c5996fe8327f16bf337b9712"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_matrix_dynamic_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa65f6e13c5996fe8327f16bf337b9712"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa65f6e13c5996fe8327f16bf337b9712.html#aa65f6e13c5996fe8327f16bf337b9712">eigenvectors</a> (const EigMat &amp;m)</td></tr>
<tr class="separator:aa65f6e13c5996fe8327f16bf337b9712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae437df0de7201dc67d268e342cf9bde9"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_not_st_var&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae437df0de7201dc67d268e342cf9bde9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae437df0de7201dc67d268e342cf9bde9.html#ae437df0de7201dc67d268e342cf9bde9">eigenvectors_sym</a> (const EigMat &amp;m)</td></tr>
<tr class="separator:ae437df0de7201dc67d268e342cf9bde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af798bd8a0d1384220c1bfb6e8f35293c"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , require_all_eigen_t&lt; Mat1, Mat2 &gt; *  = nullptr, require_all_not_st_var&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af798bd8a0d1384220c1bfb6e8f35293c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af798bd8a0d1384220c1bfb6e8f35293c.html#af798bd8a0d1384220c1bfb6e8f35293c">elt_divide</a> (const Mat1 &amp;m1, const Mat2 &amp;m2)</td></tr>
<tr class="memdesc:af798bd8a0d1384220c1bfb6e8f35293c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise division of the specified matrices.  <a href="namespacestan_1_1math_af798bd8a0d1384220c1bfb6e8f35293c.html#af798bd8a0d1384220c1bfb6e8f35293c">More...</a><br /></td></tr>
<tr class="separator:af798bd8a0d1384220c1bfb6e8f35293c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb896efcf46a2f21ebe31a38c1c0d253"><td class="memTemplParams" colspan="2">template&lt;typename Mat , typename Scal , require_matrix_t&lt; Mat &gt; *  = nullptr, require_stan_scalar_t&lt; Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afb896efcf46a2f21ebe31a38c1c0d253"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afb896efcf46a2f21ebe31a38c1c0d253.html#afb896efcf46a2f21ebe31a38c1c0d253">elt_divide</a> (const Mat &amp;m, Scal s)</td></tr>
<tr class="memdesc:afb896efcf46a2f21ebe31a38c1c0d253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise division of the specified matrix by the specified scalar.  <a href="namespacestan_1_1math_afb896efcf46a2f21ebe31a38c1c0d253.html#afb896efcf46a2f21ebe31a38c1c0d253">More...</a><br /></td></tr>
<tr class="separator:afb896efcf46a2f21ebe31a38c1c0d253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b002811703a438a39fd72b610315b5"><td class="memTemplParams" colspan="2">template&lt;typename Scal , typename Mat , require_stan_scalar_t&lt; Scal &gt; *  = nullptr, require_eigen_t&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a25b002811703a438a39fd72b610315b5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a25b002811703a438a39fd72b610315b5.html#a25b002811703a438a39fd72b610315b5">elt_divide</a> (Scal s, const Mat &amp;m)</td></tr>
<tr class="memdesc:a25b002811703a438a39fd72b610315b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise division of the specified scalar by the specified matrix.  <a href="namespacestan_1_1math_a25b002811703a438a39fd72b610315b5.html#a25b002811703a438a39fd72b610315b5">More...</a><br /></td></tr>
<tr class="separator:a25b002811703a438a39fd72b610315b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060c31d15cbc2bb6006581766481ed4c"><td class="memTemplParams" colspan="2">template&lt;typename Scal1 , typename Scal2 , require_all_stan_scalar_t&lt; Scal1, Scal2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a060c31d15cbc2bb6006581766481ed4c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a060c31d15cbc2bb6006581766481ed4c.html#a060c31d15cbc2bb6006581766481ed4c">elt_divide</a> (Scal1 s1, Scal2 s2)</td></tr>
<tr class="separator:a060c31d15cbc2bb6006581766481ed4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44ba8ada7e65086532ffa28ad8631cf"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , require_all_eigen_t&lt; Mat1, Mat2 &gt; *  = nullptr, require_all_not_st_var&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac44ba8ada7e65086532ffa28ad8631cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac44ba8ada7e65086532ffa28ad8631cf.html#ac44ba8ada7e65086532ffa28ad8631cf">elt_multiply</a> (const Mat1 &amp;m1, const Mat2 &amp;m2)</td></tr>
<tr class="memdesc:ac44ba8ada7e65086532ffa28ad8631cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise multiplication of the specified matrices.  <a href="namespacestan_1_1math_ac44ba8ada7e65086532ffa28ad8631cf.html#ac44ba8ada7e65086532ffa28ad8631cf">More...</a><br /></td></tr>
<tr class="separator:ac44ba8ada7e65086532ffa28ad8631cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7edc12e3efb6f9bb1ce1e3bb76d2342"><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 , require_all_stan_scalar_t&lt; Scalar1, Scalar2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab7edc12e3efb6f9bb1ce1e3bb76d2342"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab7edc12e3efb6f9bb1ce1e3bb76d2342.html#ab7edc12e3efb6f9bb1ce1e3bb76d2342">elt_multiply</a> (const Scalar1 &amp;a, const Scalar2 &amp;b)</td></tr>
<tr class="memdesc:ab7edc12e3efb6f9bb1ce1e3bb76d2342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise multiplication of the specified scalars.  <a href="namespacestan_1_1math_ab7edc12e3efb6f9bb1ce1e3bb76d2342.html#ab7edc12e3efb6f9bb1ce1e3bb76d2342">More...</a><br /></td></tr>
<tr class="separator:ab7edc12e3efb6f9bb1ce1e3bb76d2342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e71b0b782cf7aa5ebb24077387e599"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_matrix_t&lt; T1, T2 &gt; *  = nullptr, require_any_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a44e71b0b782cf7aa5ebb24077387e599"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a44e71b0b782cf7aa5ebb24077387e599.html#a44e71b0b782cf7aa5ebb24077387e599">elt_multiply</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:a44e71b0b782cf7aa5ebb24077387e599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified matrix multiplied by specified scalar.  <a href="namespacestan_1_1math_a44e71b0b782cf7aa5ebb24077387e599.html#a44e71b0b782cf7aa5ebb24077387e599">More...</a><br /></td></tr>
<tr class="separator:a44e71b0b782cf7aa5ebb24077387e599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1165ca04ac1e214a053e049ad165d2"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr, require_not_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaa1165ca04ac1e214a053e049ad165d2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaa1165ca04ac1e214a053e049ad165d2.html#aaa1165ca04ac1e214a053e049ad165d2">erf</a> (const T &amp;x)</td></tr>
<tr class="memdesc:aaa1165ca04ac1e214a053e049ad165d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aa283efca22c0544054a6534443e6e762.html#aa283efca22c0544054a6534443e6e762">erf()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_aaa1165ca04ac1e214a053e049ad165d2.html#aaa1165ca04ac1e214a053e049ad165d2">More...</a><br /></td></tr>
<tr class="separator:aaa1165ca04ac1e214a053e049ad165d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898c619f12c33793034f7c38940a181c"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr, require_not_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a898c619f12c33793034f7c38940a181c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a898c619f12c33793034f7c38940a181c.html#a898c619f12c33793034f7c38940a181c">erfc</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a898c619f12c33793034f7c38940a181c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ab4c763e4f09069eed96a4e96e33ea8ea.html#ab4c763e4f09069eed96a4e96e33ea8ea">erfc()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_a898c619f12c33793034f7c38940a181c.html#a898c619f12c33793034f7c38940a181c">More...</a><br /></td></tr>
<tr class="separator:a898c619f12c33793034f7c38940a181c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5144e07da75ff5357c4338a9a6f0faae"><td class="memTemplParams" colspan="2">template&lt;typename T , require_same_t&lt; std::decay_t&lt; T &gt;, plain_type_t&lt; T &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5144e07da75ff5357c4338a9a6f0faae"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5144e07da75ff5357c4338a9a6f0faae.html#a5144e07da75ff5357c4338a9a6f0faae">eval</a> (T &amp;&amp;<a class="el" href="namespacestan_1_1math_a7c8ad2370c5624d7c0700410e6612514.html#a7c8ad2370c5624d7c0700410e6612514">arg</a>)</td></tr>
<tr class="memdesc:a5144e07da75ff5357c4338a9a6f0faae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inputs which have a <a class="el" href="structstan_1_1plain__type.html" title="Determines plain (non expression) type associated with T.">plain_type</a> equal to the own time are forwarded unmodified (for <a class="el" href="namespace_eigen.html">Eigen</a> expressions these types are different)  <a href="namespacestan_1_1math_a5144e07da75ff5357c4338a9a6f0faae.html#a5144e07da75ff5357c4338a9a6f0faae">More...</a><br /></td></tr>
<tr class="separator:a5144e07da75ff5357c4338a9a6f0faae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8d32a5bccb457978ba478e2660cb6e"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_same_t&lt; std::decay_t&lt; T &gt;, plain_type_t&lt; T &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4d8d32a5bccb457978ba478e2660cb6e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4d8d32a5bccb457978ba478e2660cb6e.html#a4d8d32a5bccb457978ba478e2660cb6e">eval</a> (const T &amp;<a class="el" href="namespacestan_1_1math_a7c8ad2370c5624d7c0700410e6612514.html#a7c8ad2370c5624d7c0700410e6612514">arg</a>)</td></tr>
<tr class="memdesc:a4d8d32a5bccb457978ba478e2660cb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inputs which have a <a class="el" href="structstan_1_1plain__type.html" title="Determines plain (non expression) type associated with T.">plain_type</a> different from their own type are Eval'd (this catches <a class="el" href="namespace_eigen.html">Eigen</a> expressions)  <a href="namespacestan_1_1math_a4d8d32a5bccb457978ba478e2660cb6e.html#a4d8d32a5bccb457978ba478e2660cb6e">More...</a><br /></td></tr>
<tr class="separator:a4d8d32a5bccb457978ba478e2660cb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef7d265fdbd0a5e08d46a072b1d8593"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4ef7d265fdbd0a5e08d46a072b1d8593"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4ef7d265fdbd0a5e08d46a072b1d8593.html#a4ef7d265fdbd0a5e08d46a072b1d8593">exp</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a4ef7d265fdbd0a5e08d46a072b1d8593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise <code><a class="el" href="namespacestan_1_1math_a11f31444e8584e4debf0d6b706d66880.html#a11f31444e8584e4debf0d6b706d66880">exp()</a></code> of the specified argument, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_a4ef7d265fdbd0a5e08d46a072b1d8593.html#a4ef7d265fdbd0a5e08d46a072b1d8593">More...</a><br /></td></tr>
<tr class="separator:a4ef7d265fdbd0a5e08d46a072b1d8593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978fcebcb29a07aa69fd567891132b9a"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a978fcebcb29a07aa69fd567891132b9a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a978fcebcb29a07aa69fd567891132b9a.html#a978fcebcb29a07aa69fd567891132b9a">exp</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a978fcebcb29a07aa69fd567891132b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_a11f31444e8584e4debf0d6b706d66880.html#a11f31444e8584e4debf0d6b706d66880">exp()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_a978fcebcb29a07aa69fd567891132b9a.html#a978fcebcb29a07aa69fd567891132b9a">More...</a><br /></td></tr>
<tr class="separator:a978fcebcb29a07aa69fd567891132b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29009bb8a9bd673d0fd3d8fa463abcb"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr, require_not_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae29009bb8a9bd673d0fd3d8fa463abcb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae29009bb8a9bd673d0fd3d8fa463abcb.html#ae29009bb8a9bd673d0fd3d8fa463abcb">exp2</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae29009bb8a9bd673d0fd3d8fa463abcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise <code><a class="el" href="namespacestan_1_1math_a8c3a577694c8f584e56160580fe0821b.html#a8c3a577694c8f584e56160580fe0821b">exp2()</a></code> of the specified argument, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_ae29009bb8a9bd673d0fd3d8fa463abcb.html#ae29009bb8a9bd673d0fd3d8fa463abcb">More...</a><br /></td></tr>
<tr class="separator:ae29009bb8a9bd673d0fd3d8fa463abcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493ba56fe5b6b4d10a4f92dd1006f8ba"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr, require_not_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a493ba56fe5b6b4d10a4f92dd1006f8ba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a493ba56fe5b6b4d10a4f92dd1006f8ba.html#a493ba56fe5b6b4d10a4f92dd1006f8ba">expm1</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a493ba56fe5b6b4d10a4f92dd1006f8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise <code><a class="el" href="namespacestan_1_1math_a8a76b658b94fcf8943f4fb41c586ec94.html#a8a76b658b94fcf8943f4fb41c586ec94">expm1()</a></code> of the specified argument, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_a493ba56fe5b6b4d10a4f92dd1006f8ba.html#a493ba56fe5b6b4d10a4f92dd1006f8ba">More...</a><br /></td></tr>
<tr class="separator:a493ba56fe5b6b4d10a4f92dd1006f8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccaab038a390d1576bbdbddc7443875"><td class="memTemplParams" colspan="2">template&lt;typename Ta1 , typename Ta2 , typename Ta3 , typename Tb1 , typename Tb2 , typename Tz &gt; </td></tr>
<tr class="memitem:a7ccaab038a390d1576bbdbddc7443875"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Ta1, Ta2, Ta3, Tb1, Tb2, Tz &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7ccaab038a390d1576bbdbddc7443875.html#a7ccaab038a390d1576bbdbddc7443875">F32</a> (const Ta1 &amp;a1, const Ta2 &amp;a2, const Ta3 &amp;a3, const Tb1 &amp;b1, const Tb2 &amp;b2, const Tz &amp;z, double precision=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-6, int max_steps=1e5)</td></tr>
<tr class="memdesc:a7ccaab038a390d1576bbdbddc7443875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hypergeometric function (3F2).  <a href="namespacestan_1_1math_a7ccaab038a390d1576bbdbddc7443875.html#a7ccaab038a390d1576bbdbddc7443875">More...</a><br /></td></tr>
<tr class="separator:a7ccaab038a390d1576bbdbddc7443875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985dffb3a6c8b6226b38e70e4e00b976"><td class="memTemplParams" colspan="2">template&lt;typename T , require_arithmetic_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a985dffb3a6c8b6226b38e70e4e00b976"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a985dffb3a6c8b6226b38e70e4e00b976.html#a985dffb3a6c8b6226b38e70e4e00b976">fabs</a> (T x)</td></tr>
<tr class="separator:a985dffb3a6c8b6226b38e70e4e00b976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359ae820a6117251c8e1851acf192a47"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr, require_not_stan_scalar_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a359ae820a6117251c8e1851acf192a47"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a359ae820a6117251c8e1851acf192a47.html#a359ae820a6117251c8e1851acf192a47">fabs</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a359ae820a6117251c8e1851acf192a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a6c79c9be5c64873b74f3c6924fef6911.html#a6c79c9be5c64873b74f3c6924fef6911">fabs()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_a359ae820a6117251c8e1851acf192a47.html#a359ae820a6117251c8e1851acf192a47">More...</a><br /></td></tr>
<tr class="separator:a359ae820a6117251c8e1851acf192a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa58b6f5a871fc1ed32f78ad2b60d30"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0aa58b6f5a871fc1ed32f78ad2b60d30"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0aa58b6f5a871fc1ed32f78ad2b60d30.html#a0aa58b6f5a871fc1ed32f78ad2b60d30">fabs</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a0aa58b6f5a871fc1ed32f78ad2b60d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_a6c79c9be5c64873b74f3c6924fef6911.html#a6c79c9be5c64873b74f3c6924fef6911">fabs()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_a0aa58b6f5a871fc1ed32f78ad2b60d30.html#a0aa58b6f5a871fc1ed32f78ad2b60d30">More...</a><br /></td></tr>
<tr class="separator:a0aa58b6f5a871fc1ed32f78ad2b60d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3c9360de8944183df51fa64611bd88"><td class="memTemplParams" colspan="2">template&lt;typename T_Sigma , typename T_CPCs , typename T_sds , require_eigen_t&lt; T_Sigma &gt; *  = nullptr, require_all_eigen_vector_t&lt; T_CPCs, T_sds &gt; *  = nullptr, require_all_vt_same&lt; T_Sigma, T_CPCs, T_sds &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aef3c9360de8944183df51fa64611bd88"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aef3c9360de8944183df51fa64611bd88.html#aef3c9360de8944183df51fa64611bd88">factor_cov_matrix</a> (const T_Sigma &amp;Sigma, T_CPCs &amp;&amp;CPCs, T_sds &amp;&amp;sds)</td></tr>
<tr class="memdesc:aef3c9360de8944183df51fa64611bd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is intended to make starting values, given a covariance matrix Sigma.  <a href="namespacestan_1_1math_aef3c9360de8944183df51fa64611bd88.html#aef3c9360de8944183df51fa64611bd88">More...</a><br /></td></tr>
<tr class="separator:aef3c9360de8944183df51fa64611bd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9fec4106ac49aaf2c27e2cce85d3cc"><td class="memTemplParams" colspan="2">template&lt;typename T_U , typename T_CPCs , require_eigen_t&lt; T_U &gt; *  = nullptr, require_eigen_vector_t&lt; T_CPCs &gt; *  = nullptr, require_vt_same&lt; T_U, T_CPCs &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adb9fec4106ac49aaf2c27e2cce85d3cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adb9fec4106ac49aaf2c27e2cce85d3cc.html#adb9fec4106ac49aaf2c27e2cce85d3cc">factor_U</a> (const T_U &amp;U, T_CPCs &amp;&amp;CPCs)</td></tr>
<tr class="memdesc:adb9fec4106ac49aaf2c27e2cce85d3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is intended to make starting values, given a unit upper-triangular matrix U such that U'DU is a correlation matrix.  <a href="namespacestan_1_1math_adb9fec4106ac49aaf2c27e2cce85d3cc.html#adb9fec4106ac49aaf2c27e2cce85d3cc">More...</a><br /></td></tr>
<tr class="separator:adb9fec4106ac49aaf2c27e2cce85d3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2adf0bed6e01e4b8b3d38167fc5d7ad"><td class="memTemplParams" colspan="2">template&lt;typename T , require_arithmetic_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac2adf0bed6e01e4b8b3d38167fc5d7ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac2adf0bed6e01e4b8b3d38167fc5d7ad.html#ac2adf0bed6e01e4b8b3d38167fc5d7ad">falling_factorial</a> (const T &amp;x, int n)</td></tr>
<tr class="memdesc:ac2adf0bed6e01e4b8b3d38167fc5d7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the falling factorial function evaluated at the inputs.  <a href="namespacestan_1_1math_ac2adf0bed6e01e4b8b3d38167fc5d7ad.html#ac2adf0bed6e01e4b8b3d38167fc5d7ad">More...</a><br /></td></tr>
<tr class="separator:ac2adf0bed6e01e4b8b3d38167fc5d7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e536af3bcaad2b9c4bc2d469cf3dfe4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr, require_all_not_var_matrix_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5e536af3bcaad2b9c4bc2d469cf3dfe4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5e536af3bcaad2b9c4bc2d469cf3dfe4.html#a5e536af3bcaad2b9c4bc2d469cf3dfe4">falling_factorial</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a5e536af3bcaad2b9c4bc2d469cf3dfe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the falling factorial function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_a5e536af3bcaad2b9c4bc2d469cf3dfe4.html#a5e536af3bcaad2b9c4bc2d469cf3dfe4">More...</a><br /></td></tr>
<tr class="separator:a5e536af3bcaad2b9c4bc2d469cf3dfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8902257303d9b187e0e47d4bf87f3a1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_arithmetic_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae8902257303d9b187e0e47d4bf87f3a1"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae8902257303d9b187e0e47d4bf87f3a1.html#ae8902257303d9b187e0e47d4bf87f3a1">fdim</a> (T1 x, T2 y)</td></tr>
<tr class="memdesc:ae8902257303d9b187e0e47d4bf87f3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference of the specified values (C++11).  <a href="namespacestan_1_1math_ae8902257303d9b187e0e47d4bf87f3a1.html#ae8902257303d9b187e0e47d4bf87f3a1">More...</a><br /></td></tr>
<tr class="separator:ae8902257303d9b187e0e47d4bf87f3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae735132ce46b1fd85de7716bf278e0f6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae735132ce46b1fd85de7716bf278e0f6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae735132ce46b1fd85de7716bf278e0f6.html#ae735132ce46b1fd85de7716bf278e0f6">fdim</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ae735132ce46b1fd85de7716bf278e0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the fdim function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_ae735132ce46b1fd85de7716bf278e0f6.html#ae735132ce46b1fd85de7716bf278e0f6">More...</a><br /></td></tr>
<tr class="separator:ae735132ce46b1fd85de7716bf278e0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63eb24cc02a87c3437616797cec6cf4d"><td class="memTemplParams" colspan="2">template&lt;typename V , require_eigen_vector_vt&lt; is_complex, V &gt; *  = nullptr, require_not_var_t&lt; base_type_t&lt; value_type_t&lt; V &gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a63eb24cc02a87c3437616797cec6cf4d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; V &gt;, -1, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a63eb24cc02a87c3437616797cec6cf4d.html#a63eb24cc02a87c3437616797cec6cf4d">fft</a> (const V &amp;x)</td></tr>
<tr class="memdesc:a63eb24cc02a87c3437616797cec6cf4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the discrete Fourier transform of the specified complex vector.  <a href="namespacestan_1_1math_a63eb24cc02a87c3437616797cec6cf4d.html#a63eb24cc02a87c3437616797cec6cf4d">More...</a><br /></td></tr>
<tr class="separator:a63eb24cc02a87c3437616797cec6cf4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab216e5faa957bbdb8a8a5ca5b881cb99"><td class="memTemplParams" colspan="2">template&lt;typename V , require_eigen_vector_vt&lt; is_complex, V &gt; *  = nullptr, require_not_var_t&lt; base_type_t&lt; value_type_t&lt; V &gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab216e5faa957bbdb8a8a5ca5b881cb99"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; V &gt;, -1, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab216e5faa957bbdb8a8a5ca5b881cb99.html#ab216e5faa957bbdb8a8a5ca5b881cb99">inv_fft</a> (const V &amp;y)</td></tr>
<tr class="memdesc:ab216e5faa957bbdb8a8a5ca5b881cb99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse discrete Fourier transform of the specified complex vector.  <a href="namespacestan_1_1math_ab216e5faa957bbdb8a8a5ca5b881cb99.html#ab216e5faa957bbdb8a8a5ca5b881cb99">More...</a><br /></td></tr>
<tr class="separator:ab216e5faa957bbdb8a8a5ca5b881cb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf9fb1b51eb773875b840b1640eaded"><td class="memTemplParams" colspan="2">template&lt;typename M , require_eigen_dense_dynamic_vt&lt; is_complex, M &gt; *  = nullptr, require_not_var_t&lt; base_type_t&lt; value_type_t&lt; M &gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adcf9fb1b51eb773875b840b1640eaded"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; M &gt;, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adcf9fb1b51eb773875b840b1640eaded.html#adcf9fb1b51eb773875b840b1640eaded">fft2</a> (const M &amp;x)</td></tr>
<tr class="memdesc:adcf9fb1b51eb773875b840b1640eaded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the two-dimensional discrete Fourier transform of the specified complex matrix.  <a href="namespacestan_1_1math_adcf9fb1b51eb773875b840b1640eaded.html#adcf9fb1b51eb773875b840b1640eaded">More...</a><br /></td></tr>
<tr class="separator:adcf9fb1b51eb773875b840b1640eaded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5596c4be06cc51f3dfa344abf78fd44"><td class="memTemplParams" colspan="2">template&lt;typename M , require_eigen_dense_dynamic_vt&lt; is_complex, M &gt; *  = nullptr, require_not_var_t&lt; base_type_t&lt; value_type_t&lt; M &gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad5596c4be06cc51f3dfa344abf78fd44"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; M &gt;, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad5596c4be06cc51f3dfa344abf78fd44.html#ad5596c4be06cc51f3dfa344abf78fd44">inv_fft2</a> (const M &amp;y)</td></tr>
<tr class="memdesc:ad5596c4be06cc51f3dfa344abf78fd44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the two-dimensional inverse discrete Fourier transform of the specified complex matrix.  <a href="namespacestan_1_1math_ad5596c4be06cc51f3dfa344abf78fd44.html#ad5596c4be06cc51f3dfa344abf78fd44">More...</a><br /></td></tr>
<tr class="separator:ad5596c4be06cc51f3dfa344abf78fd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab101ab077529ae9bc7e2e5c8b929aaee"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename S , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_stan_scalar_t&lt; S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab101ab077529ae9bc7e2e5c8b929aaee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab101ab077529ae9bc7e2e5c8b929aaee.html#ab101ab077529ae9bc7e2e5c8b929aaee">fill</a> (EigMat &amp;x, const S &amp;y)</td></tr>
<tr class="memdesc:ab101ab077529ae9bc7e2e5c8b929aaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <a href="namespacestan_1_1math_ab101ab077529ae9bc7e2e5c8b929aaee.html#ab101ab077529ae9bc7e2e5c8b929aaee">More...</a><br /></td></tr>
<tr class="separator:ab101ab077529ae9bc7e2e5c8b929aaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040edecf84519bad9ef221cd298698d9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S , require_t&lt; std::is_assignable&lt; std::decay_t&lt; T &gt; &amp;, std::decay_t&lt; S &gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a040edecf84519bad9ef221cd298698d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a040edecf84519bad9ef221cd298698d9.html#a040edecf84519bad9ef221cd298698d9">fill</a> (T &amp;x, S &amp;&amp;y)</td></tr>
<tr class="memdesc:a040edecf84519bad9ef221cd298698d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <a href="namespacestan_1_1math_a040edecf84519bad9ef221cd298698d9.html#a040edecf84519bad9ef221cd298698d9">More...</a><br /></td></tr>
<tr class="separator:a040edecf84519bad9ef221cd298698d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3453d61943d7aef89d0d2e192a5308"><td class="memTemplParams" colspan="2">template&lt;typename Vec , typename S , require_std_vector_t&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3c3453d61943d7aef89d0d2e192a5308"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3c3453d61943d7aef89d0d2e192a5308.html#a3c3453d61943d7aef89d0d2e192a5308">fill</a> (Vec &amp;x, S &amp;&amp;y)</td></tr>
<tr class="memdesc:a3c3453d61943d7aef89d0d2e192a5308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <a href="namespacestan_1_1math_a3c3453d61943d7aef89d0d2e192a5308.html#a3c3453d61943d7aef89d0d2e192a5308">More...</a><br /></td></tr>
<tr class="separator:a3c3453d61943d7aef89d0d2e192a5308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ff021ea506f2b8df0a1be3ee6411e8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a71ff021ea506f2b8df0a1be3ee6411e8.html#a71ff021ea506f2b8df0a1be3ee6411e8">finite_diff_stepsize</a> (double u)</td></tr>
<tr class="memdesc:a71ff021ea506f2b8df0a1be3ee6411e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the stepsize for finite difference evaluations at the specified scalar.  <a href="namespacestan_1_1math_a71ff021ea506f2b8df0a1be3ee6411e8.html#a71ff021ea506f2b8df0a1be3ee6411e8">More...</a><br /></td></tr>
<tr class="separator:a71ff021ea506f2b8df0a1be3ee6411e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ae7a6781ee561101b6f57da2310647"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a08ae7a6781ee561101b6f57da2310647"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a08ae7a6781ee561101b6f57da2310647.html#a08ae7a6781ee561101b6f57da2310647">floor</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a08ae7a6781ee561101b6f57da2310647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a16e5a2666b377e37fe807765ba5f6aaf.html#a16e5a2666b377e37fe807765ba5f6aaf">floor()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_a08ae7a6781ee561101b6f57da2310647.html#a08ae7a6781ee561101b6f57da2310647">More...</a><br /></td></tr>
<tr class="separator:a08ae7a6781ee561101b6f57da2310647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63f8f82d7e81c99f2c8672696f82f55"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa63f8f82d7e81c99f2c8672696f82f55"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa63f8f82d7e81c99f2c8672696f82f55.html#aa63f8f82d7e81c99f2c8672696f82f55">floor</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:aa63f8f82d7e81c99f2c8672696f82f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_a16e5a2666b377e37fe807765ba5f6aaf.html#a16e5a2666b377e37fe807765ba5f6aaf">floor()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_aa63f8f82d7e81c99f2c8672696f82f55.html#aa63f8f82d7e81c99f2c8672696f82f55">More...</a><br /></td></tr>
<tr class="separator:aa63f8f82d7e81c99f2c8672696f82f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ca413a0f1c9bc970344412e39749b8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_arithmetic_t&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af0ca413a0f1c9bc970344412e39749b8"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af0ca413a0f1c9bc970344412e39749b8.html#af0ca413a0f1c9bc970344412e39749b8">fma</a> (T1 x, T2 y, T3 z)</td></tr>
<tr class="memdesc:af0ca413a0f1c9bc970344412e39749b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the first two arguments plus the third argument.  <a href="namespacestan_1_1math_af0ca413a0f1c9bc970344412e39749b8.html#af0ca413a0f1c9bc970344412e39749b8">More...</a><br /></td></tr>
<tr class="separator:af0ca413a0f1c9bc970344412e39749b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d88c89edeb8a27deaa52879f729ced"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_any_matrix_t&lt; T1, T2, T3 &gt; *  = nullptr, require_not_var_t&lt; return_type_t&lt; T1, T2, T3 &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa6d88c89edeb8a27deaa52879f729ced"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa6d88c89edeb8a27deaa52879f729ced.html#aa6d88c89edeb8a27deaa52879f729ced">fma</a> (T1 &amp;&amp;x, T2 &amp;&amp;y, T3 &amp;&amp;z)</td></tr>
<tr class="separator:aa6d88c89edeb8a27deaa52879f729ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6beecb4381062d93549455104aa698ab"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_arithmetic_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6beecb4381062d93549455104aa698ab"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6beecb4381062d93549455104aa698ab.html#a6beecb4381062d93549455104aa698ab">fmax</a> (T1 x, T2 y)</td></tr>
<tr class="memdesc:a6beecb4381062d93549455104aa698ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greater of the two specified arguments.  <a href="namespacestan_1_1math_a6beecb4381062d93549455104aa698ab.html#a6beecb4381062d93549455104aa698ab">More...</a><br /></td></tr>
<tr class="separator:a6beecb4381062d93549455104aa698ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d52789ee6d4867ff1180087c5f50b3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a29d52789ee6d4867ff1180087c5f50b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a29d52789ee6d4867ff1180087c5f50b3.html#a29d52789ee6d4867ff1180087c5f50b3">fmax</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a29d52789ee6d4867ff1180087c5f50b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the fmax function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_a29d52789ee6d4867ff1180087c5f50b3.html#a29d52789ee6d4867ff1180087c5f50b3">More...</a><br /></td></tr>
<tr class="separator:a29d52789ee6d4867ff1180087c5f50b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4406c1b978a23bc9d2940632dcf1d613"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_arithmetic_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4406c1b978a23bc9d2940632dcf1d613"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4406c1b978a23bc9d2940632dcf1d613.html#a4406c1b978a23bc9d2940632dcf1d613">fmin</a> (T1 x, T2 y)</td></tr>
<tr class="memdesc:a4406c1b978a23bc9d2940632dcf1d613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lesser of the two specified arguments.  <a href="namespacestan_1_1math_a4406c1b978a23bc9d2940632dcf1d613.html#a4406c1b978a23bc9d2940632dcf1d613">More...</a><br /></td></tr>
<tr class="separator:a4406c1b978a23bc9d2940632dcf1d613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b241336e4945206f6dad0fcf98d875"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a95b241336e4945206f6dad0fcf98d875"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a95b241336e4945206f6dad0fcf98d875.html#a95b241336e4945206f6dad0fcf98d875">fmin</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a95b241336e4945206f6dad0fcf98d875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the fmin function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_a95b241336e4945206f6dad0fcf98d875.html#a95b241336e4945206f6dad0fcf98d875">More...</a><br /></td></tr>
<tr class="separator:a95b241336e4945206f6dad0fcf98d875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44bdcf20489a07bda6ea92f95f08576"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_arithmetic_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af44bdcf20489a07bda6ea92f95f08576"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af44bdcf20489a07bda6ea92f95f08576.html#af44bdcf20489a07bda6ea92f95f08576">fmod</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:af44bdcf20489a07bda6ea92f95f08576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the floating-point remainder of numerator/denominator (rounded towards zero).  <a href="namespacestan_1_1math_af44bdcf20489a07bda6ea92f95f08576.html#af44bdcf20489a07bda6ea92f95f08576">More...</a><br /></td></tr>
<tr class="separator:af44bdcf20489a07bda6ea92f95f08576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9113faf5e002823324ad8156dd88ce"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3e9113faf5e002823324ad8156dd88ce"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3e9113faf5e002823324ad8156dd88ce.html#a3e9113faf5e002823324ad8156dd88ce">fmod</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a3e9113faf5e002823324ad8156dd88ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the fmod function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_a3e9113faf5e002823324ad8156dd88ce.html#a3e9113faf5e002823324ad8156dd88ce">More...</a><br /></td></tr>
<tr class="separator:a3e9113faf5e002823324ad8156dd88ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4192f083082e99157fdfdd79af442b41"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4192f083082e99157fdfdd79af442b41.html#a4192f083082e99157fdfdd79af442b41">gamma_p</a> (double z, double a)</td></tr>
<tr class="memdesc:a4192f083082e99157fdfdd79af442b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the normalized, lower-incomplete gamma function applied to the specified argument.  <a href="namespacestan_1_1math_a4192f083082e99157fdfdd79af442b41.html#a4192f083082e99157fdfdd79af442b41">More...</a><br /></td></tr>
<tr class="separator:a4192f083082e99157fdfdd79af442b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56bf829d0cbfa257df15c0e9f9b3fac"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae56bf829d0cbfa257df15c0e9f9b3fac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae56bf829d0cbfa257df15c0e9f9b3fac.html#ae56bf829d0cbfa257df15c0e9f9b3fac">gamma_p</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ae56bf829d0cbfa257df15c0e9f9b3fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the gamma_p function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_ae56bf829d0cbfa257df15c0e9f9b3fac.html#ae56bf829d0cbfa257df15c0e9f9b3fac">More...</a><br /></td></tr>
<tr class="separator:ae56bf829d0cbfa257df15c0e9f9b3fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0830ba049b81bc98ea9fbcf1eb7b4bd6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0830ba049b81bc98ea9fbcf1eb7b4bd6.html#a0830ba049b81bc98ea9fbcf1eb7b4bd6">gamma_q</a> (double x, double a)</td></tr>
<tr class="separator:a0830ba049b81bc98ea9fbcf1eb7b4bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362c0d49d7d0642f2df338d86abdef84"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a362c0d49d7d0642f2df338d86abdef84"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a362c0d49d7d0642f2df338d86abdef84.html#a362c0d49d7d0642f2df338d86abdef84">gamma_q</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a362c0d49d7d0642f2df338d86abdef84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the gamma_q function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_a362c0d49d7d0642f2df338d86abdef84.html#a362c0d49d7d0642f2df338d86abdef84">More...</a><br /></td></tr>
<tr class="separator:a362c0d49d7d0642f2df338d86abdef84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82644db429d45113beb3bf3c259bc75f"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_not_vt_var&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a82644db429d45113beb3bf3c259bc75f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, EigMat::ColsAtCompileTime, EigMat::RowsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a82644db429d45113beb3bf3c259bc75f.html#a82644db429d45113beb3bf3c259bc75f">generalized_inverse</a> (const EigMat &amp;G)</td></tr>
<tr class="memdesc:a82644db429d45113beb3bf3c259bc75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Moore-Penrose generalized inverse of the specified matrix.  <a href="namespacestan_1_1math_a82644db429d45113beb3bf3c259bc75f.html#a82644db429d45113beb3bf3c259bc75f">More...</a><br /></td></tr>
<tr class="separator:a82644db429d45113beb3bf3c259bc75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7535c86e2c9ee9d5391a8cc63187317e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7535c86e2c9ee9d5391a8cc63187317e"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7535c86e2c9ee9d5391a8cc63187317e.html#a7535c86e2c9ee9d5391a8cc63187317e">get_base1</a> (const std::vector&lt; T &gt; &amp;x, size_t i, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a7535c86e2c9ee9d5391a8cc63187317e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one index.  <a href="namespacestan_1_1math_a7535c86e2c9ee9d5391a8cc63187317e.html#a7535c86e2c9ee9d5391a8cc63187317e">More...</a><br /></td></tr>
<tr class="separator:a7535c86e2c9ee9d5391a8cc63187317e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7c84b936da0d3422507927cf9a68cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca7c84b936da0d3422507927cf9a68cc"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aca7c84b936da0d3422507927cf9a68cc.html#aca7c84b936da0d3422507927cf9a68cc">get_base1</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, size_t i1, size_t i2, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:aca7c84b936da0d3422507927cf9a68cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="namespacestan_1_1math_aca7c84b936da0d3422507927cf9a68cc.html#aca7c84b936da0d3422507927cf9a68cc">More...</a><br /></td></tr>
<tr class="separator:aca7c84b936da0d3422507927cf9a68cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714e39ba9fcbbd90c787a51d511c9af1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a714e39ba9fcbbd90c787a51d511c9af1"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a714e39ba9fcbbd90c787a51d511c9af1.html#a714e39ba9fcbbd90c787a51d511c9af1">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a714e39ba9fcbbd90c787a51d511c9af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="namespacestan_1_1math_a714e39ba9fcbbd90c787a51d511c9af1.html#a714e39ba9fcbbd90c787a51d511c9af1">More...</a><br /></td></tr>
<tr class="separator:a714e39ba9fcbbd90c787a51d511c9af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23b355397df347249da513307fd6667"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa23b355397df347249da513307fd6667"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa23b355397df347249da513307fd6667.html#aa23b355397df347249da513307fd6667">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:aa23b355397df347249da513307fd6667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="namespacestan_1_1math_aa23b355397df347249da513307fd6667.html#aa23b355397df347249da513307fd6667">More...</a><br /></td></tr>
<tr class="separator:aa23b355397df347249da513307fd6667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c1fac0445beea55c521c94f360e13e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a25c1fac0445beea55c521c94f360e13e"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a25c1fac0445beea55c521c94f360e13e.html#a25c1fac0445beea55c521c94f360e13e">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a25c1fac0445beea55c521c94f360e13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="namespacestan_1_1math_a25c1fac0445beea55c521c94f360e13e.html#a25c1fac0445beea55c521c94f360e13e">More...</a><br /></td></tr>
<tr class="separator:a25c1fac0445beea55c521c94f360e13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a82151947fc8816c5ce5b7bc6d8abd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20a82151947fc8816c5ce5b7bc6d8abd"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a20a82151947fc8816c5ce5b7bc6d8abd.html#a20a82151947fc8816c5ce5b7bc6d8abd">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a20a82151947fc8816c5ce5b7bc6d8abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="namespacestan_1_1math_a20a82151947fc8816c5ce5b7bc6d8abd.html#a20a82151947fc8816c5ce5b7bc6d8abd">More...</a><br /></td></tr>
<tr class="separator:a20a82151947fc8816c5ce5b7bc6d8abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb72caff19c8ce19dc6e3c25c79f7b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6fb72caff19c8ce19dc6e3c25c79f7b8"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6fb72caff19c8ce19dc6e3c25c79f7b8.html#a6fb72caff19c8ce19dc6e3c25c79f7b8">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a6fb72caff19c8ce19dc6e3c25c79f7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="namespacestan_1_1math_a6fb72caff19c8ce19dc6e3c25c79f7b8.html#a6fb72caff19c8ce19dc6e3c25c79f7b8">More...</a><br /></td></tr>
<tr class="separator:a6fb72caff19c8ce19dc6e3c25c79f7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc97dd76490d575638ebb22da233a53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:accc97dd76490d575638ebb22da233a53"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_accc97dd76490d575638ebb22da233a53.html#accc97dd76490d575638ebb22da233a53">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, size_t i8, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:accc97dd76490d575638ebb22da233a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="namespacestan_1_1math_accc97dd76490d575638ebb22da233a53.html#accc97dd76490d575638ebb22da233a53">More...</a><br /></td></tr>
<tr class="separator:accc97dd76490d575638ebb22da233a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac87dbdf4e85211a9f937331911a71e"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_not_eigen_vector_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afac87dbdf4e85211a9f937331911a71e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afac87dbdf4e85211a9f937331911a71e.html#afac87dbdf4e85211a9f937331911a71e">get_base1</a> (const EigMat &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:afac87dbdf4e85211a9f937331911a71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the row of the specified matrix at the specified base-one row index.  <a href="namespacestan_1_1math_afac87dbdf4e85211a9f937331911a71e.html#afac87dbdf4e85211a9f937331911a71e">More...</a><br /></td></tr>
<tr class="separator:afac87dbdf4e85211a9f937331911a71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3cfb8034b9fb4d5d5b175b062926c9"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5f3cfb8034b9fb4d5d5b175b062926c9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5f3cfb8034b9fb4d5d5b175b062926c9.html#a5f3cfb8034b9fb4d5d5b175b062926c9">get_base1</a> (const EigMat &amp;x, size_t m, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a5f3cfb8034b9fb4d5d5b175b062926c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified matrix at the specified base-one row and column indexes.  <a href="namespacestan_1_1math_a5f3cfb8034b9fb4d5d5b175b062926c9.html#a5f3cfb8034b9fb4d5d5b175b062926c9">More...</a><br /></td></tr>
<tr class="separator:a5f3cfb8034b9fb4d5d5b175b062926c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11c03eeb00e27b6b646175d22791c43"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_eigen_vector_t&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae11c03eeb00e27b6b646175d22791c43"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigVec &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae11c03eeb00e27b6b646175d22791c43.html#ae11c03eeb00e27b6b646175d22791c43">get_base1</a> (const EigVec &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:ae11c03eeb00e27b6b646175d22791c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified <a class="el" href="namespace_eigen.html">Eigen</a> vector at the specified base-one index.  <a href="namespacestan_1_1math_ae11c03eeb00e27b6b646175d22791c43.html#ae11c03eeb00e27b6b646175d22791c43">More...</a><br /></td></tr>
<tr class="separator:ae11c03eeb00e27b6b646175d22791c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54b1427fd9d0765f0200dc9caa830f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac54b1427fd9d0765f0200dc9caa830f9"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac54b1427fd9d0765f0200dc9caa830f9.html#ac54b1427fd9d0765f0200dc9caa830f9">get_base1_lhs</a> (std::vector&lt; T &gt; &amp;x, size_t i, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:ac54b1427fd9d0765f0200dc9caa830f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one index.  <a href="namespacestan_1_1math_ac54b1427fd9d0765f0200dc9caa830f9.html#ac54b1427fd9d0765f0200dc9caa830f9">More...</a><br /></td></tr>
<tr class="separator:ac54b1427fd9d0765f0200dc9caa830f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5711f99869d05a6263218f3256e582"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d5711f99869d05a6263218f3256e582"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4d5711f99869d05a6263218f3256e582.html#a4d5711f99869d05a6263218f3256e582">get_base1_lhs</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, size_t i1, size_t i2, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a4d5711f99869d05a6263218f3256e582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="namespacestan_1_1math_a4d5711f99869d05a6263218f3256e582.html#a4d5711f99869d05a6263218f3256e582">More...</a><br /></td></tr>
<tr class="separator:a4d5711f99869d05a6263218f3256e582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f3ceaa6197904ef662f1edc8245e1a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37f3ceaa6197904ef662f1edc8245e1a"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a37f3ceaa6197904ef662f1edc8245e1a.html#a37f3ceaa6197904ef662f1edc8245e1a">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a37f3ceaa6197904ef662f1edc8245e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="namespacestan_1_1math_a37f3ceaa6197904ef662f1edc8245e1a.html#a37f3ceaa6197904ef662f1edc8245e1a">More...</a><br /></td></tr>
<tr class="separator:a37f3ceaa6197904ef662f1edc8245e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3132eb36eaf861cfbd119b38e0a85a15"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3132eb36eaf861cfbd119b38e0a85a15"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3132eb36eaf861cfbd119b38e0a85a15.html#a3132eb36eaf861cfbd119b38e0a85a15">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a3132eb36eaf861cfbd119b38e0a85a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="namespacestan_1_1math_a3132eb36eaf861cfbd119b38e0a85a15.html#a3132eb36eaf861cfbd119b38e0a85a15">More...</a><br /></td></tr>
<tr class="separator:a3132eb36eaf861cfbd119b38e0a85a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcc061003aabcaf675f4415adc80c0a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afbcc061003aabcaf675f4415adc80c0a"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afbcc061003aabcaf675f4415adc80c0a.html#afbcc061003aabcaf675f4415adc80c0a">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:afbcc061003aabcaf675f4415adc80c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="namespacestan_1_1math_afbcc061003aabcaf675f4415adc80c0a.html#afbcc061003aabcaf675f4415adc80c0a">More...</a><br /></td></tr>
<tr class="separator:afbcc061003aabcaf675f4415adc80c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1958245532761be08be7ac9bc781f3a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1958245532761be08be7ac9bc781f3a7"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1958245532761be08be7ac9bc781f3a7.html#a1958245532761be08be7ac9bc781f3a7">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a1958245532761be08be7ac9bc781f3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="namespacestan_1_1math_a1958245532761be08be7ac9bc781f3a7.html#a1958245532761be08be7ac9bc781f3a7">More...</a><br /></td></tr>
<tr class="separator:a1958245532761be08be7ac9bc781f3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc7fc712ebe439bec1892c8f69447cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedc7fc712ebe439bec1892c8f69447cd"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aedc7fc712ebe439bec1892c8f69447cd.html#aedc7fc712ebe439bec1892c8f69447cd">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:aedc7fc712ebe439bec1892c8f69447cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="namespacestan_1_1math_aedc7fc712ebe439bec1892c8f69447cd.html#aedc7fc712ebe439bec1892c8f69447cd">More...</a><br /></td></tr>
<tr class="separator:aedc7fc712ebe439bec1892c8f69447cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64467731d9abfaf97ea8d541d528142c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64467731d9abfaf97ea8d541d528142c"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a64467731d9abfaf97ea8d541d528142c.html#a64467731d9abfaf97ea8d541d528142c">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, size_t i8, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a64467731d9abfaf97ea8d541d528142c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <a href="namespacestan_1_1math_a64467731d9abfaf97ea8d541d528142c.html#a64467731d9abfaf97ea8d541d528142c">More...</a><br /></td></tr>
<tr class="separator:a64467731d9abfaf97ea8d541d528142c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0843cd960568745e5ace70f2c45ec6c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0843cd960568745e5ace70f2c45ec6c3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Block&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0843cd960568745e5ace70f2c45ec6c3.html#a0843cd960568745e5ace70f2c45ec6c3">get_base1_lhs</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a0843cd960568745e5ace70f2c45ec6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the row of the specified vector at the specified base-one row index.  <a href="namespacestan_1_1math_a0843cd960568745e5ace70f2c45ec6c3.html#a0843cd960568745e5ace70f2c45ec6c3">More...</a><br /></td></tr>
<tr class="separator:a0843cd960568745e5ace70f2c45ec6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cb7e6e670cddcdf5527ec92fa3ff37"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8cb7e6e670cddcdf5527ec92fa3ff37"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af8cb7e6e670cddcdf5527ec92fa3ff37.html#af8cb7e6e670cddcdf5527ec92fa3ff37">get_base1_lhs</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, size_t m, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:af8cb7e6e670cddcdf5527ec92fa3ff37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified matrix at the specified base-one row and column indexes.  <a href="namespacestan_1_1math_af8cb7e6e670cddcdf5527ec92fa3ff37.html#af8cb7e6e670cddcdf5527ec92fa3ff37">More...</a><br /></td></tr>
<tr class="separator:af8cb7e6e670cddcdf5527ec92fa3ff37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffeab694f7588c92dc97b6736e5be7b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adffeab694f7588c92dc97b6736e5be7b"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adffeab694f7588c92dc97b6736e5be7b.html#adffeab694f7588c92dc97b6736e5be7b">get_base1_lhs</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:adffeab694f7588c92dc97b6736e5be7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified column vector at the specified base-one index.  <a href="namespacestan_1_1math_adffeab694f7588c92dc97b6736e5be7b.html#adffeab694f7588c92dc97b6736e5be7b">More...</a><br /></td></tr>
<tr class="separator:adffeab694f7588c92dc97b6736e5be7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6133d90708e16760b6394c6ca6a305ff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6133d90708e16760b6394c6ca6a305ff"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6133d90708e16760b6394c6ca6a305ff.html#a6133d90708e16760b6394c6ca6a305ff">get_base1_lhs</a> (Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;x, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a6133d90708e16760b6394c6ca6a305ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified row vector at the specified base-one index.  <a href="namespacestan_1_1math_a6133d90708e16760b6394c6ca6a305ff.html#a6133d90708e16760b6394c6ca6a305ff">More...</a><br /></td></tr>
<tr class="separator:a6133d90708e16760b6394c6ca6a305ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b841d1e9260d3ae5f78a0edbc7bf19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02b841d1e9260d3ae5f78a0edbc7bf19"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a02b841d1e9260d3ae5f78a0edbc7bf19.html#a02b841d1e9260d3ae5f78a0edbc7bf19">get_imag</a> (const std::complex&lt; T &gt; &amp;z)</td></tr>
<tr class="memdesc:a02b841d1e9260d3ae5f78a0edbc7bf19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the imaginary component of the complex argument.  <a href="namespacestan_1_1math_a02b841d1e9260d3ae5f78a0edbc7bf19.html#a02b841d1e9260d3ae5f78a0edbc7bf19">More...</a><br /></td></tr>
<tr class="separator:a02b841d1e9260d3ae5f78a0edbc7bf19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e8fe4691725d4a94c6b11b4176d518"><td class="memTemplParams" colspan="2">template&lt;typename Eig , require_eigen_vt&lt; is_complex, Eig &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a82e8fe4691725d4a94c6b11b4176d518"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a82e8fe4691725d4a94c6b11b4176d518.html#a82e8fe4691725d4a94c6b11b4176d518">get_imag</a> (const Eig &amp;z)</td></tr>
<tr class="memdesc:a82e8fe4691725d4a94c6b11b4176d518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the real component of the complex argument.  <a href="namespacestan_1_1math_a82e8fe4691725d4a94c6b11b4176d518.html#a82e8fe4691725d4a94c6b11b4176d518">More...</a><br /></td></tr>
<tr class="separator:a82e8fe4691725d4a94c6b11b4176d518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ecc541e99127df3f97e6af6f1ac16b"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , require_std_vector_st&lt; is_complex, StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac1ecc541e99127df3f97e6af6f1ac16b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac1ecc541e99127df3f97e6af6f1ac16b.html#ac1ecc541e99127df3f97e6af6f1ac16b">get_imag</a> (const StdVec &amp;z)</td></tr>
<tr class="memdesc:ac1ecc541e99127df3f97e6af6f1ac16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the real component of the complex argument.  <a href="namespacestan_1_1math_ac1ecc541e99127df3f97e6af6f1ac16b.html#ac1ecc541e99127df3f97e6af6f1ac16b">More...</a><br /></td></tr>
<tr class="separator:ac1ecc541e99127df3f97e6af6f1ac16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db42fb5661632cbd24a02f5b10d28e2"><td class="memTemplParams" colspan="2">template&lt;typename T_lp , typename T_lp_accum &gt; </td></tr>
<tr class="memitem:a7db42fb5661632cbd24a02f5b10d28e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_lp, T_lp_accum &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7db42fb5661632cbd24a02f5b10d28e2.html#a7db42fb5661632cbd24a02f5b10d28e2">get_lp</a> (const T_lp &amp;lp, const <a class="el" href="classstan_1_1math_1_1accumulator.html">accumulator</a>&lt; T_lp_accum &gt; &amp;lp_accum)</td></tr>
<tr class="separator:a7db42fb5661632cbd24a02f5b10d28e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51418e2763101683588225852b978bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa51418e2763101683588225852b978bb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa51418e2763101683588225852b978bb.html#aa51418e2763101683588225852b978bb">get_real</a> (const std::complex&lt; T &gt; &amp;z)</td></tr>
<tr class="memdesc:aa51418e2763101683588225852b978bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the real component of the complex argument.  <a href="namespacestan_1_1math_aa51418e2763101683588225852b978bb.html#aa51418e2763101683588225852b978bb">More...</a><br /></td></tr>
<tr class="separator:aa51418e2763101683588225852b978bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9f467ed61fb93c1882093eaddd850c"><td class="memTemplParams" colspan="2">template&lt;typename Eig , require_eigen_vt&lt; is_complex, Eig &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afb9f467ed61fb93c1882093eaddd850c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afb9f467ed61fb93c1882093eaddd850c.html#afb9f467ed61fb93c1882093eaddd850c">get_real</a> (const Eig &amp;z)</td></tr>
<tr class="memdesc:afb9f467ed61fb93c1882093eaddd850c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the real component of the complex argument.  <a href="namespacestan_1_1math_afb9f467ed61fb93c1882093eaddd850c.html#afb9f467ed61fb93c1882093eaddd850c">More...</a><br /></td></tr>
<tr class="separator:afb9f467ed61fb93c1882093eaddd850c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18014ed76673cb0afd8715e91bda69d"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , require_std_vector_st&lt; is_complex, StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab18014ed76673cb0afd8715e91bda69d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab18014ed76673cb0afd8715e91bda69d.html#ab18014ed76673cb0afd8715e91bda69d">get_real</a> (const StdVec &amp;z)</td></tr>
<tr class="memdesc:ab18014ed76673cb0afd8715e91bda69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the real component of the complex argument.  <a href="namespacestan_1_1math_ab18014ed76673cb0afd8715e91bda69d.html#ab18014ed76673cb0afd8715e91bda69d">More...</a><br /></td></tr>
<tr class="separator:ab18014ed76673cb0afd8715e91bda69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea686bdab779870ce5ab5c73a66933d"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma &gt; </td></tr>
<tr class="memitem:aaea686bdab779870ce5ab5c73a66933d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_sigma &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaea686bdab779870ce5ab5c73a66933d.html#aaea686bdab779870ce5ab5c73a66933d">gp_dot_prod_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x, Eigen::Dynamic, 1 &gt;&gt; &amp;x, const T_sigma &amp;sigma)</td></tr>
<tr class="memdesc:aaea686bdab779870ce5ab5c73a66933d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a dot product covariance matrix.  <a href="namespacestan_1_1math_aaea686bdab779870ce5ab5c73a66933d.html#aaea686bdab779870ce5ab5c73a66933d">More...</a><br /></td></tr>
<tr class="separator:aaea686bdab779870ce5ab5c73a66933d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89f2142eefa90a439473ec00e03aab7"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma &gt; </td></tr>
<tr class="memitem:ae89f2142eefa90a439473ec00e03aab7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_sigma &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae89f2142eefa90a439473ec00e03aab7.html#ae89f2142eefa90a439473ec00e03aab7">gp_dot_prod_cov</a> (const std::vector&lt; T_x &gt; &amp;x, const T_sigma &amp;sigma)</td></tr>
<tr class="memdesc:ae89f2142eefa90a439473ec00e03aab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a dot product covariance matrix.  <a href="namespacestan_1_1math_ae89f2142eefa90a439473ec00e03aab7.html#ae89f2142eefa90a439473ec00e03aab7">More...</a><br /></td></tr>
<tr class="separator:ae89f2142eefa90a439473ec00e03aab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c5a18d173575e6df8cb7029ac9a1be"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_sigma &gt; </td></tr>
<tr class="memitem:a06c5a18d173575e6df8cb7029ac9a1be"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_sigma &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a06c5a18d173575e6df8cb7029ac9a1be.html#a06c5a18d173575e6df8cb7029ac9a1be">gp_dot_prod_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x1, Eigen::Dynamic, 1 &gt;&gt; &amp;x1, const std::vector&lt; Eigen::Matrix&lt; T_x2, Eigen::Dynamic, 1 &gt;&gt; &amp;x2, const T_sigma &amp;sigma)</td></tr>
<tr class="memdesc:a06c5a18d173575e6df8cb7029ac9a1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a dot product covariance matrix of differing x's.  <a href="namespacestan_1_1math_a06c5a18d173575e6df8cb7029ac9a1be.html#a06c5a18d173575e6df8cb7029ac9a1be">More...</a><br /></td></tr>
<tr class="separator:a06c5a18d173575e6df8cb7029ac9a1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726bb81e697f155cb335d53b49e359cd"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_sigma &gt; </td></tr>
<tr class="memitem:a726bb81e697f155cb335d53b49e359cd"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_sigma &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a726bb81e697f155cb335d53b49e359cd.html#a726bb81e697f155cb335d53b49e359cd">gp_dot_prod_cov</a> (const std::vector&lt; T_x1 &gt; &amp;x1, const std::vector&lt; T_x2 &gt; &amp;x2, const T_sigma &amp;sigma)</td></tr>
<tr class="memdesc:a726bb81e697f155cb335d53b49e359cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a dot product covariance matrix of differing x's.  <a href="namespacestan_1_1math_a726bb81e697f155cb335d53b49e359cd.html#a726bb81e697f155cb335d53b49e359cd">More...</a><br /></td></tr>
<tr class="separator:a726bb81e697f155cb335d53b49e359cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe576a8c4ce809a1125b6073ac125ad5"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , typename T_l &gt; </td></tr>
<tr class="memitem:abe576a8c4ce809a1125b6073ac125ad5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_sigma, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abe576a8c4ce809a1125b6073ac125ad5.html#abe576a8c4ce809a1125b6073ac125ad5">gp_exp_quad_cov</a> (const std::vector&lt; T_x &gt; &amp;x, const T_sigma &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="memdesc:abe576a8c4ce809a1125b6073ac125ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a squared exponential kernel.  <a href="namespacestan_1_1math_abe576a8c4ce809a1125b6073ac125ad5.html#abe576a8c4ce809a1125b6073ac125ad5">More...</a><br /></td></tr>
<tr class="separator:abe576a8c4ce809a1125b6073ac125ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6af976c04b292464916c9532a7b83c"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , typename T_l &gt; </td></tr>
<tr class="memitem:afd6af976c04b292464916c9532a7b83c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_sigma, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afd6af976c04b292464916c9532a7b83c.html#afd6af976c04b292464916c9532a7b83c">gp_exp_quad_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x, -1, 1 &gt;&gt; &amp;x, const T_sigma &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="memdesc:afd6af976c04b292464916c9532a7b83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a squared exponential kernel.  <a href="namespacestan_1_1math_afd6af976c04b292464916c9532a7b83c.html#afd6af976c04b292464916c9532a7b83c">More...</a><br /></td></tr>
<tr class="separator:afd6af976c04b292464916c9532a7b83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412f753b23e6b94a2d88d382fa1078f0"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_sigma , typename T_l &gt; </td></tr>
<tr class="memitem:a412f753b23e6b94a2d88d382fa1078f0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_sigma, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a412f753b23e6b94a2d88d382fa1078f0.html#a412f753b23e6b94a2d88d382fa1078f0">gp_exp_quad_cov</a> (const std::vector&lt; T_x1 &gt; &amp;x1, const std::vector&lt; T_x2 &gt; &amp;x2, const T_sigma &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="memdesc:a412f753b23e6b94a2d88d382fa1078f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a squared exponential kernel.  <a href="namespacestan_1_1math_a412f753b23e6b94a2d88d382fa1078f0.html#a412f753b23e6b94a2d88d382fa1078f0">More...</a><br /></td></tr>
<tr class="separator:a412f753b23e6b94a2d88d382fa1078f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30c052b660dd3da62f6836bb8492f44"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:af30c052b660dd3da62f6836bb8492f44"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af30c052b660dd3da62f6836bb8492f44.html#af30c052b660dd3da62f6836bb8492f44">gp_exp_quad_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x1, -1, 1 &gt;&gt; &amp;x1, const std::vector&lt; Eigen::Matrix&lt; T_x2, -1, 1 &gt;&gt; &amp;x2, const T_s &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="memdesc:af30c052b660dd3da62f6836bb8492f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a squared exponential kernel.  <a href="namespacestan_1_1math_af30c052b660dd3da62f6836bb8492f44.html#af30c052b660dd3da62f6836bb8492f44">More...</a><br /></td></tr>
<tr class="separator:af30c052b660dd3da62f6836bb8492f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8d0f15b7246dab6b820d21490025d5"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:aff8d0f15b7246dab6b820d21490025d5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aff8d0f15b7246dab6b820d21490025d5.html#aff8d0f15b7246dab6b820d21490025d5">gp_exponential_cov</a> (const std::vector&lt; T_x &gt; &amp;x, const T_s &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="memdesc:aff8d0f15b7246dab6b820d21490025d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern exponential covariance Matrix.  <a href="namespacestan_1_1math_aff8d0f15b7246dab6b820d21490025d5.html#aff8d0f15b7246dab6b820d21490025d5">More...</a><br /></td></tr>
<tr class="separator:aff8d0f15b7246dab6b820d21490025d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56f4b4158191ffbfd7b9968ce603d8e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:ad56f4b4158191ffbfd7b9968ce603d8e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad56f4b4158191ffbfd7b9968ce603d8e.html#ad56f4b4158191ffbfd7b9968ce603d8e">gp_exponential_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x, -1, 1 &gt;&gt; &amp;x, const T_s &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="memdesc:ad56f4b4158191ffbfd7b9968ce603d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern exponential covariance matrix.  <a href="namespacestan_1_1math_ad56f4b4158191ffbfd7b9968ce603d8e.html#ad56f4b4158191ffbfd7b9968ce603d8e">More...</a><br /></td></tr>
<tr class="separator:ad56f4b4158191ffbfd7b9968ce603d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416fb6c9ad26ce2f2279e0d796b243a4"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:a416fb6c9ad26ce2f2279e0d796b243a4"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a416fb6c9ad26ce2f2279e0d796b243a4.html#a416fb6c9ad26ce2f2279e0d796b243a4">gp_exponential_cov</a> (const std::vector&lt; T_x1 &gt; &amp;x1, const std::vector&lt; T_x2 &gt; &amp;x2, const T_s &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="memdesc:a416fb6c9ad26ce2f2279e0d796b243a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern exponential cross covariance matrix.  <a href="namespacestan_1_1math_a416fb6c9ad26ce2f2279e0d796b243a4.html#a416fb6c9ad26ce2f2279e0d796b243a4">More...</a><br /></td></tr>
<tr class="separator:a416fb6c9ad26ce2f2279e0d796b243a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef4a38a615005ff8b271ed4964ff982"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:a7ef4a38a615005ff8b271ed4964ff982"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7ef4a38a615005ff8b271ed4964ff982.html#a7ef4a38a615005ff8b271ed4964ff982">gp_exponential_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x1, -1, 1 &gt;&gt; &amp;x1, const std::vector&lt; Eigen::Matrix&lt; T_x2, -1, 1 &gt;&gt; &amp;x2, const T_s &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="memdesc:a7ef4a38a615005ff8b271ed4964ff982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern exponential cross covariance matrix.  <a href="namespacestan_1_1math_a7ef4a38a615005ff8b271ed4964ff982.html#a7ef4a38a615005ff8b271ed4964ff982">More...</a><br /></td></tr>
<tr class="separator:a7ef4a38a615005ff8b271ed4964ff982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8efa309d34dbb6521e8dce0a68616f0"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:ae8efa309d34dbb6521e8dce0a68616f0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae8efa309d34dbb6521e8dce0a68616f0.html#ae8efa309d34dbb6521e8dce0a68616f0">gp_matern32_cov</a> (const std::vector&lt; T_x &gt; &amp;x, const T_s &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="memdesc:ae8efa309d34dbb6521e8dce0a68616f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern 3/2 covariance matrix.  <a href="namespacestan_1_1math_ae8efa309d34dbb6521e8dce0a68616f0.html#ae8efa309d34dbb6521e8dce0a68616f0">More...</a><br /></td></tr>
<tr class="separator:ae8efa309d34dbb6521e8dce0a68616f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f983c5311c59dc7b08f15150e26a76"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:a95f983c5311c59dc7b08f15150e26a76"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a95f983c5311c59dc7b08f15150e26a76.html#a95f983c5311c59dc7b08f15150e26a76">gp_matern32_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x, -1, 1 &gt;&gt; &amp;x, const T_s &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="memdesc:a95f983c5311c59dc7b08f15150e26a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern 3/2 covariance matrix.  <a href="namespacestan_1_1math_a95f983c5311c59dc7b08f15150e26a76.html#a95f983c5311c59dc7b08f15150e26a76">More...</a><br /></td></tr>
<tr class="separator:a95f983c5311c59dc7b08f15150e26a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19ece56fde9587c87a6d6546e2c2785"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:ac19ece56fde9587c87a6d6546e2c2785"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac19ece56fde9587c87a6d6546e2c2785.html#ac19ece56fde9587c87a6d6546e2c2785">gp_matern32_cov</a> (const std::vector&lt; T_x1 &gt; &amp;x1, const std::vector&lt; T_x2 &gt; &amp;x2, const T_s &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="memdesc:ac19ece56fde9587c87a6d6546e2c2785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern 3/2 cross covariance matrix.  <a href="namespacestan_1_1math_ac19ece56fde9587c87a6d6546e2c2785.html#ac19ece56fde9587c87a6d6546e2c2785">More...</a><br /></td></tr>
<tr class="separator:ac19ece56fde9587c87a6d6546e2c2785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d64054b4908bc9f567fcf765e1d7189"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:a3d64054b4908bc9f567fcf765e1d7189"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3d64054b4908bc9f567fcf765e1d7189.html#a3d64054b4908bc9f567fcf765e1d7189">gp_matern32_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x1, -1, 1 &gt;&gt; &amp;x1, const std::vector&lt; Eigen::Matrix&lt; T_x2, -1, 1 &gt;&gt; &amp;x2, const T_s &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="memdesc:a3d64054b4908bc9f567fcf765e1d7189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern 3/2 cross covariance matrix.  <a href="namespacestan_1_1math_a3d64054b4908bc9f567fcf765e1d7189.html#a3d64054b4908bc9f567fcf765e1d7189">More...</a><br /></td></tr>
<tr class="separator:a3d64054b4908bc9f567fcf765e1d7189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad432c610b64f42e5fcf9737f0d9d7702"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:ad432c610b64f42e5fcf9737f0d9d7702"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad432c610b64f42e5fcf9737f0d9d7702.html#ad432c610b64f42e5fcf9737f0d9d7702">gp_matern52_cov</a> (const std::vector&lt; T_x &gt; &amp;x, const T_s &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="memdesc:ad432c610b64f42e5fcf9737f0d9d7702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern 5/2 covariance matrix with one input vector.  <a href="namespacestan_1_1math_ad432c610b64f42e5fcf9737f0d9d7702.html#ad432c610b64f42e5fcf9737f0d9d7702">More...</a><br /></td></tr>
<tr class="separator:ad432c610b64f42e5fcf9737f0d9d7702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fba0fa630231e489683838e2d9dc6c3"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:a1fba0fa630231e489683838e2d9dc6c3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1fba0fa630231e489683838e2d9dc6c3.html#a1fba0fa630231e489683838e2d9dc6c3">gp_matern52_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x, Eigen::Dynamic, 1 &gt;&gt; &amp;x, const T_s &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="memdesc:a1fba0fa630231e489683838e2d9dc6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern 5/2 covariance matrix with one input vector with automatic relevance determination (ARD).  <a href="namespacestan_1_1math_a1fba0fa630231e489683838e2d9dc6c3.html#a1fba0fa630231e489683838e2d9dc6c3">More...</a><br /></td></tr>
<tr class="separator:a1fba0fa630231e489683838e2d9dc6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1021abaab8b19951557095523ebbc4f"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:af1021abaab8b19951557095523ebbc4f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af1021abaab8b19951557095523ebbc4f.html#af1021abaab8b19951557095523ebbc4f">gp_matern52_cov</a> (const std::vector&lt; T_x1 &gt; &amp;x1, const std::vector&lt; T_x2 &gt; &amp;x2, const T_s &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="memdesc:af1021abaab8b19951557095523ebbc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern 5/2 covariance matrix with two different input vectors.  <a href="namespacestan_1_1math_af1021abaab8b19951557095523ebbc4f.html#af1021abaab8b19951557095523ebbc4f">More...</a><br /></td></tr>
<tr class="separator:af1021abaab8b19951557095523ebbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf102aa4c34963b9783693140700f49"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:aacf102aa4c34963b9783693140700f49"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aacf102aa4c34963b9783693140700f49.html#aacf102aa4c34963b9783693140700f49">gp_matern52_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x1, Eigen::Dynamic, 1 &gt;&gt; &amp;x1, const std::vector&lt; Eigen::Matrix&lt; T_x2, Eigen::Dynamic, 1 &gt;&gt; &amp;x2, const T_s &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="memdesc:aacf102aa4c34963b9783693140700f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern 5/2 covariance matrix with two input vectors with automatic relevance determination (ARD).  <a href="namespacestan_1_1math_aacf102aa4c34963b9783693140700f49.html#aacf102aa4c34963b9783693140700f49">More...</a><br /></td></tr>
<tr class="separator:aacf102aa4c34963b9783693140700f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe7eafcdc367ed810e939dae02870d9"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , typename T_l , typename T_p &gt; </td></tr>
<tr class="memitem:a3fe7eafcdc367ed810e939dae02870d9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_sigma, T_l, T_p &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3fe7eafcdc367ed810e939dae02870d9.html#a3fe7eafcdc367ed810e939dae02870d9">gp_periodic_cov</a> (const std::vector&lt; T_x &gt; &amp;x, const T_sigma &amp;sigma, const T_l &amp;l, const T_p &amp;p)</td></tr>
<tr class="memdesc:a3fe7eafcdc367ed810e939dae02870d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a periodic covariance matrix \( \mathbf{K} \) using the input \( \mathbf{X} \).  <a href="namespacestan_1_1math_a3fe7eafcdc367ed810e939dae02870d9.html#a3fe7eafcdc367ed810e939dae02870d9">More...</a><br /></td></tr>
<tr class="separator:a3fe7eafcdc367ed810e939dae02870d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682a6c6549a294e171bbec3626c2018b"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_sigma , typename T_l , typename T_p &gt; </td></tr>
<tr class="memitem:a682a6c6549a294e171bbec3626c2018b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_sigma, T_l, T_p &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a682a6c6549a294e171bbec3626c2018b.html#a682a6c6549a294e171bbec3626c2018b">gp_periodic_cov</a> (const std::vector&lt; T_x1 &gt; &amp;x1, const std::vector&lt; T_x2 &gt; &amp;x2, const T_sigma &amp;sigma, const T_l &amp;l, const T_p &amp;p)</td></tr>
<tr class="memdesc:a682a6c6549a294e171bbec3626c2018b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a periodic covariance matrix \( \mathbf{K} \) using inputs \( \mathbf{X}_1 \) and \( \mathbf{X}_2 \).  <a href="namespacestan_1_1math_a682a6c6549a294e171bbec3626c2018b.html#a682a6c6549a294e171bbec3626c2018b">More...</a><br /></td></tr>
<tr class="separator:a682a6c6549a294e171bbec3626c2018b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1c4494fbd30a9556c2ae46ba525f4c"><td class="memTemplParams" colspan="2">template&lt;bool ReturnSameT, typename T1 , typename T2 , typename T3 , typename T_z , require_not_t&lt; std::integral_constant&lt; bool, ReturnSameT &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afb1c4494fbd30a9556c2ae46ba525f4c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afb1c4494fbd30a9556c2ae46ba525f4c.html#afb1c4494fbd30a9556c2ae46ba525f4c">grad_2F1</a> (const T1 &amp;a1, const T2 &amp;a2, const T3 &amp;b1, const T_z &amp;z, double precision=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-14, int max_steps=1e6)</td></tr>
<tr class="memdesc:afb1c4494fbd30a9556c2ae46ba525f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the gradients of the hypergeometric function (2F1) as the power series stopping when the series converges to within <code>precision</code> or throwing when the function takes <code>max_steps</code> steps.  <a href="namespacestan_1_1math_afb1c4494fbd30a9556c2ae46ba525f4c.html#afb1c4494fbd30a9556c2ae46ba525f4c">More...</a><br /></td></tr>
<tr class="separator:afb1c4494fbd30a9556c2ae46ba525f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04b4d834ce9de8f3e841f8c2c31e2e1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T_z &gt; </td></tr>
<tr class="memitem:aa04b4d834ce9de8f3e841f8c2c31e2e1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa04b4d834ce9de8f3e841f8c2c31e2e1.html#aa04b4d834ce9de8f3e841f8c2c31e2e1">grad_2F1</a> (const T1 &amp;a1, const T2 &amp;a2, const T3 &amp;b1, const T_z &amp;z, double precision=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-14, int max_steps=1e6)</td></tr>
<tr class="memdesc:aa04b4d834ce9de8f3e841f8c2c31e2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the gradients of the hypergeometric function (2F1) as the power series stopping when the series converges to within <code>precision</code> or throwing when the function takes <code>max_steps</code> steps.  <a href="namespacestan_1_1math_aa04b4d834ce9de8f3e841f8c2c31e2e1.html#aa04b4d834ce9de8f3e841f8c2c31e2e1">More...</a><br /></td></tr>
<tr class="separator:aa04b4d834ce9de8f3e841f8c2c31e2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e996db5005a02d2300e45ba0d3037ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e996db5005a02d2300e45ba0d3037ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1e996db5005a02d2300e45ba0d3037ec.html#a1e996db5005a02d2300e45ba0d3037ec">grad_F32</a> (T *g, const T &amp;a1, const T &amp;a2, const T &amp;a3, const T &amp;b1, const T &amp;b2, const T &amp;z, const T &amp;precision=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-6, int max_steps=1e5)</td></tr>
<tr class="memdesc:a1e996db5005a02d2300e45ba0d3037ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradients of the hypergeometric function, 3F2.  <a href="namespacestan_1_1math_a1e996db5005a02d2300e45ba0d3037ec.html#a1e996db5005a02d2300e45ba0d3037ec">More...</a><br /></td></tr>
<tr class="separator:a1e996db5005a02d2300e45ba0d3037ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cb272bd839945c13d7b41058c35c51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a33cb272bd839945c13d7b41058c35c51.html#a33cb272bd839945c13d7b41058c35c51">grad_inc_beta</a> (double &amp;g1, double &amp;g2, double a, double b, double z)</td></tr>
<tr class="separator:a33cb272bd839945c13d7b41058c35c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a223e761fcd5547c60a962a78a2194"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , typename Tz &gt; </td></tr>
<tr class="memitem:a45a223e761fcd5547c60a962a78a2194"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a45a223e761fcd5547c60a962a78a2194.html#a45a223e761fcd5547c60a962a78a2194">grad_pFq</a> (const Ta &amp;a, const Tb &amp;b, const Tz &amp;z, double precision=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-10, int outer_steps=1e6, int inner_steps=1e6)</td></tr>
<tr class="memdesc:a45a223e761fcd5547c60a962a78a2194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for calculating gradients for the generalized hypergeometric function.  <a href="namespacestan_1_1math_a45a223e761fcd5547c60a962a78a2194.html#a45a223e761fcd5547c60a962a78a2194">More...</a><br /></td></tr>
<tr class="separator:a45a223e761fcd5547c60a962a78a2194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b73820cb81a7b6701149d78606ed6e8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b73820cb81a7b6701149d78606ed6e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5b73820cb81a7b6701149d78606ed6e8.html#a5b73820cb81a7b6701149d78606ed6e8">grad_reg_inc_beta</a> (T &amp;g1, T &amp;g2, const T &amp;a, const T &amp;b, const T &amp;z, const T &amp;digammaA, const T &amp;digammaB, const T &amp;digammaSum, const T &amp;betaAB)</td></tr>
<tr class="memdesc:a5b73820cb81a7b6701149d78606ed6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gradients of the regularized incomplete beta function.  <a href="namespacestan_1_1math_a5b73820cb81a7b6701149d78606ed6e8.html#a5b73820cb81a7b6701149d78606ed6e8">More...</a><br /></td></tr>
<tr class="separator:a5b73820cb81a7b6701149d78606ed6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdc9e9a1531848db10abac909b0e4ff"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a6cdc9e9a1531848db10abac909b0e4ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6cdc9e9a1531848db10abac909b0e4ff.html#a6cdc9e9a1531848db10abac909b0e4ff">grad_reg_inc_gamma</a> (T1 a, T2 z, T1 g, T1 dig, double precision=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-6, int max_steps=1e5)</td></tr>
<tr class="memdesc:a6cdc9e9a1531848db10abac909b0e4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradient of the regularized incomplete gamma functions igamma(a, z)  <a href="namespacestan_1_1math_a6cdc9e9a1531848db10abac909b0e4ff.html#a6cdc9e9a1531848db10abac909b0e4ff">More...</a><br /></td></tr>
<tr class="separator:a6cdc9e9a1531848db10abac909b0e4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b76012fc8f408fe9092d1fb5917d1e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a41b76012fc8f408fe9092d1fb5917d1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a41b76012fc8f408fe9092d1fb5917d1e.html#a41b76012fc8f408fe9092d1fb5917d1e">grad_reg_lower_inc_gamma</a> (const T1 &amp;a, const T2 &amp;z, double precision=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-10, int max_steps=1e5)</td></tr>
<tr class="memdesc:a41b76012fc8f408fe9092d1fb5917d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gradient of the lower regularized incomplete gamma function.  <a href="namespacestan_1_1math_a41b76012fc8f408fe9092d1fb5917d1e.html#a41b76012fc8f408fe9092d1fb5917d1e">More...</a><br /></td></tr>
<tr class="separator:a41b76012fc8f408fe9092d1fb5917d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628f51eb7526cedbf71f9dce433c8581"><td class="memTemplParams" colspan="2">template&lt;typename T , require_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a628f51eb7526cedbf71f9dce433c8581"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a628f51eb7526cedbf71f9dce433c8581.html#a628f51eb7526cedbf71f9dce433c8581">head</a> (const T &amp;v, size_t n)</td></tr>
<tr class="memdesc:a628f51eb7526cedbf71f9dce433c8581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a vector or row vector (same as input) from the front of the specified vector or row vector.  <a href="namespacestan_1_1math_a628f51eb7526cedbf71f9dce433c8581.html#a628f51eb7526cedbf71f9dce433c8581">More...</a><br /></td></tr>
<tr class="separator:a628f51eb7526cedbf71f9dce433c8581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e746ba14994b318a0a192a97a0a28db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e746ba14994b318a0a192a97a0a28db"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5e746ba14994b318a0a192a97a0a28db.html#a5e746ba14994b318a0a192a97a0a28db">head</a> (const std::vector&lt; T &gt; &amp;sv, size_t n)</td></tr>
<tr class="memdesc:a5e746ba14994b318a0a192a97a0a28db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a standard vector from the front of the specified standard vector.  <a href="namespacestan_1_1math_a5e746ba14994b318a0a192a97a0a28db.html#a5e746ba14994b318a0a192a97a0a28db">More...</a><br /></td></tr>
<tr class="separator:a5e746ba14994b318a0a192a97a0a28db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089a7a270f65d5693820f56b1774320b"><td class="memTemplParams" colspan="2">template&lt;typename Ta1 , typename Ta2 , typename Tb , typename Tz , typename ScalarT  = return_type_t&lt;Ta1, Ta1, Tb, Tz&gt;, typename OptT  = boost::optional&lt;ScalarT&gt;, require_all_arithmetic_t&lt; Ta1, Ta2, Tb, Tz &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a089a7a270f65d5693820f56b1774320b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Ta1, Ta1, Tb, Tz &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a089a7a270f65d5693820f56b1774320b.html#a089a7a270f65d5693820f56b1774320b">hypergeometric_2F1</a> (const Ta1 &amp;a1, const Ta2 &amp;a2, const Tb &amp;b, const Tz &amp;z)</td></tr>
<tr class="memdesc:a089a7a270f65d5693820f56b1774320b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gauss hypergeometric function applied to the input arguments: \(_2F_1(a_1,a_2;b;z)\).  <a href="namespacestan_1_1math_a089a7a270f65d5693820f56b1774320b.html#a089a7a270f65d5693820f56b1774320b">More...</a><br /></td></tr>
<tr class="separator:a089a7a270f65d5693820f56b1774320b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7191eed856953cdd6ddc881dd3eeba85"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , typename Tz , require_all_eigen_t&lt; Ta, Tb &gt; *  = nullptr, require_stan_scalar_t&lt; Tz &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7191eed856953cdd6ddc881dd3eeba85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Ta, Tb, Tz &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7191eed856953cdd6ddc881dd3eeba85.html#a7191eed856953cdd6ddc881dd3eeba85">hypergeometric_2F2</a> (const Ta &amp;a, const Tb &amp;b, const Tz &amp;z)</td></tr>
<tr class="memdesc:a7191eed856953cdd6ddc881dd3eeba85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the generalised hypergeometric function applied to the input arguments: \(_2F_2(a_1,a_2;b_1,b_2;z)\).  <a href="namespacestan_1_1math_a7191eed856953cdd6ddc881dd3eeba85.html#a7191eed856953cdd6ddc881dd3eeba85">More...</a><br /></td></tr>
<tr class="separator:a7191eed856953cdd6ddc881dd3eeba85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cf8aebb689a21c7b30572d82c73889"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_arithmetic_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a79cf8aebb689a21c7b30572d82c73889"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a79cf8aebb689a21c7b30572d82c73889.html#a79cf8aebb689a21c7b30572d82c73889">hypot</a> (T1 x, T2 y)</td></tr>
<tr class="memdesc:a79cf8aebb689a21c7b30572d82c73889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of the hypotenuse of a right triangle with opposite and adjacent side lengths given by the specified arguments (C++11).  <a href="namespacestan_1_1math_a79cf8aebb689a21c7b30572d82c73889.html#a79cf8aebb689a21c7b30572d82c73889">More...</a><br /></td></tr>
<tr class="separator:a79cf8aebb689a21c7b30572d82c73889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe83cc912462e15f4d7f47ac13262852"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afe83cc912462e15f4d7f47ac13262852"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afe83cc912462e15f4d7f47ac13262852.html#afe83cc912462e15f4d7f47ac13262852">hypot</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:afe83cc912462e15f4d7f47ac13262852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the hypot function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_afe83cc912462e15f4d7f47ac13262852.html#afe83cc912462e15f4d7f47ac13262852">More...</a><br /></td></tr>
<tr class="separator:afe83cc912462e15f4d7f47ac13262852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada38c73acfdbf9f89c30e1cc46e1002d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada38c73acfdbf9f89c30e1cc46e1002d"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ada38c73acfdbf9f89c30e1cc46e1002d.html#ada38c73acfdbf9f89c30e1cc46e1002d">i_times</a> (const std::complex&lt; T &gt; &amp;z)</td></tr>
<tr class="memdesc:ada38c73acfdbf9f89c30e1cc46e1002d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified complex number multiplied by <code>i</code>.  <a href="namespacestan_1_1math_ada38c73acfdbf9f89c30e1cc46e1002d.html#ada38c73acfdbf9f89c30e1cc46e1002d">More...</a><br /></td></tr>
<tr class="separator:ada38c73acfdbf9f89c30e1cc46e1002d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b304da43111a382ec74af567ac6938"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a52b304da43111a382ec74af567ac6938"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a52b304da43111a382ec74af567ac6938.html#a52b304da43111a382ec74af567ac6938">neg_i_times</a> (const std::complex&lt; T &gt; &amp;z)</td></tr>
<tr class="memdesc:a52b304da43111a382ec74af567ac6938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified complex number multiplied by <code>-i</code>.  <a href="namespacestan_1_1math_a52b304da43111a382ec74af567ac6938.html#a52b304da43111a382ec74af567ac6938">More...</a><br /></td></tr>
<tr class="separator:a52b304da43111a382ec74af567ac6938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201527126997d75e3684850a84e651c1"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a201527126997d75e3684850a84e651c1"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a201527126997d75e3684850a84e651c1.html#a201527126997d75e3684850a84e651c1">complex_negate</a> (const std::complex&lt; V &gt; &amp;z)</td></tr>
<tr class="memdesc:a201527126997d75e3684850a84e651c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the complex negation of the specified complex argument.  <a href="namespacestan_1_1math_a201527126997d75e3684850a84e651c1.html#a201527126997d75e3684850a84e651c1">More...</a><br /></td></tr>
<tr class="separator:a201527126997d75e3684850a84e651c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaec8ce3421eae60ef5a95850908176e"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian = false, typename T , typename... Types, require_all_not_var_matrix_t&lt; T, Types... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeaec8ce3421eae60ef5a95850908176e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeaec8ce3421eae60ef5a95850908176e.html#aeaec8ce3421eae60ef5a95850908176e">identity_constrain</a> (T &amp;&amp;x, Types &amp;&amp;...)</td></tr>
<tr class="memdesc:aeaec8ce3421eae60ef5a95850908176e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of applying the identity constraint transform to the input.  <a href="namespacestan_1_1math_aeaec8ce3421eae60ef5a95850908176e.html#aeaec8ce3421eae60ef5a95850908176e">More...</a><br /></td></tr>
<tr class="separator:aeaec8ce3421eae60ef5a95850908176e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be3dea70cebcb8e664fcc5f049661b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types, require_all_not_var_matrix_t&lt; T, Types... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5be3dea70cebcb8e664fcc5f049661b9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5be3dea70cebcb8e664fcc5f049661b9.html#a5be3dea70cebcb8e664fcc5f049661b9">identity_free</a> (T &amp;&amp;x, Types &amp;&amp;...)</td></tr>
<tr class="memdesc:a5be3dea70cebcb8e664fcc5f049661b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of applying the inverse of the identity constraint transform to the input.  <a href="namespacestan_1_1math_a5be3dea70cebcb8e664fcc5f049661b9.html#a5be3dea70cebcb8e664fcc5f049661b9">More...</a><br /></td></tr>
<tr class="separator:a5be3dea70cebcb8e664fcc5f049661b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa990a33cef66344e8a15af4f264e3ac6"><td class="memTemplParams" colspan="2">template&lt;typename T_true , typename T_false &gt; </td></tr>
<tr class="memitem:aa990a33cef66344e8a15af4f264e3ac6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_true, T_false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa990a33cef66344e8a15af4f264e3ac6.html#aa990a33cef66344e8a15af4f264e3ac6">if_else</a> (const bool c, const T_true y_true, const T_false y_false)</td></tr>
<tr class="memdesc:aa990a33cef66344e8a15af4f264e3ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the second argument if the first argument is true and otherwise return the second argument.  <a href="namespacestan_1_1math_aa990a33cef66344e8a15af4f264e3ac6.html#aa990a33cef66344e8a15af4f264e3ac6">More...</a><br /></td></tr>
<tr class="separator:aa990a33cef66344e8a15af4f264e3ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61eebd126447446d428c170d9ba952e6"><td class="memTemplParams" colspan="2">template&lt;typename T , require_autodiff_t&lt; T &gt; &gt; </td></tr>
<tr class="memitem:a61eebd126447446d428c170d9ba952e6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a61eebd126447446d428c170d9ba952e6.html#a61eebd126447446d428c170d9ba952e6">imag</a> (const std::complex&lt; T &gt; &amp;z)</td></tr>
<tr class="memdesc:a61eebd126447446d428c170d9ba952e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the imaginary component of the complex argument.  <a href="namespacestan_1_1math_a61eebd126447446d428c170d9ba952e6.html#a61eebd126447446d428c170d9ba952e6">More...</a><br /></td></tr>
<tr class="separator:a61eebd126447446d428c170d9ba952e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fada3940c12a45aed49750fe845ae57"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5fada3940c12a45aed49750fe845ae57.html#a5fada3940c12a45aed49750fe845ae57">inc_beta</a> (double a, double b, double x)</td></tr>
<tr class="memdesc:a5fada3940c12a45aed49750fe845ae57"><td class="mdescLeft">&#160;</td><td class="mdescRight">The normalized incomplete beta function of a, b, with outcome x.  <a href="namespacestan_1_1math_a5fada3940c12a45aed49750fe845ae57.html#a5fada3940c12a45aed49750fe845ae57">More...</a><br /></td></tr>
<tr class="separator:a5fada3940c12a45aed49750fe845ae57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c265eb14e915edc9bd457e93aaaf166"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c265eb14e915edc9bd457e93aaaf166"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9c265eb14e915edc9bd457e93aaaf166.html#a9c265eb14e915edc9bd457e93aaaf166">inc_beta_dda</a> (T a, T b, T z, T digamma_a, T digamma_ab)</td></tr>
<tr class="memdesc:a9c265eb14e915edc9bd457e93aaaf166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the partial derivative of the regularized incomplete beta function, I_{z}(a, b) with respect to a.  <a href="namespacestan_1_1math_a9c265eb14e915edc9bd457e93aaaf166.html#a9c265eb14e915edc9bd457e93aaaf166">More...</a><br /></td></tr>
<tr class="separator:a9c265eb14e915edc9bd457e93aaaf166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc99a6a1e74fd1daeab96f7eeb3b05a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc99a6a1e74fd1daeab96f7eeb3b05a8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afc99a6a1e74fd1daeab96f7eeb3b05a8.html#afc99a6a1e74fd1daeab96f7eeb3b05a8">inc_beta_ddb</a> (T a, T b, T z, T digamma_b, T digamma_ab)</td></tr>
<tr class="memdesc:afc99a6a1e74fd1daeab96f7eeb3b05a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the partial derivative of the regularized incomplete beta function, I_{z}(a, b) with respect to b.  <a href="namespacestan_1_1math_afc99a6a1e74fd1daeab96f7eeb3b05a8.html#afc99a6a1e74fd1daeab96f7eeb3b05a8">More...</a><br /></td></tr>
<tr class="separator:afc99a6a1e74fd1daeab96f7eeb3b05a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2412f96d2114b4c15efb1ddbddaef35b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2412f96d2114b4c15efb1ddbddaef35b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2412f96d2114b4c15efb1ddbddaef35b.html#a2412f96d2114b4c15efb1ddbddaef35b">inc_beta_ddz</a> (T a, T b, T z)</td></tr>
<tr class="memdesc:a2412f96d2114b4c15efb1ddbddaef35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the partial derivative of the regularized incomplete beta function, I_{z}(a, b) with respect to z.  <a href="namespacestan_1_1math_a2412f96d2114b4c15efb1ddbddaef35b.html#a2412f96d2114b4c15efb1ddbddaef35b">More...</a><br /></td></tr>
<tr class="separator:a2412f96d2114b4c15efb1ddbddaef35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5957e2cb19140e6c7bacf5c68320b7"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3e5957e2cb19140e6c7bacf5c68320b7"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3e5957e2cb19140e6c7bacf5c68320b7.html#a3e5957e2cb19140e6c7bacf5c68320b7">inc_beta_ddz</a> (double a, double b, double z)</td></tr>
<tr class="separator:a3e5957e2cb19140e6c7bacf5c68320b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34507a08b7a507e638b304b614ef1311"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V , require_all_stan_scalar_t&lt; T, V &gt; *  = nullptr, require_convertible_t&lt; V, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a34507a08b7a507e638b304b614ef1311"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a34507a08b7a507e638b304b614ef1311.html#a34507a08b7a507e638b304b614ef1311">initialize</a> (T &amp;x, V v)</td></tr>
<tr class="separator:a34507a08b7a507e638b304b614ef1311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb47e7569cabd57a1c0c6816ca48293"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C, typename V &gt; </td></tr>
<tr class="memitem:a1cb47e7569cabd57a1c0c6816ca48293"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1cb47e7569cabd57a1c0c6816ca48293.html#a1cb47e7569cabd57a1c0c6816ca48293">initialize</a> (Eigen::Matrix&lt; T, R, C &gt; &amp;x, const V &amp;v)</td></tr>
<tr class="separator:a1cb47e7569cabd57a1c0c6816ca48293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27706378f77dc22746ad74721d495d4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ad27706378f77dc22746ad74721d495d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad27706378f77dc22746ad74721d495d4.html#ad27706378f77dc22746ad74721d495d4">initialize</a> (std::vector&lt; T &gt; &amp;x, const V &amp;v)</td></tr>
<tr class="separator:ad27706378f77dc22746ad74721d495d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee985a4eda856634569eeb4dd299d3d"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename S , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_stan_scalar_t&lt; S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8ee985a4eda856634569eeb4dd299d3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8ee985a4eda856634569eeb4dd299d3d.html#a8ee985a4eda856634569eeb4dd299d3d">initialize_fill</a> (EigMat &amp;x, const S &amp;y)</td></tr>
<tr class="memdesc:a8ee985a4eda856634569eeb4dd299d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <a href="namespacestan_1_1math_a8ee985a4eda856634569eeb4dd299d3d.html#a8ee985a4eda856634569eeb4dd299d3d">More...</a><br /></td></tr>
<tr class="separator:a8ee985a4eda856634569eeb4dd299d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0079527e3b721f4740873ff283136911"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S , require_t&lt; std::is_assignable&lt; std::decay_t&lt; T &gt; &amp;, std::decay_t&lt; S &gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0079527e3b721f4740873ff283136911"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0079527e3b721f4740873ff283136911.html#a0079527e3b721f4740873ff283136911">initialize_fill</a> (T &amp;x, S &amp;&amp;y)</td></tr>
<tr class="memdesc:a0079527e3b721f4740873ff283136911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <a href="namespacestan_1_1math_a0079527e3b721f4740873ff283136911.html#a0079527e3b721f4740873ff283136911">More...</a><br /></td></tr>
<tr class="separator:a0079527e3b721f4740873ff283136911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093b6b3a42514835ad8e4b5e741ac8c6"><td class="memTemplParams" colspan="2">template&lt;typename Vec , typename S , require_std_vector_t&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a093b6b3a42514835ad8e4b5e741ac8c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a093b6b3a42514835ad8e4b5e741ac8c6.html#a093b6b3a42514835ad8e4b5e741ac8c6">initialize_fill</a> (Vec &amp;x, S &amp;&amp;y)</td></tr>
<tr class="memdesc:a093b6b3a42514835ad8e4b5e741ac8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <a href="namespacestan_1_1math_a093b6b3a42514835ad8e4b5e741ac8c6.html#a093b6b3a42514835ad8e4b5e741ac8c6">More...</a><br /></td></tr>
<tr class="separator:a093b6b3a42514835ad8e4b5e741ac8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f65194aba95541f409d496c7ec90187"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f65194aba95541f409d496c7ec90187"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1f65194aba95541f409d496c7ec90187.html#a1f65194aba95541f409d496c7ec90187">int_step</a> (const T &amp;y)</td></tr>
<tr class="memdesc:a1f65194aba95541f409d496c7ec90187"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integer step, or Heaviside, function.  <a href="namespacestan_1_1math_a1f65194aba95541f409d496c7ec90187.html#a1f65194aba95541f409d496c7ec90187">More...</a><br /></td></tr>
<tr class="separator:a1f65194aba95541f409d496c7ec90187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab575aafb07e346dd7cfc4f9eb934d666"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_container_st&lt; std::is_arithmetic, T &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab575aafb07e346dd7cfc4f9eb934d666"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab575aafb07e346dd7cfc4f9eb934d666.html#ab575aafb07e346dd7cfc4f9eb934d666">inv</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ab575aafb07e346dd7cfc4f9eb934d666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise 1.0 / x of the specified argument, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_ab575aafb07e346dd7cfc4f9eb934d666.html#ab575aafb07e346dd7cfc4f9eb934d666">More...</a><br /></td></tr>
<tr class="separator:ab575aafb07e346dd7cfc4f9eb934d666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeaef46e5b7e686cd1f01e730ffe7d41"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeeaef46e5b7e686cd1f01e730ffe7d41"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeeaef46e5b7e686cd1f01e730ffe7d41.html#aeeaef46e5b7e686cd1f01e730ffe7d41">inv</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:aeeaef46e5b7e686cd1f01e730ffe7d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_a2a5386561ba622e05cb64345fdad6a3b.html#a2a5386561ba622e05cb64345fdad6a3b">inv()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_aeeaef46e5b7e686cd1f01e730ffe7d41.html#aeeaef46e5b7e686cd1f01e730ffe7d41">More...</a><br /></td></tr>
<tr class="separator:aeeaef46e5b7e686cd1f01e730ffe7d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2db64bbb86b2cf0fde9a524bc9c6cc5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af2db64bbb86b2cf0fde9a524bc9c6cc5.html#af2db64bbb86b2cf0fde9a524bc9c6cc5">inv_cloglog</a> (double x)</td></tr>
<tr class="memdesc:af2db64bbb86b2cf0fde9a524bc9c6cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse complementary log-log function.  <a href="namespacestan_1_1math_af2db64bbb86b2cf0fde9a524bc9c6cc5.html#af2db64bbb86b2cf0fde9a524bc9c6cc5">More...</a><br /></td></tr>
<tr class="separator:af2db64bbb86b2cf0fde9a524bc9c6cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cf01f803bf177c94fdf04e19ded693"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad4cf01f803bf177c94fdf04e19ded693"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad4cf01f803bf177c94fdf04e19ded693.html#ad4cf01f803bf177c94fdf04e19ded693">inv_cloglog</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ad4cf01f803bf177c94fdf04e19ded693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_aba00ed1e73c3a2366226aa4c83e4d8b9.html#aba00ed1e73c3a2366226aa4c83e4d8b9">inv_cloglog()</a>.  <a href="namespacestan_1_1math_ad4cf01f803bf177c94fdf04e19ded693.html#ad4cf01f803bf177c94fdf04e19ded693">More...</a><br /></td></tr>
<tr class="separator:ad4cf01f803bf177c94fdf04e19ded693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa1533d79beac91c9fc9b6d9d612547"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3fa1533d79beac91c9fc9b6d9d612547"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3fa1533d79beac91c9fc9b6d9d612547.html#a3fa1533d79beac91c9fc9b6d9d612547">inv_cloglog</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a3fa1533d79beac91c9fc9b6d9d612547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="namespacestan_1_1math_aba00ed1e73c3a2366226aa4c83e4d8b9.html#aba00ed1e73c3a2366226aa4c83e4d8b9">inv_cloglog()</a> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_a3fa1533d79beac91c9fc9b6d9d612547.html#a3fa1533d79beac91c9fc9b6d9d612547">More...</a><br /></td></tr>
<tr class="separator:a3fa1533d79beac91c9fc9b6d9d612547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e23342723ebe97f5bc565be353cbce8"><td class="memTemplParams" colspan="2">template&lt;typename T , require_arithmetic_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2e23342723ebe97f5bc565be353cbce8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2e23342723ebe97f5bc565be353cbce8.html#a2e23342723ebe97f5bc565be353cbce8">inv_erfc</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a2e23342723ebe97f5bc565be353cbce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse complementary error function for variables.  <a href="namespacestan_1_1math_a2e23342723ebe97f5bc565be353cbce8.html#a2e23342723ebe97f5bc565be353cbce8">More...</a><br /></td></tr>
<tr class="separator:a2e23342723ebe97f5bc565be353cbce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9087337af2d434c33dd8ae01b04049c"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr, require_not_var_matrix_t&lt; T &gt; *  = nullptr, require_not_arithmetic_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae9087337af2d434c33dd8ae01b04049c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae9087337af2d434c33dd8ae01b04049c.html#ae9087337af2d434c33dd8ae01b04049c">inv_erfc</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae9087337af2d434c33dd8ae01b04049c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a0863d6644325ad15404de50346785e55.html#a0863d6644325ad15404de50346785e55">inv_erfc()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_ae9087337af2d434c33dd8ae01b04049c.html#ae9087337af2d434c33dd8ae01b04049c">More...</a><br /></td></tr>
<tr class="separator:ae9087337af2d434c33dd8ae01b04049c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cca4efbd4462c9f1c4815e1e92672a2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3cca4efbd4462c9f1c4815e1e92672a2.html#a3cca4efbd4462c9f1c4815e1e92672a2">inv_inc_beta</a> (double a, double b, double p)</td></tr>
<tr class="memdesc:a3cca4efbd4462c9f1c4815e1e92672a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of the normalized incomplete beta function of a, b, with probability p.  <a href="namespacestan_1_1math_a3cca4efbd4462c9f1c4815e1e92672a2.html#a3cca4efbd4462c9f1c4815e1e92672a2">More...</a><br /></td></tr>
<tr class="separator:a3cca4efbd4462c9f1c4815e1e92672a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d68af3b629d4048e4044c7db23a1dc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a91d68af3b629d4048e4044c7db23a1dc.html#a91d68af3b629d4048e4044c7db23a1dc">inv_logit</a> (double a)</td></tr>
<tr class="memdesc:a91d68af3b629d4048e4044c7db23a1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse logit function applied to the argument.  <a href="namespacestan_1_1math_a91d68af3b629d4048e4044c7db23a1dc.html#a91d68af3b629d4048e4044c7db23a1dc">More...</a><br /></td></tr>
<tr class="separator:a91d68af3b629d4048e4044c7db23a1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80bc90009bf507958baf4a4e349ec75"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_var_matrix_t&lt; T &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae80bc90009bf507958baf4a4e349ec75"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae80bc90009bf507958baf4a4e349ec75.html#ae80bc90009bf507958baf4a4e349ec75">inv_logit</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae80bc90009bf507958baf4a4e349ec75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a76a22ee34432be58edb4b6ed9469370a.html#a76a22ee34432be58edb4b6ed9469370a" title="Returns the inverse logit function applied to the argument.">inv_logit()</a>.  <a href="namespacestan_1_1math_ae80bc90009bf507958baf4a4e349ec75.html#ae80bc90009bf507958baf4a4e349ec75">More...</a><br /></td></tr>
<tr class="separator:ae80bc90009bf507958baf4a4e349ec75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ce9274d4f9c0ebe500fbe3a0ac4560"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a24ce9274d4f9c0ebe500fbe3a0ac4560.html#a24ce9274d4f9c0ebe500fbe3a0ac4560">inv_Phi</a> (double p)</td></tr>
<tr class="memdesc:a24ce9274d4f9c0ebe500fbe3a0ac4560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the inverse standard normal cumulative distribution function at the specified argument.  <a href="namespacestan_1_1math_a24ce9274d4f9c0ebe500fbe3a0ac4560.html#a24ce9274d4f9c0ebe500fbe3a0ac4560">More...</a><br /></td></tr>
<tr class="separator:a24ce9274d4f9c0ebe500fbe3a0ac4560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78758abb894bd7858957d5fe9ed8ccb7"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr, require_not_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a78758abb894bd7858957d5fe9ed8ccb7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a78758abb894bd7858957d5fe9ed8ccb7.html#a78758abb894bd7858957d5fe9ed8ccb7">inv_Phi</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a78758abb894bd7858957d5fe9ed8ccb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a91bcae4b6bdf262f91673bf7b15fea99.html#a91bcae4b6bdf262f91673bf7b15fea99">inv_Phi()</a>.  <a href="namespacestan_1_1math_a78758abb894bd7858957d5fe9ed8ccb7.html#a78758abb894bd7858957d5fe9ed8ccb7">More...</a><br /></td></tr>
<tr class="separator:a78758abb894bd7858957d5fe9ed8ccb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa406f7949d4de03bf81dd1bed803c0e"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaa406f7949d4de03bf81dd1bed803c0e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaa406f7949d4de03bf81dd1bed803c0e.html#aaa406f7949d4de03bf81dd1bed803c0e">inv_sqrt</a> (T x)</td></tr>
<tr class="separator:aaa406f7949d4de03bf81dd1bed803c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63baaee2585060aca55cab924d3f4fc"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr, require_not_stan_scalar_t&lt; Container &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab63baaee2585060aca55cab924d3f4fc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab63baaee2585060aca55cab924d3f4fc.html#ab63baaee2585060aca55cab924d3f4fc">inv_sqrt</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ab63baaee2585060aca55cab924d3f4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise <code>1 / sqrt(x)}</code> of the specified argument, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_ab63baaee2585060aca55cab924d3f4fc.html#ab63baaee2585060aca55cab924d3f4fc">More...</a><br /></td></tr>
<tr class="separator:ab63baaee2585060aca55cab924d3f4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eca69ce438e1bb35fe0ac6478f2bbdf"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_var_matrix_t&lt; Container &gt; *  = nullptr, require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0eca69ce438e1bb35fe0ac6478f2bbdf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0eca69ce438e1bb35fe0ac6478f2bbdf.html#a0eca69ce438e1bb35fe0ac6478f2bbdf">inv_sqrt</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a0eca69ce438e1bb35fe0ac6478f2bbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_aca2d4971bfd22beacb304bdd5b9d3395.html#aca2d4971bfd22beacb304bdd5b9d3395">inv_sqrt()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_a0eca69ce438e1bb35fe0ac6478f2bbdf.html#a0eca69ce438e1bb35fe0ac6478f2bbdf">More...</a><br /></td></tr>
<tr class="separator:a0eca69ce438e1bb35fe0ac6478f2bbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad899b08240100518db6dc0e761ef6f98"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad899b08240100518db6dc0e761ef6f98"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad899b08240100518db6dc0e761ef6f98.html#ad899b08240100518db6dc0e761ef6f98">inv_square</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ad899b08240100518db6dc0e761ef6f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>1 / square(x)</code>.  <a href="namespacestan_1_1math_ad899b08240100518db6dc0e761ef6f98.html#ad899b08240100518db6dc0e761ef6f98">More...</a><br /></td></tr>
<tr class="separator:ad899b08240100518db6dc0e761ef6f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177d121abcc2600b862d0e0db04ac14d"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a177d121abcc2600b862d0e0db04ac14d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a177d121abcc2600b862d0e0db04ac14d.html#a177d121abcc2600b862d0e0db04ac14d">inv_square</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a177d121abcc2600b862d0e0db04ac14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="namespacestan_1_1math_aa7c1f6b0f3c9f48fa30e09f2d929336d.html#aa7c1f6b0f3c9f48fa30e09f2d929336d">inv_square()</a> that accepts <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions.  <a href="namespacestan_1_1math_a177d121abcc2600b862d0e0db04ac14d.html#a177d121abcc2600b862d0e0db04ac14d">More...</a><br /></td></tr>
<tr class="separator:a177d121abcc2600b862d0e0db04ac14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad080307f51eea3c092265fd6dd67549d"><td class="memTemplParams" colspan="2">template&lt;typename Vector , require_vector_t&lt; Vector &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad080307f51eea3c092265fd6dd67549d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad080307f51eea3c092265fd6dd67549d.html#ad080307f51eea3c092265fd6dd67549d">inverse_softmax</a> (const Vector &amp;simplex, Vector &amp;y)</td></tr>
<tr class="memdesc:ad080307f51eea3c092265fd6dd67549d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the inverse softmax of the simplex argument into the second argument.  <a href="namespacestan_1_1math_ad080307f51eea3c092265fd6dd67549d.html#ad080307f51eea3c092265fd6dd67549d">More...</a><br /></td></tr>
<tr class="separator:ad080307f51eea3c092265fd6dd67549d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c36c6078280b815f2ee32f600cc0dc1"><td class="memTemplParams" colspan="2">template&lt;typename EigMat &gt; </td></tr>
<tr class="memitem:a2c36c6078280b815f2ee32f600cc0dc1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2c36c6078280b815f2ee32f600cc0dc1.html#a2c36c6078280b815f2ee32f600cc0dc1">inverse_spd</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a2c36c6078280b815f2ee32f600cc0dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of the specified symmetric, pos/neg-definite matrix.  <a href="namespacestan_1_1math_a2c36c6078280b815f2ee32f600cc0dc1.html#a2c36c6078280b815f2ee32f600cc0dc1">More...</a><br /></td></tr>
<tr class="separator:a2c36c6078280b815f2ee32f600cc0dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e07e16a252f5b2327cf97bac22ac33"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae5e07e16a252f5b2327cf97bac22ac33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae5e07e16a252f5b2327cf97bac22ac33.html#ae5e07e16a252f5b2327cf97bac22ac33">is_any_nan</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae5e07e16a252f5b2327cf97bac22ac33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the input is NaN and false otherwise.  <a href="namespacestan_1_1math_ae5e07e16a252f5b2327cf97bac22ac33.html#ae5e07e16a252f5b2327cf97bac22ac33">More...</a><br /></td></tr>
<tr class="separator:ae5e07e16a252f5b2327cf97bac22ac33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22717ad06cad8be927efbe7c74d52cd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:ab22717ad06cad8be927efbe7c74d52cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab22717ad06cad8be927efbe7c74d52cd.html#ab22717ad06cad8be927efbe7c74d52cd">is_any_nan</a> (const T &amp;x, const Ts &amp;... xs)</td></tr>
<tr class="memdesc:ab22717ad06cad8be927efbe7c74d52cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if any input is NaN and false otherwise.  <a href="namespacestan_1_1math_ab22717ad06cad8be927efbe7c74d52cd.html#ab22717ad06cad8be927efbe7c74d52cd">More...</a><br /></td></tr>
<tr class="separator:ab22717ad06cad8be927efbe7c74d52cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273d56418e376b9d9b49c50a4b4abc46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a273d56418e376b9d9b49c50a4b4abc46.html#a273d56418e376b9d9b49c50a4b4abc46">is_inf</a> (double x)</td></tr>
<tr class="memdesc:a273d56418e376b9d9b49c50a4b4abc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the input is infinite and false otherwise.  <a href="namespacestan_1_1math_a273d56418e376b9d9b49c50a4b4abc46.html#a273d56418e376b9d9b49c50a4b4abc46">More...</a><br /></td></tr>
<tr class="separator:a273d56418e376b9d9b49c50a4b4abc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1168db19a6fedad3d1389bc73be60f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf1168db19a6fedad3d1389bc73be60f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaf1168db19a6fedad3d1389bc73be60f.html#aaf1168db19a6fedad3d1389bc73be60f">is_integer</a> (T x)</td></tr>
<tr class="memdesc:aaf1168db19a6fedad3d1389bc73be60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the input is an integer and false otherwise.  <a href="namespacestan_1_1math_aaf1168db19a6fedad3d1389bc73be60f.html#aaf1168db19a6fedad3d1389bc73be60f">More...</a><br /></td></tr>
<tr class="separator:aaf1168db19a6fedad3d1389bc73be60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4affa7de6f01f5cccd402781c0d9b83a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a4affa7de6f01f5cccd402781c0d9b83a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4affa7de6f01f5cccd402781c0d9b83a.html#a4affa7de6f01f5cccd402781c0d9b83a">is_nan</a> (T x)</td></tr>
<tr class="memdesc:a4affa7de6f01f5cccd402781c0d9b83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the input is NaN and false otherwise.  <a href="namespacestan_1_1math_a4affa7de6f01f5cccd402781c0d9b83a.html#a4affa7de6f01f5cccd402781c0d9b83a">More...</a><br /></td></tr>
<tr class="separator:a4affa7de6f01f5cccd402781c0d9b83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17467f023eab6f274732132434fd44f9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_eigen_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a17467f023eab6f274732132434fd44f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a17467f023eab6f274732132434fd44f9.html#a17467f023eab6f274732132434fd44f9">is_nan</a> (const T &amp;x)</td></tr>
<tr class="separator:a17467f023eab6f274732132434fd44f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcec73152fe82aca7c9b44ab2b8536bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abcec73152fe82aca7c9b44ab2b8536bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abcec73152fe82aca7c9b44ab2b8536bd.html#abcec73152fe82aca7c9b44ab2b8536bd">is_nonpositive_integer</a> (T x)</td></tr>
<tr class="memdesc:abcec73152fe82aca7c9b44ab2b8536bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the input is a nonpositive integer and false otherwise.  <a href="namespacestan_1_1math_abcec73152fe82aca7c9b44ab2b8536bd.html#abcec73152fe82aca7c9b44ab2b8536bd">More...</a><br /></td></tr>
<tr class="separator:abcec73152fe82aca7c9b44ab2b8536bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c14c26dc55a985e05695b3ff1eeef2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40c14c26dc55a985e05695b3ff1eeef2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a40c14c26dc55a985e05695b3ff1eeef2.html#a40c14c26dc55a985e05695b3ff1eeef2">is_uninitialized</a> (T x)</td></tr>
<tr class="memdesc:a40c14c26dc55a985e05695b3ff1eeef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the specified variable is uninitialized.  <a href="namespacestan_1_1math_a40c14c26dc55a985e05695b3ff1eeef2.html#a40c14c26dc55a985e05695b3ff1eeef2">More...</a><br /></td></tr>
<tr class="separator:a40c14c26dc55a985e05695b3ff1eeef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511adcae58163983f2eb5623df58d5c7"><td class="memTemplParams" colspan="2">template&lt;typename ADType , require_autodiff_t&lt; ADType &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a511adcae58163983f2eb5623df58d5c7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a511adcae58163983f2eb5623df58d5c7.html#a511adcae58163983f2eb5623df58d5c7">isfinite</a> (ADType &amp;&amp;v)</td></tr>
<tr class="memdesc:a511adcae58163983f2eb5623df58d5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if specified argument is finite (not infinite and not not-a-number).  <a href="namespacestan_1_1math_a511adcae58163983f2eb5623df58d5c7.html#a511adcae58163983f2eb5623df58d5c7">More...</a><br /></td></tr>
<tr class="separator:a511adcae58163983f2eb5623df58d5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c4a0fdb55af864f53543c66d48bcff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_autodiff_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a02c4a0fdb55af864f53543c66d48bcff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a02c4a0fdb55af864f53543c66d48bcff.html#a02c4a0fdb55af864f53543c66d48bcff">isinf</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a02c4a0fdb55af864f53543c66d48bcff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if specified argument is infinite (positive or negative).  <a href="namespacestan_1_1math_a02c4a0fdb55af864f53543c66d48bcff.html#a02c4a0fdb55af864f53543c66d48bcff">More...</a><br /></td></tr>
<tr class="separator:a02c4a0fdb55af864f53543c66d48bcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cf6c38e2cb76c37b04ee27b1f90684"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_autodiff_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a06cf6c38e2cb76c37b04ee27b1f90684"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a06cf6c38e2cb76c37b04ee27b1f90684.html#a06cf6c38e2cb76c37b04ee27b1f90684">isnan</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a06cf6c38e2cb76c37b04ee27b1f90684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if specified argument is not-a-number.  <a href="namespacestan_1_1math_a06cf6c38e2cb76c37b04ee27b1f90684.html#a06cf6c38e2cb76c37b04ee27b1f90684">More...</a><br /></td></tr>
<tr class="separator:a06cf6c38e2cb76c37b04ee27b1f90684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb19a220786c93c90d20f3858c25c33"><td class="memTemplParams" colspan="2">template&lt;typename ADType , require_autodiff_t&lt; ADType &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adeb19a220786c93c90d20f3858c25c33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adeb19a220786c93c90d20f3858c25c33.html#adeb19a220786c93c90d20f3858c25c33">isnormal</a> (ADType &amp;&amp;v)</td></tr>
<tr class="memdesc:adeb19a220786c93c90d20f3858c25c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if specified argument is normal.  <a href="namespacestan_1_1math_adeb19a220786c93c90d20f3858c25c33.html#adeb19a220786c93c90d20f3858c25c33">More...</a><br /></td></tr>
<tr class="separator:adeb19a220786c93c90d20f3858c25c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afbd6caa2c39ace92a10a51705a0cb6"><td class="memTemplParams" colspan="2">template&lt;typename T , require_arithmetic_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6afbd6caa2c39ace92a10a51705a0cb6"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6afbd6caa2c39ace92a10a51705a0cb6.html#a6afbd6caa2c39ace92a10a51705a0cb6">lambert_w0</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a6afbd6caa2c39ace92a10a51705a0cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Lambert W function on W0 branch for a value x.  <a href="namespacestan_1_1math_a6afbd6caa2c39ace92a10a51705a0cb6.html#a6afbd6caa2c39ace92a10a51705a0cb6">More...</a><br /></td></tr>
<tr class="separator:a6afbd6caa2c39ace92a10a51705a0cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0586b60205d9d94cd690529427aa81"><td class="memTemplParams" colspan="2">template&lt;typename T , require_arithmetic_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0a0586b60205d9d94cd690529427aa81"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0a0586b60205d9d94cd690529427aa81.html#a0a0586b60205d9d94cd690529427aa81">lambert_wm1</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a0a0586b60205d9d94cd690529427aa81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Lambert W function on W-1 branch for a value x.  <a href="namespacestan_1_1math_a0a0586b60205d9d94cd690529427aa81.html#a0a0586b60205d9d94cd690529427aa81">More...</a><br /></td></tr>
<tr class="separator:a0a0586b60205d9d94cd690529427aa81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa034cacb69d10ecaee16c446944c9d52"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_stan_scalar_t&lt; T &gt; *  = nullptr, require_not_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa034cacb69d10ecaee16c446944c9d52"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa034cacb69d10ecaee16c446944c9d52.html#aa034cacb69d10ecaee16c446944c9d52">lambert_w0</a> (const T &amp;x)</td></tr>
<tr class="memdesc:aa034cacb69d10ecaee16c446944c9d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_ac1ff22e60ccff4f720d813cf30c801b6.html#ac1ff22e60ccff4f720d813cf30c801b6">lambert_w0()</a>.  <a href="namespacestan_1_1math_aa034cacb69d10ecaee16c446944c9d52.html#aa034cacb69d10ecaee16c446944c9d52">More...</a><br /></td></tr>
<tr class="separator:aa034cacb69d10ecaee16c446944c9d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5eea61465214a2b77e80dceda997b1"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_stan_scalar_t&lt; T &gt; *  = nullptr, require_not_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0a5eea61465214a2b77e80dceda997b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0a5eea61465214a2b77e80dceda997b1.html#a0a5eea61465214a2b77e80dceda997b1">lambert_wm1</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a0a5eea61465214a2b77e80dceda997b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a9639d15cf696cb1cd047a1b61a7f5928.html#a9639d15cf696cb1cd047a1b61a7f5928">lambert_wm1()</a>.  <a href="namespacestan_1_1math_a0a5eea61465214a2b77e80dceda997b1.html#a0a5eea61465214a2b77e80dceda997b1">More...</a><br /></td></tr>
<tr class="separator:a0a5eea61465214a2b77e80dceda997b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896a60613646c7b029ec340443d9ae2d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , require_all_stan_scalar_t&lt; T, L &gt; *  = nullptr, require_all_not_st_var&lt; T, L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a896a60613646c7b029ec340443d9ae2d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a896a60613646c7b029ec340443d9ae2d.html#a896a60613646c7b029ec340443d9ae2d">lb_constrain</a> (const T &amp;x, const L &amp;lb)</td></tr>
<tr class="memdesc:a896a60613646c7b029ec340443d9ae2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-bounded value for the specified unconstrained input and specified lower bound.  <a href="namespacestan_1_1math_a896a60613646c7b029ec340443d9ae2d.html#a896a60613646c7b029ec340443d9ae2d">More...</a><br /></td></tr>
<tr class="separator:a896a60613646c7b029ec340443d9ae2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bec9c64e01f1f6705bd6242e2ce1525"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , require_eigen_t&lt; T &gt; *  = nullptr, require_stan_scalar_t&lt; L &gt; *  = nullptr, require_all_not_st_var&lt; T, L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7bec9c64e01f1f6705bd6242e2ce1525"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7bec9c64e01f1f6705bd6242e2ce1525.html#a7bec9c64e01f1f6705bd6242e2ce1525">lb_constrain</a> (T &amp;&amp;x, L &amp;&amp;lb)</td></tr>
<tr class="memdesc:a7bec9c64e01f1f6705bd6242e2ce1525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>lb_constrain</code> to apply a scalar lower bound elementwise to each input.  <a href="namespacestan_1_1math_a7bec9c64e01f1f6705bd6242e2ce1525.html#a7bec9c64e01f1f6705bd6242e2ce1525">More...</a><br /></td></tr>
<tr class="separator:a7bec9c64e01f1f6705bd6242e2ce1525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1b250c33f4d005a6566ab654f9ebc7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , require_eigen_t&lt; T &gt; *  = nullptr, require_stan_scalar_t&lt; L &gt; *  = nullptr, require_all_not_st_var&lt; T, L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6b1b250c33f4d005a6566ab654f9ebc7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6b1b250c33f4d005a6566ab654f9ebc7.html#a6b1b250c33f4d005a6566ab654f9ebc7">lb_constrain</a> (const T &amp;x, const L &amp;lb, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L &gt; &amp;lp)</td></tr>
<tr class="memdesc:a6b1b250c33f4d005a6566ab654f9ebc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>lb_constrain</code> to apply a scalar lower bound elementwise to each input.  <a href="namespacestan_1_1math_a6b1b250c33f4d005a6566ab654f9ebc7.html#a6b1b250c33f4d005a6566ab654f9ebc7">More...</a><br /></td></tr>
<tr class="separator:a6b1b250c33f4d005a6566ab654f9ebc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4d5d51badfc97f4f7da3070fdce7d9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , require_not_std_vector_t&lt; L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aac4d5d51badfc97f4f7da3070fdce7d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aac4d5d51badfc97f4f7da3070fdce7d9.html#aac4d5d51badfc97f4f7da3070fdce7d9">lb_constrain</a> (const std::vector&lt; T &gt; &amp;x, const L &amp;lb)</td></tr>
<tr class="memdesc:aac4d5d51badfc97f4f7da3070fdce7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>lb_constrain</code> to apply a container of lower bounds elementwise to each input element.  <a href="namespacestan_1_1math_aac4d5d51badfc97f4f7da3070fdce7d9.html#aac4d5d51badfc97f4f7da3070fdce7d9">More...</a><br /></td></tr>
<tr class="separator:aac4d5d51badfc97f4f7da3070fdce7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6720a1137c32b4d826dad415588be0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , require_not_std_vector_t&lt; L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6a6720a1137c32b4d826dad415588be0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6a6720a1137c32b4d826dad415588be0.html#a6a6720a1137c32b4d826dad415588be0">lb_constrain</a> (const std::vector&lt; T &gt; &amp;x, const L &amp;lb, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L &gt; &amp;lp)</td></tr>
<tr class="memdesc:a6a6720a1137c32b4d826dad415588be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>lb_constrain</code> to apply a container of lower bounds elementwise to each input element.  <a href="namespacestan_1_1math_a6a6720a1137c32b4d826dad415588be0.html#a6a6720a1137c32b4d826dad415588be0">More...</a><br /></td></tr>
<tr class="separator:a6a6720a1137c32b4d826dad415588be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b3e146fb34b60ad7c6943fcfaf9be4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L &gt; </td></tr>
<tr class="memitem:ad1b3e146fb34b60ad7c6943fcfaf9be4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad1b3e146fb34b60ad7c6943fcfaf9be4.html#ad1b3e146fb34b60ad7c6943fcfaf9be4">lb_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; L &gt; &amp;lb)</td></tr>
<tr class="memdesc:ad1b3e146fb34b60ad7c6943fcfaf9be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>lb_constrain</code> to apply a container of lower bounds elementwise to each input element.  <a href="namespacestan_1_1math_ad1b3e146fb34b60ad7c6943fcfaf9be4.html#ad1b3e146fb34b60ad7c6943fcfaf9be4">More...</a><br /></td></tr>
<tr class="separator:ad1b3e146fb34b60ad7c6943fcfaf9be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55951128e2c3e4c59107fe3f71b5ef9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L &gt; </td></tr>
<tr class="memitem:af55951128e2c3e4c59107fe3f71b5ef9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af55951128e2c3e4c59107fe3f71b5ef9.html#af55951128e2c3e4c59107fe3f71b5ef9">lb_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; L &gt; &amp;lb, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L &gt; &amp;lp)</td></tr>
<tr class="memdesc:af55951128e2c3e4c59107fe3f71b5ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>lb_constrain</code> to apply a container of lower bounds elementwise to each input element.  <a href="namespacestan_1_1math_af55951128e2c3e4c59107fe3f71b5ef9.html#af55951128e2c3e4c59107fe3f71b5ef9">More...</a><br /></td></tr>
<tr class="separator:af55951128e2c3e4c59107fe3f71b5ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9378b127f2a5a39a6f5d1af869aad1ff"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , typename L &gt; </td></tr>
<tr class="memitem:a9378b127f2a5a39a6f5d1af869aad1ff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9378b127f2a5a39a6f5d1af869aad1ff.html#a9378b127f2a5a39a6f5d1af869aad1ff">lb_constrain</a> (const T &amp;x, const L &amp;lb, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L &gt; &amp;lp)</td></tr>
<tr class="memdesc:a9378b127f2a5a39a6f5d1af869aad1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>lb_constrain</code> to apply a container of lower bounds elementwise to each input element.  <a href="namespacestan_1_1math_a9378b127f2a5a39a6f5d1af869aad1ff.html#a9378b127f2a5a39a6f5d1af869aad1ff">More...</a><br /></td></tr>
<tr class="separator:a9378b127f2a5a39a6f5d1af869aad1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc7caeeeac1f4ea49669263e4e28c4e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , require_not_std_vector_t&lt; T &gt; *  = nullptr, require_stan_scalar_t&lt; L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aafc7caeeeac1f4ea49669263e4e28c4e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aafc7caeeeac1f4ea49669263e4e28c4e.html#aafc7caeeeac1f4ea49669263e4e28c4e">lb_free</a> (T &amp;&amp;y, L &amp;&amp;lb)</td></tr>
<tr class="memdesc:aafc7caeeeac1f4ea49669263e4e28c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unconstrained value that produces the specified lower-bound constrained value.  <a href="namespacestan_1_1math_aafc7caeeeac1f4ea49669263e4e28c4e.html#aafc7caeeeac1f4ea49669263e4e28c4e">More...</a><br /></td></tr>
<tr class="separator:aafc7caeeeac1f4ea49669263e4e28c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad199ccf725e964a1fafe74d49460c0d4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , require_all_eigen_t&lt; T, L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad199ccf725e964a1fafe74d49460c0d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad199ccf725e964a1fafe74d49460c0d4.html#ad199ccf725e964a1fafe74d49460c0d4">lb_free</a> (T &amp;&amp;y, L &amp;&amp;lb)</td></tr>
<tr class="memdesc:ad199ccf725e964a1fafe74d49460c0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free matrix that corresponds to the specified lower-bounded matrix with respect to the specified lower bound.  <a href="namespacestan_1_1math_ad199ccf725e964a1fafe74d49460c0d4.html#ad199ccf725e964a1fafe74d49460c0d4">More...</a><br /></td></tr>
<tr class="separator:ad199ccf725e964a1fafe74d49460c0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea3f39e55decf6e8488990e229b5ee3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , require_not_std_vector_t&lt; L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeea3f39e55decf6e8488990e229b5ee3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeea3f39e55decf6e8488990e229b5ee3.html#aeea3f39e55decf6e8488990e229b5ee3">lb_free</a> (const std::vector&lt; T &gt; y, const L &amp;lb)</td></tr>
<tr class="memdesc:aeea3f39e55decf6e8488990e229b5ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free variable that corresponds to the specified lower-bounded variable with respect to the specified lower bound.  <a href="namespacestan_1_1math_aeea3f39e55decf6e8488990e229b5ee3.html#aeea3f39e55decf6e8488990e229b5ee3">More...</a><br /></td></tr>
<tr class="separator:aeea3f39e55decf6e8488990e229b5ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06125d727c0ad874018c05008f448be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L &gt; </td></tr>
<tr class="memitem:ae06125d727c0ad874018c05008f448be"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae06125d727c0ad874018c05008f448be.html#ae06125d727c0ad874018c05008f448be">lb_free</a> (const std::vector&lt; T &gt; y, const std::vector&lt; L &gt; &amp;lb)</td></tr>
<tr class="memdesc:ae06125d727c0ad874018c05008f448be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free variable that corresponds to the specified lower-bounded variable with respect to the specified lower bound.  <a href="namespacestan_1_1math_ae06125d727c0ad874018c05008f448be.html#ae06125d727c0ad874018c05008f448be">More...</a><br /></td></tr>
<tr class="separator:ae06125d727c0ad874018c05008f448be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2efe080a75ccb450a5ac13b8df211f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_arithmetic_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4a2efe080a75ccb450a5ac13b8df211f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a2efe080a75ccb450a5ac13b8df211f.html#a4a2efe080a75ccb450a5ac13b8df211f">lbeta</a> (const T1 a, const T2 b)</td></tr>
<tr class="memdesc:a4a2efe080a75ccb450a5ac13b8df211f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the beta function applied to the specified arguments.  <a href="namespacestan_1_1math_a4a2efe080a75ccb450a5ac13b8df211f.html#a4a2efe080a75ccb450a5ac13b8df211f">More...</a><br /></td></tr>
<tr class="separator:a4a2efe080a75ccb450a5ac13b8df211f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4001e74e67c0cd8a5e38a61194975abc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4001e74e67c0cd8a5e38a61194975abc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4001e74e67c0cd8a5e38a61194975abc.html#a4001e74e67c0cd8a5e38a61194975abc">lbeta</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a4001e74e67c0cd8a5e38a61194975abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the lbeta function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_a4001e74e67c0cd8a5e38a61194975abc.html#a4001e74e67c0cd8a5e38a61194975abc">More...</a><br /></td></tr>
<tr class="separator:a4001e74e67c0cd8a5e38a61194975abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0616f5f75ae889dba3dbaaf4474157fc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , require_arithmetic_t&lt; T1 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0616f5f75ae889dba3dbaaf4474157fc"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0616f5f75ae889dba3dbaaf4474157fc.html#a0616f5f75ae889dba3dbaaf4474157fc">ldexp</a> (T1 a, int b)</td></tr>
<tr class="memdesc:a0616f5f75ae889dba3dbaaf4474157fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of a (the significand) and 2 to power b (the exponent).  <a href="namespacestan_1_1math_a0616f5f75ae889dba3dbaaf4474157fc.html#a0616f5f75ae889dba3dbaaf4474157fc">More...</a><br /></td></tr>
<tr class="separator:a0616f5f75ae889dba3dbaaf4474157fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc5db5a46e795f5e02798b0eb259bda"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aacc5db5a46e795f5e02798b0eb259bda"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aacc5db5a46e795f5e02798b0eb259bda.html#aacc5db5a46e795f5e02798b0eb259bda">ldexp</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:aacc5db5a46e795f5e02798b0eb259bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the ldexp function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_aacc5db5a46e795f5e02798b0eb259bda.html#aacc5db5a46e795f5e02798b0eb259bda">More...</a><br /></td></tr>
<tr class="separator:aacc5db5a46e795f5e02798b0eb259bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c8ccca3e47d6bee7b24c4974f8e77a"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a14c8ccca3e47d6bee7b24c4974f8e77a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a14c8ccca3e47d6bee7b24c4974f8e77a.html#a14c8ccca3e47d6bee7b24c4974f8e77a">make_ldlt_factor</a> (const T &amp;A)</td></tr>
<tr class="memdesc:a14c8ccca3e47d6bee7b24c4974f8e77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> with matrix type <code>plain_type_t&lt;T&gt;</code>  <a href="namespacestan_1_1math_a14c8ccca3e47d6bee7b24c4974f8e77a.html#a14c8ccca3e47d6bee7b24c4974f8e77a">More...</a><br /></td></tr>
<tr class="separator:a14c8ccca3e47d6bee7b24c4974f8e77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836f46d7f63f5118a32cad11382c0551"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a836f46d7f63f5118a32cad11382c0551.html#a836f46d7f63f5118a32cad11382c0551">lgamma</a> (double x)</td></tr>
<tr class="memdesc:a836f46d7f63f5118a32cad11382c0551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the gamma function applied to the specified argument.  <a href="namespacestan_1_1math_a836f46d7f63f5118a32cad11382c0551.html#a836f46d7f63f5118a32cad11382c0551">More...</a><br /></td></tr>
<tr class="separator:a836f46d7f63f5118a32cad11382c0551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022448967319f16d2ae705ef122b219c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a022448967319f16d2ae705ef122b219c.html#a022448967319f16d2ae705ef122b219c">lgamma</a> (int x)</td></tr>
<tr class="memdesc:a022448967319f16d2ae705ef122b219c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the gamma function applied to the specified argument.  <a href="namespacestan_1_1math_a022448967319f16d2ae705ef122b219c.html#a022448967319f16d2ae705ef122b219c">More...</a><br /></td></tr>
<tr class="separator:a022448967319f16d2ae705ef122b219c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71147c5af9cdaca2866cd529ee26d624"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_var_matrix_t&lt; T &gt; *  = nullptr, require_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a71147c5af9cdaca2866cd529ee26d624"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a71147c5af9cdaca2866cd529ee26d624.html#a71147c5af9cdaca2866cd529ee26d624">lgamma</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a71147c5af9cdaca2866cd529ee26d624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_aead76f03bdbc60484ad760fc31bad40f.html#aead76f03bdbc60484ad760fc31bad40f" title="Return the natural logarithm of the gamma function applied to the specified argument.">lgamma()</a>.  <a href="namespacestan_1_1math_a71147c5af9cdaca2866cd529ee26d624.html#a71147c5af9cdaca2866cd529ee26d624">More...</a><br /></td></tr>
<tr class="separator:a71147c5af9cdaca2866cd529ee26d624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab867d87339c27891391c2e02613a359b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab867d87339c27891391c2e02613a359b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab867d87339c27891391c2e02613a359b.html#ab867d87339c27891391c2e02613a359b">lgamma_stirling</a> (const T x)</td></tr>
<tr class="memdesc:ab867d87339c27891391c2e02613a359b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Stirling approximation to the lgamma function.  <a href="namespacestan_1_1math_ab867d87339c27891391c2e02613a359b.html#ab867d87339c27891391c2e02613a359b">More...</a><br /></td></tr>
<tr class="separator:ab867d87339c27891391c2e02613a359b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd216e484d7497c7449b3ad15300db4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aafd216e484d7497c7449b3ad15300db4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aafd216e484d7497c7449b3ad15300db4.html#aafd216e484d7497c7449b3ad15300db4">lgamma_stirling_diff</a> (const T x)</td></tr>
<tr class="memdesc:aafd216e484d7497c7449b3ad15300db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference between log of the gamma function and its Stirling approximation.  <a href="namespacestan_1_1math_aafd216e484d7497c7449b3ad15300db4.html#aafd216e484d7497c7449b3ad15300db4">More...</a><br /></td></tr>
<tr class="separator:aafd216e484d7497c7449b3ad15300db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f269615538663f546d50c1e8d836402"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9f269615538663f546d50c1e8d836402.html#a9f269615538663f546d50c1e8d836402">linspaced_array</a> (int K, double low, double high)</td></tr>
<tr class="memdesc:a9f269615538663f546d50c1e8d836402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array of linearly spaced elements.  <a href="namespacestan_1_1math_a9f269615538663f546d50c1e8d836402.html#a9f269615538663f546d50c1e8d836402">More...</a><br /></td></tr>
<tr class="separator:a9f269615538663f546d50c1e8d836402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0c8918287806eb897d69960e10995b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3e0c8918287806eb897d69960e10995b.html#a3e0c8918287806eb897d69960e10995b">linspaced_int_array</a> (int K, int low, int high)</td></tr>
<tr class="memdesc:a3e0c8918287806eb897d69960e10995b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array of linearly spaced integers.  <a href="namespacestan_1_1math_a3e0c8918287806eb897d69960e10995b.html#a3e0c8918287806eb897d69960e10995b">More...</a><br /></td></tr>
<tr class="separator:a3e0c8918287806eb897d69960e10995b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f8599be4fe5cccb131aa8cce455165"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae7f8599be4fe5cccb131aa8cce455165.html#ae7f8599be4fe5cccb131aa8cce455165">linspaced_row_vector</a> (int K, double low, double high)</td></tr>
<tr class="memdesc:ae7f8599be4fe5cccb131aa8cce455165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row vector of linearly spaced elements.  <a href="namespacestan_1_1math_ae7f8599be4fe5cccb131aa8cce455165.html#ae7f8599be4fe5cccb131aa8cce455165">More...</a><br /></td></tr>
<tr class="separator:ae7f8599be4fe5cccb131aa8cce455165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6932b13c75f264fcdae7f78b32962a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3a6932b13c75f264fcdae7f78b32962a.html#a3a6932b13c75f264fcdae7f78b32962a">linspaced_vector</a> (int K, double low, double high)</td></tr>
<tr class="memdesc:a3a6932b13c75f264fcdae7f78b32962a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of linearly spaced elements.  <a href="namespacestan_1_1math_a3a6932b13c75f264fcdae7f78b32962a.html#a3a6932b13c75f264fcdae7f78b32962a">More...</a><br /></td></tr>
<tr class="separator:a3a6932b13c75f264fcdae7f78b32962a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7945f93000b7911d9bd19a30ead8917"><td class="memTemplParams" colspan="2">template&lt;typename T , require_arithmetic_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af7945f93000b7911d9bd19a30ead8917"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af7945f93000b7911d9bd19a30ead8917.html#af7945f93000b7911d9bd19a30ead8917">lmgamma</a> (int k, T x)</td></tr>
<tr class="memdesc:af7945f93000b7911d9bd19a30ead8917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the multivariate gamma function with the specified dimensions and argument.  <a href="namespacestan_1_1math_af7945f93000b7911d9bd19a30ead8917.html#af7945f93000b7911d9bd19a30ead8917">More...</a><br /></td></tr>
<tr class="separator:af7945f93000b7911d9bd19a30ead8917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c9fcbdad55212c061659c4f082d761"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae5c9fcbdad55212c061659c4f082d761"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae5c9fcbdad55212c061659c4f082d761.html#ae5c9fcbdad55212c061659c4f082d761">lmgamma</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ae5c9fcbdad55212c061659c4f082d761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the natural log of the multivariate gamma function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_ae5c9fcbdad55212c061659c4f082d761.html#ae5c9fcbdad55212c061659c4f082d761">More...</a><br /></td></tr>
<tr class="separator:ae5c9fcbdad55212c061659c4f082d761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0642dca7b54cdf8697e2a9e75467be41"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_arithmetic_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0642dca7b54cdf8697e2a9e75467be41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0642dca7b54cdf8697e2a9e75467be41.html#a0642dca7b54cdf8697e2a9e75467be41">lmultiply</a> (const T1 a, const T2 b)</td></tr>
<tr class="memdesc:a0642dca7b54cdf8697e2a9e75467be41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument times the log of the second argument.  <a href="namespacestan_1_1math_a0642dca7b54cdf8697e2a9e75467be41.html#a0642dca7b54cdf8697e2a9e75467be41">More...</a><br /></td></tr>
<tr class="separator:a0642dca7b54cdf8697e2a9e75467be41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a5692c4e84d336fe8093c760d4720f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr, require_all_not_var_matrix_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae7a5692c4e84d336fe8093c760d4720f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae7a5692c4e84d336fe8093c760d4720f.html#ae7a5692c4e84d336fe8093c760d4720f">lmultiply</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ae7a5692c4e84d336fe8093c760d4720f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of applying <code>lmultiply</code> to the arguments elementwise, with broadcasting if one of the arguments is a scalar.  <a href="namespacestan_1_1math_ae7a5692c4e84d336fe8093c760d4720f.html#ae7a5692c4e84d336fe8093c760d4720f">More...</a><br /></td></tr>
<tr class="separator:ae7a5692c4e84d336fe8093c760d4720f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d333f1c4ea884bfa3905ede0547efb"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr, require_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa7d333f1c4ea884bfa3905ede0547efb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa7d333f1c4ea884bfa3905ede0547efb.html#aa7d333f1c4ea884bfa3905ede0547efb">log</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:aa7d333f1c4ea884bfa3905ede0547efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise natural log of the specified argument, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_aa7d333f1c4ea884bfa3905ede0547efb.html#aa7d333f1c4ea884bfa3905ede0547efb">More...</a><br /></td></tr>
<tr class="separator:aa7d333f1c4ea884bfa3905ede0547efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c367272e2ff36820f1f9332a9df0f9"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a66c367272e2ff36820f1f9332a9df0f9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a66c367272e2ff36820f1f9332a9df0f9.html#a66c367272e2ff36820f1f9332a9df0f9">log</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a66c367272e2ff36820f1f9332a9df0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_a915ada1e5971c467aa16ee926997a442.html#a915ada1e5971c467aa16ee926997a442">log()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_a66c367272e2ff36820f1f9332a9df0f9.html#a66c367272e2ff36820f1f9332a9df0f9">More...</a><br /></td></tr>
<tr class="separator:a66c367272e2ff36820f1f9332a9df0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fea755bc3e8dfd50e47bfdbe62195b"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_var_matrix_t&lt; Container &gt; *  = nullptr, require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae9fea755bc3e8dfd50e47bfdbe62195b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae9fea755bc3e8dfd50e47bfdbe62195b.html#ae9fea755bc3e8dfd50e47bfdbe62195b">log10</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ae9fea755bc3e8dfd50e47bfdbe62195b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a808cbb5ac4003f28e2538805ebe338ef.html#a808cbb5ac4003f28e2538805ebe338ef">log10()</a>.  <a href="namespacestan_1_1math_ae9fea755bc3e8dfd50e47bfdbe62195b.html#ae9fea755bc3e8dfd50e47bfdbe62195b">More...</a><br /></td></tr>
<tr class="separator:ae9fea755bc3e8dfd50e47bfdbe62195b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbad1abda71a738f051904147a9d686a"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abbad1abda71a738f051904147a9d686a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abbad1abda71a738f051904147a9d686a.html#abbad1abda71a738f051904147a9d686a">log10</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:abbad1abda71a738f051904147a9d686a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="namespacestan_1_1math_a808cbb5ac4003f28e2538805ebe338ef.html#a808cbb5ac4003f28e2538805ebe338ef">log10()</a> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_abbad1abda71a738f051904147a9d686a.html#abbad1abda71a738f051904147a9d686a">More...</a><br /></td></tr>
<tr class="separator:abbad1abda71a738f051904147a9d686a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6081423c9042ea5849a0b8f3c3540e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aff6081423c9042ea5849a0b8f3c3540e.html#aff6081423c9042ea5849a0b8f3c3540e">log1m</a> (double x)</td></tr>
<tr class="memdesc:aff6081423c9042ea5849a0b8f3c3540e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one minus the specified value.  <a href="namespacestan_1_1math_aff6081423c9042ea5849a0b8f3c3540e.html#aff6081423c9042ea5849a0b8f3c3540e">More...</a><br /></td></tr>
<tr class="separator:aff6081423c9042ea5849a0b8f3c3540e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baa8880a0f695e5d100682376c399b0"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_var_matrix_t&lt; T &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7baa8880a0f695e5d100682376c399b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7baa8880a0f695e5d100682376c399b0.html#a7baa8880a0f695e5d100682376c399b0">log1m</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a7baa8880a0f695e5d100682376c399b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a8d92a982acd829e77b3f5b975baa6aed.html#a8d92a982acd829e77b3f5b975baa6aed">log1m()</a>.  <a href="namespacestan_1_1math_a7baa8880a0f695e5d100682376c399b0.html#a7baa8880a0f695e5d100682376c399b0">More...</a><br /></td></tr>
<tr class="separator:a7baa8880a0f695e5d100682376c399b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8a7380246a034a750c5bafbfa2e2c5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3b8a7380246a034a750c5bafbfa2e2c5.html#a3b8a7380246a034a750c5bafbfa2e2c5">log1m_exp</a> (double a)</td></tr>
<tr class="memdesc:a3b8a7380246a034a750c5bafbfa2e2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the natural logarithm of one minus the exponential of the specified value without overflow,.  <a href="namespacestan_1_1math_a3b8a7380246a034a750c5bafbfa2e2c5.html#a3b8a7380246a034a750c5bafbfa2e2c5">More...</a><br /></td></tr>
<tr class="separator:a3b8a7380246a034a750c5bafbfa2e2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7a7cc7c2f96948cb6aca4edd537b76"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_var_matrix_t&lt; T &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9c7a7cc7c2f96948cb6aca4edd537b76"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9c7a7cc7c2f96948cb6aca4edd537b76.html#a9c7a7cc7c2f96948cb6aca4edd537b76">log1m_exp</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a9c7a7cc7c2f96948cb6aca4edd537b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a7760d28e8fddf268113469b44463de07.html#a7760d28e8fddf268113469b44463de07" title="Return the natural logarithm of one minus the exponentiation of the specified argument.">log1m_exp()</a>.  <a href="namespacestan_1_1math_a9c7a7cc7c2f96948cb6aca4edd537b76.html#a9c7a7cc7c2f96948cb6aca4edd537b76">More...</a><br /></td></tr>
<tr class="separator:a9c7a7cc7c2f96948cb6aca4edd537b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbc99a62ef0f24b77c9c3c950a6003d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aabbc99a62ef0f24b77c9c3c950a6003d.html#aabbc99a62ef0f24b77c9c3c950a6003d">log1m_inv_logit</a> (double u)</td></tr>
<tr class="memdesc:aabbc99a62ef0f24b77c9c3c950a6003d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of 1 minus the inverse logit of the specified argument.  <a href="namespacestan_1_1math_aabbc99a62ef0f24b77c9c3c950a6003d.html#aabbc99a62ef0f24b77c9c3c950a6003d">More...</a><br /></td></tr>
<tr class="separator:aabbc99a62ef0f24b77c9c3c950a6003d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ec6f02e29ec6560cdfba104e1993cf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a04ec6f02e29ec6560cdfba104e1993cf.html#a04ec6f02e29ec6560cdfba104e1993cf">log1m_inv_logit</a> (int u)</td></tr>
<tr class="memdesc:a04ec6f02e29ec6560cdfba104e1993cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one minus the inverse logit of the specified argument.  <a href="namespacestan_1_1math_a04ec6f02e29ec6560cdfba104e1993cf.html#a04ec6f02e29ec6560cdfba104e1993cf">More...</a><br /></td></tr>
<tr class="separator:a04ec6f02e29ec6560cdfba104e1993cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b1157577cec4be4361f54a996647c8"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_var_matrix_t&lt; T &gt; *  = nullptr, require_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a57b1157577cec4be4361f54a996647c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary.html">apply_scalar_unary</a>&lt; <a class="el" href="structstan_1_1math_1_1log1m__inv__logit__fun.html">log1m_inv_logit_fun</a>, T &gt;::return_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a57b1157577cec4be4361f54a996647c8.html#a57b1157577cec4be4361f54a996647c8">log1m_inv_logit</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a57b1157577cec4be4361f54a996647c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a79f286f8a9043aee8a1a844493da0d55.html#a79f286f8a9043aee8a1a844493da0d55" title="Return the natural logarithm of one minus the inverse logit of the specified argument.">log1m_inv_logit()</a></code> to specified argument container.  <a href="namespacestan_1_1math_a57b1157577cec4be4361f54a996647c8.html#a57b1157577cec4be4361f54a996647c8">More...</a><br /></td></tr>
<tr class="separator:a57b1157577cec4be4361f54a996647c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c8b55bdbd94b5f6f60208336da665e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a80c8b55bdbd94b5f6f60208336da665e.html#a80c8b55bdbd94b5f6f60208336da665e">log1p</a> (double x)</td></tr>
<tr class="memdesc:a80c8b55bdbd94b5f6f60208336da665e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one plus the specified value.  <a href="namespacestan_1_1math_a80c8b55bdbd94b5f6f60208336da665e.html#a80c8b55bdbd94b5f6f60208336da665e">More...</a><br /></td></tr>
<tr class="separator:a80c8b55bdbd94b5f6f60208336da665e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4211f75c8f20d524ec882ff02ddc626"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae4211f75c8f20d524ec882ff02ddc626.html#ae4211f75c8f20d524ec882ff02ddc626">log1p</a> (int x)</td></tr>
<tr class="memdesc:ae4211f75c8f20d524ec882ff02ddc626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one plus the specified argument.  <a href="namespacestan_1_1math_ae4211f75c8f20d524ec882ff02ddc626.html#ae4211f75c8f20d524ec882ff02ddc626">More...</a><br /></td></tr>
<tr class="separator:ae4211f75c8f20d524ec882ff02ddc626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d55dc641b6a46255a609b827ff3871a"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr, require_not_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6d55dc641b6a46255a609b827ff3871a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6d55dc641b6a46255a609b827ff3871a.html#a6d55dc641b6a46255a609b827ff3871a">log1p</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a6d55dc641b6a46255a609b827ff3871a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_aa16e57e82fb1e17f74ef43592748ff32.html#aa16e57e82fb1e17f74ef43592748ff32">log1p()</a></code> to specified argument container.  <a href="namespacestan_1_1math_a6d55dc641b6a46255a609b827ff3871a.html#a6d55dc641b6a46255a609b827ff3871a">More...</a><br /></td></tr>
<tr class="separator:a6d55dc641b6a46255a609b827ff3871a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fcffd9ef56632268d02e8d6144aee7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a83fcffd9ef56632268d02e8d6144aee7.html#a83fcffd9ef56632268d02e8d6144aee7">log1p_exp</a> (double a)</td></tr>
<tr class="memdesc:a83fcffd9ef56632268d02e8d6144aee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log of 1 plus the exponential of the specified value without overflow.  <a href="namespacestan_1_1math_a83fcffd9ef56632268d02e8d6144aee7.html#a83fcffd9ef56632268d02e8d6144aee7">More...</a><br /></td></tr>
<tr class="separator:a83fcffd9ef56632268d02e8d6144aee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6183eda9ebe6e81e3d8e80b6f47c8f5d"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr, require_not_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6183eda9ebe6e81e3d8e80b6f47c8f5d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6183eda9ebe6e81e3d8e80b6f47c8f5d.html#a6183eda9ebe6e81e3d8e80b6f47c8f5d">log1p_exp</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a6183eda9ebe6e81e3d8e80b6f47c8f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a0fe928ad2b96b802f6d488ba43167489.html#a0fe928ad2b96b802f6d488ba43167489">log1p_exp()</a>.  <a href="namespacestan_1_1math_a6183eda9ebe6e81e3d8e80b6f47c8f5d.html#a6183eda9ebe6e81e3d8e80b6f47c8f5d">More...</a><br /></td></tr>
<tr class="separator:a6183eda9ebe6e81e3d8e80b6f47c8f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44eb38e5b317dadf97e8b359197902ea"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a44eb38e5b317dadf97e8b359197902ea.html#a44eb38e5b317dadf97e8b359197902ea">log2</a> ()</td></tr>
<tr class="memdesc:a44eb38e5b317dadf97e8b359197902ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return natural logarithm of two.  <a href="namespacestan_1_1math_a44eb38e5b317dadf97e8b359197902ea.html#a44eb38e5b317dadf97e8b359197902ea">More...</a><br /></td></tr>
<tr class="separator:a44eb38e5b317dadf97e8b359197902ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7251d72d334fd8a8595c14d3231003cd"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_var_matrix_t&lt; T &gt; *  = nullptr, require_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7251d72d334fd8a8595c14d3231003cd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7251d72d334fd8a8595c14d3231003cd.html#a7251d72d334fd8a8595c14d3231003cd">log2</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a7251d72d334fd8a8595c14d3231003cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a4eea39b4ca603cff7518068499884364.html#a4eea39b4ca603cff7518068499884364" title="Return the base two logarithm of the specified argument.">log2()</a></code> to specified argument container.  <a href="namespacestan_1_1math_a7251d72d334fd8a8595c14d3231003cd.html#a7251d72d334fd8a8595c14d3231003cd">More...</a><br /></td></tr>
<tr class="separator:a7251d72d334fd8a8595c14d3231003cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43a5998ebfefa7f84ca7d0f45d994cd"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_rev_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af43a5998ebfefa7f84ca7d0f45d994cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af43a5998ebfefa7f84ca7d0f45d994cd.html#af43a5998ebfefa7f84ca7d0f45d994cd">log_determinant_ldlt</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:af43a5998ebfefa7f84ca7d0f45d994cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns log(abs(det(A))) given a <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> of A.  <a href="namespacestan_1_1math_af43a5998ebfefa7f84ca7d0f45d994cd.html#af43a5998ebfefa7f84ca7d0f45d994cd">More...</a><br /></td></tr>
<tr class="separator:af43a5998ebfefa7f84ca7d0f45d994cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e7c93957697274d816ce06640d832e"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_not_vt_var&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a12e7c93957697274d816ce06640d832e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a12e7c93957697274d816ce06640d832e.html#a12e7c93957697274d816ce06640d832e">log_determinant_spd</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a12e7c93957697274d816ce06640d832e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log absolute determinant of the specified square matrix.  <a href="namespacestan_1_1math_a12e7c93957697274d816ce06640d832e.html#a12e7c93957697274d816ce06640d832e">More...</a><br /></td></tr>
<tr class="separator:a12e7c93957697274d816ce06640d832e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03eb5ca61bbbb4e96f14349a46919b5d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_arithmetic_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a03eb5ca61bbbb4e96f14349a46919b5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a03eb5ca61bbbb4e96f14349a46919b5d.html#a03eb5ca61bbbb4e96f14349a46919b5d">log_diff_exp</a> (const T1 x, const T2 y)</td></tr>
<tr class="memdesc:a03eb5ca61bbbb4e96f14349a46919b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of the difference of the natural exponentiation of x and the natural exponentiation of y.  <a href="namespacestan_1_1math_a03eb5ca61bbbb4e96f14349a46919b5d.html#a03eb5ca61bbbb4e96f14349a46919b5d">More...</a><br /></td></tr>
<tr class="separator:a03eb5ca61bbbb4e96f14349a46919b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdf787b2994e5987cfa1991c8d3a1fe"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adcdf787b2994e5987cfa1991c8d3a1fe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adcdf787b2994e5987cfa1991c8d3a1fe.html#adcdf787b2994e5987cfa1991c8d3a1fe">log_diff_exp</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:adcdf787b2994e5987cfa1991c8d3a1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the log_diff_exp function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_adcdf787b2994e5987cfa1991c8d3a1fe.html#adcdf787b2994e5987cfa1991c8d3a1fe">More...</a><br /></td></tr>
<tr class="separator:adcdf787b2994e5987cfa1991c8d3a1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae682f16704aedace0d078d712142f7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_arithmetic_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaae682f16704aedace0d078d712142f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaae682f16704aedace0d078d712142f7.html#aaae682f16704aedace0d078d712142f7">log_falling_factorial</a> (const T1 x, const T2 n)</td></tr>
<tr class="memdesc:aaae682f16704aedace0d078d712142f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural log of the falling factorial of the specified arguments.  <a href="namespacestan_1_1math_aaae682f16704aedace0d078d712142f7.html#aaae682f16704aedace0d078d712142f7">More...</a><br /></td></tr>
<tr class="separator:aaae682f16704aedace0d078d712142f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded9b4e858cdd4e6cf93d9ab450ec5d9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aded9b4e858cdd4e6cf93d9ab450ec5d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aded9b4e858cdd4e6cf93d9ab450ec5d9.html#aded9b4e858cdd4e6cf93d9ab450ec5d9">log_falling_factorial</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:aded9b4e858cdd4e6cf93d9ab450ec5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the log_falling_factorial function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_aded9b4e858cdd4e6cf93d9ab450ec5d9.html#aded9b4e858cdd4e6cf93d9ab450ec5d9">More...</a><br /></td></tr>
<tr class="separator:aded9b4e858cdd4e6cf93d9ab450ec5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844ee30d107f63c17406629071fdf71d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a844ee30d107f63c17406629071fdf71d.html#a844ee30d107f63c17406629071fdf71d">log_inv_logit</a> (double u)</td></tr>
<tr class="memdesc:a844ee30d107f63c17406629071fdf71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the inverse logit of the specified argument.  <a href="namespacestan_1_1math_a844ee30d107f63c17406629071fdf71d.html#a844ee30d107f63c17406629071fdf71d">More...</a><br /></td></tr>
<tr class="separator:a844ee30d107f63c17406629071fdf71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e26b21d942c19f21f440ed7b4be7fac"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8e26b21d942c19f21f440ed7b4be7fac.html#a8e26b21d942c19f21f440ed7b4be7fac">log_inv_logit</a> (int u)</td></tr>
<tr class="memdesc:a8e26b21d942c19f21f440ed7b4be7fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the inverse logit of the specified argument.  <a href="namespacestan_1_1math_a8e26b21d942c19f21f440ed7b4be7fac.html#a8e26b21d942c19f21f440ed7b4be7fac">More...</a><br /></td></tr>
<tr class="separator:a8e26b21d942c19f21f440ed7b4be7fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb72ba53a3661c93aa39c0f31029a36"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8bb72ba53a3661c93aa39c0f31029a36"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8bb72ba53a3661c93aa39c0f31029a36.html#a8bb72ba53a3661c93aa39c0f31029a36">log_inv_logit</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a8bb72ba53a3661c93aa39c0f31029a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_acd2fe56bce70a04dd11e8a5a32b1b51c.html#acd2fe56bce70a04dd11e8a5a32b1b51c">log_inv_logit()</a></code> to specified argument container.  <a href="namespacestan_1_1math_a8bb72ba53a3661c93aa39c0f31029a36.html#a8bb72ba53a3661c93aa39c0f31029a36">More...</a><br /></td></tr>
<tr class="separator:a8bb72ba53a3661c93aa39c0f31029a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65a60eae65accc2bb2c55967ef94e68"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_arithmetic_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae65a60eae65accc2bb2c55967ef94e68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae65a60eae65accc2bb2c55967ef94e68.html#ae65a60eae65accc2bb2c55967ef94e68">log_inv_logit_diff</a> (const T1 &amp;x, const T2 &amp;y)</td></tr>
<tr class="memdesc:ae65a60eae65accc2bb2c55967ef94e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the difference of the inverse logits of the specified arguments.  <a href="namespacestan_1_1math_ae65a60eae65accc2bb2c55967ef94e68.html#ae65a60eae65accc2bb2c55967ef94e68">More...</a><br /></td></tr>
<tr class="separator:ae65a60eae65accc2bb2c55967ef94e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5f2098c95854af0f2c9c8c36c54a5a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acc5f2098c95854af0f2c9c8c36c54a5a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acc5f2098c95854af0f2c9c8c36c54a5a.html#acc5f2098c95854af0f2c9c8c36c54a5a">log_inv_logit_diff</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:acc5f2098c95854af0f2c9c8c36c54a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the log_inv_logit_diff function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_acc5f2098c95854af0f2c9c8c36c54a5a.html#acc5f2098c95854af0f2c9c8c36c54a5a">More...</a><br /></td></tr>
<tr class="separator:acc5f2098c95854af0f2c9c8c36c54a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778f1e17b8fd2b6e566c68054a96ec20"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , typename T_lambda1 , typename T_lambda2 , require_all_arithmetic_t&lt; T_theta, T_lambda1, T_lambda2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a778f1e17b8fd2b6e566c68054a96ec20"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a778f1e17b8fd2b6e566c68054a96ec20.html#a778f1e17b8fd2b6e566c68054a96ec20">log_mix</a> (T_theta theta, T_lambda1 lambda1, T_lambda2 lambda2)</td></tr>
<tr class="memdesc:a778f1e17b8fd2b6e566c68054a96ec20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log mixture density with specified mixing proportion and log densities.  <a href="namespacestan_1_1math_a778f1e17b8fd2b6e566c68054a96ec20.html#a778f1e17b8fd2b6e566c68054a96ec20">More...</a><br /></td></tr>
<tr class="separator:a778f1e17b8fd2b6e566c68054a96ec20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa840032c03b2d14e7ca9ba9355d3b59d"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , typename T_lam , require_any_vector_t&lt; T_theta, T_lam &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa840032c03b2d14e7ca9ba9355d3b59d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta, T_lam &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa840032c03b2d14e7ca9ba9355d3b59d.html#aa840032c03b2d14e7ca9ba9355d3b59d">log_mix</a> (const T_theta &amp;theta, const T_lam &amp;lambda)</td></tr>
<tr class="memdesc:aa840032c03b2d14e7ca9ba9355d3b59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log mixture density with specified mixing proportions and log densities.  <a href="namespacestan_1_1math_aa840032c03b2d14e7ca9ba9355d3b59d.html#aa840032c03b2d14e7ca9ba9355d3b59d">More...</a><br /></td></tr>
<tr class="separator:aa840032c03b2d14e7ca9ba9355d3b59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b51db7f24309e70c97fc1b7fb57c34"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , typename T_lam , require_vector_t&lt; T_lam &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a34b51db7f24309e70c97fc1b7fb57c34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta, std::vector&lt; T_lam &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a34b51db7f24309e70c97fc1b7fb57c34.html#a34b51db7f24309e70c97fc1b7fb57c34">log_mix</a> (const T_theta &amp;theta, const std::vector&lt; T_lam &gt; &amp;lambda)</td></tr>
<tr class="memdesc:a34b51db7f24309e70c97fc1b7fb57c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log mixture density given specified mixing proportions and array of log density vectors.  <a href="namespacestan_1_1math_a34b51db7f24309e70c97fc1b7fb57c34.html#a34b51db7f24309e70c97fc1b7fb57c34">More...</a><br /></td></tr>
<tr class="separator:a34b51db7f24309e70c97fc1b7fb57c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2889598ca645cf59e4a5248b3271932"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa2889598ca645cf59e4a5248b3271932"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa2889598ca645cf59e4a5248b3271932.html#aa2889598ca645cf59e4a5248b3271932">log_modified_bessel_first_kind</a> (const T1 v, const T2 z)</td></tr>
<tr class="separator:aa2889598ca645cf59e4a5248b3271932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340e3839a6d0cfb34ce12548115b2ff2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a340e3839a6d0cfb34ce12548115b2ff2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a340e3839a6d0cfb34ce12548115b2ff2.html#a340e3839a6d0cfb34ce12548115b2ff2">log_modified_bessel_first_kind</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a340e3839a6d0cfb34ce12548115b2ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the log_modified_bessel_first_kind function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_a340e3839a6d0cfb34ce12548115b2ff2.html#a340e3839a6d0cfb34ce12548115b2ff2">More...</a><br /></td></tr>
<tr class="separator:a340e3839a6d0cfb34ce12548115b2ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a3b746071afd4ba989654bbd4021aa"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_arithmetic_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af9a3b746071afd4ba989654bbd4021aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af9a3b746071afd4ba989654bbd4021aa.html#af9a3b746071afd4ba989654bbd4021aa">log_rising_factorial</a> (const T1 &amp;x, const T2 &amp;n)</td></tr>
<tr class="memdesc:af9a3b746071afd4ba989654bbd4021aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the rising factorial from the first specified argument to the second.  <a href="namespacestan_1_1math_af9a3b746071afd4ba989654bbd4021aa.html#af9a3b746071afd4ba989654bbd4021aa">More...</a><br /></td></tr>
<tr class="separator:af9a3b746071afd4ba989654bbd4021aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6920b039552582b319e26a0d9166c82"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af6920b039552582b319e26a0d9166c82"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af6920b039552582b319e26a0d9166c82.html#af6920b039552582b319e26a0d9166c82">log_rising_factorial</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:af6920b039552582b319e26a0d9166c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the log_rising_factorial function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_af6920b039552582b319e26a0d9166c82.html#af6920b039552582b319e26a0d9166c82">More...</a><br /></td></tr>
<tr class="separator:af6920b039552582b319e26a0d9166c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d78a2d07ada896bb46eb7bfc03e3a3"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_st_arithmetic&lt; Container &gt; *  = nullptr, require_container_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a42d78a2d07ada896bb46eb7bfc03e3a3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a42d78a2d07ada896bb46eb7bfc03e3a3.html#a42d78a2d07ada896bb46eb7bfc03e3a3">log_softmax</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a42d78a2d07ada896bb46eb7bfc03e3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the softmax of the specified vector.  <a href="namespacestan_1_1math_a42d78a2d07ada896bb46eb7bfc03e3a3.html#a42d78a2d07ada896bb46eb7bfc03e3a3">More...</a><br /></td></tr>
<tr class="separator:a42d78a2d07ada896bb46eb7bfc03e3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf57e297bcaa160196707a000fbe559e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_not_st_var&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abf57e297bcaa160196707a000fbe559e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abf57e297bcaa160196707a000fbe559e.html#abf57e297bcaa160196707a000fbe559e">log_sum_exp</a> (const T2 &amp;a, const T1 &amp;b)</td></tr>
<tr class="memdesc:abf57e297bcaa160196707a000fbe559e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log sum of exponentials without overflow.  <a href="namespacestan_1_1math_abf57e297bcaa160196707a000fbe559e.html#abf57e297bcaa160196707a000fbe559e">More...</a><br /></td></tr>
<tr class="separator:abf57e297bcaa160196707a000fbe559e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868b0772a7c29d7f7ea8f28c2d205ff5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_autodiff_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a868b0772a7c29d7f7ea8f28c2d205ff5"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a868b0772a7c29d7f7ea8f28c2d205ff5.html#a868b0772a7c29d7f7ea8f28c2d205ff5">logb</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a868b0772a7c29d7f7ea8f28c2d205ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the unbiased radix-independent exponent from the floating-point argument.  <a href="namespacestan_1_1math_a868b0772a7c29d7f7ea8f28c2d205ff5.html#a868b0772a7c29d7f7ea8f28c2d205ff5">More...</a><br /></td></tr>
<tr class="separator:a868b0772a7c29d7f7ea8f28c2d205ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adc35bab2db89b3ceda66f11e1fa53ec8.html#adc35bab2db89b3ceda66f11e1fa53ec8">logical_and</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical and function which returns 1 if both arguments are unequal to zero and 0 otherwise.  <a href="namespacestan_1_1math_adc35bab2db89b3ceda66f11e1fa53ec8.html#adc35bab2db89b3ceda66f11e1fa53ec8">More...</a><br /></td></tr>
<tr class="separator:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2213736b55fd6696fa0120fd3fe72e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab2213736b55fd6696fa0120fd3fe72e4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab2213736b55fd6696fa0120fd3fe72e4.html#ab2213736b55fd6696fa0120fd3fe72e4">logical_eq</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:ab2213736b55fd6696fa0120fd3fe72e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is equal to the second.  <a href="namespacestan_1_1math_ab2213736b55fd6696fa0120fd3fe72e4.html#ab2213736b55fd6696fa0120fd3fe72e4">More...</a><br /></td></tr>
<tr class="separator:ab2213736b55fd6696fa0120fd3fe72e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6997e6a36d3166194c640158f3cfe16"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab6997e6a36d3166194c640158f3cfe16"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab6997e6a36d3166194c640158f3cfe16.html#ab6997e6a36d3166194c640158f3cfe16">logical_gt</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:ab6997e6a36d3166194c640158f3cfe16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is strictly greater than the second.  <a href="namespacestan_1_1math_ab6997e6a36d3166194c640158f3cfe16.html#ab6997e6a36d3166194c640158f3cfe16">More...</a><br /></td></tr>
<tr class="separator:ab6997e6a36d3166194c640158f3cfe16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae411878fff3cdcc04a6acdb2ad04b57d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ae411878fff3cdcc04a6acdb2ad04b57d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae411878fff3cdcc04a6acdb2ad04b57d.html#ae411878fff3cdcc04a6acdb2ad04b57d">logical_gte</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:ae411878fff3cdcc04a6acdb2ad04b57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is greater than or equal to the second.  <a href="namespacestan_1_1math_ae411878fff3cdcc04a6acdb2ad04b57d.html#ae411878fff3cdcc04a6acdb2ad04b57d">More...</a><br /></td></tr>
<tr class="separator:ae411878fff3cdcc04a6acdb2ad04b57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff4be4f156c548433292ea3df5bfb20"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a8ff4be4f156c548433292ea3df5bfb20"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8ff4be4f156c548433292ea3df5bfb20.html#a8ff4be4f156c548433292ea3df5bfb20">logical_lt</a> (T1 x1, T2 x2)</td></tr>
<tr class="memdesc:a8ff4be4f156c548433292ea3df5bfb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is strictly less than the second.  <a href="namespacestan_1_1math_a8ff4be4f156c548433292ea3df5bfb20.html#a8ff4be4f156c548433292ea3df5bfb20">More...</a><br /></td></tr>
<tr class="separator:a8ff4be4f156c548433292ea3df5bfb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f90533a3e94f2dba3542597ff5b6d6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a37f90533a3e94f2dba3542597ff5b6d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a37f90533a3e94f2dba3542597ff5b6d6.html#a37f90533a3e94f2dba3542597ff5b6d6">logical_lte</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:a37f90533a3e94f2dba3542597ff5b6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is less than or equal to the second.  <a href="namespacestan_1_1math_a37f90533a3e94f2dba3542597ff5b6d6.html#a37f90533a3e94f2dba3542597ff5b6d6">More...</a><br /></td></tr>
<tr class="separator:a37f90533a3e94f2dba3542597ff5b6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28610d664daa3fa5abd69646a2d97f5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28610d664daa3fa5abd69646a2d97f5a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a28610d664daa3fa5abd69646a2d97f5a.html#a28610d664daa3fa5abd69646a2d97f5a">logical_negation</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a28610d664daa3fa5abd69646a2d97f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical negation function which returns one if the input is equal to zero and zero otherwise.  <a href="namespacestan_1_1math_a28610d664daa3fa5abd69646a2d97f5a.html#a28610d664daa3fa5abd69646a2d97f5a">More...</a><br /></td></tr>
<tr class="separator:a28610d664daa3fa5abd69646a2d97f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206eb210d8e7e2c718af25c40de8f9d1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a206eb210d8e7e2c718af25c40de8f9d1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a206eb210d8e7e2c718af25c40de8f9d1.html#a206eb210d8e7e2c718af25c40de8f9d1">logical_neq</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:a206eb210d8e7e2c718af25c40de8f9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is unequal to the second.  <a href="namespacestan_1_1math_a206eb210d8e7e2c718af25c40de8f9d1.html#a206eb210d8e7e2c718af25c40de8f9d1">More...</a><br /></td></tr>
<tr class="separator:a206eb210d8e7e2c718af25c40de8f9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74007e2d5f55d5ae4a308f535869aee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac74007e2d5f55d5ae4a308f535869aee"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac74007e2d5f55d5ae4a308f535869aee.html#ac74007e2d5f55d5ae4a308f535869aee">logical_or</a> (T1 x1, T2 x2)</td></tr>
<tr class="memdesc:ac74007e2d5f55d5ae4a308f535869aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical or function which returns 1 if either argument is unequal to zero and 0 otherwise.  <a href="namespacestan_1_1math_ac74007e2d5f55d5ae4a308f535869aee.html#ac74007e2d5f55d5ae4a308f535869aee">More...</a><br /></td></tr>
<tr class="separator:ac74007e2d5f55d5ae4a308f535869aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7671eba9cac59b9052ef183de27ba5b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac7671eba9cac59b9052ef183de27ba5b.html#ac7671eba9cac59b9052ef183de27ba5b">logit</a> (double u)</td></tr>
<tr class="memdesc:ac7671eba9cac59b9052ef183de27ba5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log odds of the argument.  <a href="namespacestan_1_1math_ac7671eba9cac59b9052ef183de27ba5b.html#ac7671eba9cac59b9052ef183de27ba5b">More...</a><br /></td></tr>
<tr class="separator:ac7671eba9cac59b9052ef183de27ba5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044d6a3a30855ba177973a5c7db2125c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a044d6a3a30855ba177973a5c7db2125c.html#a044d6a3a30855ba177973a5c7db2125c">logit</a> (int u)</td></tr>
<tr class="memdesc:a044d6a3a30855ba177973a5c7db2125c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log odds of the argument.  <a href="namespacestan_1_1math_a044d6a3a30855ba177973a5c7db2125c.html#a044d6a3a30855ba177973a5c7db2125c">More...</a><br /></td></tr>
<tr class="separator:a044d6a3a30855ba177973a5c7db2125c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68da7c9c3e50d5e249f9bb07ba4fe1d6"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr, require_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a68da7c9c3e50d5e249f9bb07ba4fe1d6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a68da7c9c3e50d5e249f9bb07ba4fe1d6.html#a68da7c9c3e50d5e249f9bb07ba4fe1d6">logit</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a68da7c9c3e50d5e249f9bb07ba4fe1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_ab025eaf1e6f5c920f69c37e7a7f8b319.html#ab025eaf1e6f5c920f69c37e7a7f8b319">logit()</a></code> to specified argument container.  <a href="namespacestan_1_1math_a68da7c9c3e50d5e249f9bb07ba4fe1d6.html#a68da7c9c3e50d5e249f9bb07ba4fe1d6">More...</a><br /></td></tr>
<tr class="separator:a68da7c9c3e50d5e249f9bb07ba4fe1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d651925b8f57e59c0aa08e2b7cfd0fe"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8d651925b8f57e59c0aa08e2b7cfd0fe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8d651925b8f57e59c0aa08e2b7cfd0fe.html#a8d651925b8f57e59c0aa08e2b7cfd0fe">logit</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a8d651925b8f57e59c0aa08e2b7cfd0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="namespacestan_1_1math_ab025eaf1e6f5c920f69c37e7a7f8b319.html#ab025eaf1e6f5c920f69c37e7a7f8b319">logit()</a> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_a8d651925b8f57e59c0aa08e2b7cfd0fe.html#a8d651925b8f57e59c0aa08e2b7cfd0fe">More...</a><br /></td></tr>
<tr class="separator:a8d651925b8f57e59c0aa08e2b7cfd0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae497d37bdef3fcbba1d0be1ce5f385a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , require_all_stan_scalar_t&lt; T, L, U &gt; *  = nullptr, require_not_var_t&lt; return_type_t&lt; T, L, U &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aae497d37bdef3fcbba1d0be1ce5f385a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aae497d37bdef3fcbba1d0be1ce5f385a.html#aae497d37bdef3fcbba1d0be1ce5f385a">lub_constrain</a> (T &amp;&amp;x, L &amp;&amp;lb, U &amp;&amp;ub)</td></tr>
<tr class="memdesc:aae497d37bdef3fcbba1d0be1ce5f385a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower and upper-bounded scalar derived by transforming the specified free scalar given the specified lower and upper bounds.  <a href="namespacestan_1_1math_aae497d37bdef3fcbba1d0be1ce5f385a.html#aae497d37bdef3fcbba1d0be1ce5f385a">More...</a><br /></td></tr>
<tr class="separator:aae497d37bdef3fcbba1d0be1ce5f385a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae134c42fe1bca06f7f8ccacab4879f33"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , require_all_stan_scalar_t&lt; T, L, U &gt; *  = nullptr, require_not_var_t&lt; return_type_t&lt; T, L, U &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae134c42fe1bca06f7f8ccacab4879f33"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae134c42fe1bca06f7f8ccacab4879f33.html#ae134c42fe1bca06f7f8ccacab4879f33">lub_constrain</a> (T &amp;&amp;x, L &amp;&amp;lb, U &amp;&amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:ae134c42fe1bca06f7f8ccacab4879f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower- and upper-bounded scalar derived by transforming the specified free scalar given the specified lower and upper bounds and increment the specified log density with the log absolute Jacobian determinant.  <a href="namespacestan_1_1math_ae134c42fe1bca06f7f8ccacab4879f33.html#ae134c42fe1bca06f7f8ccacab4879f33">More...</a><br /></td></tr>
<tr class="separator:ae134c42fe1bca06f7f8ccacab4879f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecad691243b07d692c104b77c238cdb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , require_eigen_t&lt; T &gt; *  = nullptr, require_all_stan_scalar_t&lt; L, U &gt; *  = nullptr, require_not_var_t&lt; return_type_t&lt; T, L, U &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaecad691243b07d692c104b77c238cdb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaecad691243b07d692c104b77c238cdb.html#aaecad691243b07d692c104b77c238cdb">lub_constrain</a> (const T &amp;x, const L &amp;lb, const U &amp;ub)</td></tr>
<tr class="memdesc:aaecad691243b07d692c104b77c238cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for <a class="el" href="namespace_eigen.html">Eigen</a> matrix and scalar bounds.  <a href="namespacestan_1_1math_aaecad691243b07d692c104b77c238cdb.html#aaecad691243b07d692c104b77c238cdb">More...</a><br /></td></tr>
<tr class="separator:aaecad691243b07d692c104b77c238cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04174686500fae0f855f32a57a5f3447"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , require_eigen_t&lt; T &gt; *  = nullptr, require_all_stan_scalar_t&lt; L, U &gt; *  = nullptr, require_not_var_t&lt; return_type_t&lt; T, L, U &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a04174686500fae0f855f32a57a5f3447"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a04174686500fae0f855f32a57a5f3447.html#a04174686500fae0f855f32a57a5f3447">lub_constrain</a> (const T &amp;x, const L &amp;lb, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:a04174686500fae0f855f32a57a5f3447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for <a class="el" href="namespace_eigen.html">Eigen</a> matrix and scalar bounds plus lp.  <a href="namespacestan_1_1math_a04174686500fae0f855f32a57a5f3447.html#a04174686500fae0f855f32a57a5f3447">More...</a><br /></td></tr>
<tr class="separator:a04174686500fae0f855f32a57a5f3447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab957f3a08646b760db1cab5fcb5b762d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , require_all_eigen_t&lt; T, L, U &gt; *  = nullptr, require_not_var_t&lt; return_type_t&lt; T, L, U &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab957f3a08646b760db1cab5fcb5b762d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab957f3a08646b760db1cab5fcb5b762d.html#ab957f3a08646b760db1cab5fcb5b762d">lub_constrain</a> (const T &amp;x, const L &amp;lb, const U &amp;ub)</td></tr>
<tr class="memdesc:ab957f3a08646b760db1cab5fcb5b762d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for <a class="el" href="namespace_eigen.html">Eigen</a> matrix and matrix bounds.  <a href="namespacestan_1_1math_ab957f3a08646b760db1cab5fcb5b762d.html#ab957f3a08646b760db1cab5fcb5b762d">More...</a><br /></td></tr>
<tr class="separator:ab957f3a08646b760db1cab5fcb5b762d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fe3b39de2d7765910a028df5fbfe51"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , require_all_not_std_vector_t&lt; L, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a15fe3b39de2d7765910a028df5fbfe51"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a15fe3b39de2d7765910a028df5fbfe51.html#a15fe3b39de2d7765910a028df5fbfe51">lub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const L &amp;lb, const U &amp;ub)</td></tr>
<tr class="memdesc:a15fe3b39de2d7765910a028df5fbfe51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and non-array lb and ub.  <a href="namespacestan_1_1math_a15fe3b39de2d7765910a028df5fbfe51.html#a15fe3b39de2d7765910a028df5fbfe51">More...</a><br /></td></tr>
<tr class="separator:a15fe3b39de2d7765910a028df5fbfe51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092f79b9e5b19ffa6cd8c7748e3c62a6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , require_all_not_std_vector_t&lt; L, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a092f79b9e5b19ffa6cd8c7748e3c62a6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a092f79b9e5b19ffa6cd8c7748e3c62a6.html#a092f79b9e5b19ffa6cd8c7748e3c62a6">lub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const L &amp;lb, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:a092f79b9e5b19ffa6cd8c7748e3c62a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and non-array lb and ub with lp.  <a href="namespacestan_1_1math_a092f79b9e5b19ffa6cd8c7748e3c62a6.html#a092f79b9e5b19ffa6cd8c7748e3c62a6">More...</a><br /></td></tr>
<tr class="separator:a092f79b9e5b19ffa6cd8c7748e3c62a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbdd40aa85089a5f31e27d7aa788453"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , require_not_std_vector_t&lt; L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aadbdd40aa85089a5f31e27d7aa788453"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aadbdd40aa85089a5f31e27d7aa788453.html#aadbdd40aa85089a5f31e27d7aa788453">lub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const L &amp;lb, const std::vector&lt; U &gt; &amp;ub)</td></tr>
<tr class="memdesc:aadbdd40aa85089a5f31e27d7aa788453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and ub and non-array lb.  <a href="namespacestan_1_1math_aadbdd40aa85089a5f31e27d7aa788453.html#aadbdd40aa85089a5f31e27d7aa788453">More...</a><br /></td></tr>
<tr class="separator:aadbdd40aa85089a5f31e27d7aa788453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40e264cb3fffacaccdcae7e912702ae"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , require_not_std_vector_t&lt; L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac40e264cb3fffacaccdcae7e912702ae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac40e264cb3fffacaccdcae7e912702ae.html#ac40e264cb3fffacaccdcae7e912702ae">lub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const L &amp;lb, const std::vector&lt; U &gt; &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:ac40e264cb3fffacaccdcae7e912702ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and ub and non-array lb with lp.  <a href="namespacestan_1_1math_ac40e264cb3fffacaccdcae7e912702ae.html#ac40e264cb3fffacaccdcae7e912702ae">More...</a><br /></td></tr>
<tr class="separator:ac40e264cb3fffacaccdcae7e912702ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455e05e9fa5aeceb0b34aa2924f73f28"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , require_not_std_vector_t&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a455e05e9fa5aeceb0b34aa2924f73f28"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a455e05e9fa5aeceb0b34aa2924f73f28.html#a455e05e9fa5aeceb0b34aa2924f73f28">lub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; L &gt; &amp;lb, const U &amp;ub)</td></tr>
<tr class="memdesc:a455e05e9fa5aeceb0b34aa2924f73f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and lb and non-array ub.  <a href="namespacestan_1_1math_a455e05e9fa5aeceb0b34aa2924f73f28.html#a455e05e9fa5aeceb0b34aa2924f73f28">More...</a><br /></td></tr>
<tr class="separator:a455e05e9fa5aeceb0b34aa2924f73f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6ea9417298dfc59aeea48423791a80"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , require_not_std_vector_t&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8f6ea9417298dfc59aeea48423791a80"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8f6ea9417298dfc59aeea48423791a80.html#a8f6ea9417298dfc59aeea48423791a80">lub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; L &gt; &amp;lb, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:a8f6ea9417298dfc59aeea48423791a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and lb and non-array ub with lp.  <a href="namespacestan_1_1math_a8f6ea9417298dfc59aeea48423791a80.html#a8f6ea9417298dfc59aeea48423791a80">More...</a><br /></td></tr>
<tr class="separator:a8f6ea9417298dfc59aeea48423791a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e85e3460b32eeeb97506d24e30ea46"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:a37e85e3460b32eeeb97506d24e30ea46"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a37e85e3460b32eeeb97506d24e30ea46.html#a37e85e3460b32eeeb97506d24e30ea46">lub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; L &gt; &amp;lb, const std::vector&lt; U &gt; &amp;ub)</td></tr>
<tr class="memdesc:a37e85e3460b32eeeb97506d24e30ea46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x, lb, and ub with lp.  <a href="namespacestan_1_1math_a37e85e3460b32eeeb97506d24e30ea46.html#a37e85e3460b32eeeb97506d24e30ea46">More...</a><br /></td></tr>
<tr class="separator:a37e85e3460b32eeeb97506d24e30ea46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3463cc493c5b235e3dc6036a26291c02"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:a3463cc493c5b235e3dc6036a26291c02"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3463cc493c5b235e3dc6036a26291c02.html#a3463cc493c5b235e3dc6036a26291c02">lub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; L &gt; &amp;lb, const std::vector&lt; U &gt; &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:a3463cc493c5b235e3dc6036a26291c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x, lb, and ub.  <a href="namespacestan_1_1math_a3463cc493c5b235e3dc6036a26291c02.html#a3463cc493c5b235e3dc6036a26291c02">More...</a><br /></td></tr>
<tr class="separator:a3463cc493c5b235e3dc6036a26291c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf16b46888fe2babb597e4ab46acbe3e"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:adf16b46888fe2babb597e4ab46acbe3e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adf16b46888fe2babb597e4ab46acbe3e.html#adf16b46888fe2babb597e4ab46acbe3e">lub_constrain</a> (const T &amp;x, const L &amp;lb, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:adf16b46888fe2babb597e4ab46acbe3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower and upper-bounded scalar derived by transforming the specified free scalar given the specified lower and upper bounds.  <a href="namespacestan_1_1math_adf16b46888fe2babb597e4ab46acbe3e.html#adf16b46888fe2babb597e4ab46acbe3e">More...</a><br /></td></tr>
<tr class="separator:adf16b46888fe2babb597e4ab46acbe3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19226fbd86432a305e50e527506cff52"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a19226fbd86432a305e50e527506cff52"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a19226fbd86432a305e50e527506cff52.html#a19226fbd86432a305e50e527506cff52">make_nu</a> (const T &amp;eta, size_t K)</td></tr>
<tr class="memdesc:a19226fbd86432a305e50e527506cff52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the degrees of freedom for the t distribution that corresponds to the shape parameter in the LKJ distribution.  <a href="namespacestan_1_1math_a19226fbd86432a305e50e527506cff52.html#a19226fbd86432a305e50e527506cff52">More...</a><br /></td></tr>
<tr class="separator:a19226fbd86432a305e50e527506cff52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76993ead728548fa4da12c95b9cd0e7a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_eigen_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a76993ead728548fa4da12c95b9cd0e7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a76993ead728548fa4da12c95b9cd0e7a.html#a76993ead728548fa4da12c95b9cd0e7a">matrix_exp</a> (const T &amp;A_in)</td></tr>
<tr class="memdesc:a76993ead728548fa4da12c95b9cd0e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the matrix exponential of the input matrix.  <a href="namespacestan_1_1math_a76993ead728548fa4da12c95b9cd0e7a.html#a76993ead728548fa4da12c95b9cd0e7a">More...</a><br /></td></tr>
<tr class="separator:a76993ead728548fa4da12c95b9cd0e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ad6a38a91fb4f77ba34b4233eb0269"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a25ad6a38a91fb4f77ba34b4233eb0269"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a25ad6a38a91fb4f77ba34b4233eb0269.html#a25ad6a38a91fb4f77ba34b4233eb0269">matrix_exp_2x2</a> (const EigMat &amp;A)</td></tr>
<tr class="memdesc:a25ad6a38a91fb4f77ba34b4233eb0269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the matrix exponential of a 2x2 matrix.  <a href="namespacestan_1_1math_a25ad6a38a91fb4f77ba34b4233eb0269.html#a25ad6a38a91fb4f77ba34b4233eb0269">More...</a><br /></td></tr>
<tr class="separator:a25ad6a38a91fb4f77ba34b4233eb0269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81dfe794c9eacc6b45ea3ef3729e59b6"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_eigen_t&lt; EigMat1, EigMat2 &gt; *  = nullptr, require_all_st_same&lt; double, EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a81dfe794c9eacc6b45ea3ef3729e59b6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, Eigen::Dynamic, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a81dfe794c9eacc6b45ea3ef3729e59b6.html#a81dfe794c9eacc6b45ea3ef3729e59b6">matrix_exp_multiply</a> (const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:a81dfe794c9eacc6b45ea3ef3729e59b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return product of exp(A) and B, where A is a NxN double matrix, B is a NxCb double matrix, and t is a double.  <a href="namespacestan_1_1math_a81dfe794c9eacc6b45ea3ef3729e59b6.html#a81dfe794c9eacc6b45ea3ef3729e59b6">More...</a><br /></td></tr>
<tr class="separator:a81dfe794c9eacc6b45ea3ef3729e59b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20e6d4600f748c4c09ec257821c0bd9"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa20e6d4600f748c4c09ec257821c0bd9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, EigMat::RowsAtCompileTime, EigMat::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa20e6d4600f748c4c09ec257821c0bd9.html#aa20e6d4600f748c4c09ec257821c0bd9">matrix_exp_pade</a> (const EigMat &amp;<a class="el" href="namespacestan_1_1math_a7c8ad2370c5624d7c0700410e6612514.html#a7c8ad2370c5624d7c0700410e6612514">arg</a>)</td></tr>
<tr class="memdesc:aa20e6d4600f748c4c09ec257821c0bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the matrix exponential, using a Pade approximation, coupled with scaling and squaring.  <a href="namespacestan_1_1math_aa20e6d4600f748c4c09ec257821c0bd9.html#aa20e6d4600f748c4c09ec257821c0bd9">More...</a><br /></td></tr>
<tr class="separator:aa20e6d4600f748c4c09ec257821c0bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40d25cfa0f172be54ca709582d893c8"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_not_vt_var&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae40d25cfa0f172be54ca709582d893c8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, EigMat::RowsAtCompileTime, EigMat::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae40d25cfa0f172be54ca709582d893c8.html#ae40d25cfa0f172be54ca709582d893c8">matrix_power</a> (const EigMat &amp;M, const int n)</td></tr>
<tr class="memdesc:ae40d25cfa0f172be54ca709582d893c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth power of the specific matrix.  <a href="namespacestan_1_1math_ae40d25cfa0f172be54ca709582d893c8.html#ae40d25cfa0f172be54ca709582d893c8">More...</a><br /></td></tr>
<tr class="separator:ae40d25cfa0f172be54ca709582d893c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adc2477c064451364bfd15d50a95803"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4adc2477c064451364bfd15d50a95803"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, EigMat::RowsAtCompileTime, EigMat::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4adc2477c064451364bfd15d50a95803.html#a4adc2477c064451364bfd15d50a95803">operator^</a> (const EigMat &amp;M, const int n)</td></tr>
<tr class="separator:a4adc2477c064451364bfd15d50a95803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff33af49e42875a07f600583adb4940"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_arithmetic_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeff33af49e42875a07f600583adb4940"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeff33af49e42875a07f600583adb4940.html#aeff33af49e42875a07f600583adb4940">max</a> (T1 x, T2 y)</td></tr>
<tr class="memdesc:aeff33af49e42875a07f600583adb4940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum value of the two specified scalar arguments.  <a href="namespacestan_1_1math_aeff33af49e42875a07f600583adb4940.html#aeff33af49e42875a07f600583adb4940">More...</a><br /></td></tr>
<tr class="separator:aeff33af49e42875a07f600583adb4940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3381f5ed989090b1de96d93cc5cebe"><td class="memTemplParams" colspan="2">template&lt;typename T , require_container_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1b3381f5ed989090b1de96d93cc5cebe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1b3381f5ed989090b1de96d93cc5cebe.html#a1b3381f5ed989090b1de96d93cc5cebe">max</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a1b3381f5ed989090b1de96d93cc5cebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum value in the specified matrix, vector, row vector or std vector.  <a href="namespacestan_1_1math_a1b3381f5ed989090b1de96d93cc5cebe.html#a1b3381f5ed989090b1de96d93cc5cebe">More...</a><br /></td></tr>
<tr class="separator:a1b3381f5ed989090b1de96d93cc5cebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d06f7aa2013c06d8e026cea3f4c6aaa"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename... Ts&gt; </td></tr>
<tr class="memitem:a0d06f7aa2013c06d8e026cea3f4c6aaa"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0d06f7aa2013c06d8e026cea3f4c6aaa.html#a0d06f7aa2013c06d8e026cea3f4c6aaa">max_size</a> (const T1 &amp;x1, const Ts &amp;... xs)</td></tr>
<tr class="memdesc:a0d06f7aa2013c06d8e026cea3f4c6aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size of the largest input.  <a href="namespacestan_1_1math_a0d06f7aa2013c06d8e026cea3f4c6aaa.html#a0d06f7aa2013c06d8e026cea3f4c6aaa">More...</a><br /></td></tr>
<tr class="separator:a0d06f7aa2013c06d8e026cea3f4c6aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6ecee5a1e1e5ba862e8613ade4e55a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename... Ts&gt; </td></tr>
<tr class="memitem:a9f6ecee5a1e1e5ba862e8613ade4e55a"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9f6ecee5a1e1e5ba862e8613ade4e55a.html#a9f6ecee5a1e1e5ba862e8613ade4e55a">max_size_mvt</a> (const T1 &amp;x1, const Ts &amp;... xs)</td></tr>
<tr class="memdesc:a9f6ecee5a1e1e5ba862e8613ade4e55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size of the largest multivariate input.  <a href="namespacestan_1_1math_a9f6ecee5a1e1e5ba862e8613ade4e55a.html#a9f6ecee5a1e1e5ba862e8613ade4e55a">More...</a><br /></td></tr>
<tr class="separator:a9f6ecee5a1e1e5ba862e8613ade4e55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77dbfd1625ac9bc2037d73d68870bea5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_eigen_vt&lt; std::is_arithmetic, T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a77dbfd1625ac9bc2037d73d68870bea5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a77dbfd1625ac9bc2037d73d68870bea5.html#a77dbfd1625ac9bc2037d73d68870bea5">mdivide_left</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="memdesc:a77dbfd1625ac9bc2037d73d68870bea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b.  <a href="namespacestan_1_1math_a77dbfd1625ac9bc2037d73d68870bea5.html#a77dbfd1625ac9bc2037d73d68870bea5">More...</a><br /></td></tr>
<tr class="separator:a77dbfd1625ac9bc2037d73d68870bea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3f43a72fce06b48ae9c94d385d90a5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_all_not_st_var&lt; T, EigMat &gt; *  = nullptr, require_any_not_t&lt; std::is_arithmetic&lt; value_type_t&lt; T &gt;&gt;, is_fvar&lt; value_type_t&lt; EigMat &gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aba3f43a72fce06b48ae9c94d385d90a5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, EigMat &gt;, Eigen::Dynamic, EigMat::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aba3f43a72fce06b48ae9c94d385d90a5.html#aba3f43a72fce06b48ae9c94d385d90a5">mdivide_left_ldlt</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A, const EigMat &amp;b)</td></tr>
<tr class="memdesc:aba3f43a72fce06b48ae9c94d385d90a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> of A.  <a href="namespacestan_1_1math_aba3f43a72fce06b48ae9c94d385d90a5.html#aba3f43a72fce06b48ae9c94d385d90a5">More...</a><br /></td></tr>
<tr class="separator:aba3f43a72fce06b48ae9c94d385d90a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae163bc33a0092940191010d7b43a840"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_eigen_t&lt; EigMat1, EigMat2 &gt; *  = nullptr, require_all_not_vt_var&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aae163bc33a0092940191010d7b43a840"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, EigMat2 &gt;, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aae163bc33a0092940191010d7b43a840.html#aae163bc33a0092940191010d7b43a840">mdivide_left_spd</a> (const EigMat1 &amp;A, const EigMat2 &amp;b)</td></tr>
<tr class="memdesc:aae163bc33a0092940191010d7b43a840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b where A is symmetric positive definite.  <a href="namespacestan_1_1math_aae163bc33a0092940191010d7b43a840.html#aae163bc33a0092940191010d7b43a840">More...</a><br /></td></tr>
<tr class="separator:aae163bc33a0092940191010d7b43a840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352f3763c8ab5f11a104a22ea67299b7"><td class="memTemplParams" colspan="2">template&lt;Eigen::UpLoType TriView, typename T1 , typename T2 , require_all_eigen_t&lt; T1, T2 &gt; *  = nullptr, require_all_not_eigen_vt&lt; is_var, T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a352f3763c8ab5f11a104a22ea67299b7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a352f3763c8ab5f11a104a22ea67299b7.html#a352f3763c8ab5f11a104a22ea67299b7">mdivide_left_tri</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="memdesc:a352f3763c8ab5f11a104a22ea67299b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is triangular.  <a href="namespacestan_1_1math_a352f3763c8ab5f11a104a22ea67299b7.html#a352f3763c8ab5f11a104a22ea67299b7">More...</a><br /></td></tr>
<tr class="separator:a352f3763c8ab5f11a104a22ea67299b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3421ad6db5fb33eb489e01365c964625"><td class="memTemplParams" colspan="2">template&lt;Eigen::UpLoType TriView, typename T , require_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3421ad6db5fb33eb489e01365c964625"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3421ad6db5fb33eb489e01365c964625.html#a3421ad6db5fb33eb489e01365c964625">mdivide_left_tri</a> (const T &amp;A)</td></tr>
<tr class="memdesc:a3421ad6db5fb33eb489e01365c964625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is triangular and b=I.  <a href="namespacestan_1_1math_a3421ad6db5fb33eb489e01365c964625.html#a3421ad6db5fb33eb489e01365c964625">More...</a><br /></td></tr>
<tr class="separator:a3421ad6db5fb33eb489e01365c964625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f03ae4f72a048bc8bb56e4013d982a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_eigen_t&lt; T1, T2 &gt; *  = nullptr, require_all_not_eigen_vt&lt; is_fvar, T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a45f03ae4f72a048bc8bb56e4013d982a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a45f03ae4f72a048bc8bb56e4013d982a.html#a45f03ae4f72a048bc8bb56e4013d982a">mdivide_left_tri_low</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="memdesc:a45f03ae4f72a048bc8bb56e4013d982a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of left dividing the second argument by the first argument.  <a href="namespacestan_1_1math_a45f03ae4f72a048bc8bb56e4013d982a.html#a45f03ae4f72a048bc8bb56e4013d982a">More...</a><br /></td></tr>
<tr class="separator:a45f03ae4f72a048bc8bb56e4013d982a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48558db1c950455ae3f24aaff6c4695c"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr, require_not_eigen_vt&lt; is_fvar, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a48558db1c950455ae3f24aaff6c4695c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a48558db1c950455ae3f24aaff6c4695c.html#a48558db1c950455ae3f24aaff6c4695c">mdivide_left_tri_low</a> (const T &amp;A)</td></tr>
<tr class="separator:a48558db1c950455ae3f24aaff6c4695c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7164a9de9096f00a3567db729ed6c5f"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_eigen_t&lt; EigMat1, EigMat2 &gt; *  = nullptr, require_all_not_vt_fvar&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac7164a9de9096f00a3567db729ed6c5f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, EigMat2 &gt;, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac7164a9de9096f00a3567db729ed6c5f.html#ac7164a9de9096f00a3567db729ed6c5f">mdivide_right</a> (const EigMat1 &amp;b, const EigMat2 &amp;A)</td></tr>
<tr class="memdesc:ac7164a9de9096f00a3567db729ed6c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system xA=b.  <a href="namespacestan_1_1math_ac7164a9de9096f00a3567db729ed6c5f.html#ac7164a9de9096f00a3567db729ed6c5f">More...</a><br /></td></tr>
<tr class="separator:ac7164a9de9096f00a3567db729ed6c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c6a1c2143143a9540e2ebe417509fd"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename T , require_all_matrix_t&lt; EigMat, T &gt; *  = nullptr, require_any_not_st_arithmetic&lt; EigMat, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a15c6a1c2143143a9540e2ebe417509fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a15c6a1c2143143a9540e2ebe417509fd.html#a15c6a1c2143143a9540e2ebe417509fd">mdivide_right_ldlt</a> (const EigMat &amp;b, <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a15c6a1c2143143a9540e2ebe417509fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system xA=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> of A.  <a href="namespacestan_1_1math_a15c6a1c2143143a9540e2ebe417509fd.html#a15c6a1c2143143a9540e2ebe417509fd">More...</a><br /></td></tr>
<tr class="separator:a15c6a1c2143143a9540e2ebe417509fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa158e0937bbb4f102142898da4ca5b09"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename T , require_all_matrix_t&lt; EigMat, T &gt; *  = nullptr, require_all_st_arithmetic&lt; EigMat, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa158e0937bbb4f102142898da4ca5b09"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, EigMat::RowsAtCompileTime, T::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa158e0937bbb4f102142898da4ca5b09.html#aa158e0937bbb4f102142898da4ca5b09">mdivide_right_ldlt</a> (const EigMat &amp;b, <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aa158e0937bbb4f102142898da4ca5b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system xA=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> of A.  <a href="namespacestan_1_1math_aa158e0937bbb4f102142898da4ca5b09.html#aa158e0937bbb4f102142898da4ca5b09">More...</a><br /></td></tr>
<tr class="separator:aa158e0937bbb4f102142898da4ca5b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63997d441df1ac809a686517cc14797c"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_eigen_t&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a63997d441df1ac809a686517cc14797c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, EigMat2 &gt;, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a63997d441df1ac809a686517cc14797c.html#a63997d441df1ac809a686517cc14797c">mdivide_right_spd</a> (const EigMat1 &amp;b, const EigMat2 &amp;A)</td></tr>
<tr class="memdesc:a63997d441df1ac809a686517cc14797c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system xA=b where A is symmetric positive definite.  <a href="namespacestan_1_1math_a63997d441df1ac809a686517cc14797c.html#a63997d441df1ac809a686517cc14797c">More...</a><br /></td></tr>
<tr class="separator:a63997d441df1ac809a686517cc14797c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e274bf1d7c1181a117e5ad5c22c712d"><td class="memTemplParams" colspan="2">template&lt;Eigen::UpLoType TriView, typename EigMat1 , typename EigMat2 , require_all_eigen_t&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4e274bf1d7c1181a117e5ad5c22c712d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, EigMat2 &gt;, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4e274bf1d7c1181a117e5ad5c22c712d.html#a4e274bf1d7c1181a117e5ad5c22c712d">mdivide_right_tri</a> (const EigMat1 &amp;b, const EigMat2 &amp;A)</td></tr>
<tr class="memdesc:a4e274bf1d7c1181a117e5ad5c22c712d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system xA=b when A is triangular.  <a href="namespacestan_1_1math_a4e274bf1d7c1181a117e5ad5c22c712d.html#a4e274bf1d7c1181a117e5ad5c22c712d">More...</a><br /></td></tr>
<tr class="separator:a4e274bf1d7c1181a117e5ad5c22c712d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604872aef450127710a752301ee10149"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_eigen_t&lt; EigMat1, EigMat2 &gt; *  = nullptr, require_all_not_vt_fvar&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a604872aef450127710a752301ee10149"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, EigMat2 &gt;, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a604872aef450127710a752301ee10149.html#a604872aef450127710a752301ee10149">mdivide_right_tri_low</a> (const EigMat1 &amp;b, const EigMat2 &amp;A)</td></tr>
<tr class="memdesc:a604872aef450127710a752301ee10149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system x tri(A) = b when tri(A) is a lower triangular view of the matrix A.  <a href="namespacestan_1_1math_a604872aef450127710a752301ee10149.html#a604872aef450127710a752301ee10149">More...</a><br /></td></tr>
<tr class="separator:a604872aef450127710a752301ee10149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043904ca7823211c81af6e37278f7ab4"><td class="memTemplParams" colspan="2">template&lt;typename T , require_container_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a043904ca7823211c81af6e37278f7ab4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a043904ca7823211c81af6e37278f7ab4.html#a043904ca7823211c81af6e37278f7ab4">mean</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a043904ca7823211c81af6e37278f7ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample mean (i.e., average) of the coefficients in the specified std vector, vector, row vector, or matrix.  <a href="namespacestan_1_1math_a043904ca7823211c81af6e37278f7ab4.html#a043904ca7823211c81af6e37278f7ab4">More...</a><br /></td></tr>
<tr class="separator:a043904ca7823211c81af6e37278f7ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc5039339f8847534dee8b83cecad6c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_arithmetic_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9fc5039339f8847534dee8b83cecad6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9fc5039339f8847534dee8b83cecad6c.html#a9fc5039339f8847534dee8b83cecad6c">min</a> (T1 x, T2 y)</td></tr>
<tr class="memdesc:a9fc5039339f8847534dee8b83cecad6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum coefficient of the two specified scalar arguments.  <a href="namespacestan_1_1math_a9fc5039339f8847534dee8b83cecad6c.html#a9fc5039339f8847534dee8b83cecad6c">More...</a><br /></td></tr>
<tr class="separator:a9fc5039339f8847534dee8b83cecad6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e3c796496a4e9adaa2e1154b8a4838"><td class="memTemplParams" colspan="2">template&lt;typename T , require_container_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a36e3c796496a4e9adaa2e1154b8a4838"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a36e3c796496a4e9adaa2e1154b8a4838.html#a36e3c796496a4e9adaa2e1154b8a4838">min</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a36e3c796496a4e9adaa2e1154b8a4838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum coefficient in the specified matrix, vector, row vector or std vector.  <a href="namespacestan_1_1math_a36e3c796496a4e9adaa2e1154b8a4838.html#a36e3c796496a4e9adaa2e1154b8a4838">More...</a><br /></td></tr>
<tr class="separator:a36e3c796496a4e9adaa2e1154b8a4838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8849681cbcd96ae4967e4fb558ade8f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae8849681cbcd96ae4967e4fb558ade8f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae8849681cbcd96ae4967e4fb558ade8f.html#ae8849681cbcd96ae4967e4fb558ade8f">minus</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae8849681cbcd96ae4967e4fb558ade8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the negation of the specified scalar or matrix.  <a href="namespacestan_1_1math_ae8849681cbcd96ae4967e4fb558ade8f.html#ae8849681cbcd96ae4967e4fb558ade8f">More...</a><br /></td></tr>
<tr class="separator:ae8849681cbcd96ae4967e4fb558ade8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79b03c1902b72500d0374e7e8e0d17c"><td class="memTemplParams" colspan="2">template&lt;typename T2 , require_arithmetic_t&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac79b03c1902b72500d0374e7e8e0d17c"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac79b03c1902b72500d0374e7e8e0d17c.html#ac79b03c1902b72500d0374e7e8e0d17c">modified_bessel_first_kind</a> (int v, const T2 z)</td></tr>
<tr class="separator:ac79b03c1902b72500d0374e7e8e0d17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ca66bb0d964fed5f674e337638a933"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a51ca66bb0d964fed5f674e337638a933.html#a51ca66bb0d964fed5f674e337638a933">modified_bessel_first_kind</a> (int v, int z)</td></tr>
<tr class="memdesc:a51ca66bb0d964fed5f674e337638a933"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exists because when z is of type integer, cyl_bessel_i(v, z) returns an integer.  <a href="namespacestan_1_1math_a51ca66bb0d964fed5f674e337638a933.html#a51ca66bb0d964fed5f674e337638a933">More...</a><br /></td></tr>
<tr class="separator:a51ca66bb0d964fed5f674e337638a933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409b61bce5fbe6663bf23fd4dcac0c68"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a409b61bce5fbe6663bf23fd4dcac0c68"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a409b61bce5fbe6663bf23fd4dcac0c68.html#a409b61bce5fbe6663bf23fd4dcac0c68">modified_bessel_first_kind</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a409b61bce5fbe6663bf23fd4dcac0c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the modified_bessel_first_kind function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_a409b61bce5fbe6663bf23fd4dcac0c68.html#a409b61bce5fbe6663bf23fd4dcac0c68">More...</a><br /></td></tr>
<tr class="separator:a409b61bce5fbe6663bf23fd4dcac0c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6648ce15a9deb7c469d4615e6b2019"><td class="memTemplParams" colspan="2">template&lt;typename T2 , require_arithmetic_t&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaf6648ce15a9deb7c469d4615e6b2019"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaf6648ce15a9deb7c469d4615e6b2019.html#aaf6648ce15a9deb7c469d4615e6b2019">modified_bessel_second_kind</a> (int v, const T2 z)</td></tr>
<tr class="separator:aaf6648ce15a9deb7c469d4615e6b2019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0f55ec26ce8dc242d4de21ea3a99b2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abb0f55ec26ce8dc242d4de21ea3a99b2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abb0f55ec26ce8dc242d4de21ea3a99b2.html#abb0f55ec26ce8dc242d4de21ea3a99b2">modified_bessel_second_kind</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:abb0f55ec26ce8dc242d4de21ea3a99b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the modified_bessel_second_kind function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_abb0f55ec26ce8dc242d4de21ea3a99b2.html#abb0f55ec26ce8dc242d4de21ea3a99b2">More...</a><br /></td></tr>
<tr class="separator:abb0f55ec26ce8dc242d4de21ea3a99b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4949bffcdbae074c6017c13756a199e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4949bffcdbae074c6017c13756a199e3.html#a4949bffcdbae074c6017c13756a199e3">modulus</a> (int x, int y)</td></tr>
<tr class="separator:a4949bffcdbae074c6017c13756a199e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac01c236597fa71e13877a182aa5c3c"><td class="memTemplParams" colspan="2">template&lt;typename Mat , typename Scal , require_stan_scalar_t&lt; Scal &gt; *  = nullptr, require_eigen_t&lt; Mat &gt; *  = nullptr, require_all_not_st_var&lt; Scal, Mat &gt; *  = nullptr, require_all_not_complex_t&lt; Scal, value_type_t&lt; Mat &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9ac01c236597fa71e13877a182aa5c3c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ac01c236597fa71e13877a182aa5c3c.html#a9ac01c236597fa71e13877a182aa5c3c">multiply</a> (const Mat &amp;m, Scal c)</td></tr>
<tr class="memdesc:a9ac01c236597fa71e13877a182aa5c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified matrix multiplied by specified scalar.  <a href="namespacestan_1_1math_a9ac01c236597fa71e13877a182aa5c3c.html#a9ac01c236597fa71e13877a182aa5c3c">More...</a><br /></td></tr>
<tr class="separator:a9ac01c236597fa71e13877a182aa5c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e07ed24522fba9a8a099c6d1bbd9851"><td class="memTemplParams" colspan="2">template&lt;typename Mat , typename Scal , require_any_complex_t&lt; value_type_t&lt; Mat &gt;, Scal &gt; *  = nullptr, require_eigen_t&lt; Mat &gt; *  = nullptr, require_not_eigen_t&lt; Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9e07ed24522fba9a8a099c6d1bbd9851"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9e07ed24522fba9a8a099c6d1bbd9851.html#a9e07ed24522fba9a8a099c6d1bbd9851">multiply</a> (const Mat &amp;m, Scal c)</td></tr>
<tr class="memdesc:a9e07ed24522fba9a8a099c6d1bbd9851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the specified matrix and scalar, one of which must have a complex value type.  <a href="namespacestan_1_1math_a9e07ed24522fba9a8a099c6d1bbd9851.html#a9e07ed24522fba9a8a099c6d1bbd9851">More...</a><br /></td></tr>
<tr class="separator:a9e07ed24522fba9a8a099c6d1bbd9851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f48447fbea87a44755806b5de5aeb9"><td class="memTemplParams" colspan="2">template&lt;typename Mat , typename Scal , require_any_complex_t&lt; value_type_t&lt; Mat &gt;, Scal &gt; *  = nullptr, require_eigen_t&lt; Mat &gt; *  = nullptr, require_not_eigen_t&lt; Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a24f48447fbea87a44755806b5de5aeb9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a24f48447fbea87a44755806b5de5aeb9.html#a24f48447fbea87a44755806b5de5aeb9">multiply</a> (const Scal &amp;m, const Mat &amp;c)</td></tr>
<tr class="memdesc:a24f48447fbea87a44755806b5de5aeb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the specified matrix and scalar, one of which must have a complex value type.  <a href="namespacestan_1_1math_a24f48447fbea87a44755806b5de5aeb9.html#a24f48447fbea87a44755806b5de5aeb9">More...</a><br /></td></tr>
<tr class="separator:a24f48447fbea87a44755806b5de5aeb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162d159f007e5858090dd348400d35e6"><td class="memTemplParams" colspan="2">template&lt;typename Scal , typename Mat , require_stan_scalar_t&lt; Scal &gt; *  = nullptr, require_eigen_t&lt; Mat &gt; *  = nullptr, require_all_not_st_var&lt; Scal, Mat &gt; *  = nullptr, require_all_not_complex_t&lt; Scal, value_type_t&lt; Mat &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a162d159f007e5858090dd348400d35e6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a162d159f007e5858090dd348400d35e6.html#a162d159f007e5858090dd348400d35e6">multiply</a> (Scal c, const Mat &amp;m)</td></tr>
<tr class="memdesc:a162d159f007e5858090dd348400d35e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified scalar multiplied by specified matrix.  <a href="namespacestan_1_1math_a162d159f007e5858090dd348400d35e6.html#a162d159f007e5858090dd348400d35e6">More...</a><br /></td></tr>
<tr class="separator:a162d159f007e5858090dd348400d35e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0093659bc153fd5dcaecb29d33ff9f"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , require_all_eigen_vt&lt; std::is_arithmetic, Mat1, Mat2 &gt; *  = nullptr, require_not_eigen_row_and_col_t&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaf0093659bc153fd5dcaecb29d33ff9f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaf0093659bc153fd5dcaecb29d33ff9f.html#aaf0093659bc153fd5dcaecb29d33ff9f">multiply</a> (const Mat1 &amp;m1, const Mat2 &amp;m2)</td></tr>
<tr class="memdesc:aaf0093659bc153fd5dcaecb29d33ff9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the specified matrices.  <a href="namespacestan_1_1math_aaf0093659bc153fd5dcaecb29d33ff9f.html#aaf0093659bc153fd5dcaecb29d33ff9f">More...</a><br /></td></tr>
<tr class="separator:aaf0093659bc153fd5dcaecb29d33ff9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b4549f797ad9b35249fddc6e3586dd"><td class="memTemplParams" colspan="2">template&lt;typename RowVec , typename ColVec , require_not_var_t&lt; return_type_t&lt; RowVec, ColVec &gt;&gt; *  = nullptr, require_eigen_row_and_col_t&lt; RowVec, ColVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab5b4549f797ad9b35249fddc6e3586dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab5b4549f797ad9b35249fddc6e3586dd.html#ab5b4549f797ad9b35249fddc6e3586dd">multiply</a> (const RowVec &amp;rv, const ColVec &amp;v)</td></tr>
<tr class="memdesc:ab5b4549f797ad9b35249fddc6e3586dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the scalar product of the specified row vector and specified column vector.  <a href="namespacestan_1_1math_ab5b4549f797ad9b35249fddc6e3586dd.html#ab5b4549f797ad9b35249fddc6e3586dd">More...</a><br /></td></tr>
<tr class="separator:ab5b4549f797ad9b35249fddc6e3586dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533ddcf6d4ed648389a43130dee23125"><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 , require_all_stan_scalar_t&lt; Scalar1, Scalar2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a533ddcf6d4ed648389a43130dee23125"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Scalar1, Scalar2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a533ddcf6d4ed648389a43130dee23125.html#a533ddcf6d4ed648389a43130dee23125">multiply</a> (Scalar1 m, Scalar2 c)</td></tr>
<tr class="memdesc:a533ddcf6d4ed648389a43130dee23125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return product of scalars.  <a href="namespacestan_1_1math_a533ddcf6d4ed648389a43130dee23125.html#a533ddcf6d4ed648389a43130dee23125">More...</a><br /></td></tr>
<tr class="separator:a533ddcf6d4ed648389a43130dee23125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9444366e6a1b52f57b103bb5f3c8121d"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , require_all_arithmetic_t&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9444366e6a1b52f57b103bb5f3c8121d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_a, T_b &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9444366e6a1b52f57b103bb5f3c8121d.html#a9444366e6a1b52f57b103bb5f3c8121d">multiply_log</a> (const T_a a, const T_b b)</td></tr>
<tr class="memdesc:a9444366e6a1b52f57b103bb5f3c8121d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value of the first argument times log of the second argument while behaving properly with 0 inputs.  <a href="namespacestan_1_1math_a9444366e6a1b52f57b103bb5f3c8121d.html#a9444366e6a1b52f57b103bb5f3c8121d">More...</a><br /></td></tr>
<tr class="separator:a9444366e6a1b52f57b103bb5f3c8121d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42f126b20c232247a1c95d68aaf672e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr, require_all_not_var_matrix_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa42f126b20c232247a1c95d68aaf672e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa42f126b20c232247a1c95d68aaf672e.html#aa42f126b20c232247a1c95d68aaf672e">multiply_log</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:aa42f126b20c232247a1c95d68aaf672e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the multiply_log function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_aa42f126b20c232247a1c95d68aaf672e.html#aa42f126b20c232247a1c95d68aaf672e">More...</a><br /></td></tr>
<tr class="separator:aa42f126b20c232247a1c95d68aaf672e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89008c6dab18001aef6ddef1ac298db"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_matrix_dynamic_t&lt; EigMat &gt; *  = nullptr, require_not_st_autodiff&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac89008c6dab18001aef6ddef1ac298db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_aca2e8a0b7c1cca979b7ff43cbb75ca65.html#aca2e8a0b7c1cca979b7ff43cbb75ca65">matrix_d</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac89008c6dab18001aef6ddef1ac298db.html#ac89008c6dab18001aef6ddef1ac298db">multiply_lower_tri_self_transpose</a> (const EigMat &amp;L)</td></tr>
<tr class="memdesc:ac89008c6dab18001aef6ddef1ac298db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of multiplying the lower triangular portion of the input matrix by its own transpose.  <a href="namespacestan_1_1math_ac89008c6dab18001aef6ddef1ac298db.html#ac89008c6dab18001aef6ddef1ac298db">More...</a><br /></td></tr>
<tr class="separator:ac89008c6dab18001aef6ddef1ac298db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761e86b784eddd56b06b1ea50cba535a"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a761e86b784eddd56b06b1ea50cba535a"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a761e86b784eddd56b06b1ea50cba535a.html#a761e86b784eddd56b06b1ea50cba535a">norm</a> (const std::complex&lt; V &gt; &amp;z)</td></tr>
<tr class="memdesc:a761e86b784eddd56b06b1ea50cba535a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the squared magnitude of the complex argument.  <a href="namespacestan_1_1math_a761e86b784eddd56b06b1ea50cba535a.html#a761e86b784eddd56b06b1ea50cba535a">More...</a><br /></td></tr>
<tr class="separator:a761e86b784eddd56b06b1ea50cba535a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7837e5b258e3cc77500a296d8902baec"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vt&lt; std::is_arithmetic, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7837e5b258e3cc77500a296d8902baec"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7837e5b258e3cc77500a296d8902baec.html#a7837e5b258e3cc77500a296d8902baec">norm1</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a7837e5b258e3cc77500a296d8902baec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns L1 norm of a vector.  <a href="namespacestan_1_1math_a7837e5b258e3cc77500a296d8902baec.html#a7837e5b258e3cc77500a296d8902baec">More...</a><br /></td></tr>
<tr class="separator:a7837e5b258e3cc77500a296d8902baec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece7684acb74c6c155a8a573bf6423cb"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vt&lt; std::is_arithmetic, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aece7684acb74c6c155a8a573bf6423cb"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aece7684acb74c6c155a8a573bf6423cb.html#aece7684acb74c6c155a8a573bf6423cb">norm2</a> (const T &amp;v)</td></tr>
<tr class="memdesc:aece7684acb74c6c155a8a573bf6423cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns L2 norm of a vector.  <a href="namespacestan_1_1math_aece7684acb74c6c155a8a573bf6423cb.html#aece7684acb74c6c155a8a573bf6423cb">More...</a><br /></td></tr>
<tr class="separator:aece7684acb74c6c155a8a573bf6423cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda661a426de6d99b3aa3ea9ad846db7"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeda661a426de6d99b3aa3ea9ad846db7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeda661a426de6d99b3aa3ea9ad846db7.html#aeda661a426de6d99b3aa3ea9ad846db7">num_elements</a> (const T &amp;x)</td></tr>
<tr class="memdesc:aeda661a426de6d99b3aa3ea9ad846db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1, the number of elements in a primitive type.  <a href="namespacestan_1_1math_aeda661a426de6d99b3aa3ea9ad846db7.html#aeda661a426de6d99b3aa3ea9ad846db7">More...</a><br /></td></tr>
<tr class="separator:aeda661a426de6d99b3aa3ea9ad846db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a5d6d7f867666902fcd0adbe602920"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38a5d6d7f867666902fcd0adbe602920"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a38a5d6d7f867666902fcd0adbe602920.html#a38a5d6d7f867666902fcd0adbe602920">num_elements</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a38a5d6d7f867666902fcd0adbe602920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the specified vector.  <a href="namespacestan_1_1math_a38a5d6d7f867666902fcd0adbe602920.html#a38a5d6d7f867666902fcd0adbe602920">More...</a><br /></td></tr>
<tr class="separator:a38a5d6d7f867666902fcd0adbe602920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf991e16ddef0d7d5b980df3fe839e8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T, M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aedf991e16ddef0d7d5b980df3fe839e8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aedf991e16ddef0d7d5b980df3fe839e8.html#aedf991e16ddef0d7d5b980df3fe839e8">offset_multiplier_constrain</a> (const T &amp;x, const M &amp;mu, const S &amp;sigma)</td></tr>
<tr class="memdesc:aedf991e16ddef0d7d5b980df3fe839e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearly transformed value for the specified unconstrained input and specified offset and multiplier.  <a href="namespacestan_1_1math_aedf991e16ddef0d7d5b980df3fe839e8.html#aedf991e16ddef0d7d5b980df3fe839e8">More...</a><br /></td></tr>
<tr class="separator:aedf991e16ddef0d7d5b980df3fe839e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9cced951ec4341dee8a4313a0d486a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T, M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ade9cced951ec4341dee8a4313a0d486a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade9cced951ec4341dee8a4313a0d486a.html#ade9cced951ec4341dee8a4313a0d486a">offset_multiplier_constrain</a> (const T &amp;x, const M &amp;mu, const S &amp;sigma, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, M, S &gt; &amp;lp)</td></tr>
<tr class="memdesc:ade9cced951ec4341dee8a4313a0d486a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearly transformed value for the specified unconstrained input and specified offset and multiplier, incrementing the specified reference with the log absolute Jacobian determinant of the transform.  <a href="namespacestan_1_1math_ade9cced951ec4341dee8a4313a0d486a.html#ade9cced951ec4341dee8a4313a0d486a">More...</a><br /></td></tr>
<tr class="separator:ade9cced951ec4341dee8a4313a0d486a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf97fbdb286a72b9c2001b2a735372b1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , require_all_not_std_vector_t&lt; M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abf97fbdb286a72b9c2001b2a735372b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abf97fbdb286a72b9c2001b2a735372b1.html#abf97fbdb286a72b9c2001b2a735372b1">offset_multiplier_constrain</a> (const std::vector&lt; T &gt; &amp;x, const M &amp;mu, const S &amp;sigma)</td></tr>
<tr class="memdesc:abf97fbdb286a72b9c2001b2a735372b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and non-array mu and sigma.  <a href="namespacestan_1_1math_abf97fbdb286a72b9c2001b2a735372b1.html#abf97fbdb286a72b9c2001b2a735372b1">More...</a><br /></td></tr>
<tr class="separator:abf97fbdb286a72b9c2001b2a735372b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008d694d88d54a7b7a0e8abf19d775d9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , require_all_not_std_vector_t&lt; M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a008d694d88d54a7b7a0e8abf19d775d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a008d694d88d54a7b7a0e8abf19d775d9.html#a008d694d88d54a7b7a0e8abf19d775d9">offset_multiplier_constrain</a> (const std::vector&lt; T &gt; &amp;x, const M &amp;mu, const S &amp;sigma, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, M, S &gt; &amp;lp)</td></tr>
<tr class="memdesc:a008d694d88d54a7b7a0e8abf19d775d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and non-array mu and sigma with lp.  <a href="namespacestan_1_1math_a008d694d88d54a7b7a0e8abf19d775d9.html#a008d694d88d54a7b7a0e8abf19d775d9">More...</a><br /></td></tr>
<tr class="separator:a008d694d88d54a7b7a0e8abf19d775d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420a0d37c60c7bd6d06b54585babe066"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , require_not_std_vector_t&lt; M &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a420a0d37c60c7bd6d06b54585babe066"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a420a0d37c60c7bd6d06b54585babe066.html#a420a0d37c60c7bd6d06b54585babe066">offset_multiplier_constrain</a> (const std::vector&lt; T &gt; &amp;x, const M &amp;mu, const std::vector&lt; S &gt; &amp;sigma)</td></tr>
<tr class="memdesc:a420a0d37c60c7bd6d06b54585babe066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and sigma and non-array mu.  <a href="namespacestan_1_1math_a420a0d37c60c7bd6d06b54585babe066.html#a420a0d37c60c7bd6d06b54585babe066">More...</a><br /></td></tr>
<tr class="separator:a420a0d37c60c7bd6d06b54585babe066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b80302340e1436f422e6cc479dda19"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , require_not_std_vector_t&lt; M &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a03b80302340e1436f422e6cc479dda19"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a03b80302340e1436f422e6cc479dda19.html#a03b80302340e1436f422e6cc479dda19">offset_multiplier_constrain</a> (const std::vector&lt; T &gt; &amp;x, const M &amp;mu, const std::vector&lt; S &gt; &amp;sigma, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, M, S &gt; &amp;lp)</td></tr>
<tr class="memdesc:a03b80302340e1436f422e6cc479dda19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and sigma and non-array mu with lp.  <a href="namespacestan_1_1math_a03b80302340e1436f422e6cc479dda19.html#a03b80302340e1436f422e6cc479dda19">More...</a><br /></td></tr>
<tr class="separator:a03b80302340e1436f422e6cc479dda19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d13ff302785c8869fffc687eec205a1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , require_not_std_vector_t&lt; S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4d13ff302785c8869fffc687eec205a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4d13ff302785c8869fffc687eec205a1.html#a4d13ff302785c8869fffc687eec205a1">offset_multiplier_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; M &gt; &amp;mu, const S &amp;sigma)</td></tr>
<tr class="memdesc:a4d13ff302785c8869fffc687eec205a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and mu and non-array sigma.  <a href="namespacestan_1_1math_a4d13ff302785c8869fffc687eec205a1.html#a4d13ff302785c8869fffc687eec205a1">More...</a><br /></td></tr>
<tr class="separator:a4d13ff302785c8869fffc687eec205a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde7904bdf92ab67581bb39e9ab318bf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , require_not_std_vector_t&lt; S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afde7904bdf92ab67581bb39e9ab318bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afde7904bdf92ab67581bb39e9ab318bf.html#afde7904bdf92ab67581bb39e9ab318bf">offset_multiplier_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; M &gt; &amp;mu, const S &amp;sigma, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, M, S &gt; &amp;lp)</td></tr>
<tr class="memdesc:afde7904bdf92ab67581bb39e9ab318bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and mu and non-array sigma with lp.  <a href="namespacestan_1_1math_afde7904bdf92ab67581bb39e9ab318bf.html#afde7904bdf92ab67581bb39e9ab318bf">More...</a><br /></td></tr>
<tr class="separator:afde7904bdf92ab67581bb39e9ab318bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23fd4c859fe1ca5576a41f4457f3770"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S &gt; </td></tr>
<tr class="memitem:ad23fd4c859fe1ca5576a41f4457f3770"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad23fd4c859fe1ca5576a41f4457f3770.html#ad23fd4c859fe1ca5576a41f4457f3770">offset_multiplier_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; M &gt; &amp;mu, const std::vector&lt; S &gt; &amp;sigma)</td></tr>
<tr class="memdesc:ad23fd4c859fe1ca5576a41f4457f3770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x, mu, and sigma.  <a href="namespacestan_1_1math_ad23fd4c859fe1ca5576a41f4457f3770.html#ad23fd4c859fe1ca5576a41f4457f3770">More...</a><br /></td></tr>
<tr class="separator:ad23fd4c859fe1ca5576a41f4457f3770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa20a66a6ae30ec1604f35596f697be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S &gt; </td></tr>
<tr class="memitem:a2fa20a66a6ae30ec1604f35596f697be"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2fa20a66a6ae30ec1604f35596f697be.html#a2fa20a66a6ae30ec1604f35596f697be">offset_multiplier_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; M &gt; &amp;mu, const std::vector&lt; S &gt; &amp;sigma, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, M, S &gt; &amp;lp)</td></tr>
<tr class="memdesc:a2fa20a66a6ae30ec1604f35596f697be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x, mu, and sigma with lp.  <a href="namespacestan_1_1math_a2fa20a66a6ae30ec1604f35596f697be.html#a2fa20a66a6ae30ec1604f35596f697be">More...</a><br /></td></tr>
<tr class="separator:a2fa20a66a6ae30ec1604f35596f697be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d097e81ee6fa5b85a65b651cac84b1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S &gt; </td></tr>
<tr class="memitem:a67d097e81ee6fa5b85a65b651cac84b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a67d097e81ee6fa5b85a65b651cac84b1.html#a67d097e81ee6fa5b85a65b651cac84b1">offset_multiplier_free</a> (const T &amp;y, const M &amp;mu, const S &amp;sigma)</td></tr>
<tr class="memdesc:a67d097e81ee6fa5b85a65b651cac84b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unconstrained variable that transforms to the specified offset and multiplier constrained variable given the specified offset and multiplier.  <a href="namespacestan_1_1math_a67d097e81ee6fa5b85a65b651cac84b1.html#a67d097e81ee6fa5b85a65b651cac84b1">More...</a><br /></td></tr>
<tr class="separator:a67d097e81ee6fa5b85a65b651cac84b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3377532ab8d2ab913af4aa86b3ba6a8e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , require_all_not_std_vector_t&lt; M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3377532ab8d2ab913af4aa86b3ba6a8e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3377532ab8d2ab913af4aa86b3ba6a8e.html#a3377532ab8d2ab913af4aa86b3ba6a8e">offset_multiplier_free</a> (const std::vector&lt; T &gt; &amp;x, const M &amp;mu, const S &amp;sigma)</td></tr>
<tr class="memdesc:a3377532ab8d2ab913af4aa86b3ba6a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and non-array mu and sigma.  <a href="namespacestan_1_1math_a3377532ab8d2ab913af4aa86b3ba6a8e.html#a3377532ab8d2ab913af4aa86b3ba6a8e">More...</a><br /></td></tr>
<tr class="separator:a3377532ab8d2ab913af4aa86b3ba6a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2070af02d9160f828e0c9cc97b9536"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , require_not_std_vector_t&lt; M &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0f2070af02d9160f828e0c9cc97b9536"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0f2070af02d9160f828e0c9cc97b9536.html#a0f2070af02d9160f828e0c9cc97b9536">offset_multiplier_free</a> (const std::vector&lt; T &gt; &amp;x, const M &amp;mu, const std::vector&lt; S &gt; &amp;sigma)</td></tr>
<tr class="memdesc:a0f2070af02d9160f828e0c9cc97b9536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and sigma and non-array mu.  <a href="namespacestan_1_1math_a0f2070af02d9160f828e0c9cc97b9536.html#a0f2070af02d9160f828e0c9cc97b9536">More...</a><br /></td></tr>
<tr class="separator:a0f2070af02d9160f828e0c9cc97b9536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f66a79b120f46e613ba1f5bb9faac2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , require_not_std_vector_t&lt; S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a82f66a79b120f46e613ba1f5bb9faac2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a82f66a79b120f46e613ba1f5bb9faac2.html#a82f66a79b120f46e613ba1f5bb9faac2">offset_multiplier_free</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; M &gt; &amp;mu, const S &amp;sigma)</td></tr>
<tr class="memdesc:a82f66a79b120f46e613ba1f5bb9faac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and mu and non-array sigma.  <a href="namespacestan_1_1math_a82f66a79b120f46e613ba1f5bb9faac2.html#a82f66a79b120f46e613ba1f5bb9faac2">More...</a><br /></td></tr>
<tr class="separator:a82f66a79b120f46e613ba1f5bb9faac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5341d90f34ad1845cf8803b87c86b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S &gt; </td></tr>
<tr class="memitem:a1c5341d90f34ad1845cf8803b87c86b9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c5341d90f34ad1845cf8803b87c86b9.html#a1c5341d90f34ad1845cf8803b87c86b9">offset_multiplier_free</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; M &gt; &amp;mu, const std::vector&lt; S &gt; &amp;sigma)</td></tr>
<tr class="memdesc:a1c5341d90f34ad1845cf8803b87c86b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x, mu, and sigma.  <a href="namespacestan_1_1math_a1c5341d90f34ad1845cf8803b87c86b9.html#a1c5341d90f34ad1845cf8803b87c86b9">More...</a><br /></td></tr>
<tr class="separator:a1c5341d90f34ad1845cf8803b87c86b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c6315f53c1e066d55110ab47dd2a69"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a43c6315f53c1e066d55110ab47dd2a69.html#a43c6315f53c1e066d55110ab47dd2a69">one_hot_array</a> (int K, int k)</td></tr>
<tr class="memdesc:a43c6315f53c1e066d55110ab47dd2a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array with 1 in the k-th position and zero elsewhere.  <a href="namespacestan_1_1math_a43c6315f53c1e066d55110ab47dd2a69.html#a43c6315f53c1e066d55110ab47dd2a69">More...</a><br /></td></tr>
<tr class="separator:a43c6315f53c1e066d55110ab47dd2a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204b46cc37ce8e98ed985bb7324316be"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a204b46cc37ce8e98ed985bb7324316be.html#a204b46cc37ce8e98ed985bb7324316be">one_hot_int_array</a> (int K, int k)</td></tr>
<tr class="memdesc:a204b46cc37ce8e98ed985bb7324316be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an integer array with 1 in the k-th position and zero elsewhere.  <a href="namespacestan_1_1math_a204b46cc37ce8e98ed985bb7324316be.html#a204b46cc37ce8e98ed985bb7324316be">More...</a><br /></td></tr>
<tr class="separator:a204b46cc37ce8e98ed985bb7324316be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd26302c05628b4ffa75fc74e8ba01e8"><td class="memItemLeft" align="right" valign="top">Eigen::RowVectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afd26302c05628b4ffa75fc74e8ba01e8.html#afd26302c05628b4ffa75fc74e8ba01e8">one_hot_row_vector</a> (int K, int k)</td></tr>
<tr class="memdesc:afd26302c05628b4ffa75fc74e8ba01e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row vector with 1 in the k-th position and zero elsewhere.  <a href="namespacestan_1_1math_afd26302c05628b4ffa75fc74e8ba01e8.html#afd26302c05628b4ffa75fc74e8ba01e8">More...</a><br /></td></tr>
<tr class="separator:afd26302c05628b4ffa75fc74e8ba01e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca3688bf2cadf2f53e5c1e44db81047"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeca3688bf2cadf2f53e5c1e44db81047.html#aeca3688bf2cadf2f53e5c1e44db81047">one_hot_vector</a> (int K, int k)</td></tr>
<tr class="memdesc:aeca3688bf2cadf2f53e5c1e44db81047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector with 1 in the k-th position and zero elsewhere.  <a href="namespacestan_1_1math_aeca3688bf2cadf2f53e5c1e44db81047.html#aeca3688bf2cadf2f53e5c1e44db81047">More...</a><br /></td></tr>
<tr class="separator:aeca3688bf2cadf2f53e5c1e44db81047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edc54856924450a47f7975d9e5a14a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1edc54856924450a47f7975d9e5a14a8.html#a1edc54856924450a47f7975d9e5a14a8">ones_array</a> (int K)</td></tr>
<tr class="memdesc:a1edc54856924450a47f7975d9e5a14a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array of ones.  <a href="namespacestan_1_1math_a1edc54856924450a47f7975d9e5a14a8.html#a1edc54856924450a47f7975d9e5a14a8">More...</a><br /></td></tr>
<tr class="separator:a1edc54856924450a47f7975d9e5a14a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5b5101d528f4a5ecdc400483f7b99e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2d5b5101d528f4a5ecdc400483f7b99e.html#a2d5b5101d528f4a5ecdc400483f7b99e">ones_int_array</a> (int K)</td></tr>
<tr class="memdesc:a2d5b5101d528f4a5ecdc400483f7b99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an integer array of ones.  <a href="namespacestan_1_1math_a2d5b5101d528f4a5ecdc400483f7b99e.html#a2d5b5101d528f4a5ecdc400483f7b99e">More...</a><br /></td></tr>
<tr class="separator:a2d5b5101d528f4a5ecdc400483f7b99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046a8930e6ddfa1971e8b3702f0f0d07"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a046a8930e6ddfa1971e8b3702f0f0d07.html#a046a8930e6ddfa1971e8b3702f0f0d07">ones_row_vector</a> (int K)</td></tr>
<tr class="memdesc:a046a8930e6ddfa1971e8b3702f0f0d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row vector of ones.  <a href="namespacestan_1_1math_a046a8930e6ddfa1971e8b3702f0f0d07.html#a046a8930e6ddfa1971e8b3702f0f0d07">More...</a><br /></td></tr>
<tr class="separator:a046a8930e6ddfa1971e8b3702f0f0d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864bcb045ed57c89c5be99cfd90681f2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a864bcb045ed57c89c5be99cfd90681f2.html#a864bcb045ed57c89c5be99cfd90681f2">ones_vector</a> (int K)</td></tr>
<tr class="memdesc:a864bcb045ed57c89c5be99cfd90681f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of ones.  <a href="namespacestan_1_1math_a864bcb045ed57c89c5be99cfd90681f2.html#a864bcb045ed57c89c5be99cfd90681f2">More...</a><br /></td></tr>
<tr class="separator:a864bcb045ed57c89c5be99cfd90681f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ddb078e5381247946f0abd117560f3"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_eigen_col_vector_t&lt; EigVec &gt; *  = nullptr, require_not_st_var&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a76ddb078e5381247946f0abd117560f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; EigVec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a76ddb078e5381247946f0abd117560f3.html#a76ddb078e5381247946f0abd117560f3">ordered_constrain</a> (const EigVec &amp;x)</td></tr>
<tr class="memdesc:a76ddb078e5381247946f0abd117560f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an increasing ordered vector derived from the specified free vector.  <a href="namespacestan_1_1math_a76ddb078e5381247946f0abd117560f3.html#a76ddb078e5381247946f0abd117560f3">More...</a><br /></td></tr>
<tr class="separator:a76ddb078e5381247946f0abd117560f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29a5524fe8df8693351838cd520bf2e"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_eigen_col_vector_t&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad29a5524fe8df8693351838cd520bf2e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad29a5524fe8df8693351838cd520bf2e.html#ad29a5524fe8df8693351838cd520bf2e">ordered_constrain</a> (const EigVec &amp;x, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigVec &gt; &amp;lp)</td></tr>
<tr class="memdesc:ad29a5524fe8df8693351838cd520bf2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a positive valued, increasing ordered vector derived from the specified free vector and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <a href="namespacestan_1_1math_ad29a5524fe8df8693351838cd520bf2e.html#ad29a5524fe8df8693351838cd520bf2e">More...</a><br /></td></tr>
<tr class="separator:ad29a5524fe8df8693351838cd520bf2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce3b3e7aa50a2550bf304531a571686"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , require_not_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4ce3b3e7aa50a2550bf304531a571686"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4ce3b3e7aa50a2550bf304531a571686.html#a4ce3b3e7aa50a2550bf304531a571686">ordered_constrain</a> (const T &amp;x, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a4ce3b3e7aa50a2550bf304531a571686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a positive valued, increasing ordered vector derived from the specified free vector.  <a href="namespacestan_1_1math_a4ce3b3e7aa50a2550bf304531a571686.html#a4ce3b3e7aa50a2550bf304531a571686">More...</a><br /></td></tr>
<tr class="separator:a4ce3b3e7aa50a2550bf304531a571686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac81ca2b8d8c0e3e50e663e2f7786b8b"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_eigen_col_vector_t&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aac81ca2b8d8c0e3e50e663e2f7786b8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; EigVec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aac81ca2b8d8c0e3e50e663e2f7786b8b.html#aac81ca2b8d8c0e3e50e663e2f7786b8b">ordered_free</a> (const EigVec &amp;y)</td></tr>
<tr class="memdesc:aac81ca2b8d8c0e3e50e663e2f7786b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of unconstrained scalars that transform to the specified positive ordered vector.  <a href="namespacestan_1_1math_aac81ca2b8d8c0e3e50e663e2f7786b8b.html#aac81ca2b8d8c0e3e50e663e2f7786b8b">More...</a><br /></td></tr>
<tr class="separator:aac81ca2b8d8c0e3e50e663e2f7786b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8139d24e2b5106f36a5a9ee7e68adb2"><td class="memTemplParams" colspan="2">template&lt;typename T , require_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab8139d24e2b5106f36a5a9ee7e68adb2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab8139d24e2b5106f36a5a9ee7e68adb2.html#ab8139d24e2b5106f36a5a9ee7e68adb2">ordered_free</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ab8139d24e2b5106f36a5a9ee7e68adb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_aac81ca2b8d8c0e3e50e663e2f7786b8b.html#aac81ca2b8d8c0e3e50e663e2f7786b8b" title="Return the vector of unconstrained scalars that transform to the specified positive ordered vector.">ordered_free()</a></code> to untransform each <a class="el" href="namespace_eigen.html">Eigen</a> vector in a standard vector.  <a href="namespacestan_1_1math_ab8139d24e2b5106f36a5a9ee7e68adb2.html#ab8139d24e2b5106f36a5a9ee7e68adb2">More...</a><br /></td></tr>
<tr class="separator:ab8139d24e2b5106f36a5a9ee7e68adb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cb1a99f207d37c15d722085576834b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac3cb1a99f207d37c15d722085576834b.html#ac3cb1a99f207d37c15d722085576834b">owens_t</a> (double h, double a)</td></tr>
<tr class="memdesc:ac3cb1a99f207d37c15d722085576834b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of applying Owen's T function to the specified arguments.  <a href="namespacestan_1_1math_ac3cb1a99f207d37c15d722085576834b.html#ac3cb1a99f207d37c15d722085576834b">More...</a><br /></td></tr>
<tr class="separator:ac3cb1a99f207d37c15d722085576834b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f2f601c3b4f55c0c426ba25f1b12ee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr, require_all_not_var_and_matrix_types&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a49f2f601c3b4f55c0c426ba25f1b12ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a49f2f601c3b4f55c0c426ba25f1b12ee.html#a49f2f601c3b4f55c0c426ba25f1b12ee">owens_t</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a49f2f601c3b4f55c0c426ba25f1b12ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the owens_t function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_a49f2f601c3b4f55c0c426ba25f1b12ee.html#a49f2f601c3b4f55c0c426ba25f1b12ee">More...</a><br /></td></tr>
<tr class="separator:a49f2f601c3b4f55c0c426ba25f1b12ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230f87fdb29de01fb55f204f184ffd52"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a230f87fdb29de01fb55f204f184ffd52.html#a230f87fdb29de01fb55f204f184ffd52">Phi</a> (double x)</td></tr>
<tr class="memdesc:a230f87fdb29de01fb55f204f184ffd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unit normal cumulative distribution function.  <a href="namespacestan_1_1math_a230f87fdb29de01fb55f204f184ffd52.html#a230f87fdb29de01fb55f204f184ffd52">More...</a><br /></td></tr>
<tr class="separator:a230f87fdb29de01fb55f204f184ffd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a5b0f856d404ca9d40626033de418f"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr, require_not_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a85a5b0f856d404ca9d40626033de418f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a85a5b0f856d404ca9d40626033de418f.html#a85a5b0f856d404ca9d40626033de418f">Phi</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a85a5b0f856d404ca9d40626033de418f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_ac73a2c7f20161172ffee17c7c880019f.html#ac73a2c7f20161172ffee17c7c880019f">Phi()</a>.  <a href="namespacestan_1_1math_a85a5b0f856d404ca9d40626033de418f.html#a85a5b0f856d404ca9d40626033de418f">More...</a><br /></td></tr>
<tr class="separator:a85a5b0f856d404ca9d40626033de418f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afafe7c31f20df7e498de012e1e599d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2afafe7c31f20df7e498de012e1e599d.html#a2afafe7c31f20df7e498de012e1e599d">Phi_approx</a> (double x)</td></tr>
<tr class="memdesc:a2afafe7c31f20df7e498de012e1e599d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an approximation of the unit normal CDF.  <a href="namespacestan_1_1math_a2afafe7c31f20df7e498de012e1e599d.html#a2afafe7c31f20df7e498de012e1e599d">More...</a><br /></td></tr>
<tr class="separator:a2afafe7c31f20df7e498de012e1e599d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f646df0e9eca0cbe1a325e5e4fc85e9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4f646df0e9eca0cbe1a325e5e4fc85e9.html#a4f646df0e9eca0cbe1a325e5e4fc85e9">Phi_approx</a> (int x)</td></tr>
<tr class="memdesc:a4f646df0e9eca0cbe1a325e5e4fc85e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an approximation of the unit normal CDF.  <a href="namespacestan_1_1math_a4f646df0e9eca0cbe1a325e5e4fc85e9.html#a4f646df0e9eca0cbe1a325e5e4fc85e9">More...</a><br /></td></tr>
<tr class="separator:a4f646df0e9eca0cbe1a325e5e4fc85e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516e74bff9b716b35aac30455a85f212"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr, require_not_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a516e74bff9b716b35aac30455a85f212"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a516e74bff9b716b35aac30455a85f212.html#a516e74bff9b716b35aac30455a85f212">Phi_approx</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a516e74bff9b716b35aac30455a85f212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a628f13a708272b55a72684f3ea8dede5.html#a628f13a708272b55a72684f3ea8dede5" title="Return an approximation of the unit normal cumulative distribution function (CDF).">Phi_approx()</a></code> to specified argument container.  <a href="namespacestan_1_1math_a516e74bff9b716b35aac30455a85f212.html#a516e74bff9b716b35aac30455a85f212">More...</a><br /></td></tr>
<tr class="separator:a516e74bff9b716b35aac30455a85f212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86bc80305f8bb8db823d88c3e4f05eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af86bc80305f8bb8db823d88c3e4f05eb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af86bc80305f8bb8db823d88c3e4f05eb.html#af86bc80305f8bb8db823d88c3e4f05eb">plus</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:af86bc80305f8bb8db823d88c3e4f05eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unary plus of the input.  <a href="namespacestan_1_1math_af86bc80305f8bb8db823d88c3e4f05eb.html#af86bc80305f8bb8db823d88c3e4f05eb">More...</a><br /></td></tr>
<tr class="separator:af86bc80305f8bb8db823d88c3e4f05eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84df3d71a961e123283be2543439415"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , typename T_scalar  = scalar_type_t&lt;T_theta&gt;, require_eigen_vector_t&lt; T_theta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab84df3d71a961e123283be2543439415"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab84df3d71a961e123283be2543439415.html#ab84df3d71a961e123283be2543439415">poisson_binomial_log_probs</a> (int y, const T_theta &amp;theta)</td></tr>
<tr class="memdesc:ab84df3d71a961e123283be2543439415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last row of the log probability matrix of the Poisson-Binomial distribution given the number of successes and a vector of success probabilities.  <a href="namespacestan_1_1math_ab84df3d71a961e123283be2543439415.html#ab84df3d71a961e123283be2543439415">More...</a><br /></td></tr>
<tr class="separator:ab84df3d71a961e123283be2543439415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d6c5176ec865af96a7fdcae7c98097"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_theta , require_vt_integral&lt; T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae1d6c5176ec865af96a7fdcae7c98097"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae1d6c5176ec865af96a7fdcae7c98097.html#ae1d6c5176ec865af96a7fdcae7c98097">poisson_binomial_log_probs</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:ae1d6c5176ec865af96a7fdcae7c98097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d2546ae5f18c5aed605d87d227f2dd"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a45d2546ae5f18c5aed605d87d227f2dd.html#a45d2546ae5f18c5aed605d87d227f2dd">polar</a> (double r, double theta)</td></tr>
<tr class="memdesc:a45d2546ae5f18c5aed605d87d227f2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complex number with specified magnitude and phase angle.  <a href="namespacestan_1_1math_a45d2546ae5f18c5aed605d87d227f2dd.html#a45d2546ae5f18c5aed605d87d227f2dd">More...</a><br /></td></tr>
<tr class="separator:a45d2546ae5f18c5aed605d87d227f2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c15ef31f3848528570989459364287"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac8c15ef31f3848528570989459364287.html#ac8c15ef31f3848528570989459364287">polar</a> (double r, int theta)</td></tr>
<tr class="separator:ac8c15ef31f3848528570989459364287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7d145de94c45b57414f710201f81ae"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9a7d145de94c45b57414f710201f81ae.html#a9a7d145de94c45b57414f710201f81ae">polar</a> (int r, double theta)</td></tr>
<tr class="separator:a9a7d145de94c45b57414f710201f81ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8d36daa2d80c52c1cc0d22f004618a"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adf8d36daa2d80c52c1cc0d22f004618a.html#adf8d36daa2d80c52c1cc0d22f004618a">polar</a> (int r, int theta)</td></tr>
<tr class="separator:adf8d36daa2d80c52c1cc0d22f004618a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed63eca605a96847ceaee18f46592ffa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed63eca605a96847ceaee18f46592ffa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aed63eca605a96847ceaee18f46592ffa.html#aed63eca605a96847ceaee18f46592ffa">positive_constrain</a> (const T &amp;x)</td></tr>
<tr class="memdesc:aed63eca605a96847ceaee18f46592ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive value for the specified unconstrained input.  <a href="namespacestan_1_1math_aed63eca605a96847ceaee18f46592ffa.html#aed63eca605a96847ceaee18f46592ffa">More...</a><br /></td></tr>
<tr class="separator:aed63eca605a96847ceaee18f46592ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea85d57aa65b9b62108a2b2aee0e028"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:acea85d57aa65b9b62108a2b2aee0e028"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acea85d57aa65b9b62108a2b2aee0e028.html#acea85d57aa65b9b62108a2b2aee0e028">positive_constrain</a> (const T &amp;x, S &amp;lp)</td></tr>
<tr class="memdesc:acea85d57aa65b9b62108a2b2aee0e028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive value for the specified unconstrained input, incrementing the scalar reference with the log absolute Jacobian determinant.  <a href="namespacestan_1_1math_acea85d57aa65b9b62108a2b2aee0e028.html#acea85d57aa65b9b62108a2b2aee0e028">More...</a><br /></td></tr>
<tr class="separator:acea85d57aa65b9b62108a2b2aee0e028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e62e6476b4bd40be4f4f3d43948697d"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , require_not_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4e62e6476b4bd40be4f4f3d43948697d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4e62e6476b4bd40be4f4f3d43948697d.html#a4e62e6476b4bd40be4f4f3d43948697d">positive_constrain</a> (const T &amp;x, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a4e62e6476b4bd40be4f4f3d43948697d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive value for the specified unconstrained input.  <a href="namespacestan_1_1math_a4e62e6476b4bd40be4f4f3d43948697d.html#a4e62e6476b4bd40be4f4f3d43948697d">More...</a><br /></td></tr>
<tr class="separator:a4e62e6476b4bd40be4f4f3d43948697d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdf39f8f4f0754f06127f6af22ea33a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adcdf39f8f4f0754f06127f6af22ea33a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adcdf39f8f4f0754f06127f6af22ea33a.html#adcdf39f8f4f0754f06127f6af22ea33a">positive_free</a> (const T &amp;y)</td></tr>
<tr class="memdesc:adcdf39f8f4f0754f06127f6af22ea33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unconstrained value corresponding to the specified positive-constrained value.  <a href="namespacestan_1_1math_adcdf39f8f4f0754f06127f6af22ea33a.html#adcdf39f8f4f0754f06127f6af22ea33a">More...</a><br /></td></tr>
<tr class="separator:adcdf39f8f4f0754f06127f6af22ea33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cf2116783272e6bac4ad1c44478d8f"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_eigen_col_vector_t&lt; EigVec &gt; *  = nullptr, require_not_st_var&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa2cf2116783272e6bac4ad1c44478d8f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa2cf2116783272e6bac4ad1c44478d8f.html#aa2cf2116783272e6bac4ad1c44478d8f">positive_ordered_constrain</a> (const EigVec &amp;x)</td></tr>
<tr class="memdesc:aa2cf2116783272e6bac4ad1c44478d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an increasing positive ordered vector derived from the specified free vector.  <a href="namespacestan_1_1math_aa2cf2116783272e6bac4ad1c44478d8f.html#aa2cf2116783272e6bac4ad1c44478d8f">More...</a><br /></td></tr>
<tr class="separator:aa2cf2116783272e6bac4ad1c44478d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55b4f941c0b5cd9d47f10dd9936612a"><td class="memTemplParams" colspan="2">template&lt;typename Vec , require_col_vector_t&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af55b4f941c0b5cd9d47f10dd9936612a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af55b4f941c0b5cd9d47f10dd9936612a.html#af55b4f941c0b5cd9d47f10dd9936612a">positive_ordered_constrain</a> (const Vec &amp;x, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Vec &gt; &amp;lp)</td></tr>
<tr class="memdesc:af55b4f941c0b5cd9d47f10dd9936612a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a positive valued, increasing positive ordered vector derived from the specified free vector and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <a href="namespacestan_1_1math_af55b4f941c0b5cd9d47f10dd9936612a.html#af55b4f941c0b5cd9d47f10dd9936612a">More...</a><br /></td></tr>
<tr class="separator:af55b4f941c0b5cd9d47f10dd9936612a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868920c89bc9cec6609b909d7ac88bb8"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename Vec , require_not_std_vector_t&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a868920c89bc9cec6609b909d7ac88bb8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a868920c89bc9cec6609b909d7ac88bb8.html#a868920c89bc9cec6609b909d7ac88bb8">positive_ordered_constrain</a> (const Vec &amp;x, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Vec &gt; &amp;lp)</td></tr>
<tr class="memdesc:a868920c89bc9cec6609b909d7ac88bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a positive valued, increasing positive ordered vector derived from the specified free vector.  <a href="namespacestan_1_1math_a868920c89bc9cec6609b909d7ac88bb8.html#a868920c89bc9cec6609b909d7ac88bb8">More...</a><br /></td></tr>
<tr class="separator:a868920c89bc9cec6609b909d7ac88bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af884fb84903d7ac0ddfb89e7d2f2035b"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , require_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af884fb84903d7ac0ddfb89e7d2f2035b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af884fb84903d7ac0ddfb89e7d2f2035b.html#af884fb84903d7ac0ddfb89e7d2f2035b">positive_ordered_constrain</a> (const T &amp;x, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:af884fb84903d7ac0ddfb89e7d2f2035b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a positive valued, increasing positive ordered vector derived from the specified free vector.  <a href="namespacestan_1_1math_af884fb84903d7ac0ddfb89e7d2f2035b.html#af884fb84903d7ac0ddfb89e7d2f2035b">More...</a><br /></td></tr>
<tr class="separator:af884fb84903d7ac0ddfb89e7d2f2035b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f7b8f690e86347454dc50312d7e20e"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_eigen_col_vector_t&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a75f7b8f690e86347454dc50312d7e20e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a75f7b8f690e86347454dc50312d7e20e.html#a75f7b8f690e86347454dc50312d7e20e">positive_ordered_free</a> (const EigVec &amp;y)</td></tr>
<tr class="memdesc:a75f7b8f690e86347454dc50312d7e20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of unconstrained scalars that transform to the specified positive ordered vector.  <a href="namespacestan_1_1math_a75f7b8f690e86347454dc50312d7e20e.html#a75f7b8f690e86347454dc50312d7e20e">More...</a><br /></td></tr>
<tr class="separator:a75f7b8f690e86347454dc50312d7e20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c316e7c0b3b2f26d660d9d3c29076d"><td class="memTemplParams" colspan="2">template&lt;typename T , require_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a49c316e7c0b3b2f26d660d9d3c29076d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a49c316e7c0b3b2f26d660d9d3c29076d.html#a49c316e7c0b3b2f26d660d9d3c29076d">positive_ordered_free</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a49c316e7c0b3b2f26d660d9d3c29076d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_a75f7b8f690e86347454dc50312d7e20e.html#a75f7b8f690e86347454dc50312d7e20e" title="Return the vector of unconstrained scalars that transform to the specified positive ordered vector.">positive_ordered_free()</a></code> to untransform each <a class="el" href="namespace_eigen.html">Eigen</a> vector in a standard vector.  <a href="namespacestan_1_1math_a49c316e7c0b3b2f26d660d9d3c29076d.html#a49c316e7c0b3b2f26d660d9d3c29076d">More...</a><br /></td></tr>
<tr class="separator:a49c316e7c0b3b2f26d660d9d3c29076d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa64b79bf3e702a6aa8a2512aa1c4db"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_t&lt; disjunction&lt; is_complex&lt; T1 &gt;, std::is_arithmetic&lt; T1 &gt;&gt;, disjunction&lt; is_complex&lt; T2 &gt;, std::is_arithmetic&lt; T2 &gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1fa64b79bf3e702a6aa8a2512aa1c4db"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1fa64b79bf3e702a6aa8a2512aa1c4db.html#a1fa64b79bf3e702a6aa8a2512aa1c4db">pow</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a1fa64b79bf3e702a6aa8a2512aa1c4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_a1fa64b79bf3e702a6aa8a2512aa1c4db.html#a1fa64b79bf3e702a6aa8a2512aa1c4db">More...</a><br /></td></tr>
<tr class="separator:a1fa64b79bf3e702a6aa8a2512aa1c4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5b8c8fb2f1918390558eb92d798efa"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr, require_all_not_matrix_st&lt; is_var, T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aad5b8c8fb2f1918390558eb92d798efa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aad5b8c8fb2f1918390558eb92d798efa.html#aad5b8c8fb2f1918390558eb92d798efa">pow</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:aad5b8c8fb2f1918390558eb92d798efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise raising of the first argument to the power of the second argument.  <a href="namespacestan_1_1math_aad5b8c8fb2f1918390558eb92d798efa.html#aad5b8c8fb2f1918390558eb92d798efa">More...</a><br /></td></tr>
<tr class="separator:aad5b8c8fb2f1918390558eb92d798efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcab1be70c001e732a6d6192abb88259"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adcab1be70c001e732a6d6192abb88259"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adcab1be70c001e732a6d6192abb88259.html#adcab1be70c001e732a6d6192abb88259">primitive_value</a> (T x)</td></tr>
<tr class="memdesc:adcab1be70c001e732a6d6192abb88259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified arithmetic argument unmodified with its own declared type.  <a href="namespacestan_1_1math_adcab1be70c001e732a6d6192abb88259.html#adcab1be70c001e732a6d6192abb88259">More...</a><br /></td></tr>
<tr class="separator:adcab1be70c001e732a6d6192abb88259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ca3182db83f58f821a8a7848f6475d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae7ca3182db83f58f821a8a7848f6475d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_arithmetic&lt; T &gt;::value, double &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae7ca3182db83f58f821a8a7848f6475d.html#ae7ca3182db83f58f821a8a7848f6475d">primitive_value</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae7ca3182db83f58f821a8a7848f6475d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the primitive value of the specified argument.  <a href="namespacestan_1_1math_ae7ca3182db83f58f821a8a7848f6475d.html#ae7ca3182db83f58f821a8a7848f6475d">More...</a><br /></td></tr>
<tr class="separator:ae7ca3182db83f58f821a8a7848f6475d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25230814358d3c34c873c15fd632763"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae25230814358d3c34c873c15fd632763"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae25230814358d3c34c873c15fd632763.html#ae25230814358d3c34c873c15fd632763">prob_constrain</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae25230814358d3c34c873c15fd632763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a probability value constrained to fall between 0 and 1 (inclusive) for the specified free scalar.  <a href="namespacestan_1_1math_ae25230814358d3c34c873c15fd632763.html#ae25230814358d3c34c873c15fd632763">More...</a><br /></td></tr>
<tr class="separator:ae25230814358d3c34c873c15fd632763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19d6612c8fe53619c02ff877414ca10"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af19d6612c8fe53619c02ff877414ca10"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af19d6612c8fe53619c02ff877414ca10.html#af19d6612c8fe53619c02ff877414ca10">prob_constrain</a> (const T &amp;x, T &amp;lp)</td></tr>
<tr class="memdesc:af19d6612c8fe53619c02ff877414ca10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a probability value constrained to fall between 0 and 1 (inclusive) for the specified free scalar and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <a href="namespacestan_1_1math_af19d6612c8fe53619c02ff877414ca10.html#af19d6612c8fe53619c02ff877414ca10">More...</a><br /></td></tr>
<tr class="separator:af19d6612c8fe53619c02ff877414ca10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21533f0a7d1376831b404ce9de0e50c5"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T &gt; </td></tr>
<tr class="memitem:a21533f0a7d1376831b404ce9de0e50c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a21533f0a7d1376831b404ce9de0e50c5.html#a21533f0a7d1376831b404ce9de0e50c5">prob_constrain</a> (const T &amp;x, T &amp;lp)</td></tr>
<tr class="memdesc:a21533f0a7d1376831b404ce9de0e50c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a probability value constrained to fall between 0 and 1 (inclusive) for the specified free scalar.  <a href="namespacestan_1_1math_a21533f0a7d1376831b404ce9de0e50c5.html#a21533f0a7d1376831b404ce9de0e50c5">More...</a><br /></td></tr>
<tr class="separator:a21533f0a7d1376831b404ce9de0e50c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9321898b01526d513e0c9ddaf9db2fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9321898b01526d513e0c9ddaf9db2fd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af9321898b01526d513e0c9ddaf9db2fd.html#af9321898b01526d513e0c9ddaf9db2fd">prob_free</a> (const T &amp;y)</td></tr>
<tr class="memdesc:af9321898b01526d513e0c9ddaf9db2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free scalar that when transformed to a probability produces the specified scalar.  <a href="namespacestan_1_1math_af9321898b01526d513e0c9ddaf9db2fd.html#af9321898b01526d513e0c9ddaf9db2fd">More...</a><br /></td></tr>
<tr class="separator:af9321898b01526d513e0c9ddaf9db2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7a33b156c2c6a0f86dcb14583f51a7"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adc7a33b156c2c6a0f86dcb14583f51a7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adc7a33b156c2c6a0f86dcb14583f51a7.html#adc7a33b156c2c6a0f86dcb14583f51a7">prod</a> (const T &amp;v)</td></tr>
<tr class="memdesc:adc7a33b156c2c6a0f86dcb14583f51a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of given scalar.  <a href="namespacestan_1_1math_adc7a33b156c2c6a0f86dcb14583f51a7.html#adc7a33b156c2c6a0f86dcb14583f51a7">More...</a><br /></td></tr>
<tr class="separator:adc7a33b156c2c6a0f86dcb14583f51a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1649a895ec6e79097d5645a3f8b8a1e6.html#a1649a895ec6e79097d5645a3f8b8a1e6">prod</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of the coefficients of the specified standard vector.  <a href="namespacestan_1_1math_a1649a895ec6e79097d5645a3f8b8a1e6.html#a1649a895ec6e79097d5645a3f8b8a1e6">More...</a><br /></td></tr>
<tr class="separator:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86bdf37241a7130250b59deb615f594"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad86bdf37241a7130250b59deb615f594"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad86bdf37241a7130250b59deb615f594.html#ad86bdf37241a7130250b59deb615f594">prod</a> (const EigMat &amp;v)</td></tr>
<tr class="memdesc:ad86bdf37241a7130250b59deb615f594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of the coefficients of the specified column vector.  <a href="namespacestan_1_1math_ad86bdf37241a7130250b59deb615f594.html#ad86bdf37241a7130250b59deb615f594">More...</a><br /></td></tr>
<tr class="separator:ad86bdf37241a7130250b59deb615f594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31007c38a32e4019f259071aba89f067"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a31007c38a32e4019f259071aba89f067"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a31007c38a32e4019f259071aba89f067.html#a31007c38a32e4019f259071aba89f067">proj</a> (const std::complex&lt; V &gt; &amp;z)</td></tr>
<tr class="memdesc:a31007c38a32e4019f259071aba89f067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the projection of the complex argument onto the Riemann sphere.  <a href="namespacestan_1_1math_a31007c38a32e4019f259071aba89f067.html#a31007c38a32e4019f259071aba89f067">More...</a><br /></td></tr>
<tr class="separator:a31007c38a32e4019f259071aba89f067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ab54f1764c792a9b24f40f08639ab9"><td class="memTemplParams" colspan="2">template&lt;typename PromotionScalar , typename UnPromotedType , require_constructible_t&lt; PromotionScalar, UnPromotedType &gt; *  = nullptr, require_not_same_t&lt; PromotionScalar, UnPromotedType &gt; *  = nullptr, require_all_not_tuple_t&lt; PromotionScalar, UnPromotedType &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a68ab54f1764c792a9b24f40f08639ab9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a68ab54f1764c792a9b24f40f08639ab9.html#a68ab54f1764c792a9b24f40f08639ab9">promote_scalar</a> (UnPromotedType &amp;&amp;x)</td></tr>
<tr class="memdesc:a68ab54f1764c792a9b24f40f08639ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote a scalar to another scalar type.  <a href="namespacestan_1_1math_a68ab54f1764c792a9b24f40f08639ab9.html#a68ab54f1764c792a9b24f40f08639ab9">More...</a><br /></td></tr>
<tr class="separator:a68ab54f1764c792a9b24f40f08639ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371c6e1648cb9198ca11f17abc9b8a31"><td class="memTemplParams" colspan="2">template&lt;typename PromotionScalar , typename UnPromotedType , require_same_t&lt; PromotionScalar, scalar_type_t&lt; UnPromotedType &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a371c6e1648cb9198ca11f17abc9b8a31"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a371c6e1648cb9198ca11f17abc9b8a31.html#a371c6e1648cb9198ca11f17abc9b8a31">promote_scalar</a> (UnPromotedType &amp;&amp;x) noexcept</td></tr>
<tr class="memdesc:a371c6e1648cb9198ca11f17abc9b8a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-op overload when promoting a type's scalar to the type it already has.  <a href="namespacestan_1_1math_a371c6e1648cb9198ca11f17abc9b8a31.html#a371c6e1648cb9198ca11f17abc9b8a31">More...</a><br /></td></tr>
<tr class="separator:a371c6e1648cb9198ca11f17abc9b8a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92640a2dc97a9c9ca2f40d86c00f7f84"><td class="memTemplParams" colspan="2">template&lt;typename PromotionScalar , typename UnPromotedType , require_eigen_t&lt; UnPromotedType &gt; *  = nullptr, require_not_same_t&lt; PromotionScalar, value_type_t&lt; UnPromotedType &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a92640a2dc97a9c9ca2f40d86c00f7f84"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a92640a2dc97a9c9ca2f40d86c00f7f84.html#a92640a2dc97a9c9ca2f40d86c00f7f84">promote_scalar</a> (UnPromotedType &amp;&amp;x)</td></tr>
<tr class="memdesc:a92640a2dc97a9c9ca2f40d86c00f7f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the scalar type of an eigen matrix to the requested type.  <a href="namespacestan_1_1math_a92640a2dc97a9c9ca2f40d86c00f7f84.html#a92640a2dc97a9c9ca2f40d86c00f7f84">More...</a><br /></td></tr>
<tr class="separator:a92640a2dc97a9c9ca2f40d86c00f7f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57b44e86335da2110727e00ec5c90cb"><td class="memTemplParams" colspan="2">template&lt;typename PromotionScalars , typename UnPromotedTypes , require_all_tuple_t&lt; PromotionScalars, UnPromotedTypes &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac57b44e86335da2110727e00ec5c90cb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">promote_scalar_t</a>&lt; PromotionScalars, UnPromotedTypes &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac57b44e86335da2110727e00ec5c90cb.html#ac57b44e86335da2110727e00ec5c90cb">promote_scalar</a> (UnPromotedTypes &amp;&amp;x)</td></tr>
<tr class="memdesc:ac57b44e86335da2110727e00ec5c90cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the scalar type of a tuples elements to the requested types.  <a href="namespacestan_1_1math_ac57b44e86335da2110727e00ec5c90cb.html#ac57b44e86335da2110727e00ec5c90cb">More...</a><br /></td></tr>
<tr class="separator:ac57b44e86335da2110727e00ec5c90cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa815120fce5e13d78ad7ae74a8e33f3d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa815120fce5e13d78ad7ae74a8e33f3d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa815120fce5e13d78ad7ae74a8e33f3d.html#aa815120fce5e13d78ad7ae74a8e33f3d">pseudo_eigenvalues</a> (const Eigen::Matrix&lt; T, -1, -1 &gt; &amp;m)</td></tr>
<tr class="separator:aa815120fce5e13d78ad7ae74a8e33f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4c69d23537b38478f0dd16dcf33cbe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f4c69d23537b38478f0dd16dcf33cbe"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1f4c69d23537b38478f0dd16dcf33cbe.html#a1f4c69d23537b38478f0dd16dcf33cbe">pseudo_eigenvectors</a> (const Eigen::Matrix&lt; T, -1, -1 &gt; &amp;m)</td></tr>
<tr class="separator:a1f4c69d23537b38478f0dd16dcf33cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb802a1b4a7de54d0aa964924ed8db21"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afb802a1b4a7de54d0aa964924ed8db21"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afb802a1b4a7de54d0aa964924ed8db21.html#afb802a1b4a7de54d0aa964924ed8db21">qr_Q</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:afb802a1b4a7de54d0aa964924ed8db21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orthogonal factor of the fat QR decomposition.  <a href="namespacestan_1_1math_afb802a1b4a7de54d0aa964924ed8db21.html#afb802a1b4a7de54d0aa964924ed8db21">More...</a><br /></td></tr>
<tr class="separator:afb802a1b4a7de54d0aa964924ed8db21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc03653f112e844339224fe2f1e20c1c"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acc03653f112e844339224fe2f1e20c1c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acc03653f112e844339224fe2f1e20c1c.html#acc03653f112e844339224fe2f1e20c1c">qr_R</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:acc03653f112e844339224fe2f1e20c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the upper triangular factor of the fat QR decomposition.  <a href="namespacestan_1_1math_acc03653f112e844339224fe2f1e20c1c.html#acc03653f112e844339224fe2f1e20c1c">More...</a><br /></td></tr>
<tr class="separator:acc03653f112e844339224fe2f1e20c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb29fea9cae60b57abf44a308dd73b5"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8fb29fea9cae60b57abf44a308dd73b5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8fb29fea9cae60b57abf44a308dd73b5.html#a8fb29fea9cae60b57abf44a308dd73b5">qr_thin_Q</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a8fb29fea9cae60b57abf44a308dd73b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orthogonal factor of the thin QR decomposition.  <a href="namespacestan_1_1math_a8fb29fea9cae60b57abf44a308dd73b5.html#a8fb29fea9cae60b57abf44a308dd73b5">More...</a><br /></td></tr>
<tr class="separator:a8fb29fea9cae60b57abf44a308dd73b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f27180d4e6030d85f06151733dad35e"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2f27180d4e6030d85f06151733dad35e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f27180d4e6030d85f06151733dad35e.html#a2f27180d4e6030d85f06151733dad35e">qr_thin_R</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a2f27180d4e6030d85f06151733dad35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the upper triangular factor of the thin QR decomposition.  <a href="namespacestan_1_1math_a2f27180d4e6030d85f06151733dad35e.html#a2f27180d4e6030d85f06151733dad35e">More...</a><br /></td></tr>
<tr class="separator:a2f27180d4e6030d85f06151733dad35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7e08af24c1dad00cc176f6e95dad0a"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_eigen_t&lt; EigMat1, EigMat2 &gt; *  = nullptr, require_not_eigen_col_vector_t&lt; EigMat2 &gt; *  = nullptr, require_vt_same&lt; EigMat1, EigMat2 &gt; *  = nullptr, require_all_vt_arithmetic&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afc7e08af24c1dad00cc176f6e95dad0a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afc7e08af24c1dad00cc176f6e95dad0a.html#afc7e08af24c1dad00cc176f6e95dad0a">quad_form</a> (const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:afc7e08af24c1dad00cc176f6e95dad0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \).  <a href="namespacestan_1_1math_afc7e08af24c1dad00cc176f6e95dad0a.html#afc7e08af24c1dad00cc176f6e95dad0a">More...</a><br /></td></tr>
<tr class="separator:afc7e08af24c1dad00cc176f6e95dad0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9eaedab42eb23cff434527d757e38a"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename ColVec , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_eigen_col_vector_t&lt; ColVec &gt; *  = nullptr, require_vt_same&lt; EigMat, ColVec &gt; *  = nullptr, require_all_vt_arithmetic&lt; EigMat, ColVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1d9eaedab42eb23cff434527d757e38a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1d9eaedab42eb23cff434527d757e38a.html#a1d9eaedab42eb23cff434527d757e38a">quad_form</a> (const EigMat &amp;A, const ColVec &amp;B)</td></tr>
<tr class="memdesc:a1d9eaedab42eb23cff434527d757e38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \).  <a href="namespacestan_1_1math_a1d9eaedab42eb23cff434527d757e38a.html#a1d9eaedab42eb23cff434527d757e38a">More...</a><br /></td></tr>
<tr class="separator:a1d9eaedab42eb23cff434527d757e38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e23444134726d0c61abeaedb1b7240"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename EigVec , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_eigen_vector_t&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a26e23444134726d0c61abeaedb1b7240"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a26e23444134726d0c61abeaedb1b7240.html#a26e23444134726d0c61abeaedb1b7240">quad_form_diag</a> (const EigMat &amp;mat, const EigVec &amp;vec)</td></tr>
<tr class="separator:a26e23444134726d0c61abeaedb1b7240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c4cd8a49851a3e044e893fb7091e91"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_eigen_t&lt; EigMat1, EigMat2 &gt; *  = nullptr, require_not_eigen_col_vector_t&lt; EigMat2 &gt; *  = nullptr, require_vt_same&lt; EigMat1, EigMat2 &gt; *  = nullptr, require_all_vt_arithmetic&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a84c4cd8a49851a3e044e893fb7091e91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; EigMat2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a84c4cd8a49851a3e044e893fb7091e91.html#a84c4cd8a49851a3e044e893fb7091e91">quad_form_sym</a> (const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:a84c4cd8a49851a3e044e893fb7091e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \) of a symmetric matrix.  <a href="namespacestan_1_1math_a84c4cd8a49851a3e044e893fb7091e91.html#a84c4cd8a49851a3e044e893fb7091e91">More...</a><br /></td></tr>
<tr class="separator:a84c4cd8a49851a3e044e893fb7091e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cf5679fabcfcc8a67b143f7f4109ab"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename ColVec , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_eigen_col_vector_t&lt; ColVec &gt; *  = nullptr, require_vt_same&lt; EigMat, ColVec &gt; *  = nullptr, require_all_vt_arithmetic&lt; EigMat, ColVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa8cf5679fabcfcc8a67b143f7f4109ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa8cf5679fabcfcc8a67b143f7f4109ab.html#aa8cf5679fabcfcc8a67b143f7f4109ab">quad_form_sym</a> (const EigMat &amp;A, const ColVec &amp;B)</td></tr>
<tr class="memdesc:aa8cf5679fabcfcc8a67b143f7f4109ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \) of a symmetric matrix.  <a href="namespacestan_1_1math_aa8cf5679fabcfcc8a67b143f7f4109ab.html#aa8cf5679fabcfcc8a67b143f7f4109ab">More...</a><br /></td></tr>
<tr class="separator:aa8cf5679fabcfcc8a67b143f7f4109ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffe1d7f897c2cffbcdba638dd4ef062"><td class="memTemplParams" colspan="2">template&lt;typename T , require_vector_t&lt; T &gt; *  = nullptr, require_vector_vt&lt; std::is_arithmetic, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5ffe1d7f897c2cffbcdba638dd4ef062"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5ffe1d7f897c2cffbcdba638dd4ef062.html#a5ffe1d7f897c2cffbcdba638dd4ef062">quantile</a> (const T &amp;samples_vec, const double p)</td></tr>
<tr class="memdesc:a5ffe1d7f897c2cffbcdba638dd4ef062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sample quantiles corresponding to the given probabilities.  <a href="namespacestan_1_1math_a5ffe1d7f897c2cffbcdba638dd4ef062.html#a5ffe1d7f897c2cffbcdba638dd4ef062">More...</a><br /></td></tr>
<tr class="separator:a5ffe1d7f897c2cffbcdba638dd4ef062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5939ddb5adc99896c1d028995bc9cfa0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tp , require_all_vector_t&lt; T, Tp &gt; *  = nullptr, require_vector_vt&lt; std::is_arithmetic, T &gt; *  = nullptr, require_std_vector_vt&lt; std::is_arithmetic, Tp &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5939ddb5adc99896c1d028995bc9cfa0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5939ddb5adc99896c1d028995bc9cfa0.html#a5939ddb5adc99896c1d028995bc9cfa0">quantile</a> (const T &amp;samples_vec, const Tp &amp;ps)</td></tr>
<tr class="memdesc:a5939ddb5adc99896c1d028995bc9cfa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sample quantiles corresponding to the given probabilities.  <a href="namespacestan_1_1math_a5939ddb5adc99896c1d028995bc9cfa0.html#a5939ddb5adc99896c1d028995bc9cfa0">More...</a><br /></td></tr>
<tr class="separator:a5939ddb5adc99896c1d028995bc9cfa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08cf44474c3253c7193f81afa498d15"><td class="memTemplParams" colspan="2">template&lt;typename C , require_container_t&lt; C &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac08cf44474c3253c7193f81afa498d15"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac08cf44474c3253c7193f81afa498d15.html#ac08cf44474c3253c7193f81afa498d15">rank</a> (const C &amp;v, int s)</td></tr>
<tr class="memdesc:ac08cf44474c3253c7193f81afa498d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of components of v less than v[s].  <a href="namespacestan_1_1math_ac08cf44474c3253c7193f81afa498d15.html#ac08cf44474c3253c7193f81afa498d15">More...</a><br /></td></tr>
<tr class="separator:ac08cf44474c3253c7193f81afa498d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17c4248dd4118aaf1fb88b862bf2e0f"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad17c4248dd4118aaf1fb88b862bf2e0f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad17c4248dd4118aaf1fb88b862bf2e0f.html#ad17c4248dd4118aaf1fb88b862bf2e0f">read_corr_L</a> (const T &amp;CPCs, size_t K)</td></tr>
<tr class="memdesc:ad17c4248dd4118aaf1fb88b862bf2e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations.  <a href="namespacestan_1_1math_ad17c4248dd4118aaf1fb88b862bf2e0f.html#ad17c4248dd4118aaf1fb88b862bf2e0f">More...</a><br /></td></tr>
<tr class="separator:ad17c4248dd4118aaf1fb88b862bf2e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b40797bb4e01259076e8cd8e79abbb7"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2b40797bb4e01259076e8cd8e79abbb7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2b40797bb4e01259076e8cd8e79abbb7.html#a2b40797bb4e01259076e8cd8e79abbb7">read_corr_L</a> (const T &amp;CPCs, size_t K, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &amp;log_prob)</td></tr>
<tr class="memdesc:a2b40797bb4e01259076e8cd8e79abbb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations, incrementing the specified scalar reference with the log absolute determinant of the Jacobian of the transformation.  <a href="namespacestan_1_1math_a2b40797bb4e01259076e8cd8e79abbb7.html#a2b40797bb4e01259076e8cd8e79abbb7">More...</a><br /></td></tr>
<tr class="separator:a2b40797bb4e01259076e8cd8e79abbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674910bd8b234ed0d1423fc79c874406"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , require_eigen_vector_t&lt; T_CPCs &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a674910bd8b234ed0d1423fc79c874406"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_CPCs &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a674910bd8b234ed0d1423fc79c874406.html#a674910bd8b234ed0d1423fc79c874406">read_corr_matrix</a> (const T_CPCs &amp;CPCs, size_t K)</td></tr>
<tr class="memdesc:a674910bd8b234ed0d1423fc79c874406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations.  <a href="namespacestan_1_1math_a674910bd8b234ed0d1423fc79c874406.html#a674910bd8b234ed0d1423fc79c874406">More...</a><br /></td></tr>
<tr class="separator:a674910bd8b234ed0d1423fc79c874406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e76d7b9ddc8ed3059b7383fc1908834"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , require_eigen_vector_t&lt; T_CPCs &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2e76d7b9ddc8ed3059b7383fc1908834"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_CPCs &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2e76d7b9ddc8ed3059b7383fc1908834.html#a2e76d7b9ddc8ed3059b7383fc1908834">read_corr_matrix</a> (const T_CPCs &amp;CPCs, size_t K, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_CPCs &gt; &amp;log_prob)</td></tr>
<tr class="memdesc:a2e76d7b9ddc8ed3059b7383fc1908834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations, incrementing the specified scalar reference with the log absolute determinant of the Jacobian of the transformation.  <a href="namespacestan_1_1math_a2e76d7b9ddc8ed3059b7383fc1908834.html#a2e76d7b9ddc8ed3059b7383fc1908834">More...</a><br /></td></tr>
<tr class="separator:a2e76d7b9ddc8ed3059b7383fc1908834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f04378d937f42a4198f1950c0800ea0"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , typename T_sds , require_all_eigen_vector_t&lt; T_CPCs, T_sds &gt; *  = nullptr, require_vt_same&lt; T_CPCs, T_sds &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1f04378d937f42a4198f1950c0800ea0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_CPCs &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1f04378d937f42a4198f1950c0800ea0.html#a1f04378d937f42a4198f1950c0800ea0">read_cov_L</a> (const T_CPCs &amp;CPCs, const T_sds &amp;sds, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_CPCs &gt; &amp;log_prob)</td></tr>
<tr class="memdesc:a1f04378d937f42a4198f1950c0800ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function that should be called prior to evaluating the density of any elliptical distribution.  <a href="namespacestan_1_1math_a1f04378d937f42a4198f1950c0800ea0.html#a1f04378d937f42a4198f1950c0800ea0">More...</a><br /></td></tr>
<tr class="separator:a1f04378d937f42a4198f1950c0800ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2c3dfd610eb95e9244fa36b40bb6bf"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , typename T_sds , require_all_eigen_vector_t&lt; T_CPCs, T_sds &gt; *  = nullptr, require_vt_same&lt; T_CPCs, T_sds &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abe2c3dfd610eb95e9244fa36b40bb6bf"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_CPCs &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abe2c3dfd610eb95e9244fa36b40bb6bf.html#abe2c3dfd610eb95e9244fa36b40bb6bf">read_cov_matrix</a> (const T_CPCs &amp;CPCs, const T_sds &amp;sds, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_CPCs &gt; &amp;log_prob)</td></tr>
<tr class="memdesc:abe2c3dfd610eb95e9244fa36b40bb6bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generally worse alternative to call prior to evaluating the density of an elliptical distribution.  <a href="namespacestan_1_1math_abe2c3dfd610eb95e9244fa36b40bb6bf.html#abe2c3dfd610eb95e9244fa36b40bb6bf">More...</a><br /></td></tr>
<tr class="separator:abe2c3dfd610eb95e9244fa36b40bb6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15f0863ce25c352541c564e979cd350"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , typename T_sds , require_all_eigen_vector_t&lt; T_CPCs, T_sds &gt; *  = nullptr, require_vt_same&lt; T_CPCs, T_sds &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae15f0863ce25c352541c564e979cd350"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_CPCs &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae15f0863ce25c352541c564e979cd350.html#ae15f0863ce25c352541c564e979cd350">read_cov_matrix</a> (const T_CPCs &amp;CPCs, const T_sds &amp;sds)</td></tr>
<tr class="memdesc:ae15f0863ce25c352541c564e979cd350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a covariance matrix from CPCs and standard deviations.  <a href="namespacestan_1_1math_ae15f0863ce25c352541c564e979cd350.html#ae15f0863ce25c352541c564e979cd350">More...</a><br /></td></tr>
<tr class="separator:ae15f0863ce25c352541c564e979cd350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2385fde5624f0ea3c0d2c60d0568a5"><td class="memTemplParams" colspan="2">template&lt;typename T , require_autodiff_t&lt; T &gt; &gt; </td></tr>
<tr class="memitem:a3e2385fde5624f0ea3c0d2c60d0568a5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3e2385fde5624f0ea3c0d2c60d0568a5.html#a3e2385fde5624f0ea3c0d2c60d0568a5">real</a> (const std::complex&lt; T &gt; &amp;z)</td></tr>
<tr class="memdesc:a3e2385fde5624f0ea3c0d2c60d0568a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the real component of the complex argument.  <a href="namespacestan_1_1math_a3e2385fde5624f0ea3c0d2c60d0568a5.html#a3e2385fde5624f0ea3c0d2c60d0568a5">More...</a><br /></td></tr>
<tr class="separator:a3e2385fde5624f0ea3c0d2c60d0568a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbb85712ed9750e577f66b75374c427"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , typename In , require_std_vector_t&lt; T_ret &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0fbb85712ed9750e577f66b75374c427"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; In &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0fbb85712ed9750e577f66b75374c427.html#a0fbb85712ed9750e577f66b75374c427">rep_array</a> (const In &amp;x, int n)</td></tr>
<tr class="separator:a0fbb85712ed9750e577f66b75374c427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fe4b5c01614b7de13d707f0779d5d4"><td class="memTemplParams" colspan="2">template&lt;typename In &gt; </td></tr>
<tr class="memitem:a41fe4b5c01614b7de13d707f0779d5d4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; In &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a41fe4b5c01614b7de13d707f0779d5d4.html#a41fe4b5c01614b7de13d707f0779d5d4">rep_array</a> (const In &amp;x, int n)</td></tr>
<tr class="separator:a41fe4b5c01614b7de13d707f0779d5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8beef1b2f94819b4f7e6c30d8ff156e1"><td class="memTemplParams" colspan="2">template&lt;typename In &gt; </td></tr>
<tr class="memitem:a8beef1b2f94819b4f7e6c30d8ff156e1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; In &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8beef1b2f94819b4f7e6c30d8ff156e1.html#a8beef1b2f94819b4f7e6c30d8ff156e1">rep_array</a> (const In &amp;x, int m, int n)</td></tr>
<tr class="separator:a8beef1b2f94819b4f7e6c30d8ff156e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6c8a10505c2e39272a1b13d19a9cc6"><td class="memTemplParams" colspan="2">template&lt;typename In &gt; </td></tr>
<tr class="memitem:a3d6c8a10505c2e39272a1b13d19a9cc6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; In &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3d6c8a10505c2e39272a1b13d19a9cc6.html#a3d6c8a10505c2e39272a1b13d19a9cc6">rep_array</a> (const In &amp;x, int k, int m, int n)</td></tr>
<tr class="separator:a3d6c8a10505c2e39272a1b13d19a9cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2382bdc64f50d70aff928c0cec0b69e4"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename T , require_eigen_matrix_dynamic_vt&lt; is_stan_scalar, Ret &gt; *  = nullptr, require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2382bdc64f50d70aff928c0cec0b69e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2382bdc64f50d70aff928c0cec0b69e4.html#a2382bdc64f50d70aff928c0cec0b69e4">rep_matrix</a> (const T &amp;x, int m, int n)</td></tr>
<tr class="memdesc:a2382bdc64f50d70aff928c0cec0b69e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of rep_matrix returning an <a class="el" href="namespace_eigen.html">Eigen</a> matrix with scalar type equal to the input scalar type.  <a href="namespacestan_1_1math_a2382bdc64f50d70aff928c0cec0b69e4.html#a2382bdc64f50d70aff928c0cec0b69e4">More...</a><br /></td></tr>
<tr class="separator:a2382bdc64f50d70aff928c0cec0b69e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9669d5b8a55a8ed0acc54265689c0f2b"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9669d5b8a55a8ed0acc54265689c0f2b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9669d5b8a55a8ed0acc54265689c0f2b.html#a9669d5b8a55a8ed0acc54265689c0f2b">rep_matrix</a> (const T &amp;x, int m, int n)</td></tr>
<tr class="memdesc:a9669d5b8a55a8ed0acc54265689c0f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Implementation of rep_matrix returning an <a class="el" href="namespace_eigen.html">Eigen</a> matrix with scalar type equal to the input scalar type.  <a href="namespacestan_1_1math_a9669d5b8a55a8ed0acc54265689c0f2b.html#a9669d5b8a55a8ed0acc54265689c0f2b">More...</a><br /></td></tr>
<tr class="separator:a9669d5b8a55a8ed0acc54265689c0f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1043a040a2342329fc08e732f7d1cf"><td class="memTemplParams" colspan="2">template&lt;typename Vec , require_eigen_vector_t&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7c1043a040a2342329fc08e732f7d1cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7c1043a040a2342329fc08e732f7d1cf.html#a7c1043a040a2342329fc08e732f7d1cf">rep_matrix</a> (const Vec &amp;x, int n)</td></tr>
<tr class="memdesc:a7c1043a040a2342329fc08e732f7d1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of rep_matrix returning an <a class="el" href="namespace_eigen.html">Eigen</a> matrix from an <a class="el" href="namespace_eigen.html">Eigen</a> vector.  <a href="namespacestan_1_1math_a7c1043a040a2342329fc08e732f7d1cf.html#a7c1043a040a2342329fc08e732f7d1cf">More...</a><br /></td></tr>
<tr class="separator:a7c1043a040a2342329fc08e732f7d1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be864fed7d2707279e973d7281f6ba6"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , typename T , require_eigen_row_vector_t&lt; T_ret &gt; *  = nullptr, require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1be864fed7d2707279e973d7281f6ba6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1be864fed7d2707279e973d7281f6ba6.html#a1be864fed7d2707279e973d7281f6ba6">rep_row_vector</a> (const T &amp;x, int n)</td></tr>
<tr class="separator:a1be864fed7d2707279e973d7281f6ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e1df8e01072288a9a2f5140d93507a"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a64e1df8e01072288a9a2f5140d93507a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a64e1df8e01072288a9a2f5140d93507a.html#a64e1df8e01072288a9a2f5140d93507a">rep_row_vector</a> (const T &amp;x, int n)</td></tr>
<tr class="separator:a64e1df8e01072288a9a2f5140d93507a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa94a2628245a969873d40d7c51d8be7"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , typename T , require_eigen_col_vector_t&lt; T_ret &gt; *  = nullptr, require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaa94a2628245a969873d40d7c51d8be7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaa94a2628245a969873d40d7c51d8be7.html#aaa94a2628245a969873d40d7c51d8be7">rep_vector</a> (const T &amp;x, int n)</td></tr>
<tr class="separator:aaa94a2628245a969873d40d7c51d8be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba4256db717f17c98de74df71edc1a7"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4ba4256db717f17c98de74df71edc1a7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4ba4256db717f17c98de74df71edc1a7.html#a4ba4256db717f17c98de74df71edc1a7">rep_vector</a> (const T &amp;x, int n)</td></tr>
<tr class="separator:a4ba4256db717f17c98de74df71edc1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04c2acf592bafdc7165ee76f134d700"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad04c2acf592bafdc7165ee76f134d700"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad04c2acf592bafdc7165ee76f134d700.html#ad04c2acf592bafdc7165ee76f134d700">resize</a> (T &amp;x, std::vector&lt; int &gt; <a class="el" href="group__opencl_gaff473895b1f11e364afd4c2d3cb5cab4.html#gaff473895b1f11e364afd4c2d3cb5cab4">dims</a>)</td></tr>
<tr class="memdesc:ad04c2acf592bafdc7165ee76f134d700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively resize the specified vector of vectors, which must bottom out at scalar values, <a class="el" href="namespace_eigen.html">Eigen</a> vectors or <a class="el" href="namespace_eigen.html">Eigen</a> matrices.  <a href="namespacestan_1_1math_ad04c2acf592bafdc7165ee76f134d700.html#ad04c2acf592bafdc7165ee76f134d700">More...</a><br /></td></tr>
<tr class="separator:ad04c2acf592bafdc7165ee76f134d700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aae3430731a3b055898a703e5fe50e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1aae3430731a3b055898a703e5fe50e5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1aae3430731a3b055898a703e5fe50e5.html#a1aae3430731a3b055898a703e5fe50e5">reverse</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a1aae3430731a3b055898a703e5fe50e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the specified array in reversed order.  <a href="namespacestan_1_1math_a1aae3430731a3b055898a703e5fe50e5.html#a1aae3430731a3b055898a703e5fe50e5">More...</a><br /></td></tr>
<tr class="separator:a1aae3430731a3b055898a703e5fe50e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee3d799cb32c60381d7ad77cb17ba88"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_vector_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a7ee3d799cb32c60381d7ad77cb17ba88"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7ee3d799cb32c60381d7ad77cb17ba88.html#a7ee3d799cb32c60381d7ad77cb17ba88">reverse</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a7ee3d799cb32c60381d7ad77cb17ba88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the specified vector or row vector in reversed order.  <a href="namespacestan_1_1math_a7ee3d799cb32c60381d7ad77cb17ba88.html#a7ee3d799cb32c60381d7ad77cb17ba88">More...</a><br /></td></tr>
<tr class="separator:a7ee3d799cb32c60381d7ad77cb17ba88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff5840107dc1b0b7c989351d464467c"><td class="memTemplParams" colspan="2">template&lt;typename T , require_arithmetic_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9ff5840107dc1b0b7c989351d464467c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ff5840107dc1b0b7c989351d464467c.html#a9ff5840107dc1b0b7c989351d464467c">rising_factorial</a> (const T &amp;x, int n)</td></tr>
<tr class="memdesc:a9ff5840107dc1b0b7c989351d464467c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the rising factorial function evaluated at the inputs.  <a href="namespacestan_1_1math_a9ff5840107dc1b0b7c989351d464467c.html#a9ff5840107dc1b0b7c989351d464467c">More...</a><br /></td></tr>
<tr class="separator:a9ff5840107dc1b0b7c989351d464467c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f43afe8a8acf0b1b3e984927b8fd90"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a60f43afe8a8acf0b1b3e984927b8fd90"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a60f43afe8a8acf0b1b3e984927b8fd90.html#a60f43afe8a8acf0b1b3e984927b8fd90">rising_factorial</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a60f43afe8a8acf0b1b3e984927b8fd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorised application of the rising_factorial function, when the first and/or second arguments are containers.  <a href="namespacestan_1_1math_a60f43afe8a8acf0b1b3e984927b8fd90.html#a60f43afe8a8acf0b1b3e984927b8fd90">More...</a><br /></td></tr>
<tr class="separator:a60f43afe8a8acf0b1b3e984927b8fd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab681eea525b46c4b700b2ff106451c11"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab681eea525b46c4b700b2ff106451c11"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab681eea525b46c4b700b2ff106451c11.html#ab681eea525b46c4b700b2ff106451c11">round</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ab681eea525b46c4b700b2ff106451c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <code><a class="el" href="namespacestan_1_1math_adb73c37a4cec41a69516391a2336fb11.html#adb73c37a4cec41a69516391a2336fb11" title="Return the closest integer to the specified argument, with halfway cases rounded away from zero.">round()</a></code>.  <a href="namespacestan_1_1math_ab681eea525b46c4b700b2ff106451c11.html#ab681eea525b46c4b700b2ff106451c11">More...</a><br /></td></tr>
<tr class="separator:ab681eea525b46c4b700b2ff106451c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f9347746c57abe5c2b318766ee2892"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a28f9347746c57abe5c2b318766ee2892"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a28f9347746c57abe5c2b318766ee2892.html#a28f9347746c57abe5c2b318766ee2892">round</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a28f9347746c57abe5c2b318766ee2892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_adb73c37a4cec41a69516391a2336fb11.html#adb73c37a4cec41a69516391a2336fb11" title="Return the closest integer to the specified argument, with halfway cases rounded away from zero.">round()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_a28f9347746c57abe5c2b318766ee2892.html#a28f9347746c57abe5c2b318766ee2892">More...</a><br /></td></tr>
<tr class="separator:a28f9347746c57abe5c2b318766ee2892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170126040a0b7c594c32f16d2f280d62"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a170126040a0b7c594c32f16d2f280d62"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a170126040a0b7c594c32f16d2f280d62.html#a170126040a0b7c594c32f16d2f280d62">row</a> (const T &amp;m, size_t i)</td></tr>
<tr class="memdesc:a170126040a0b7c594c32f16d2f280d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified row of the specified matrix, using start-at-1 indexing.  <a href="namespacestan_1_1math_a170126040a0b7c594c32f16d2f280d62.html#a170126040a0b7c594c32f16d2f280d62">More...</a><br /></td></tr>
<tr class="separator:a170126040a0b7c594c32f16d2f280d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8dccff7facd64877956505ce8f5fd5"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abd8dccff7facd64877956505ce8f5fd5"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abd8dccff7facd64877956505ce8f5fd5.html#abd8dccff7facd64877956505ce8f5fd5">rows</a> (const T &amp;m)</td></tr>
<tr class="memdesc:abd8dccff7facd64877956505ce8f5fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of rows in the specified matrix, vector, or row vector.  <a href="namespacestan_1_1math_abd8dccff7facd64877956505ce8f5fd5.html#abd8dccff7facd64877956505ce8f5fd5">More...</a><br /></td></tr>
<tr class="separator:abd8dccff7facd64877956505ce8f5fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4684a38a1480b02f695176a35bcb81"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , require_all_eigen_t&lt; Mat1, Mat2 &gt; *  = nullptr, require_all_not_eigen_vt&lt; is_var, Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6a4684a38a1480b02f695176a35bcb81"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Mat1, Mat2 &gt;, Mat1::RowsAtCompileTime, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6a4684a38a1480b02f695176a35bcb81.html#a6a4684a38a1480b02f695176a35bcb81">rows_dot_product</a> (const Mat1 &amp;v1, const Mat2 &amp;v2)</td></tr>
<tr class="memdesc:a6a4684a38a1480b02f695176a35bcb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of rows of the specified matrices.  <a href="namespacestan_1_1math_a6a4684a38a1480b02f695176a35bcb81.html#a6a4684a38a1480b02f695176a35bcb81">More...</a><br /></td></tr>
<tr class="separator:a6a4684a38a1480b02f695176a35bcb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c10aeec73c78893354ac56ab4219971"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr, require_not_st_var&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5c10aeec73c78893354ac56ab4219971"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, T::RowsAtCompileTime, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5c10aeec73c78893354ac56ab4219971.html#a5c10aeec73c78893354ac56ab4219971">rows_dot_self</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a5c10aeec73c78893354ac56ab4219971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each row of a matrix with itself.  <a href="namespacestan_1_1math_a5c10aeec73c78893354ac56ab4219971.html#a5c10aeec73c78893354ac56ab4219971">More...</a><br /></td></tr>
<tr class="separator:a5c10aeec73c78893354ac56ab4219971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb68633654dd492a44bd8c240171d92"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_autodiff_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a5eb68633654dd492a44bd8c240171d92"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5eb68633654dd492a44bd8c240171d92.html#a5eb68633654dd492a44bd8c240171d92">scalbn</a> (const T &amp;x, int n)</td></tr>
<tr class="separator:a5eb68633654dd492a44bd8c240171d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe0de26cc544ae9fe4e34fa6dce7e05"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_eigen_vt&lt; std::is_arithmetic, EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abbe0de26cc544ae9fe4e34fa6dce7e05"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, Eigen::Dynamic, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abbe0de26cc544ae9fe4e34fa6dce7e05.html#abbe0de26cc544ae9fe4e34fa6dce7e05">scale_matrix_exp_multiply</a> (const double &amp;t, const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:abbe0de26cc544ae9fe4e34fa6dce7e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return product of exp(At) and B, where A is a NxN double matrix, B is a NxCb double matrix, and t is a double.  <a href="namespacestan_1_1math_abbe0de26cc544ae9fe4e34fa6dce7e05.html#abbe0de26cc544ae9fe4e34fa6dce7e05">More...</a><br /></td></tr>
<tr class="separator:abbe0de26cc544ae9fe4e34fa6dce7e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d5d9c9f1d485d2f79ab82204da5b72"><td class="memTemplParams" colspan="2">template&lt;typename Tt , typename EigMat1 , typename EigMat2 , require_all_eigen_t&lt; EigMat1, EigMat2 &gt; *  = nullptr, require_any_autodiff_t&lt; Tt, value_type_t&lt; EigMat1 &gt;, value_type_t&lt; EigMat2 &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a80d5d9c9f1d485d2f79ab82204da5b72"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Tt, EigMat1, EigMat2 &gt;, Eigen::Dynamic, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a80d5d9c9f1d485d2f79ab82204da5b72.html#a80d5d9c9f1d485d2f79ab82204da5b72">scale_matrix_exp_multiply</a> (const Tt &amp;t, const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:a80d5d9c9f1d485d2f79ab82204da5b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return product of exp(At) and B, where A is a NxN matrix, B is a NxCb matrix and t is a scalar.  <a href="namespacestan_1_1math_a80d5d9c9f1d485d2f79ab82204da5b72.html#a80d5d9c9f1d485d2f79ab82204da5b72">More...</a><br /></td></tr>
<tr class="separator:a80d5d9c9f1d485d2f79ab82204da5b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4ac8609acf513ecd19de2fe90cd6f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acc4ac8609acf513ecd19de2fe90cd6f4.html#acc4ac8609acf513ecd19de2fe90cd6f4">scaled_add</a> (std::vector&lt; double &gt; &amp;x, const std::vector&lt; double &gt; &amp;y, double lambda)</td></tr>
<tr class="separator:acc4ac8609acf513ecd19de2fe90cd6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b69d1f30ba5c7c8f42646053e42955"><td class="memTemplParams" colspan="2">template&lt;typename T , require_container_t&lt; T &gt; *  = nullptr, require_not_st_var&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a20b69d1f30ba5c7c8f42646053e42955"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a20b69d1f30ba5c7c8f42646053e42955.html#a20b69d1f30ba5c7c8f42646053e42955">sd</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a20b69d1f30ba5c7c8f42646053e42955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unbiased sample standard deviation of the coefficients in the specified std vector, column vector, row vector, or matrix.  <a href="namespacestan_1_1math_a20b69d1f30ba5c7c8f42646053e42955.html#a20b69d1f30ba5c7c8f42646053e42955">More...</a><br /></td></tr>
<tr class="separator:a20b69d1f30ba5c7c8f42646053e42955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3007ebc208b30c9b027ade071363d3b4"><td class="memTemplParams" colspan="2">template&lt;typename Vec , require_vector_t&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3007ebc208b30c9b027ade071363d3b4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3007ebc208b30c9b027ade071363d3b4.html#a3007ebc208b30c9b027ade071363d3b4">segment</a> (const Vec &amp;v, size_t i, size_t n)</td></tr>
<tr class="memdesc:a3007ebc208b30c9b027ade071363d3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a row/column vector starting from the specified element - 1 of the specified row/column vector.  <a href="namespacestan_1_1math_a3007ebc208b30c9b027ade071363d3b4.html#a3007ebc208b30c9b027ade071363d3b4">More...</a><br /></td></tr>
<tr class="separator:a3007ebc208b30c9b027ade071363d3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721232b5c8e7c068a120719255f5fb0c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a721232b5c8e7c068a120719255f5fb0c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a721232b5c8e7c068a120719255f5fb0c.html#a721232b5c8e7c068a120719255f5fb0c">segment</a> (const std::vector&lt; T &gt; &amp;sv, size_t i, size_t n)</td></tr>
<tr class="separator:a721232b5c8e7c068a120719255f5fb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01efc26078fd7a89235e96b4d7898f9"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad01efc26078fd7a89235e96b4d7898f9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad01efc26078fd7a89235e96b4d7898f9.html#ad01efc26078fd7a89235e96b4d7898f9">sign</a> (const T &amp;z)</td></tr>
<tr class="separator:ad01efc26078fd7a89235e96b4d7898f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec8241508f45b89c73ede80f4a69b67"><td class="memTemplParams" colspan="2">template&lt;typename ADType , require_autodiff_t&lt; ADType &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afec8241508f45b89c73ede80f4a69b67"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afec8241508f45b89c73ede80f4a69b67.html#afec8241508f45b89c73ede80f4a69b67">signbit</a> (ADType &amp;&amp;v)</td></tr>
<tr class="memdesc:afec8241508f45b89c73ede80f4a69b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified argument is negative and <code>false</code> otherwise.  <a href="namespacestan_1_1math_afec8241508f45b89c73ede80f4a69b67.html#afec8241508f45b89c73ede80f4a69b67">More...</a><br /></td></tr>
<tr class="separator:afec8241508f45b89c73ede80f4a69b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f54b79be640584c9276f7730aba6a2"><td class="memTemplParams" colspan="2">template&lt;typename Vec , require_eigen_col_vector_t&lt; Vec &gt; *  = nullptr, require_not_st_var&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae2f54b79be640584c9276f7730aba6a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae2f54b79be640584c9276f7730aba6a2.html#ae2f54b79be640584c9276f7730aba6a2">simplex_constrain</a> (const Vec &amp;y)</td></tr>
<tr class="memdesc:ae2f54b79be640584c9276f7730aba6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the simplex corresponding to the specified free vector.  <a href="namespacestan_1_1math_ae2f54b79be640584c9276f7730aba6a2.html#ae2f54b79be640584c9276f7730aba6a2">More...</a><br /></td></tr>
<tr class="separator:ae2f54b79be640584c9276f7730aba6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e2b3bbea7c1d0a7373119c56ac18b8"><td class="memTemplParams" colspan="2">template&lt;typename Vec , require_eigen_col_vector_t&lt; Vec &gt; *  = nullptr, require_not_st_var&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a95e2b3bbea7c1d0a7373119c56ac18b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a95e2b3bbea7c1d0a7373119c56ac18b8.html#a95e2b3bbea7c1d0a7373119c56ac18b8">simplex_constrain</a> (const Vec &amp;y, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; Vec &gt; &amp;lp)</td></tr>
<tr class="memdesc:a95e2b3bbea7c1d0a7373119c56ac18b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the simplex corresponding to the specified free vector and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <a href="namespacestan_1_1math_a95e2b3bbea7c1d0a7373119c56ac18b8.html#a95e2b3bbea7c1d0a7373119c56ac18b8">More...</a><br /></td></tr>
<tr class="separator:a95e2b3bbea7c1d0a7373119c56ac18b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3941fdf51435cf090d7c6716a246f0"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename Vec , require_not_std_vector_t&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3d3941fdf51435cf090d7c6716a246f0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3d3941fdf51435cf090d7c6716a246f0.html#a3d3941fdf51435cf090d7c6716a246f0">simplex_constrain</a> (const Vec &amp;y, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Vec &gt; &amp;lp)</td></tr>
<tr class="memdesc:a3d3941fdf51435cf090d7c6716a246f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the simplex corresponding to the specified free vector.  <a href="namespacestan_1_1math_a3d3941fdf51435cf090d7c6716a246f0.html#a3d3941fdf51435cf090d7c6716a246f0">More...</a><br /></td></tr>
<tr class="separator:a3d3941fdf51435cf090d7c6716a246f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c1ecd3bf9c01640f9b6e19d5683ca1"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , require_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa0c1ecd3bf9c01640f9b6e19d5683ca1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa0c1ecd3bf9c01640f9b6e19d5683ca1.html#aa0c1ecd3bf9c01640f9b6e19d5683ca1">simplex_constrain</a> (const T &amp;y, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:aa0c1ecd3bf9c01640f9b6e19d5683ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the simplex corresponding to the specified free vector.  <a href="namespacestan_1_1math_aa0c1ecd3bf9c01640f9b6e19d5683ca1.html#aa0c1ecd3bf9c01640f9b6e19d5683ca1">More...</a><br /></td></tr>
<tr class="separator:aa0c1ecd3bf9c01640f9b6e19d5683ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458bb490fa781be233a2164fe78d2a7d"><td class="memTemplParams" colspan="2">template&lt;typename Vec , require_eigen_col_vector_t&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a458bb490fa781be233a2164fe78d2a7d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a458bb490fa781be233a2164fe78d2a7d.html#a458bb490fa781be233a2164fe78d2a7d">simplex_free</a> (const Vec &amp;x)</td></tr>
<tr class="memdesc:a458bb490fa781be233a2164fe78d2a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unconstrained vector that when transformed produces the specified simplex.  <a href="namespacestan_1_1math_a458bb490fa781be233a2164fe78d2a7d.html#a458bb490fa781be233a2164fe78d2a7d">More...</a><br /></td></tr>
<tr class="separator:a458bb490fa781be233a2164fe78d2a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad150fb4477b2de04e654a826c2d29fda"><td class="memTemplParams" colspan="2">template&lt;typename T , require_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad150fb4477b2de04e654a826c2d29fda"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad150fb4477b2de04e654a826c2d29fda.html#ad150fb4477b2de04e654a826c2d29fda">simplex_free</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ad150fb4477b2de04e654a826c2d29fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_a458bb490fa781be233a2164fe78d2a7d.html#a458bb490fa781be233a2164fe78d2a7d" title="Return an unconstrained vector that when transformed produces the specified simplex.">simplex_free()</a></code> to untransform each <a class="el" href="namespace_eigen.html">Eigen</a> vector in a standard vector.  <a href="namespacestan_1_1math_ad150fb4477b2de04e654a826c2d29fda.html#ad150fb4477b2de04e654a826c2d29fda">More...</a><br /></td></tr>
<tr class="separator:ad150fb4477b2de04e654a826c2d29fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14814493e855dc68adf4576b1d40a9ce"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_container_st&lt; std::is_arithmetic, T &gt; *  = nullptr, require_not_var_matrix_t&lt; T &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a14814493e855dc68adf4576b1d40a9ce"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a14814493e855dc68adf4576b1d40a9ce.html#a14814493e855dc68adf4576b1d40a9ce">sin</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a14814493e855dc68adf4576b1d40a9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_aff3f2dd84567a0566cfdd7eb10e13607.html#aff3f2dd84567a0566cfdd7eb10e13607">sin()</a>.  <a href="namespacestan_1_1math_a14814493e855dc68adf4576b1d40a9ce.html#a14814493e855dc68adf4576b1d40a9ce">More...</a><br /></td></tr>
<tr class="separator:a14814493e855dc68adf4576b1d40a9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8814ed6981127e4a0e2010ead478824"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae8814ed6981127e4a0e2010ead478824"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae8814ed6981127e4a0e2010ead478824.html#ae8814ed6981127e4a0e2010ead478824">sin</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ae8814ed6981127e4a0e2010ead478824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="namespacestan_1_1math_aff3f2dd84567a0566cfdd7eb10e13607.html#aff3f2dd84567a0566cfdd7eb10e13607">sin()</a> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_ae8814ed6981127e4a0e2010ead478824.html#ae8814ed6981127e4a0e2010ead478824">More...</a><br /></td></tr>
<tr class="separator:ae8814ed6981127e4a0e2010ead478824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad101c75225637f8e1a75018e246919c5"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_matrix_dynamic_t&lt; EigMat &gt; *  = nullptr, require_not_st_var&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad101c75225637f8e1a75018e246919c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad101c75225637f8e1a75018e246919c5.html#ad101c75225637f8e1a75018e246919c5">singular_values</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:ad101c75225637f8e1a75018e246919c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of the singular values of the specified matrix in decreasing order of magnitude.  <a href="namespacestan_1_1math_ad101c75225637f8e1a75018e246919c5.html#ad101c75225637f8e1a75018e246919c5">More...</a><br /></td></tr>
<tr class="separator:ad101c75225637f8e1a75018e246919c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34d0d75451d1c0ed453b30aaa74e506"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab34d0d75451d1c0ed453b30aaa74e506"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab34d0d75451d1c0ed453b30aaa74e506.html#ab34d0d75451d1c0ed453b30aaa74e506">sinh</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ab34d0d75451d1c0ed453b30aaa74e506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a646a34790ca2b692b2a8c74c4e4fb726.html#a646a34790ca2b692b2a8c74c4e4fb726">sinh()</a>.  <a href="namespacestan_1_1math_ab34d0d75451d1c0ed453b30aaa74e506.html#ab34d0d75451d1c0ed453b30aaa74e506">More...</a><br /></td></tr>
<tr class="separator:ab34d0d75451d1c0ed453b30aaa74e506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf656a1bfc885b654cb549599611abb5"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acf656a1bfc885b654cb549599611abb5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acf656a1bfc885b654cb549599611abb5.html#acf656a1bfc885b654cb549599611abb5">sinh</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:acf656a1bfc885b654cb549599611abb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="namespacestan_1_1math_a646a34790ca2b692b2a8c74c4e4fb726.html#a646a34790ca2b692b2a8c74c4e4fb726">sinh()</a> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_acf656a1bfc885b654cb549599611abb5.html#acf656a1bfc885b654cb549599611abb5">More...</a><br /></td></tr>
<tr class="separator:acf656a1bfc885b654cb549599611abb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9a1e2f6c725ab45a9a0d5335ae9b0c1"><td class="memTemplParams" colspan="2">template&lt;typename ScalarT , require_stan_scalar_t&lt; ScalarT &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab9a1e2f6c725ab45a9a0d5335ae9b0c1"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gab9a1e2f6c725ab45a9a0d5335ae9b0c1.html#gab9a1e2f6c725ab45a9a0d5335ae9b0c1">size_mvt</a> (const ScalarT &amp;)</td></tr>
<tr class="separator:gab9a1e2f6c725ab45a9a0d5335ae9b0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4139f69c577c0b98e8d9bf781f18ba3"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , require_matrix_t&lt; MatrixT &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab4139f69c577c0b98e8d9bf781f18ba3"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab4139f69c577c0b98e8d9bf781f18ba3.html#ab4139f69c577c0b98e8d9bf781f18ba3">size_mvt</a> (const MatrixT &amp;)</td></tr>
<tr class="separator:ab4139f69c577c0b98e8d9bf781f18ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb73aabe92db3b374568e3c7305ce1a"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , require_matrix_t&lt; MatrixT &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acdb73aabe92db3b374568e3c7305ce1a"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acdb73aabe92db3b374568e3c7305ce1a.html#acdb73aabe92db3b374568e3c7305ce1a">size_mvt</a> (const std::vector&lt; MatrixT &gt; &amp;x)</td></tr>
<tr class="separator:acdb73aabe92db3b374568e3c7305ce1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa7124838a3c8c241f21d063016a58a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2aa7124838a3c8c241f21d063016a58a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2aa7124838a3c8c241f21d063016a58a.html#a2aa7124838a3c8c241f21d063016a58a">size_zero</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a2aa7124838a3c8c241f21d063016a58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if input is of length 0, returns 0 otherwise.  <a href="namespacestan_1_1math_a2aa7124838a3c8c241f21d063016a58a.html#a2aa7124838a3c8c241f21d063016a58a">More...</a><br /></td></tr>
<tr class="separator:a2aa7124838a3c8c241f21d063016a58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac31032b503cd0f3e68155fb715281a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a2ac31032b503cd0f3e68155fb715281a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2ac31032b503cd0f3e68155fb715281a.html#a2ac31032b503cd0f3e68155fb715281a">size_zero</a> (const T &amp;x, const Ts &amp;... xs)</td></tr>
<tr class="memdesc:a2ac31032b503cd0f3e68155fb715281a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if any inputs are of length 0, returns 0 otherwise.  <a href="namespacestan_1_1math_a2ac31032b503cd0f3e68155fb715281a.html#a2ac31032b503cd0f3e68155fb715281a">More...</a><br /></td></tr>
<tr class="separator:a2ac31032b503cd0f3e68155fb715281a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86984ae449f712982aa5d08164c1ff8"><td class="memTemplParams" colspan="2">template&lt;typename ColVec , require_eigen_col_vector_vt&lt; std::is_arithmetic, ColVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae86984ae449f712982aa5d08164c1ff8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; ColVec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae86984ae449f712982aa5d08164c1ff8.html#ae86984ae449f712982aa5d08164c1ff8">softmax</a> (const ColVec &amp;v)</td></tr>
<tr class="memdesc:ae86984ae449f712982aa5d08164c1ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the softmax of the specified vector.  <a href="namespacestan_1_1math_ae86984ae449f712982aa5d08164c1ff8.html#ae86984ae449f712982aa5d08164c1ff8">More...</a><br /></td></tr>
<tr class="separator:ae86984ae449f712982aa5d08164c1ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f5418b16ea26e9bc6d2a8f9b764897"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80f5418b16ea26e9bc6d2a8f9b764897"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a80f5418b16ea26e9bc6d2a8f9b764897.html#a80f5418b16ea26e9bc6d2a8f9b764897">sort_asc</a> (std::vector&lt; T &gt; xs)</td></tr>
<tr class="memdesc:a80f5418b16ea26e9bc6d2a8f9b764897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified standard vector in ascending order.  <a href="namespacestan_1_1math_a80f5418b16ea26e9bc6d2a8f9b764897.html#a80f5418b16ea26e9bc6d2a8f9b764897">More...</a><br /></td></tr>
<tr class="separator:a80f5418b16ea26e9bc6d2a8f9b764897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc35144d86022f7e52a2cf2cf9c2efb"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_eigen_vector_t&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6dc35144d86022f7e52a2cf2cf9c2efb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; EigVec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6dc35144d86022f7e52a2cf2cf9c2efb.html#a6dc35144d86022f7e52a2cf2cf9c2efb">sort_asc</a> (EigVec &amp;&amp;xs)</td></tr>
<tr class="memdesc:a6dc35144d86022f7e52a2cf2cf9c2efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified vector in ascending order.  <a href="namespacestan_1_1math_a6dc35144d86022f7e52a2cf2cf9c2efb.html#a6dc35144d86022f7e52a2cf2cf9c2efb">More...</a><br /></td></tr>
<tr class="separator:a6dc35144d86022f7e52a2cf2cf9c2efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b2712eab9b95535c0589455ed11cfc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0b2712eab9b95535c0589455ed11cfc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab0b2712eab9b95535c0589455ed11cfc.html#ab0b2712eab9b95535c0589455ed11cfc">sort_desc</a> (std::vector&lt; T &gt; xs)</td></tr>
<tr class="memdesc:ab0b2712eab9b95535c0589455ed11cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified standard vector in descending order.  <a href="namespacestan_1_1math_ab0b2712eab9b95535c0589455ed11cfc.html#ab0b2712eab9b95535c0589455ed11cfc">More...</a><br /></td></tr>
<tr class="separator:ab0b2712eab9b95535c0589455ed11cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453fc62260cf218974c45eaecf39c1fc"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_eigen_vector_t&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a453fc62260cf218974c45eaecf39c1fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; EigVec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a453fc62260cf218974c45eaecf39c1fc.html#a453fc62260cf218974c45eaecf39c1fc">sort_desc</a> (EigVec &amp;&amp;xs)</td></tr>
<tr class="memdesc:a453fc62260cf218974c45eaecf39c1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified vector in descending order.  <a href="namespacestan_1_1math_a453fc62260cf218974c45eaecf39c1fc.html#a453fc62260cf218974c45eaecf39c1fc">More...</a><br /></td></tr>
<tr class="separator:a453fc62260cf218974c45eaecf39c1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7aa71479c0d3586a23207bc3130586"><td class="memTemplParams" colspan="2">template&lt;bool ascending, typename C &gt; </td></tr>
<tr class="memitem:afc7aa71479c0d3586a23207bc3130586"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afc7aa71479c0d3586a23207bc3130586.html#afc7aa71479c0d3586a23207bc3130586">sort_indices</a> (const C &amp;xs)</td></tr>
<tr class="memdesc:afc7aa71479c0d3586a23207bc3130586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an integer array of indices of the specified container sorting the values in ascending or descending order based on the value of the first template parameter.  <a href="namespacestan_1_1math_afc7aa71479c0d3586a23207bc3130586.html#afc7aa71479c0d3586a23207bc3130586">More...</a><br /></td></tr>
<tr class="separator:afc7aa71479c0d3586a23207bc3130586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a13ccb29cba05ef0daa9712ee9bf7a3"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a4a13ccb29cba05ef0daa9712ee9bf7a3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a13ccb29cba05ef0daa9712ee9bf7a3.html#a4a13ccb29cba05ef0daa9712ee9bf7a3">sort_indices_asc</a> (const C &amp;xs)</td></tr>
<tr class="memdesc:a4a13ccb29cba05ef0daa9712ee9bf7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sorted copy of the argument container in ascending order.  <a href="namespacestan_1_1math_a4a13ccb29cba05ef0daa9712ee9bf7a3.html#a4a13ccb29cba05ef0daa9712ee9bf7a3">More...</a><br /></td></tr>
<tr class="separator:a4a13ccb29cba05ef0daa9712ee9bf7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f6f9085eb850e9e0fcb98df345aeba"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a27f6f9085eb850e9e0fcb98df345aeba"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a27f6f9085eb850e9e0fcb98df345aeba.html#a27f6f9085eb850e9e0fcb98df345aeba">sort_indices_desc</a> (const C &amp;xs)</td></tr>
<tr class="memdesc:a27f6f9085eb850e9e0fcb98df345aeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sorted copy of the argument container in ascending order.  <a href="namespacestan_1_1math_a27f6f9085eb850e9e0fcb98df345aeba.html#a27f6f9085eb850e9e0fcb98df345aeba">More...</a><br /></td></tr>
<tr class="separator:a27f6f9085eb850e9e0fcb98df345aeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2a9be31d68cd290928a5aa9b55bc44"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aea2a9be31d68cd290928a5aa9b55bc44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aea2a9be31d68cd290928a5aa9b55bc44.html#aea2a9be31d68cd290928a5aa9b55bc44">sqrt</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:aea2a9be31d68cd290928a5aa9b55bc44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <code><a class="el" href="namespacestan_1_1math_aa5231d132852d58cd3fe610221c9766f.html#aa5231d132852d58cd3fe610221c9766f">sqrt()</a></code>.  <a href="namespacestan_1_1math_aea2a9be31d68cd290928a5aa9b55bc44.html#aea2a9be31d68cd290928a5aa9b55bc44">More...</a><br /></td></tr>
<tr class="separator:aea2a9be31d68cd290928a5aa9b55bc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37a6a298ce1b6b6d6328bf8a87954f1"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae37a6a298ce1b6b6d6328bf8a87954f1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae37a6a298ce1b6b6d6328bf8a87954f1.html#ae37a6a298ce1b6b6d6328bf8a87954f1">sqrt</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ae37a6a298ce1b6b6d6328bf8a87954f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_aa5231d132852d58cd3fe610221c9766f.html#aa5231d132852d58cd3fe610221c9766f">sqrt()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_ae37a6a298ce1b6b6d6328bf8a87954f1.html#ae37a6a298ce1b6b6d6328bf8a87954f1">More...</a><br /></td></tr>
<tr class="separator:ae37a6a298ce1b6b6d6328bf8a87954f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075f83d407717c0a93fbf134c5f13361"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a075f83d407717c0a93fbf134c5f13361.html#a075f83d407717c0a93fbf134c5f13361">square</a> (double x)</td></tr>
<tr class="memdesc:a075f83d407717c0a93fbf134c5f13361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of the specified argument.  <a href="namespacestan_1_1math_a075f83d407717c0a93fbf134c5f13361.html#a075f83d407717c0a93fbf134c5f13361">More...</a><br /></td></tr>
<tr class="separator:a075f83d407717c0a93fbf134c5f13361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef6272acd45f92534e5a3ccfc999849"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_stan_scalar_t&lt; Container &gt; *  = nullptr, require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr, require_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9ef6272acd45f92534e5a3ccfc999849"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ef6272acd45f92534e5a3ccfc999849.html#a9ef6272acd45f92534e5a3ccfc999849">square</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a9ef6272acd45f92534e5a3ccfc999849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_ab1ed68bdfff9b340a187964ef7684091.html#ab1ed68bdfff9b340a187964ef7684091">square()</a>.  <a href="namespacestan_1_1math_a9ef6272acd45f92534e5a3ccfc999849.html#a9ef6272acd45f92534e5a3ccfc999849">More...</a><br /></td></tr>
<tr class="separator:a9ef6272acd45f92534e5a3ccfc999849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ccad831392dfa7fb6e5441bc782e1c"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a07ccad831392dfa7fb6e5441bc782e1c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a07ccad831392dfa7fb6e5441bc782e1c.html#a07ccad831392dfa7fb6e5441bc782e1c">square</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a07ccad831392dfa7fb6e5441bc782e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="namespacestan_1_1math_ab1ed68bdfff9b340a187964ef7684091.html#ab1ed68bdfff9b340a187964ef7684091">square()</a> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_a07ccad831392dfa7fb6e5441bc782e1c.html#a07ccad831392dfa7fb6e5441bc782e1c">More...</a><br /></td></tr>
<tr class="separator:a07ccad831392dfa7fb6e5441bc782e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab691927064a4839ad87c32c3d16cff"><td class="memTemplParams" colspan="2">template&lt;typename Scal1 , typename Scal2 , require_all_stan_scalar_t&lt; Scal1, Scal2 &gt; *  = nullptr, require_all_not_var_t&lt; Scal1, Scal2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1ab691927064a4839ad87c32c3d16cff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Scal1, Scal2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1ab691927064a4839ad87c32c3d16cff.html#a1ab691927064a4839ad87c32c3d16cff">squared_distance</a> (const Scal1 &amp;x1, const Scal2 &amp;x2)</td></tr>
<tr class="memdesc:a1ab691927064a4839ad87c32c3d16cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance.  <a href="namespacestan_1_1math_a1ab691927064a4839ad87c32c3d16cff.html#a1ab691927064a4839ad87c32c3d16cff">More...</a><br /></td></tr>
<tr class="separator:a1ab691927064a4839ad87c32c3d16cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53476c8db01c5e3a01795e1984bfc5bc"><td class="memTemplParams" colspan="2">template&lt;typename EigVec1 , typename EigVec2 , require_all_eigen_vector_t&lt; EigVec1, EigVec2 &gt; *  = nullptr, require_all_not_eigen_vt&lt; is_var, EigVec1, EigVec2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a53476c8db01c5e3a01795e1984bfc5bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigVec1, EigVec2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a53476c8db01c5e3a01795e1984bfc5bc.html#a53476c8db01c5e3a01795e1984bfc5bc">squared_distance</a> (const EigVec1 &amp;v1, const EigVec2 &amp;v2)</td></tr>
<tr class="memdesc:a53476c8db01c5e3a01795e1984bfc5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance between the specified vectors of the same dimensions.  <a href="namespacestan_1_1math_a53476c8db01c5e3a01795e1984bfc5bc.html#a53476c8db01c5e3a01795e1984bfc5bc">More...</a><br /></td></tr>
<tr class="separator:a53476c8db01c5e3a01795e1984bfc5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace42bb9974f5fbe1e30f9a4a5fc50c0b"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_container_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ace42bb9974f5fbe1e30f9a4a5fc50c0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ace42bb9974f5fbe1e30f9a4a5fc50c0b.html#ace42bb9974f5fbe1e30f9a4a5fc50c0b">stan_print</a> (std::ostream *o, const T &amp;x)</td></tr>
<tr class="separator:ace42bb9974f5fbe1e30f9a4a5fc50c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7594018532e7e465f028676dd1b3b2b0"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_eigen_vector_t&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7594018532e7e465f028676dd1b3b2b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7594018532e7e465f028676dd1b3b2b0.html#a7594018532e7e465f028676dd1b3b2b0">stan_print</a> (std::ostream *o, const EigVec &amp;x)</td></tr>
<tr class="separator:a7594018532e7e465f028676dd1b3b2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723e116c3a7e9161911a23420611f213"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_not_eigen_vector_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a723e116c3a7e9161911a23420611f213"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a723e116c3a7e9161911a23420611f213.html#a723e116c3a7e9161911a23420611f213">stan_print</a> (std::ostream *o, const EigMat &amp;x)</td></tr>
<tr class="separator:a723e116c3a7e9161911a23420611f213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cb2d874adcc950cb0439af044f549f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a37cb2d874adcc950cb0439af044f549f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a37cb2d874adcc950cb0439af044f549f.html#a37cb2d874adcc950cb0439af044f549f">stan_print</a> (std::ostream *o, const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a37cb2d874adcc950cb0439af044f549f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee16e810d0e707c24f7274af63f8635"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4ee16e810d0e707c24f7274af63f8635"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4ee16e810d0e707c24f7274af63f8635.html#a4ee16e810d0e707c24f7274af63f8635">step</a> (const T &amp;y)</td></tr>
<tr class="memdesc:a4ee16e810d0e707c24f7274af63f8635"><td class="mdescLeft">&#160;</td><td class="mdescRight">The step, or Heaviside, function.  <a href="namespacestan_1_1math_a4ee16e810d0e707c24f7274af63f8635.html#a4ee16e810d0e707c24f7274af63f8635">More...</a><br /></td></tr>
<tr class="separator:a4ee16e810d0e707c24f7274af63f8635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04620f821b34ac0beffdb9727f268130"><td class="memTemplParams" colspan="2">template&lt;typename T , require_container_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a04620f821b34ac0beffdb9727f268130"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a04620f821b34ac0beffdb9727f268130.html#a04620f821b34ac0beffdb9727f268130">step</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a04620f821b34ac0beffdb9727f268130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a4ee16e810d0e707c24f7274af63f8635.html#a4ee16e810d0e707c24f7274af63f8635" title="The step, or Heaviside, function.">step()</a></code> to specified argument container.  <a href="namespacestan_1_1math_a04620f821b34ac0beffdb9727f268130.html#a04620f821b34ac0beffdb9727f268130">More...</a><br /></td></tr>
<tr class="separator:a04620f821b34ac0beffdb9727f268130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e49cae251175dfc267aae38af76c1f"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_t&lt; T &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a67e49cae251175dfc267aae38af76c1f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a67e49cae251175dfc267aae38af76c1f.html#a67e49cae251175dfc267aae38af76c1f">sub_col</a> (const T &amp;m, size_t i, size_t j, size_t nrows)</td></tr>
<tr class="memdesc:a67e49cae251175dfc267aae38af76c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a nrows x 1 subcolumn starting at (i-1, j-1).  <a href="namespacestan_1_1math_a67e49cae251175dfc267aae38af76c1f.html#a67e49cae251175dfc267aae38af76c1f">More...</a><br /></td></tr>
<tr class="separator:a67e49cae251175dfc267aae38af76c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b39a3595da70eb89b520b979bb74c31"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_t&lt; T &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1b39a3595da70eb89b520b979bb74c31"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1b39a3595da70eb89b520b979bb74c31.html#a1b39a3595da70eb89b520b979bb74c31">sub_row</a> (const T &amp;m, size_t i, size_t j, size_t ncols)</td></tr>
<tr class="memdesc:a1b39a3595da70eb89b520b979bb74c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a 1 x ncols subrow starting at (i-1, j-1).  <a href="namespacestan_1_1math_a1b39a3595da70eb89b520b979bb74c31.html#a1b39a3595da70eb89b520b979bb74c31">More...</a><br /></td></tr>
<tr class="separator:a1b39a3595da70eb89b520b979bb74c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a51a8c390bc790245cab0d6b080e31"><td class="memTemplParams" colspan="2">template&lt;typename ScalarA , typename ScalarB , require_all_stan_scalar_t&lt; ScalarA, ScalarB &gt; *  = nullptr, require_all_not_var_t&lt; ScalarA, ScalarB &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a88a51a8c390bc790245cab0d6b080e31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; ScalarA, ScalarB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a88a51a8c390bc790245cab0d6b080e31.html#a88a51a8c390bc790245cab0d6b080e31">subtract</a> (const ScalarA &amp;a, const ScalarB &amp;b)</td></tr>
<tr class="memdesc:a88a51a8c390bc790245cab0d6b080e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of subtracting the second scalar from the first scalar.  <a href="namespacestan_1_1math_a88a51a8c390bc790245cab0d6b080e31.html#a88a51a8c390bc790245cab0d6b080e31">More...</a><br /></td></tr>
<tr class="separator:a88a51a8c390bc790245cab0d6b080e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5271ab237f1b64536256e11f84fef0e5"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , require_all_eigen_t&lt; Mat1, Mat2 &gt; *  = nullptr, require_all_not_st_var&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5271ab237f1b64536256e11f84fef0e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5271ab237f1b64536256e11f84fef0e5.html#a5271ab237f1b64536256e11f84fef0e5">subtract</a> (const Mat1 &amp;m1, const Mat2 &amp;m2)</td></tr>
<tr class="memdesc:a5271ab237f1b64536256e11f84fef0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of subtracting the second specified matrix from the first specified matrix.  <a href="namespacestan_1_1math_a5271ab237f1b64536256e11f84fef0e5.html#a5271ab237f1b64536256e11f84fef0e5">More...</a><br /></td></tr>
<tr class="separator:a5271ab237f1b64536256e11f84fef0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c610fa5dd31e027d24ee1cca68d105b"><td class="memTemplParams" colspan="2">template&lt;typename Scal , typename Mat , require_stan_scalar_t&lt; Scal &gt; *  = nullptr, require_eigen_t&lt; Mat &gt; *  = nullptr, require_all_not_st_var&lt; Mat, Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6c610fa5dd31e027d24ee1cca68d105b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6c610fa5dd31e027d24ee1cca68d105b.html#a6c610fa5dd31e027d24ee1cca68d105b">subtract</a> (const Scal c, const Mat &amp;m)</td></tr>
<tr class="memdesc:a6c610fa5dd31e027d24ee1cca68d105b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of subtracting the specified matrix from the specified scalar.  <a href="namespacestan_1_1math_a6c610fa5dd31e027d24ee1cca68d105b.html#a6c610fa5dd31e027d24ee1cca68d105b">More...</a><br /></td></tr>
<tr class="separator:a6c610fa5dd31e027d24ee1cca68d105b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d3ce82fde36dbcc8eb3158f48326dc"><td class="memTemplParams" colspan="2">template&lt;typename Mat , typename Scal , require_eigen_t&lt; Mat &gt; *  = nullptr, require_stan_scalar_t&lt; Scal &gt; *  = nullptr, require_all_not_st_var&lt; Scal, Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a34d3ce82fde36dbcc8eb3158f48326dc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a34d3ce82fde36dbcc8eb3158f48326dc.html#a34d3ce82fde36dbcc8eb3158f48326dc">subtract</a> (const Mat &amp;m, const Scal c)</td></tr>
<tr class="memdesc:a34d3ce82fde36dbcc8eb3158f48326dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of subtracting the specified scalar from the specified matrix.  <a href="namespacestan_1_1math_a34d3ce82fde36dbcc8eb3158f48326dc.html#a34d3ce82fde36dbcc8eb3158f48326dc">More...</a><br /></td></tr>
<tr class="separator:a34d3ce82fde36dbcc8eb3158f48326dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac459ffd33c159edf3bb7b61f9daf0bc2"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac459ffd33c159edf3bb7b61f9daf0bc2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac459ffd33c159edf3bb7b61f9daf0bc2.html#ac459ffd33c159edf3bb7b61f9daf0bc2">sum</a> (T &amp;&amp;m)</td></tr>
<tr class="memdesc:ac459ffd33c159edf3bb7b61f9daf0bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns specified input value.  <a href="namespacestan_1_1math_ac459ffd33c159edf3bb7b61f9daf0bc2.html#ac459ffd33c159edf3bb7b61f9daf0bc2">More...</a><br /></td></tr>
<tr class="separator:ac459ffd33c159edf3bb7b61f9daf0bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e26d40598b8d6e024bc435210dbfbbe"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_var_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3e26d40598b8d6e024bc435210dbfbbe"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3e26d40598b8d6e024bc435210dbfbbe.html#a3e26d40598b8d6e024bc435210dbfbbe">sum</a> (const std::vector&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a3e26d40598b8d6e024bc435210dbfbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the values in the specified standard vector.  <a href="namespacestan_1_1math_a3e26d40598b8d6e024bc435210dbfbbe.html#a3e26d40598b8d6e024bc435210dbfbbe">More...</a><br /></td></tr>
<tr class="separator:a3e26d40598b8d6e024bc435210dbfbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139969c77cafb316f8c3d93ab3346fe1"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_matrix_dynamic_t&lt; EigMat &gt; *  = nullptr, require_not_st_var&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a139969c77cafb316f8c3d93ab3346fe1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a139969c77cafb316f8c3d93ab3346fe1.html#a139969c77cafb316f8c3d93ab3346fe1">svd_U</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a139969c77cafb316f8c3d93ab3346fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given input matrix m, return matrix U where <code>m = UDV^{T}</code>  <a href="namespacestan_1_1math_a139969c77cafb316f8c3d93ab3346fe1.html#a139969c77cafb316f8c3d93ab3346fe1">More...</a><br /></td></tr>
<tr class="separator:a139969c77cafb316f8c3d93ab3346fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa941d599c19dbaf65c3b1a9d587b6fa1"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_matrix_dynamic_t&lt; EigMat &gt; *  = nullptr, require_not_st_var&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa941d599c19dbaf65c3b1a9d587b6fa1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa941d599c19dbaf65c3b1a9d587b6fa1.html#aa941d599c19dbaf65c3b1a9d587b6fa1">svd_V</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:aa941d599c19dbaf65c3b1a9d587b6fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given input matrix m, return matrix V where <code>m = UDV^{T}</code>  <a href="namespacestan_1_1math_aa941d599c19dbaf65c3b1a9d587b6fa1.html#aa941d599c19dbaf65c3b1a9d587b6fa1">More...</a><br /></td></tr>
<tr class="separator:aa941d599c19dbaf65c3b1a9d587b6fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9cb89d281f69bae244784bf2adff92"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7e9cb89d281f69bae244784bf2adff92"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7e9cb89d281f69bae244784bf2adff92.html#a7e9cb89d281f69bae244784bf2adff92">symmetrize_from_lower_tri</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a7e9cb89d281f69bae244784bf2adff92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a symmetric matrix using elements from the lower triangular part of the input matrix.  <a href="namespacestan_1_1math_a7e9cb89d281f69bae244784bf2adff92.html#a7e9cb89d281f69bae244784bf2adff92">More...</a><br /></td></tr>
<tr class="separator:a7e9cb89d281f69bae244784bf2adff92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4baabd0dcc8eeac870be3ecbb2adfc4b"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4baabd0dcc8eeac870be3ecbb2adfc4b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4baabd0dcc8eeac870be3ecbb2adfc4b.html#a4baabd0dcc8eeac870be3ecbb2adfc4b">symmetrize_from_upper_tri</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a4baabd0dcc8eeac870be3ecbb2adfc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a symmetric matrix using elements from the upper triangular part of the input matrix.  <a href="namespacestan_1_1math_a4baabd0dcc8eeac870be3ecbb2adfc4b.html#a4baabd0dcc8eeac870be3ecbb2adfc4b">More...</a><br /></td></tr>
<tr class="separator:a4baabd0dcc8eeac870be3ecbb2adfc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68e83105d9d3c1629ae9c91121bc1b1"><td class="memTemplParams" colspan="2">template&lt;typename T , require_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab68e83105d9d3c1629ae9c91121bc1b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab68e83105d9d3c1629ae9c91121bc1b1.html#ab68e83105d9d3c1629ae9c91121bc1b1">tail</a> (const T &amp;v, size_t n)</td></tr>
<tr class="memdesc:ab68e83105d9d3c1629ae9c91121bc1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a vector or row vector (same as input) from the back of the specified vector or row vector.  <a href="namespacestan_1_1math_ab68e83105d9d3c1629ae9c91121bc1b1.html#ab68e83105d9d3c1629ae9c91121bc1b1">More...</a><br /></td></tr>
<tr class="separator:ab68e83105d9d3c1629ae9c91121bc1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9956cf78180c6340f61667e797cf7055"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9956cf78180c6340f61667e797cf7055"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9956cf78180c6340f61667e797cf7055.html#a9956cf78180c6340f61667e797cf7055">tail</a> (const std::vector&lt; T &gt; &amp;sv, size_t n)</td></tr>
<tr class="memdesc:a9956cf78180c6340f61667e797cf7055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a standard vector from the back of the specified standard vector.  <a href="namespacestan_1_1math_a9956cf78180c6340f61667e797cf7055.html#a9956cf78180c6340f61667e797cf7055">More...</a><br /></td></tr>
<tr class="separator:a9956cf78180c6340f61667e797cf7055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d08c61098334239db16e2338a06b6df"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9d08c61098334239db16e2338a06b6df"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9d08c61098334239db16e2338a06b6df.html#a9d08c61098334239db16e2338a06b6df">tan</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a9d08c61098334239db16e2338a06b6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <code><a class="el" href="namespacestan_1_1math_ae09b685b660830075f80caaf8a350676.html#ae09b685b660830075f80caaf8a350676">tan()</a></code>.  <a href="namespacestan_1_1math_a9d08c61098334239db16e2338a06b6df.html#a9d08c61098334239db16e2338a06b6df">More...</a><br /></td></tr>
<tr class="separator:a9d08c61098334239db16e2338a06b6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbaa36f1e9691e3c92be71f9e7041c37"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afbaa36f1e9691e3c92be71f9e7041c37"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afbaa36f1e9691e3c92be71f9e7041c37.html#afbaa36f1e9691e3c92be71f9e7041c37">tan</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:afbaa36f1e9691e3c92be71f9e7041c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_ae09b685b660830075f80caaf8a350676.html#ae09b685b660830075f80caaf8a350676">tan()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_afbaa36f1e9691e3c92be71f9e7041c37.html#afbaa36f1e9691e3c92be71f9e7041c37">More...</a><br /></td></tr>
<tr class="separator:afbaa36f1e9691e3c92be71f9e7041c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5075e9720ec3ecb70d856365ef7b2bb2"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_not_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr, require_not_var_matrix_t&lt; Container &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5075e9720ec3ecb70d856365ef7b2bb2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5075e9720ec3ecb70d856365ef7b2bb2.html#a5075e9720ec3ecb70d856365ef7b2bb2">tanh</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a5075e9720ec3ecb70d856365ef7b2bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <code><a class="el" href="namespacestan_1_1math_ae11dc45fd471bec1a19462ce58f434b8.html#ae11dc45fd471bec1a19462ce58f434b8">tanh()</a></code>.  <a href="namespacestan_1_1math_a5075e9720ec3ecb70d856365ef7b2bb2.html#a5075e9720ec3ecb70d856365ef7b2bb2">More...</a><br /></td></tr>
<tr class="separator:a5075e9720ec3ecb70d856365ef7b2bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a1e69077c84dbc1619541732a385b3"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_container_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae6a1e69077c84dbc1619541732a385b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae6a1e69077c84dbc1619541732a385b3.html#ae6a1e69077c84dbc1619541732a385b3">tanh</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ae6a1e69077c84dbc1619541732a385b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_ae11dc45fd471bec1a19462ce58f434b8.html#ae11dc45fd471bec1a19462ce58f434b8">tanh()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <a href="namespacestan_1_1math_ae6a1e69077c84dbc1619541732a385b3.html#ae6a1e69077c84dbc1619541732a385b3">More...</a><br /></td></tr>
<tr class="separator:ae6a1e69077c84dbc1619541732a385b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78ab663420e3d49750706346139be6c"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vt&lt; std::is_arithmetic, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af78ab663420e3d49750706346139be6c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, T::RowsAtCompileTime, T::RowsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af78ab663420e3d49750706346139be6c.html#af78ab663420e3d49750706346139be6c">tcrossprod</a> (const T &amp;M)</td></tr>
<tr class="memdesc:af78ab663420e3d49750706346139be6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of post-multiplying a matrix by its own transpose.  <a href="namespacestan_1_1math_af78ab663420e3d49750706346139be6c.html#af78ab663420e3d49750706346139be6c">More...</a><br /></td></tr>
<tr class="separator:af78ab663420e3d49750706346139be6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b2a872141f3a9d7b2aff0dae078b07"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa6b2a872141f3a9d7b2aff0dae078b07.html#aa6b2a872141f3a9d7b2aff0dae078b07">tgamma</a> (double x)</td></tr>
<tr class="memdesc:aa6b2a872141f3a9d7b2aff0dae078b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the gamma function applied to the specified argument.  <a href="namespacestan_1_1math_aa6b2a872141f3a9d7b2aff0dae078b07.html#aa6b2a872141f3a9d7b2aff0dae078b07">More...</a><br /></td></tr>
<tr class="separator:aa6b2a872141f3a9d7b2aff0dae078b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae7b06ec937180ec5f3b2839d7de014"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr, require_not_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6ae7b06ec937180ec5f3b2839d7de014"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6ae7b06ec937180ec5f3b2839d7de014.html#a6ae7b06ec937180ec5f3b2839d7de014">tgamma</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a6ae7b06ec937180ec5f3b2839d7de014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a73eaf0a5d0593bb8610234e0d69e7cec.html#a73eaf0a5d0593bb8610234e0d69e7cec" title="Return the result of applying the gamma function to the specified argument.">tgamma()</a>.  <a href="namespacestan_1_1math_a6ae7b06ec937180ec5f3b2839d7de014.html#a6ae7b06ec937180ec5f3b2839d7de014">More...</a><br /></td></tr>
<tr class="separator:a6ae7b06ec937180ec5f3b2839d7de014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907b769f1f3c43277c1a8402b5bee682"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a907b769f1f3c43277c1a8402b5bee682"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a907b769f1f3c43277c1a8402b5bee682.html#a907b769f1f3c43277c1a8402b5bee682">to_array_1d</a> (const EigMat &amp;matrix)</td></tr>
<tr class="separator:a907b769f1f3c43277c1a8402b5bee682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6f4ebba197a343912387588ac340f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade6f4ebba197a343912387588ac340f3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade6f4ebba197a343912387588ac340f3.html#ade6f4ebba197a343912387588ac340f3">to_array_1d</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ade6f4ebba197a343912387588ac340f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71818f6ee8bdf60ee5d43aa0a266ea3c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a71818f6ee8bdf60ee5d43aa0a266ea3c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="structstan_1_1scalar__type.html">scalar_type</a>&lt; T &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a71818f6ee8bdf60ee5d43aa0a266ea3c.html#a71818f6ee8bdf60ee5d43aa0a266ea3c">to_array_1d</a> (const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;x)</td></tr>
<tr class="separator:a71818f6ee8bdf60ee5d43aa0a266ea3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2207dd28024b4b90f943cebd50b38d"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7d2207dd28024b4b90f943cebd50b38d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7d2207dd28024b4b90f943cebd50b38d.html#a7d2207dd28024b4b90f943cebd50b38d">to_array_2d</a> (const EigMat &amp;matrix)</td></tr>
<tr class="separator:a7d2207dd28024b4b90f943cebd50b38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab887ba2b1e3b691fbbeeb41c0db38194"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, typename S  = double, require_all_not_container_t&lt; T, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab887ba2b1e3b691fbbeeb41c0db38194"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::complex&lt; <a class="el" href="group__type__trait_gac9d3fe14d5102916bf0b5b05712c833e.html#gac9d3fe14d5102916bf0b5b05712c833e">stan::real_return_t</a>&lt; T, S &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab887ba2b1e3b691fbbeeb41c0db38194.html#ab887ba2b1e3b691fbbeeb41c0db38194">to_complex</a> (const T &amp;re=0, const S &amp;im=0)</td></tr>
<tr class="memdesc:ab887ba2b1e3b691fbbeeb41c0db38194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a complex value from a real component and an imaginary component.  <a href="namespacestan_1_1math_ab887ba2b1e3b691fbbeeb41c0db38194.html#ab887ba2b1e3b691fbbeeb41c0db38194">More...</a><br /></td></tr>
<tr class="separator:ab887ba2b1e3b691fbbeeb41c0db38194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb769176f6114ac45be33f245da1acd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_container_t&lt; T1, T2 &gt; *  = nullptr, require_all_st_stan_scalar&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3fb769176f6114ac45be33f245da1acd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3fb769176f6114ac45be33f245da1acd.html#a3fb769176f6114ac45be33f245da1acd">to_complex</a> (const T1 &amp;re, const T2 &amp;im)</td></tr>
<tr class="memdesc:a3fb769176f6114ac45be33f245da1acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a complex valued container from a real component and an imaginary component.  <a href="namespacestan_1_1math_a3fb769176f6114ac45be33f245da1acd.html#a3fb769176f6114ac45be33f245da1acd">More...</a><br /></td></tr>
<tr class="separator:a3fb769176f6114ac45be33f245da1acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10cc18c6e86357217fecedca8825c96"><td class="memTemplParams" colspan="2">template&lt;typename T , require_integral_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad10cc18c6e86357217fecedca8825c96"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad10cc18c6e86357217fecedca8825c96.html#ad10cc18c6e86357217fecedca8825c96">to_int</a> (T x)</td></tr>
<tr class="memdesc:ad10cc18c6e86357217fecedca8825c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input scalar as an integer type.  <a href="namespacestan_1_1math_ad10cc18c6e86357217fecedca8825c96.html#ad10cc18c6e86357217fecedca8825c96">More...</a><br /></td></tr>
<tr class="separator:ad10cc18c6e86357217fecedca8825c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a918d940e9012b956021e884814d4fa"><td class="memTemplParams" colspan="2">template&lt;typename T , require_floating_point_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4a918d940e9012b956021e884814d4fa"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a918d940e9012b956021e884814d4fa.html#a4a918d940e9012b956021e884814d4fa">to_int</a> (T x)</td></tr>
<tr class="memdesc:a4a918d940e9012b956021e884814d4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input scalar as an integer type.  <a href="namespacestan_1_1math_a4a918d940e9012b956021e884814d4fa.html#a4a918d940e9012b956021e884814d4fa">More...</a><br /></td></tr>
<tr class="separator:a4a918d940e9012b956021e884814d4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114332a122c003b3c9ac9b62361154cc"><td class="memTemplParams" colspan="2">template&lt;typename Container , require_std_vector_st&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a114332a122c003b3c9ac9b62361154cc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a114332a122c003b3c9ac9b62361154cc.html#a114332a122c003b3c9ac9b62361154cc">to_int</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a114332a122c003b3c9ac9b62361154cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ad10cc18c6e86357217fecedca8825c96.html#ad10cc18c6e86357217fecedca8825c96" title="Returns the input scalar as an integer type.">to_int()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <a href="namespacestan_1_1math_a114332a122c003b3c9ac9b62361154cc.html#a114332a122c003b3c9ac9b62361154cc">More...</a><br /></td></tr>
<tr class="separator:a114332a122c003b3c9ac9b62361154cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ad676574bc770c93e801ae72182e7b"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_dense_dynamic_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a01ad676574bc770c93e801ae72182e7b"><td class="memTemplItemLeft" align="right" valign="top">EigMat&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a01ad676574bc770c93e801ae72182e7b.html#a01ad676574bc770c93e801ae72182e7b">to_matrix</a> (EigMat &amp;&amp;x)</td></tr>
<tr class="memdesc:a01ad676574bc770c93e801ae72182e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix with dynamic dimensions constructed from an <a class="el" href="namespace_eigen.html">Eigen</a> matrix.  <a href="namespacestan_1_1math_a01ad676574bc770c93e801ae72182e7b.html#a01ad676574bc770c93e801ae72182e7b">More...</a><br /></td></tr>
<tr class="separator:a01ad676574bc770c93e801ae72182e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5766fea16f0d03147b15b47d9c57e7b"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_eigen_vector_t&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac5766fea16f0d03147b15b47d9c57e7b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac5766fea16f0d03147b15b47d9c57e7b.html#ac5766fea16f0d03147b15b47d9c57e7b">to_matrix</a> (EigVec &amp;&amp;matrix)</td></tr>
<tr class="memdesc:ac5766fea16f0d03147b15b47d9c57e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix with dynamic dimensions constructed from an <a class="el" href="namespace_eigen.html">Eigen</a> row or column vector.  <a href="namespacestan_1_1math_ac5766fea16f0d03147b15b47d9c57e7b.html#ac5766fea16f0d03147b15b47d9c57e7b">More...</a><br /></td></tr>
<tr class="separator:ac5766fea16f0d03147b15b47d9c57e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53fff0d7981031cb1eded0b31b4b56c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa53fff0d7981031cb1eded0b31b4b56c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa53fff0d7981031cb1eded0b31b4b56c.html#aa53fff0d7981031cb1eded0b31b4b56c">to_matrix</a> (const std::vector&lt; Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt;&gt; &amp;x)</td></tr>
<tr class="memdesc:aa53fff0d7981031cb1eded0b31b4b56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of a standard vector of <a class="el" href="namespace_eigen.html">Eigen</a> row vectors with the same dimensions and indexing order.  <a href="namespacestan_1_1math_aa53fff0d7981031cb1eded0b31b4b56c.html#aa53fff0d7981031cb1eded0b31b4b56c">More...</a><br /></td></tr>
<tr class="separator:aa53fff0d7981031cb1eded0b31b4b56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6e6a5a136b9df6fd7d56351f5e6a78"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab6e6a5a136b9df6fd7d56351f5e6a78"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, double &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab6e6a5a136b9df6fd7d56351f5e6a78.html#aab6e6a5a136b9df6fd7d56351f5e6a78">to_matrix</a> (const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;x)</td></tr>
<tr class="memdesc:aab6e6a5a136b9df6fd7d56351f5e6a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of the standard vector of standard vectors with the same dimensions and indexing order.  <a href="namespacestan_1_1math_aab6e6a5a136b9df6fd7d56351f5e6a78.html#aab6e6a5a136b9df6fd7d56351f5e6a78">More...</a><br /></td></tr>
<tr class="separator:aab6e6a5a136b9df6fd7d56351f5e6a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9aa926e8438bd0f7a9aa556e9328e1"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1a9aa926e8438bd0f7a9aa556e9328e1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1a9aa926e8438bd0f7a9aa556e9328e1.html#a1a9aa926e8438bd0f7a9aa556e9328e1">to_matrix</a> (EigMat &amp;&amp;x, int m, int n)</td></tr>
<tr class="memdesc:a1a9aa926e8438bd0f7a9aa556e9328e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of the vector in column-major order with the specified number of rows and columns.  <a href="namespacestan_1_1math_a1a9aa926e8438bd0f7a9aa556e9328e1.html#a1a9aa926e8438bd0f7a9aa556e9328e1">More...</a><br /></td></tr>
<tr class="separator:a1a9aa926e8438bd0f7a9aa556e9328e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d304ce4be8060879e8fdaf2096c5211"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d304ce4be8060879e8fdaf2096c5211"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3d304ce4be8060879e8fdaf2096c5211.html#a3d304ce4be8060879e8fdaf2096c5211">to_matrix</a> (const std::vector&lt; T &gt; &amp;x, int m, int n)</td></tr>
<tr class="memdesc:a3d304ce4be8060879e8fdaf2096c5211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of the vector in column-major order with the specified number of rows and columns.  <a href="namespacestan_1_1math_a3d304ce4be8060879e8fdaf2096c5211.html#a3d304ce4be8060879e8fdaf2096c5211">More...</a><br /></td></tr>
<tr class="separator:a3d304ce4be8060879e8fdaf2096c5211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1c1f4e78ebe47680896e6d536bd4d7"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afc1c1f4e78ebe47680896e6d536bd4d7.html#afc1c1f4e78ebe47680896e6d536bd4d7">to_matrix</a> (const std::vector&lt; int &gt; &amp;x, int m, int n)</td></tr>
<tr class="memdesc:afc1c1f4e78ebe47680896e6d536bd4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of the vector in column-major order with the specified number of rows and columns.  <a href="namespacestan_1_1math_afc1c1f4e78ebe47680896e6d536bd4d7.html#afc1c1f4e78ebe47680896e6d536bd4d7">More...</a><br /></td></tr>
<tr class="separator:afc1c1f4e78ebe47680896e6d536bd4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e687a801cd6029e1583436ba95e92e4"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6e687a801cd6029e1583436ba95e92e4"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6e687a801cd6029e1583436ba95e92e4.html#a6e687a801cd6029e1583436ba95e92e4">to_matrix</a> (EigMat &amp;&amp;x, int m, int n, bool col_major)</td></tr>
<tr class="memdesc:a6e687a801cd6029e1583436ba95e92e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of the vector in column-major order with the specified number of rows and columns.  <a href="namespacestan_1_1math_a6e687a801cd6029e1583436ba95e92e4.html#a6e687a801cd6029e1583436ba95e92e4">More...</a><br /></td></tr>
<tr class="separator:a6e687a801cd6029e1583436ba95e92e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cb4eaa74bfd1687a44c05705989a9a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac1cb4eaa74bfd1687a44c05705989a9a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, double &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac1cb4eaa74bfd1687a44c05705989a9a.html#ac1cb4eaa74bfd1687a44c05705989a9a">to_matrix</a> (const std::vector&lt; T &gt; &amp;x, int m, int n, bool col_major)</td></tr>
<tr class="memdesc:ac1cb4eaa74bfd1687a44c05705989a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of the vector in column-major order with the specified number of rows and columns.  <a href="namespacestan_1_1math_ac1cb4eaa74bfd1687a44c05705989a9a.html#ac1cb4eaa74bfd1687a44c05705989a9a">More...</a><br /></td></tr>
<tr class="separator:ac1cb4eaa74bfd1687a44c05705989a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3145f3467ad20649633bbf9842ddf909"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3145f3467ad20649633bbf9842ddf909"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a98f14126101865ddd8f5562480ad4927.html#a98f14126101865ddd8f5562480ad4927">ref_type_t</a>&lt; T &amp;&amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3145f3467ad20649633bbf9842ddf909.html#a3145f3467ad20649633bbf9842ddf909">to_ref</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a3145f3467ad20649633bbf9842ddf909"><td class="mdescLeft">&#160;</td><td class="mdescRight">This evaluates expensive <a class="el" href="namespace_eigen.html">Eigen</a> expressions.  <a href="namespacestan_1_1math_a3145f3467ad20649633bbf9842ddf909.html#a3145f3467ad20649633bbf9842ddf909">More...</a><br /></td></tr>
<tr class="separator:a3145f3467ad20649633bbf9842ddf909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6a46d167aa3367672cd930e2f4ab1e"><td class="memTemplParams" colspan="2">template&lt;bool Cond, typename T , std::enable_if_t&lt;!Cond &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b6a46d167aa3367672cd930e2f4ab1e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4b6a46d167aa3367672cd930e2f4ab1e.html#a4b6a46d167aa3367672cd930e2f4ab1e">to_ref_if</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a4b6a46d167aa3367672cd930e2f4ab1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-op that should be optimized away.  <a href="namespacestan_1_1math_a4b6a46d167aa3367672cd930e2f4ab1e.html#a4b6a46d167aa3367672cd930e2f4ab1e">More...</a><br /></td></tr>
<tr class="separator:a4b6a46d167aa3367672cd930e2f4ab1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edf843afaf6b773df1606d79dbb6c59"><td class="memTemplParams" colspan="2">template&lt;bool Cond, typename T , std::enable_if_t&lt; Cond &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3edf843afaf6b773df1606d79dbb6c59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a98f14126101865ddd8f5562480ad4927.html#a98f14126101865ddd8f5562480ad4927">ref_type_t</a>&lt; T &amp;&amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3edf843afaf6b773df1606d79dbb6c59.html#a3edf843afaf6b773df1606d79dbb6c59">to_ref_if</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a3edf843afaf6b773df1606d79dbb6c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the condition is true, evaluates expensive <a class="el" href="namespace_eigen.html">Eigen</a> expressions.  <a href="namespacestan_1_1math_a3edf843afaf6b773df1606d79dbb6c59.html#a3edf843afaf6b773df1606d79dbb6c59">More...</a><br /></td></tr>
<tr class="separator:a3edf843afaf6b773df1606d79dbb6c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebee752032e863043dcd469732179209"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aebee752032e863043dcd469732179209"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aebee752032e863043dcd469732179209.html#aebee752032e863043dcd469732179209">to_row_vector</a> (const EigMat &amp;matrix)</td></tr>
<tr class="separator:aebee752032e863043dcd469732179209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ee946e9b4885352c0cacf9bd985db3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4ee946e9b4885352c0cacf9bd985db3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad4ee946e9b4885352c0cacf9bd985db3.html#ad4ee946e9b4885352c0cacf9bd985db3">to_row_vector</a> (const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:ad4ee946e9b4885352c0cacf9bd985db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f96854fa55967e61b6e7a6f1decd4c8"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 1, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0f96854fa55967e61b6e7a6f1decd4c8.html#a0f96854fa55967e61b6e7a6f1decd4c8">to_row_vector</a> (const std::vector&lt; int &gt; &amp;vec)</td></tr>
<tr class="separator:a0f96854fa55967e61b6e7a6f1decd4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8989ec00f6f2c9fa0772e90a596a5e5c"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8989ec00f6f2c9fa0772e90a596a5e5c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8989ec00f6f2c9fa0772e90a596a5e5c.html#a8989ec00f6f2c9fa0772e90a596a5e5c">to_vector</a> (const EigMat &amp;matrix)</td></tr>
<tr class="separator:a8989ec00f6f2c9fa0772e90a596a5e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d35e6eb055462e57cd43865f18d5d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af7d35e6eb055462e57cd43865f18d5d6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af7d35e6eb055462e57cd43865f18d5d6.html#af7d35e6eb055462e57cd43865f18d5d6">to_vector</a> (const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:af7d35e6eb055462e57cd43865f18d5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbc759ea8f0f34b3dd92e0617c4ea02"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5fbc759ea8f0f34b3dd92e0617c4ea02.html#a5fbc759ea8f0f34b3dd92e0617c4ea02">to_vector</a> (const std::vector&lt; int &gt; &amp;vec)</td></tr>
<tr class="separator:a5fbc759ea8f0f34b3dd92e0617c4ea02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbafba87b855623e06c74e8f08e9015"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr, require_not_st_var&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acfbafba87b855623e06c74e8f08e9015"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acfbafba87b855623e06c74e8f08e9015.html#acfbafba87b855623e06c74e8f08e9015">trace</a> (const T &amp;m)</td></tr>
<tr class="memdesc:acfbafba87b855623e06c74e8f08e9015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trace of the specified matrix.  <a href="namespacestan_1_1math_acfbafba87b855623e06c74e8f08e9015.html#acfbafba87b855623e06c74e8f08e9015">More...</a><br /></td></tr>
<tr class="separator:acfbafba87b855623e06c74e8f08e9015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1cc2e5a3d2826bfb34e9bfbb256aec"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename T2 , typename EigMat3 , require_not_col_vector_t&lt; EigMat1 &gt; *  = nullptr, require_all_not_st_var&lt; EigMat1, T2, EigMat3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3e1cc2e5a3d2826bfb34e9bfbb256aec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, T2, EigMat3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3e1cc2e5a3d2826bfb34e9bfbb256aec.html#a3e1cc2e5a3d2826bfb34e9bfbb256aec">trace_gen_inv_quad_form_ldlt</a> (const EigMat1 &amp;D, <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T2 &gt; &amp;A, const EigMat3 &amp;B)</td></tr>
<tr class="memdesc:a3e1cc2e5a3d2826bfb34e9bfbb256aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the trace of an inverse quadratic form.  <a href="namespacestan_1_1math_a3e1cc2e5a3d2826bfb34e9bfbb256aec.html#a3e1cc2e5a3d2826bfb34e9bfbb256aec">More...</a><br /></td></tr>
<tr class="separator:a3e1cc2e5a3d2826bfb34e9bfbb256aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cef07d12aca5a432acf0433cbdcb12"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , typename T , typename EigMat , require_col_vector_t&lt; EigVec &gt; *  = nullptr, require_all_not_st_var&lt; EigVec, T, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a61cef07d12aca5a432acf0433cbdcb12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigVec, T, EigMat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a61cef07d12aca5a432acf0433cbdcb12.html#a61cef07d12aca5a432acf0433cbdcb12">trace_gen_inv_quad_form_ldlt</a> (const EigVec &amp;D, <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A, const EigMat &amp;B)</td></tr>
<tr class="memdesc:a61cef07d12aca5a432acf0433cbdcb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the trace of an inverse quadratic form.  <a href="namespacestan_1_1math_a61cef07d12aca5a432acf0433cbdcb12.html#a61cef07d12aca5a432acf0433cbdcb12">More...</a><br /></td></tr>
<tr class="separator:a61cef07d12aca5a432acf0433cbdcb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2495108b8463b99a75074f3f612553"><td class="memTemplParams" colspan="2">template&lt;typename TD , typename TA , typename TB , typename  = require_all_eigen_t&lt;TD, TA, TB&gt;, typename  = require_all_not_vt_var&lt;TD, TA, TB&gt;, typename  = require_any_not_vt_arithmetic&lt;TD, TA, TB&gt;&gt; </td></tr>
<tr class="memitem:a8c2495108b8463b99a75074f3f612553"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8c2495108b8463b99a75074f3f612553.html#a8c2495108b8463b99a75074f3f612553">trace_gen_quad_form</a> (const TD &amp;D, const TA &amp;A, const TB &amp;B)</td></tr>
<tr class="memdesc:a8c2495108b8463b99a75074f3f612553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the trace of D times the quadratic form of B and A.  <a href="namespacestan_1_1math_a8c2495108b8463b99a75074f3f612553.html#a8c2495108b8463b99a75074f3f612553">More...</a><br /></td></tr>
<tr class="separator:a8c2495108b8463b99a75074f3f612553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa880d0c51c43efe2deeae94c19f25662"><td class="memTemplParams" colspan="2">template&lt;typename EigMatD , typename EigMatA , typename EigMatB , require_all_eigen_vt&lt; std::is_arithmetic, EigMatD, EigMatA, EigMatB &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa880d0c51c43efe2deeae94c19f25662"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa880d0c51c43efe2deeae94c19f25662.html#aa880d0c51c43efe2deeae94c19f25662">trace_gen_quad_form</a> (const EigMatD &amp;D, const EigMatA &amp;A, const EigMatB &amp;B)</td></tr>
<tr class="memdesc:aa880d0c51c43efe2deeae94c19f25662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the trace of D times the quadratic form of B and A.  <a href="namespacestan_1_1math_aa880d0c51c43efe2deeae94c19f25662.html#aa880d0c51c43efe2deeae94c19f25662">More...</a><br /></td></tr>
<tr class="separator:aa880d0c51c43efe2deeae94c19f25662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2339c6a3ce39579520430158219c27d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename EigMat2 , typename  = require_all_not_st_var&lt;T, EigMat2&gt;&gt; </td></tr>
<tr class="memitem:af2339c6a3ce39579520430158219c27d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, EigMat2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af2339c6a3ce39579520430158219c27d.html#af2339c6a3ce39579520430158219c27d">trace_inv_quad_form_ldlt</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:af2339c6a3ce39579520430158219c27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the trace of an inverse quadratic form.  <a href="namespacestan_1_1math_af2339c6a3ce39579520430158219c27d.html#af2339c6a3ce39579520430158219c27d">More...</a><br /></td></tr>
<tr class="separator:af2339c6a3ce39579520430158219c27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de09fb2edcd6868d828a288e06b3645"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_eigen_vt&lt; std::is_arithmetic, EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0de09fb2edcd6868d828a288e06b3645"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, EigMat2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0de09fb2edcd6868d828a288e06b3645.html#a0de09fb2edcd6868d828a288e06b3645">trace_quad_form</a> (const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:a0de09fb2edcd6868d828a288e06b3645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute trace(B^T A B).  <a href="namespacestan_1_1math_a0de09fb2edcd6868d828a288e06b3645.html#a0de09fb2edcd6868d828a288e06b3645">More...</a><br /></td></tr>
<tr class="separator:a0de09fb2edcd6868d828a288e06b3645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b43cedefbca1e3f4c7d9b317de22e6"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad4b43cedefbca1e3f4c7d9b317de22e6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad4b43cedefbca1e3f4c7d9b317de22e6.html#ad4b43cedefbca1e3f4c7d9b317de22e6">transpose</a> (const T &amp;m)</td></tr>
<tr class="memdesc:ad4b43cedefbca1e3f4c7d9b317de22e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a matrix.  <a href="namespacestan_1_1math_ad4b43cedefbca1e3f4c7d9b317de22e6.html#ad4b43cedefbca1e3f4c7d9b317de22e6">More...</a><br /></td></tr>
<tr class="separator:ad4b43cedefbca1e3f4c7d9b317de22e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506d4de701530a593f41c4b426578546"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a506d4de701530a593f41c4b426578546"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a506d4de701530a593f41c4b426578546.html#a506d4de701530a593f41c4b426578546">trigamma_impl</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a506d4de701530a593f41c4b426578546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the trigamma function applied to the argument.  <a href="namespacestan_1_1math_a506d4de701530a593f41c4b426578546.html#a506d4de701530a593f41c4b426578546">More...</a><br /></td></tr>
<tr class="separator:a506d4de701530a593f41c4b426578546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab9fae0321be4202e5593fdf1ee9ff3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6ab9fae0321be4202e5593fdf1ee9ff3.html#a6ab9fae0321be4202e5593fdf1ee9ff3">trigamma</a> (double u)</td></tr>
<tr class="memdesc:a6ab9fae0321be4202e5593fdf1ee9ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the second derivative of the log Gamma function evaluated at the specified argument.  <a href="namespacestan_1_1math_a6ab9fae0321be4202e5593fdf1ee9ff3.html#a6ab9fae0321be4202e5593fdf1ee9ff3">More...</a><br /></td></tr>
<tr class="separator:a6ab9fae0321be4202e5593fdf1ee9ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97eaa7c973b3685e8f30304092df693"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af97eaa7c973b3685e8f30304092df693.html#af97eaa7c973b3685e8f30304092df693">trigamma</a> (int u)</td></tr>
<tr class="memdesc:af97eaa7c973b3685e8f30304092df693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the second derivative of the log Gamma function evaluated at the specified argument.  <a href="namespacestan_1_1math_af97eaa7c973b3685e8f30304092df693.html#af97eaa7c973b3685e8f30304092df693">More...</a><br /></td></tr>
<tr class="separator:af97eaa7c973b3685e8f30304092df693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ca5b852814bbf7daa900d9111536c5"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad9ca5b852814bbf7daa900d9111536c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad9ca5b852814bbf7daa900d9111536c5.html#ad9ca5b852814bbf7daa900d9111536c5">trigamma</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ad9ca5b852814bbf7daa900d9111536c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a3cf833bfffb0fb87dfc1d1ec81a20122.html#a3cf833bfffb0fb87dfc1d1ec81a20122" title="Return the value of the trigamma function at the specified argument (i.e., the second derivative of t...">trigamma()</a></code> to specified argument container.  <a href="namespacestan_1_1math_ad9ca5b852814bbf7daa900d9111536c5.html#ad9ca5b852814bbf7daa900d9111536c5">More...</a><br /></td></tr>
<tr class="separator:ad9ca5b852814bbf7daa900d9111536c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db32a1233cdda92afd65fc35e643440"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9db32a1233cdda92afd65fc35e643440"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9db32a1233cdda92afd65fc35e643440.html#a9db32a1233cdda92afd65fc35e643440">trunc</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a9db32a1233cdda92afd65fc35e643440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a79abc1d4f747b3c26c07b2b1e4871603.html#a79abc1d4f747b3c26c07b2b1e4871603" title="Return the nearest integral value that is not larger in magnitude than the specified argument.">trunc()</a></code> to specified argument container.  <a href="namespacestan_1_1math_a9db32a1233cdda92afd65fc35e643440.html#a9db32a1233cdda92afd65fc35e643440">More...</a><br /></td></tr>
<tr class="separator:a9db32a1233cdda92afd65fc35e643440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666f5bf87f93b1af9a38ec74db82a306"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_all_stan_scalar_t&lt; T, U &gt; *  = nullptr, require_all_not_st_var&lt; T, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a666f5bf87f93b1af9a38ec74db82a306"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a666f5bf87f93b1af9a38ec74db82a306.html#a666f5bf87f93b1af9a38ec74db82a306">ub_constrain</a> (const T &amp;x, const U &amp;ub)</td></tr>
<tr class="memdesc:a666f5bf87f93b1af9a38ec74db82a306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper-bounded value for the specified unconstrained matrix and upper bound.  <a href="namespacestan_1_1math_a666f5bf87f93b1af9a38ec74db82a306.html#a666f5bf87f93b1af9a38ec74db82a306">More...</a><br /></td></tr>
<tr class="separator:a666f5bf87f93b1af9a38ec74db82a306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3afb2c61308f0558ff0d53d97de3a2a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_all_stan_scalar_t&lt; T, U &gt; *  = nullptr, require_all_not_st_var&lt; T, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac3afb2c61308f0558ff0d53d97de3a2a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac3afb2c61308f0558ff0d53d97de3a2a.html#ac3afb2c61308f0558ff0d53d97de3a2a">ub_constrain</a> (const T &amp;x, const U &amp;ub, std::decay_t&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, U &gt;&gt; &amp;lp)</td></tr>
<tr class="memdesc:ac3afb2c61308f0558ff0d53d97de3a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper-bounded value for the specified unconstrained scalar and upper bound and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <a href="namespacestan_1_1math_ac3afb2c61308f0558ff0d53d97de3a2a.html#ac3afb2c61308f0558ff0d53d97de3a2a">More...</a><br /></td></tr>
<tr class="separator:ac3afb2c61308f0558ff0d53d97de3a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2303e293a67f40dc322920d6dec977"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_eigen_t&lt; T &gt; *  = nullptr, require_stan_scalar_t&lt; U &gt; *  = nullptr, require_all_not_st_var&lt; T, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1c2303e293a67f40dc322920d6dec977"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c2303e293a67f40dc322920d6dec977.html#a1c2303e293a67f40dc322920d6dec977">ub_constrain</a> (const T &amp;x, const U &amp;ub)</td></tr>
<tr class="memdesc:a1c2303e293a67f40dc322920d6dec977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>ub_constrain</code> to apply a scalar upper bound elementwise to each input.  <a href="namespacestan_1_1math_a1c2303e293a67f40dc322920d6dec977.html#a1c2303e293a67f40dc322920d6dec977">More...</a><br /></td></tr>
<tr class="separator:a1c2303e293a67f40dc322920d6dec977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb44f5c854d7863ed179efbe9334450d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_eigen_t&lt; T &gt; *  = nullptr, require_stan_scalar_t&lt; U &gt; *  = nullptr, require_all_not_st_var&lt; T, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afb44f5c854d7863ed179efbe9334450d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afb44f5c854d7863ed179efbe9334450d.html#afb44f5c854d7863ed179efbe9334450d">ub_constrain</a> (const T &amp;x, const U &amp;ub, std::decay_t&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, U &gt;&gt; &amp;lp)</td></tr>
<tr class="memdesc:afb44f5c854d7863ed179efbe9334450d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>ub_constrain</code> to apply a scalar upper bound elementwise to each input.  <a href="namespacestan_1_1math_afb44f5c854d7863ed179efbe9334450d.html#afb44f5c854d7863ed179efbe9334450d">More...</a><br /></td></tr>
<tr class="separator:afb44f5c854d7863ed179efbe9334450d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ac7e19032e4502a5478be859881dbb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_not_std_vector_t&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af7ac7e19032e4502a5478be859881dbb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af7ac7e19032e4502a5478be859881dbb.html#af7ac7e19032e4502a5478be859881dbb">ub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const U &amp;ub)</td></tr>
<tr class="memdesc:af7ac7e19032e4502a5478be859881dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>ub_constrain</code> to apply a scalar upper bound elementwise to each input element.  <a href="namespacestan_1_1math_af7ac7e19032e4502a5478be859881dbb.html#af7ac7e19032e4502a5478be859881dbb">More...</a><br /></td></tr>
<tr class="separator:af7ac7e19032e4502a5478be859881dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e60eeb19caa5c6072ca5dff1adf2c74"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_not_std_vector_t&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9e60eeb19caa5c6072ca5dff1adf2c74"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9e60eeb19caa5c6072ca5dff1adf2c74.html#a9e60eeb19caa5c6072ca5dff1adf2c74">ub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:a9e60eeb19caa5c6072ca5dff1adf2c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>ub_constrain</code> to apply a scalar upper bound elementwise to each input element.  <a href="namespacestan_1_1math_a9e60eeb19caa5c6072ca5dff1adf2c74.html#a9e60eeb19caa5c6072ca5dff1adf2c74">More...</a><br /></td></tr>
<tr class="separator:a9e60eeb19caa5c6072ca5dff1adf2c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae474e7fa4f18fe7384f24e206640aa31"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae474e7fa4f18fe7384f24e206640aa31"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae474e7fa4f18fe7384f24e206640aa31.html#ae474e7fa4f18fe7384f24e206640aa31">ub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; U &gt; &amp;ub)</td></tr>
<tr class="memdesc:ae474e7fa4f18fe7384f24e206640aa31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>ub_constrain</code> to apply a container of upper bounds elementwise to each input element.  <a href="namespacestan_1_1math_ae474e7fa4f18fe7384f24e206640aa31.html#ae474e7fa4f18fe7384f24e206640aa31">More...</a><br /></td></tr>
<tr class="separator:ae474e7fa4f18fe7384f24e206640aa31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf661ccd6745adbac3940b0faee75208"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:acf661ccd6745adbac3940b0faee75208"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acf661ccd6745adbac3940b0faee75208.html#acf661ccd6745adbac3940b0faee75208">ub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; U &gt; &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:acf661ccd6745adbac3940b0faee75208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>ub_constrain</code> to apply a container of upper bounds elementwise to each input element.  <a href="namespacestan_1_1math_acf661ccd6745adbac3940b0faee75208.html#acf661ccd6745adbac3940b0faee75208">More...</a><br /></td></tr>
<tr class="separator:acf661ccd6745adbac3940b0faee75208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899ee13b8e9448f30833fe4d23849d52"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , typename U &gt; </td></tr>
<tr class="memitem:a899ee13b8e9448f30833fe4d23849d52"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a899ee13b8e9448f30833fe4d23849d52.html#a899ee13b8e9448f30833fe4d23849d52">ub_constrain</a> (const T &amp;x, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:a899ee13b8e9448f30833fe4d23849d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>ub_constrain</code> to apply a container of upper bounds elementwise to each input element.  <a href="namespacestan_1_1math_a899ee13b8e9448f30833fe4d23849d52.html#a899ee13b8e9448f30833fe4d23849d52">More...</a><br /></td></tr>
<tr class="separator:a899ee13b8e9448f30833fe4d23849d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd887af855dafd1c0c1ee5155fbbe45"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_not_std_vector_t&lt; T &gt; *  = nullptr, require_stan_scalar_t&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8dd887af855dafd1c0c1ee5155fbbe45"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8dd887af855dafd1c0c1ee5155fbbe45.html#a8dd887af855dafd1c0c1ee5155fbbe45">ub_free</a> (T &amp;&amp;y, U &amp;&amp;ub)</td></tr>
<tr class="memdesc:a8dd887af855dafd1c0c1ee5155fbbe45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free scalar that corresponds to the specified upper-bounded value with respect to the specified upper bound.  <a href="namespacestan_1_1math_a8dd887af855dafd1c0c1ee5155fbbe45.html#a8dd887af855dafd1c0c1ee5155fbbe45">More...</a><br /></td></tr>
<tr class="separator:a8dd887af855dafd1c0c1ee5155fbbe45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c1eaf483574499f7817d12b654b90a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_all_eigen_t&lt; T, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac0c1eaf483574499f7817d12b654b90a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac0c1eaf483574499f7817d12b654b90a.html#ac0c1eaf483574499f7817d12b654b90a">ub_free</a> (T &amp;&amp;y, U &amp;&amp;ub)</td></tr>
<tr class="memdesc:ac0c1eaf483574499f7817d12b654b90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free matrix that corresponds to the specified upper-bounded matrix with respect to the specified upper bound.  <a href="namespacestan_1_1math_ac0c1eaf483574499f7817d12b654b90a.html#ac0c1eaf483574499f7817d12b654b90a">More...</a><br /></td></tr>
<tr class="separator:ac0c1eaf483574499f7817d12b654b90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5352791751a23470cee51da867b2914a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_not_std_vector_t&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5352791751a23470cee51da867b2914a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5352791751a23470cee51da867b2914a.html#a5352791751a23470cee51da867b2914a">ub_free</a> (const std::vector&lt; T &gt; y, const U &amp;ub)</td></tr>
<tr class="memdesc:a5352791751a23470cee51da867b2914a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free variable that corresponds to the specified upper-bounded variable with respect to the specified upper bound.  <a href="namespacestan_1_1math_a5352791751a23470cee51da867b2914a.html#a5352791751a23470cee51da867b2914a">More...</a><br /></td></tr>
<tr class="separator:a5352791751a23470cee51da867b2914a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9485fee45feb064415cb66467891d2d8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a9485fee45feb064415cb66467891d2d8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9485fee45feb064415cb66467891d2d8.html#a9485fee45feb064415cb66467891d2d8">ub_free</a> (const std::vector&lt; T &gt; y, const std::vector&lt; U &gt; &amp;ub)</td></tr>
<tr class="memdesc:a9485fee45feb064415cb66467891d2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free variable that corresponds to the specified upper-bounded variable with respect to the specified upper bound.  <a href="namespacestan_1_1math_a9485fee45feb064415cb66467891d2d8.html#a9485fee45feb064415cb66467891d2d8">More...</a><br /></td></tr>
<tr class="separator:a9485fee45feb064415cb66467891d2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f247efaab4142c9498384d4363c80ab"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4f247efaab4142c9498384d4363c80ab.html#a4f247efaab4142c9498384d4363c80ab">uniform_simplex</a> (int K)</td></tr>
<tr class="memdesc:a4f247efaab4142c9498384d4363c80ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a uniform simplex of size K.  <a href="namespacestan_1_1math_a4f247efaab4142c9498384d4363c80ab.html#a4f247efaab4142c9498384d4363c80ab">More...</a><br /></td></tr>
<tr class="separator:a4f247efaab4142c9498384d4363c80ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9d2f8c4a6482de7f5dbfc5ffbfd866"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_col_vector_t&lt; T &gt; *  = nullptr, require_not_vt_autodiff&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aca9d2f8c4a6482de7f5dbfc5ffbfd866"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aca9d2f8c4a6482de7f5dbfc5ffbfd866.html#aca9d2f8c4a6482de7f5dbfc5ffbfd866">unit_vector_constrain</a> (const T &amp;y)</td></tr>
<tr class="memdesc:aca9d2f8c4a6482de7f5dbfc5ffbfd866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the free vector y.  <a href="namespacestan_1_1math_aca9d2f8c4a6482de7f5dbfc5ffbfd866.html#aca9d2f8c4a6482de7f5dbfc5ffbfd866">More...</a><br /></td></tr>
<tr class="separator:aca9d2f8c4a6482de7f5dbfc5ffbfd866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce578acc7d220eaecc0dab177f1b18f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_eigen_col_vector_t&lt; T1 &gt; *  = nullptr, require_all_not_vt_autodiff&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0ce578acc7d220eaecc0dab177f1b18f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0ce578acc7d220eaecc0dab177f1b18f.html#a0ce578acc7d220eaecc0dab177f1b18f">unit_vector_constrain</a> (const T1 &amp;y, T2 &amp;lp)</td></tr>
<tr class="memdesc:a0ce578acc7d220eaecc0dab177f1b18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the free vector y.  <a href="namespacestan_1_1math_a0ce578acc7d220eaecc0dab177f1b18f.html#a0ce578acc7d220eaecc0dab177f1b18f">More...</a><br /></td></tr>
<tr class="separator:a0ce578acc7d220eaecc0dab177f1b18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc19ec92cfbdaaa96ee9f2921347ad3"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , require_not_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afdc19ec92cfbdaaa96ee9f2921347ad3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afdc19ec92cfbdaaa96ee9f2921347ad3.html#afdc19ec92cfbdaaa96ee9f2921347ad3">unit_vector_constrain</a> (const T &amp;y, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:afdc19ec92cfbdaaa96ee9f2921347ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the free vector y.  <a href="namespacestan_1_1math_afdc19ec92cfbdaaa96ee9f2921347ad3.html#afdc19ec92cfbdaaa96ee9f2921347ad3">More...</a><br /></td></tr>
<tr class="separator:afdc19ec92cfbdaaa96ee9f2921347ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69fba3e6524e671b4db41ba42769689"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_eigen_col_vector_t&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa69fba3e6524e671b4db41ba42769689"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa69fba3e6524e671b4db41ba42769689.html#aa69fba3e6524e671b4db41ba42769689">unit_vector_free</a> (EigVec &amp;&amp;x)</td></tr>
<tr class="memdesc:aa69fba3e6524e671b4db41ba42769689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation of a unit length vector to a "free" vector However, we are just fixing the unidentified radius to 1.  <a href="namespacestan_1_1math_aa69fba3e6524e671b4db41ba42769689.html#aa69fba3e6524e671b4db41ba42769689">More...</a><br /></td></tr>
<tr class="separator:aa69fba3e6524e671b4db41ba42769689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ef9f1e782bc7f7a0f2f91e806b338b"><td class="memTemplParams" colspan="2">template&lt;typename T , require_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab8ef9f1e782bc7f7a0f2f91e806b338b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab8ef9f1e782bc7f7a0f2f91e806b338b.html#ab8ef9f1e782bc7f7a0f2f91e806b338b">unit_vector_free</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ab8ef9f1e782bc7f7a0f2f91e806b338b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_aa69fba3e6524e671b4db41ba42769689.html#aa69fba3e6524e671b4db41ba42769689" title="Transformation of a unit length vector to a &quot;free&quot; vector However, we are just fixing the unidentifie...">unit_vector_free()</a></code> to untransform each <a class="el" href="namespace_eigen.html">Eigen</a> vector in a standard vector.  <a href="namespacestan_1_1math_ab8ef9f1e782bc7f7a0f2f91e806b338b.html#ab8ef9f1e782bc7f7a0f2f91e806b338b">More...</a><br /></td></tr>
<tr class="separator:ab8ef9f1e782bc7f7a0f2f91e806b338b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e13f5270b98195282fb4c73a24ba92"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae4e13f5270b98195282fb4c73a24ba92.html#ae4e13f5270b98195282fb4c73a24ba92">unitspaced_array</a> (int low, int high)</td></tr>
<tr class="memdesc:ae4e13f5270b98195282fb4c73a24ba92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array of integers in an ordered sequence.  <a href="namespacestan_1_1math_ae4e13f5270b98195282fb4c73a24ba92.html#ae4e13f5270b98195282fb4c73a24ba92">More...</a><br /></td></tr>
<tr class="separator:ae4e13f5270b98195282fb4c73a24ba92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63910a0f81de7c9bcd54054e2dfd2ed7"><td class="memTemplParams" colspan="2">template&lt;typename T , require_st_arithmetic&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a63910a0f81de7c9bcd54054e2dfd2ed7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a63910a0f81de7c9bcd54054e2dfd2ed7.html#a63910a0f81de7c9bcd54054e2dfd2ed7">value_of</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:a63910a0f81de7c9bcd54054e2dfd2ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inputs that are arithmetic types or containers of airthmetric types are returned from value_of unchanged.  <a href="namespacestan_1_1math_a63910a0f81de7c9bcd54054e2dfd2ed7.html#a63910a0f81de7c9bcd54054e2dfd2ed7">More...</a><br /></td></tr>
<tr class="separator:a63910a0f81de7c9bcd54054e2dfd2ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdd2a5181cf24e1cc788a5e86e27316"><td class="memTemplParams" colspan="2">template&lt;typename T , require_complex_t&lt; T &gt; *  = nullptr, require_t&lt; std::is_arithmetic&lt; typename std::decay_t&lt; T &gt;::value_type &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4fdd2a5181cf24e1cc788a5e86e27316"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4fdd2a5181cf24e1cc788a5e86e27316.html#a4fdd2a5181cf24e1cc788a5e86e27316">value_of</a> (T &amp;&amp;x)</td></tr>
<tr class="separator:a4fdd2a5181cf24e1cc788a5e86e27316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5732f20a97c47531bb0f29cbf1612367"><td class="memTemplParams" colspan="2">template&lt;typename T , require_std_vector_t&lt; T &gt; *  = nullptr, require_not_st_arithmetic&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5732f20a97c47531bb0f29cbf1612367"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5732f20a97c47531bb0f29cbf1612367.html#a5732f20a97c47531bb0f29cbf1612367">value_of</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a5732f20a97c47531bb0f29cbf1612367"><td class="mdescLeft">&#160;</td><td class="mdescRight">For std::vectors of non-arithmetic types, return a std::vector composed of value_of applied to each element.  <a href="namespacestan_1_1math_a5732f20a97c47531bb0f29cbf1612367.html#a5732f20a97c47531bb0f29cbf1612367">More...</a><br /></td></tr>
<tr class="separator:a5732f20a97c47531bb0f29cbf1612367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7919e1a4f59deff48ddc9c19e5d9c5"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_not_st_arithmetic&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adc7919e1a4f59deff48ddc9c19e5d9c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adc7919e1a4f59deff48ddc9c19e5d9c5.html#adc7919e1a4f59deff48ddc9c19e5d9c5">value_of</a> (EigMat &amp;&amp;M)</td></tr>
<tr class="memdesc:adc7919e1a4f59deff48ddc9c19e5d9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <a class="el" href="namespace_eigen.html">Eigen</a> matrices and expressions of non-arithmetic types, return an expression that represents the Eigen::Matrix resulting from applying value_of elementwise.  <a href="namespacestan_1_1math_adc7919e1a4f59deff48ddc9c19e5d9c5.html#adc7919e1a4f59deff48ddc9c19e5d9c5">More...</a><br /></td></tr>
<tr class="separator:adc7919e1a4f59deff48ddc9c19e5d9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5b8cb78e6305d3e985f7c44f752785"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_stan_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aeb5b8cb78e6305d3e985f7c44f752785"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeb5b8cb78e6305d3e985f7c44f752785.html#aeb5b8cb78e6305d3e985f7c44f752785">value_of_rec</a> (const T x)</td></tr>
<tr class="memdesc:aeb5b8cb78e6305d3e985f7c44f752785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified scalar argument converted to a double value.  <a href="namespacestan_1_1math_aeb5b8cb78e6305d3e985f7c44f752785.html#aeb5b8cb78e6305d3e985f7c44f752785">More...</a><br /></td></tr>
<tr class="separator:aeb5b8cb78e6305d3e985f7c44f752785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0548ef9deaae6edf2187b885ba545b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afe0548ef9deaae6edf2187b885ba545b.html#afe0548ef9deaae6edf2187b885ba545b">value_of_rec</a> (double x)</td></tr>
<tr class="memdesc:afe0548ef9deaae6edf2187b885ba545b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified argument.  <a href="namespacestan_1_1math_afe0548ef9deaae6edf2187b885ba545b.html#afe0548ef9deaae6edf2187b885ba545b">More...</a><br /></td></tr>
<tr class="separator:afe0548ef9deaae6edf2187b885ba545b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963454be52a1f8cb4b23bb7712fcf6d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a963454be52a1f8cb4b23bb7712fcf6d1"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a963454be52a1f8cb4b23bb7712fcf6d1.html#a963454be52a1f8cb4b23bb7712fcf6d1">value_of_rec</a> (const std::complex&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a963454be52a1f8cb4b23bb7712fcf6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively apply value-of to the parts of the argument.  <a href="namespacestan_1_1math_a963454be52a1f8cb4b23bb7712fcf6d1.html#a963454be52a1f8cb4b23bb7712fcf6d1">More...</a><br /></td></tr>
<tr class="separator:a963454be52a1f8cb4b23bb7712fcf6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1379363fb490fa1d5285c4aadd95a795"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_same_t&lt; double, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1379363fb490fa1d5285c4aadd95a795"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1379363fb490fa1d5285c4aadd95a795.html#a1379363fb490fa1d5285c4aadd95a795">value_of_rec</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a1379363fb490fa1d5285c4aadd95a795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a std::vector of type T to a std::vector of doubles.  <a href="namespacestan_1_1math_a1379363fb490fa1d5285c4aadd95a795.html#a1379363fb490fa1d5285c4aadd95a795">More...</a><br /></td></tr>
<tr class="separator:a1379363fb490fa1d5285c4aadd95a795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0881827f62ff24b1d822e0654133dc5"><td class="memTemplParams" colspan="2">template&lt;typename T , require_std_vector_t&lt; T &gt; *  = nullptr, require_vt_same&lt; double, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac0881827f62ff24b1d822e0654133dc5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac0881827f62ff24b1d822e0654133dc5.html#ac0881827f62ff24b1d822e0654133dc5">value_of_rec</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:ac0881827f62ff24b1d822e0654133dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified argument.  <a href="namespacestan_1_1math_ac0881827f62ff24b1d822e0654133dc5.html#ac0881827f62ff24b1d822e0654133dc5">More...</a><br /></td></tr>
<tr class="separator:ac0881827f62ff24b1d822e0654133dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45e9f7eeb8977c34f5fe541250b8ebb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_not_st_same&lt;T, double&gt;, typename  = require_eigen_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ae45e9f7eeb8977c34f5fe541250b8ebb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae45e9f7eeb8977c34f5fe541250b8ebb.html#ae45e9f7eeb8977c34f5fe541250b8ebb">value_of_rec</a> (T &amp;&amp;M)</td></tr>
<tr class="memdesc:ae45e9f7eeb8977c34f5fe541250b8ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a matrix of type T to a matrix of doubles.  <a href="namespacestan_1_1math_ae45e9f7eeb8977c34f5fe541250b8ebb.html#ae45e9f7eeb8977c34f5fe541250b8ebb">More...</a><br /></td></tr>
<tr class="separator:ae45e9f7eeb8977c34f5fe541250b8ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8876e4ea89731704f84654e6cd23137a"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_not_vt_var&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8876e4ea89731704f84654e6cd23137a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8876e4ea89731704f84654e6cd23137a.html#a8876e4ea89731704f84654e6cd23137a">variance</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a8876e4ea89731704f84654e6cd23137a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample variance (divide by length - 1) of the coefficients in the specified matrix.  <a href="namespacestan_1_1math_a8876e4ea89731704f84654e6cd23137a.html#a8876e4ea89731704f84654e6cd23137a">More...</a><br /></td></tr>
<tr class="separator:a8876e4ea89731704f84654e6cd23137a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cb5f1a7bf7249f92b034654c8a06fe"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , require_std_vector_t&lt; StdVec &gt; *  = nullptr, require_not_vt_var&lt; StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af6cb5f1a7bf7249f92b034654c8a06fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; StdVec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af6cb5f1a7bf7249f92b034654c8a06fe.html#af6cb5f1a7bf7249f92b034654c8a06fe">variance</a> (const StdVec &amp;v)</td></tr>
<tr class="memdesc:af6cb5f1a7bf7249f92b034654c8a06fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample variance (divide by length - 1) of the coefficients in the specified standard vector.  <a href="namespacestan_1_1math_af6cb5f1a7bf7249f92b034654c8a06fe.html#af6cb5f1a7bf7249f92b034654c8a06fe">More...</a><br /></td></tr>
<tr class="separator:af6cb5f1a7bf7249f92b034654c8a06fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d052d8144d9d7578f3260a701c3e108"><td class="memTemplParams" colspan="2">template&lt;typename Vec , typename... Args&gt; </td></tr>
<tr class="memitem:a8d052d8144d9d7578f3260a701c3e108"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8d052d8144d9d7578f3260a701c3e108.html#a8d052d8144d9d7578f3260a701c3e108">vec_concat</a> (const Vec &amp;v1, const Args &amp;... args)</td></tr>
<tr class="memdesc:a8d052d8144d9d7578f3260a701c3e108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the event stack from a vector of events and other arguments.  <a href="namespacestan_1_1math_a8d052d8144d9d7578f3260a701c3e108.html#a8d052d8144d9d7578f3260a701c3e108">More...</a><br /></td></tr>
<tr class="separator:a8d052d8144d9d7578f3260a701c3e108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf7199dc24a85273fa7c116be78d113"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9cf7199dc24a85273fa7c116be78d113.html#a9cf7199dc24a85273fa7c116be78d113">zeros_array</a> (int K)</td></tr>
<tr class="memdesc:a9cf7199dc24a85273fa7c116be78d113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array of zeros.  <a href="namespacestan_1_1math_a9cf7199dc24a85273fa7c116be78d113.html#a9cf7199dc24a85273fa7c116be78d113">More...</a><br /></td></tr>
<tr class="separator:a9cf7199dc24a85273fa7c116be78d113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20af970dcb506b54e85b143a128989d4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a20af970dcb506b54e85b143a128989d4.html#a20af970dcb506b54e85b143a128989d4">zeros_int_array</a> (int K)</td></tr>
<tr class="memdesc:a20af970dcb506b54e85b143a128989d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an integer array of zeros.  <a href="namespacestan_1_1math_a20af970dcb506b54e85b143a128989d4.html#a20af970dcb506b54e85b143a128989d4">More...</a><br /></td></tr>
<tr class="separator:a20af970dcb506b54e85b143a128989d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d994d53428a7b36ae932bd97e3274e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a44d994d53428a7b36ae932bd97e3274e.html#a44d994d53428a7b36ae932bd97e3274e">zeros_row_vector</a> (int K)</td></tr>
<tr class="memdesc:a44d994d53428a7b36ae932bd97e3274e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row vector of zeros.  <a href="namespacestan_1_1math_a44d994d53428a7b36ae932bd97e3274e.html#a44d994d53428a7b36ae932bd97e3274e">More...</a><br /></td></tr>
<tr class="separator:a44d994d53428a7b36ae932bd97e3274e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde7be965b8b219a0d48c14ecee847ea"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abde7be965b8b219a0d48c14ecee847ea.html#abde7be965b8b219a0d48c14ecee847ea">zeros_vector</a> (int K)</td></tr>
<tr class="memdesc:abde7be965b8b219a0d48c14ecee847ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of zeros.  <a href="namespacestan_1_1math_abde7be965b8b219a0d48c14ecee847ea.html#abde7be965b8b219a0d48c14ecee847ea">More...</a><br /></td></tr>
<tr class="separator:abde7be965b8b219a0d48c14ecee847ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd7c862016910e0217ad1893736bcce"><td class="memTemplParams" colspan="2">template&lt;class F , class Tuple &gt; </td></tr>
<tr class="memitem:adbd7c862016910e0217ad1893736bcce"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adbd7c862016910e0217ad1893736bcce.html#adbd7c862016910e0217ad1893736bcce">apply</a> (F &amp;&amp;f, Tuple &amp;&amp;t)</td></tr>
<tr class="separator:adbd7c862016910e0217ad1893736bcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd139a5cfbed5b58bb028c6df89a712"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename F , require_all_stan_scalar_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adcd139a5cfbed5b58bb028c6df89a712"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adcd139a5cfbed5b58bb028c6df89a712.html#adcd139a5cfbed5b58bb028c6df89a712">apply_scalar_binary</a> (const T1 &amp;x, const T2 &amp;y, const F &amp;f)</td></tr>
<tr class="memdesc:adcd139a5cfbed5b58bb028c6df89a712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template function for vectorization of binary scalar functions defined by applying a functor to a combination of scalars, containers of matching sizes, or a combination of a scalar and a container.  <a href="namespacestan_1_1math_adcd139a5cfbed5b58bb028c6df89a712.html#adcd139a5cfbed5b58bb028c6df89a712">More...</a><br /></td></tr>
<tr class="separator:adcd139a5cfbed5b58bb028c6df89a712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135de1c7b96ba79ba9fa8f89cfab0170"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename F , require_eigen_vector_vt&lt; is_stan_scalar, T1 &gt; *  = nullptr, require_std_vector_vt&lt; std::is_integral, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a135de1c7b96ba79ba9fa8f89cfab0170"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a135de1c7b96ba79ba9fa8f89cfab0170.html#a135de1c7b96ba79ba9fa8f89cfab0170">apply_scalar_binary</a> (const T1 &amp;x, const T2 &amp;y, const F &amp;f)</td></tr>
<tr class="memdesc:a135de1c7b96ba79ba9fa8f89cfab0170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation for use with one <a class="el" href="namespace_eigen.html">Eigen</a> vector (row or column) and a one-dimensional std::vector of integer types.  <a href="namespacestan_1_1math_a135de1c7b96ba79ba9fa8f89cfab0170.html#a135de1c7b96ba79ba9fa8f89cfab0170">More...</a><br /></td></tr>
<tr class="separator:a135de1c7b96ba79ba9fa8f89cfab0170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9d6b14a483bfc0a6ce5f47c9e5ddac"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename F , require_eigen_matrix_dynamic_vt&lt; is_stan_scalar, T1 &gt; *  = nullptr, require_std_vector_vt&lt; is_std_vector, T2 &gt; *  = nullptr, require_std_vector_st&lt; std::is_integral, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abb9d6b14a483bfc0a6ce5f47c9e5ddac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abb9d6b14a483bfc0a6ce5f47c9e5ddac.html#abb9d6b14a483bfc0a6ce5f47c9e5ddac">apply_scalar_binary</a> (const T1 &amp;x, const T2 &amp;y, const F &amp;f)</td></tr>
<tr class="memdesc:abb9d6b14a483bfc0a6ce5f47c9e5ddac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation for use with one <a class="el" href="namespace_eigen.html">Eigen</a> matrix and a two-dimensional std::vector of integer types.  <a href="namespacestan_1_1math_abb9d6b14a483bfc0a6ce5f47c9e5ddac.html#abb9d6b14a483bfc0a6ce5f47c9e5ddac">More...</a><br /></td></tr>
<tr class="separator:abb9d6b14a483bfc0a6ce5f47c9e5ddac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd8731d906268bf1b3c160a45fca29d"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:adbd8731d906268bf1b3c160a45fca29d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adbd8731d906268bf1b3c160a45fca29d.html#adbd8731d906268bf1b3c160a45fca29d">finite_diff_gradient</a> (const F &amp;f, const Eigen::VectorXd &amp;x, double &amp;fx, Eigen::VectorXd &amp;grad_fx, double epsilon=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-03)</td></tr>
<tr class="memdesc:adbd8731d906268bf1b3c160a45fca29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value and the gradient of the specified function at the specified argument using finite difference.  <a href="namespacestan_1_1math_adbd8731d906268bf1b3c160a45fca29d.html#adbd8731d906268bf1b3c160a45fca29d">More...</a><br /></td></tr>
<tr class="separator:adbd8731d906268bf1b3c160a45fca29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae382499655ebe56e54c941372310f650"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ae382499655ebe56e54c941372310f650"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae382499655ebe56e54c941372310f650.html#ae382499655ebe56e54c941372310f650">finite_diff_gradient_auto</a> (const F &amp;f, const Eigen::VectorXd &amp;x, double &amp;fx, Eigen::VectorXd &amp;grad_fx)</td></tr>
<tr class="memdesc:ae382499655ebe56e54c941372310f650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value and the gradient of the specified function at the specified argument using finite difference.  <a href="namespacestan_1_1math_ae382499655ebe56e54c941372310f650.html#ae382499655ebe56e54c941372310f650">More...</a><br /></td></tr>
<tr class="separator:ae382499655ebe56e54c941372310f650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03905527dea9be46cc0eb973ad4b6120"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:a03905527dea9be46cc0eb973ad4b6120"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a03905527dea9be46cc0eb973ad4b6120.html#a03905527dea9be46cc0eb973ad4b6120">for_each</a> (F &amp;&amp;f, T &amp;&amp;t)</td></tr>
<tr class="memdesc:a03905527dea9be46cc0eb973ad4b6120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each element of a tuple.  <a href="namespacestan_1_1math_a03905527dea9be46cc0eb973ad4b6120.html#a03905527dea9be46cc0eb973ad4b6120">More...</a><br /></td></tr>
<tr class="separator:a03905527dea9be46cc0eb973ad4b6120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f4ad90150c1f57a2643ab610e964d3"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af1f4ad90150c1f57a2643ab610e964d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af1f4ad90150c1f57a2643ab610e964d3.html#af1f4ad90150c1f57a2643ab610e964d3">for_each</a> (F &amp;&amp;f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</td></tr>
<tr class="memdesc:af1f4ad90150c1f57a2643ab610e964d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each element of two tuples.  <a href="namespacestan_1_1math_af1f4ad90150c1f57a2643ab610e964d3.html#af1f4ad90150c1f57a2643ab610e964d3">More...</a><br /></td></tr>
<tr class="separator:af1f4ad90150c1f57a2643ab610e964d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f8789fecb763c0565624f92fc762f9"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:af2f8789fecb763c0565624f92fc762f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af2f8789fecb763c0565624f92fc762f9.html#af2f8789fecb763c0565624f92fc762f9">for_each</a> (F &amp;&amp;f, T1 &amp;&amp;t1, T2 &amp;&amp;t2, T3 &amp;&amp;t3)</td></tr>
<tr class="memdesc:af2f8789fecb763c0565624f92fc762f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each element of three tuples.  <a href="namespacestan_1_1math_af2f8789fecb763c0565624f92fc762f9.html#af2f8789fecb763c0565624f92fc762f9">More...</a><br /></td></tr>
<tr class="separator:af2f8789fecb763c0565624f92fc762f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca44e8ac9fda3b011083dfee7a5b10eb"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:aca44e8ac9fda3b011083dfee7a5b10eb"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aca44e8ac9fda3b011083dfee7a5b10eb.html#aca44e8ac9fda3b011083dfee7a5b10eb">integrate</a> (const F &amp;f, double a, double b, double relative_tolerance)</td></tr>
<tr class="memdesc:aca44e8ac9fda3b011083dfee7a5b10eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate a single variable function f from a to b to within a specified relative tolerance.  <a href="namespacestan_1_1math_aca44e8ac9fda3b011083dfee7a5b10eb.html#aca44e8ac9fda3b011083dfee7a5b10eb">More...</a><br /></td></tr>
<tr class="separator:aca44e8ac9fda3b011083dfee7a5b10eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae037a8245e74bd267b93084c11c4ca02"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Args, require_all_not_st_var&lt; Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae037a8245e74bd267b93084c11c4ca02"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae037a8245e74bd267b93084c11c4ca02.html#ae037a8245e74bd267b93084c11c4ca02">integrate_1d_impl</a> (const F &amp;f, double a, double b, double relative_tolerance, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:ae037a8245e74bd267b93084c11c4ca02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integral of the single variable function f from a to b to within a specified relative tolerance.  <a href="namespacestan_1_1math_ae037a8245e74bd267b93084c11c4ca02.html#ae037a8245e74bd267b93084c11c4ca02">More...</a><br /></td></tr>
<tr class="separator:ae037a8245e74bd267b93084c11c4ca02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c617b18457b48f46759cbdb7d9fdd06"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a5c617b18457b48f46759cbdb7d9fdd06"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5c617b18457b48f46759cbdb7d9fdd06.html#a5c617b18457b48f46759cbdb7d9fdd06">integrate_1d</a> (const F &amp;f, double a, double b, const std::vector&lt; double &gt; &amp;theta, const std::vector&lt; double &gt; &amp;x_r, const std::vector&lt; int &gt; &amp;x_i, std::ostream *msgs, const double relative_tolerance=std::sqrt(<a class="el" href="namespacestan_1_1math_a28af31756798a98947ed5351b67fd9c4.html#a28af31756798a98947ed5351b67fd9c4">EPSILON</a>))</td></tr>
<tr class="memdesc:a5c617b18457b48f46759cbdb7d9fdd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integral of the single variable function f from a to b to within a specified relative tolerance.  <a href="namespacestan_1_1math_a5c617b18457b48f46759cbdb7d9fdd06.html#a5c617b18457b48f46759cbdb7d9fdd06">More...</a><br /></td></tr>
<tr class="separator:a5c617b18457b48f46759cbdb7d9fdd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65b85b75b4d404c0c83ee48358b569b"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_param , typename T_t0 , typename T_ts &gt; </td></tr>
<tr class="memitem:aa65b85b75b4d404c0c83ee48358b569b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa65b85b75b4d404c0c83ee48358b569b.html#aa65b85b75b4d404c0c83ee48358b569b">integrate_ode_rk45</a> (const F &amp;f, const std::vector&lt; T_y0 &gt; &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, const std::vector&lt; T_param &gt; &amp;theta, const std::vector&lt; double &gt; &amp;x, const std::vector&lt; int &gt; &amp;x_int, std::ostream *msgs=nullptr, double relative_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-6, double absolute_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-6, int max_num_steps=1e6)</td></tr>
<tr class="separator:aa65b85b75b4d404c0c83ee48358b569b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cecacf8be264f6e7afa96bf8adb2b1"><td class="memTemplParams" colspan="2">template&lt;int call_id, typename F , typename T_shared_param , typename T_job_param , require_eigen_col_vector_t&lt; T_shared_param &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae8cecacf8be264f6e7afa96bf8adb2b1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shared_param, T_job_param &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae8cecacf8be264f6e7afa96bf8adb2b1.html#ae8cecacf8be264f6e7afa96bf8adb2b1">map_rect</a> (const T_shared_param &amp;shared_params, const std::vector&lt; Eigen::Matrix&lt; T_job_param, Eigen::Dynamic, 1 &gt;&gt; &amp;job_params, const std::vector&lt; std::vector&lt; double &gt;&gt; &amp;x_r, const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;x_i, std::ostream *msgs=nullptr)</td></tr>
<tr class="memdesc:ae8cecacf8be264f6e7afa96bf8adb2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map N function evaluations to parameters and data which are in rectangular format.  <a href="namespacestan_1_1math_ae8cecacf8be264f6e7afa96bf8adb2b1.html#ae8cecacf8be264f6e7afa96bf8adb2b1">More...</a><br /></td></tr>
<tr class="separator:ae8cecacf8be264f6e7afa96bf8adb2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e519f155deb6e163a8cc1c6b807fb9f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8e519f155deb6e163a8cc1c6b807fb9f.html#a8e519f155deb6e163a8cc1c6b807fb9f">mpi_map_chunks</a> (std::size_t num_jobs, std::size_t chunk_size=1)</td></tr>
<tr class="memdesc:a8e519f155deb6e163a8cc1c6b807fb9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps jobs of given chunk size to workers and returning a vector of counts.  <a href="namespacestan_1_1math_a8e519f155deb6e163a8cc1c6b807fb9f.html#a8e519f155deb6e163a8cc1c6b807fb9f">More...</a><br /></td></tr>
<tr class="separator:a8e519f155deb6e163a8cc1c6b807fb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32d1b150cc0f0da1f57f213133c8291"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad32d1b150cc0f0da1f57f213133c8291"><td class="memTemplItemLeft" align="right" valign="top">std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad32d1b150cc0f0da1f57f213133c8291.html#ad32d1b150cc0f0da1f57f213133c8291">mpi_broadcast_command</a> ()</td></tr>
<tr class="memdesc:ad32d1b150cc0f0da1f57f213133c8291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts default constructible commands to the cluster.  <a href="namespacestan_1_1math_ad32d1b150cc0f0da1f57f213133c8291.html#ad32d1b150cc0f0da1f57f213133c8291">More...</a><br /></td></tr>
<tr class="separator:ad32d1b150cc0f0da1f57f213133c8291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab783a07b347fdf80f9fda0a5cf3948d6"><td class="memItemLeft" align="right" valign="top">std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab783a07b347fdf80f9fda0a5cf3948d6.html#ab783a07b347fdf80f9fda0a5cf3948d6">mpi_broadcast_command</a> (std::shared_ptr&lt; <a class="el" href="structstan_1_1math_1_1mpi__command.html">mpi_command</a> &gt; &amp;command)</td></tr>
<tr class="memdesc:ab783a07b347fdf80f9fda0a5cf3948d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts a command instance to the listening cluster.  <a href="namespacestan_1_1math_ab783a07b347fdf80f9fda0a5cf3948d6.html#ab783a07b347fdf80f9fda0a5cf3948d6">More...</a><br /></td></tr>
<tr class="separator:ab783a07b347fdf80f9fda0a5cf3948d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f62c11413f3a8664b77dadf76825dc"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... Args, require_eigen_vector_t&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a24f62c11413f3a8664b77dadf76825dc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a24f62c11413f3a8664b77dadf76825dc.html#a24f62c11413f3a8664b77dadf76825dc">ode_ckrk_tol_impl</a> (const char *function_name, const F &amp;f, const T_y0 &amp;y0_arg, T_t0 t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance, double absolute_tolerance, long int max_num_steps, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:a24f62c11413f3a8664b77dadf76825dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_a24f62c11413f3a8664b77dadf76825dc.html#a24f62c11413f3a8664b77dadf76825dc">More...</a><br /></td></tr>
<tr class="separator:a24f62c11413f3a8664b77dadf76825dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9379841c341296c507727372c0c5d043"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... Args, require_eigen_vector_t&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9379841c341296c507727372c0c5d043"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9379841c341296c507727372c0c5d043.html#a9379841c341296c507727372c0c5d043">ode_ckrk_tol</a> (const F &amp;f, const T_y0 &amp;y0_arg, T_t0 t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance, double absolute_tolerance, long int max_num_steps, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:a9379841c341296c507727372c0c5d043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_a9379841c341296c507727372c0c5d043.html#a9379841c341296c507727372c0c5d043">More...</a><br /></td></tr>
<tr class="separator:a9379841c341296c507727372c0c5d043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310e29c660cee8ea82d51b69b23ce8ee"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... Args, require_eigen_vector_t&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a310e29c660cee8ea82d51b69b23ce8ee"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a310e29c660cee8ea82d51b69b23ce8ee.html#a310e29c660cee8ea82d51b69b23ce8ee">ode_ckrk</a> (const F &amp;f, const T_y0 &amp;y0, T_t0 t0, const std::vector&lt; T_ts &gt; &amp;ts, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:a310e29c660cee8ea82d51b69b23ce8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_a310e29c660cee8ea82d51b69b23ce8ee.html#a310e29c660cee8ea82d51b69b23ce8ee">More...</a><br /></td></tr>
<tr class="separator:a310e29c660cee8ea82d51b69b23ce8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad627189a25b587465910b85404aa8134"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... Args, require_eigen_vector_t&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad627189a25b587465910b85404aa8134"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad627189a25b587465910b85404aa8134.html#ad627189a25b587465910b85404aa8134">ode_rk45_tol_impl</a> (const char *function_name, const F &amp;f, const T_y0 &amp;y0_arg, T_t0 t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance, double absolute_tolerance, long int max_num_steps, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:ad627189a25b587465910b85404aa8134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_ad627189a25b587465910b85404aa8134.html#ad627189a25b587465910b85404aa8134">More...</a><br /></td></tr>
<tr class="separator:ad627189a25b587465910b85404aa8134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f1acf2552b6820b3de600031caeada"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... Args, require_eigen_vector_t&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a51f1acf2552b6820b3de600031caeada"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a51f1acf2552b6820b3de600031caeada.html#a51f1acf2552b6820b3de600031caeada">ode_rk45_tol</a> (const F &amp;f, const T_y0 &amp;y0_arg, T_t0 t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance, double absolute_tolerance, long int max_num_steps, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:a51f1acf2552b6820b3de600031caeada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_a51f1acf2552b6820b3de600031caeada.html#a51f1acf2552b6820b3de600031caeada">More...</a><br /></td></tr>
<tr class="separator:a51f1acf2552b6820b3de600031caeada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b02f2ae45f25c61804c04b7fac8de04"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... Args, require_eigen_vector_t&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8b02f2ae45f25c61804c04b7fac8de04"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8b02f2ae45f25c61804c04b7fac8de04.html#a8b02f2ae45f25c61804c04b7fac8de04">ode_rk45</a> (const F &amp;f, const T_y0 &amp;y0, T_t0 t0, const std::vector&lt; T_ts &gt; &amp;ts, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:a8b02f2ae45f25c61804c04b7fac8de04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_a8b02f2ae45f25c61804c04b7fac8de04.html#a8b02f2ae45f25c61804c04b7fac8de04">More...</a><br /></td></tr>
<tr class="separator:a8b02f2ae45f25c61804c04b7fac8de04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab414676ddd1eb0882d6b41e0c2189928"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0_t0 , typename T_t0 , typename T_t , typename... Args, typename  = require_all_arithmetic_t&lt;T_y0_t0, T_t0, T_t, scalar_type_t&lt;Args&gt;...&gt;&gt; </td></tr>
<tr class="memitem:ab414676ddd1eb0882d6b41e0c2189928"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab414676ddd1eb0882d6b41e0c2189928.html#ab414676ddd1eb0882d6b41e0c2189928">ode_store_sensitivities</a> (const F &amp;f, const std::vector&lt; double &gt; &amp;coupled_state, const Eigen::Matrix&lt; T_y0_t0, Eigen::Dynamic, 1 &gt; &amp;y0, T_t0 t0, T_t t, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:ab414676ddd1eb0882d6b41e0c2189928"><td class="mdescLeft">&#160;</td><td class="mdescRight">When all arguments are arithmetic, there are no sensitivities to store, so the function just returns the current coupled_state.  <a href="namespacestan_1_1math_ab414676ddd1eb0882d6b41e0c2189928.html#ab414676ddd1eb0882d6b41e0c2189928">More...</a><br /></td></tr>
<tr class="separator:ab414676ddd1eb0882d6b41e0c2189928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e156d0934e4aee29b8defd07962d9cd"><td class="memTemplParams" colspan="2">template&lt;typename ReduceFunction , typename Vec , typename  = require_vector_like_t&lt;Vec&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:a6e156d0934e4aee29b8defd07962d9cd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6e156d0934e4aee29b8defd07962d9cd.html#a6e156d0934e4aee29b8defd07962d9cd">reduce_sum</a> (Vec &amp;&amp;vmapped, int grainsize, std::ostream *msgs, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6e156d0934e4aee29b8defd07962d9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call an instance of the function <code>ReduceFunction</code> on every element of an input sequence and sum these terms.  <a href="namespacestan_1_1math_a6e156d0934e4aee29b8defd07962d9cd.html#a6e156d0934e4aee29b8defd07962d9cd">More...</a><br /></td></tr>
<tr class="separator:a6e156d0934e4aee29b8defd07962d9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c5098c8dcebb6ff7c232f2ce39a553"><td class="memTemplParams" colspan="2">template&lt;typename ReduceFunction , typename Vec , typename  = require_vector_like_t&lt;Vec&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:a85c5098c8dcebb6ff7c232f2ce39a553"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a85c5098c8dcebb6ff7c232f2ce39a553.html#a85c5098c8dcebb6ff7c232f2ce39a553">reduce_sum_static</a> (Vec &amp;&amp;vmapped, int grainsize, std::ostream *msgs, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a85c5098c8dcebb6ff7c232f2ce39a553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call an instance of the function <code>ReduceFunction</code> on every element of an input sequence and sum these terms.  <a href="namespacestan_1_1math_a85c5098c8dcebb6ff7c232f2ce39a553.html#a85c5098c8dcebb6ff7c232f2ce39a553">More...</a><br /></td></tr>
<tr class="separator:a85c5098c8dcebb6ff7c232f2ce39a553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0af4c158839e8c4c401e0f7e78bb4dc6"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;T_actual&gt;,                                          std::decay_t&lt;T_desired&gt;&gt;::value                             &amp;&amp; !is_eigen&lt;T_desired&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga0af4c158839e8c4c401e0f7e78bb4dc6"><td class="memTemplItemLeft" align="right" valign="top">T_actual &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga0af4c158839e8c4c401e0f7e78bb4dc6.html#ga0af4c158839e8c4c401e0f7e78bb4dc6">forward_as</a> (T_actual &amp;&amp;a)</td></tr>
<tr class="separator:ga0af4c158839e8c4c401e0f7e78bb4dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;              !std::is_same&lt;std::decay&lt;T_actual&gt;, std::decay&lt;T_desired&gt;&gt;::value              &amp;&amp; (!is_eigen&lt;T_desired&gt;::value || !is_eigen&lt;T_actual&gt;::value)&gt;&gt; </td></tr>
<tr class="memitem:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memTemplItemLeft" align="right" valign="top">T_desired&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga6cc77bba018fff06dd1f0f0f2d79e5b9.html#ga6cc77bba018fff06dd1f0f0f2d79e5b9">forward_as</a> (const T_actual &amp;a)</td></tr>
<tr class="separator:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga385d807274aa40985a59c273d49cf9cd"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , require_eigen_t&lt; T_desired &gt; *  = nullptr, std::enable_if_t&lt; std::is_same&lt; value_type_t&lt; T_actual &gt;, value_type_t&lt; T_desired &gt;&gt;::value &amp;&amp;is_eigen&lt; T_desired &gt;::value &amp;&amp;is_eigen&lt; T_actual &gt;::value &amp;&amp;internal::eigen_static_size_match(T_desired::RowsAtCompileTime, std::decay_t&lt; T_actual &gt;::RowsAtCompileTime) &amp;&amp;internal::eigen_static_size_match(T_desired::ColsAtCompileTime, std::decay_t&lt; T_actual &gt;::ColsAtCompileTime)&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga385d807274aa40985a59c273d49cf9cd"><td class="memTemplItemLeft" align="right" valign="top">T_actual &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga385d807274aa40985a59c273d49cf9cd.html#ga385d807274aa40985a59c273d49cf9cd">forward_as</a> (T_actual &amp;&amp;a)</td></tr>
<tr class="separator:ga385d807274aa40985a59c273d49cf9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9105ec386170113bb24f3808c7ba6f7"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , require_all_eigen_t&lt; T_desired, T_actual &gt; *  = nullptr, std::enable_if_t&lt; !std::is_same&lt; value_type_t&lt; T_actual &gt;, value_type_t&lt; T_desired &gt;&gt;::value||!internal::eigen_static_size_match(T_desired::RowsAtCompileTime, std::decay_t&lt; T_actual &gt;::RowsAtCompileTime)||!internal::eigen_static_size_match(T_desired::ColsAtCompileTime, std::decay_t&lt; T_actual &gt;::ColsAtCompileTime)&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae9105ec386170113bb24f3808c7ba6f7"><td class="memTemplItemLeft" align="right" valign="top">T_desired&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae9105ec386170113bb24f3808c7ba6f7.html#ae9105ec386170113bb24f3808c7ba6f7">forward_as</a> (const T_actual &amp;a)</td></tr>
<tr class="memdesc:ae9105ec386170113bb24f3808c7ba6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume which type we get.  <a href="namespacestan_1_1math_ae9105ec386170113bb24f3808c7ba6f7.html#ae9105ec386170113bb24f3808c7ba6f7">More...</a><br /></td></tr>
<tr class="separator:ae9105ec386170113bb24f3808c7ba6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa478b0c74cd87e5216789188a0a1783a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ptrs, std::enable_if_t&lt; sizeof...(Ptrs) &gt;  = 1&gt; </td></tr>
<tr class="memitem:aa478b0c74cd87e5216789188a0a1783a"><td class="memTemplItemLeft" align="right" valign="top">Ptrs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa478b0c74cd87e5216789188a0a1783a.html#aa478b0c74cd87e5216789188a0a1783a">holder</a> (T &amp;&amp;<a class="el" href="namespacestan_1_1math_a7c8ad2370c5624d7c0700410e6612514.html#a7c8ad2370c5624d7c0700410e6612514">arg</a>, Ptrs *... pointers)</td></tr>
<tr class="separator:aa478b0c74cd87e5216789188a0a1783a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34bc168bdd4da488fd9f0daef383624"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af34bc168bdd4da488fd9f0daef383624"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af34bc168bdd4da488fd9f0daef383624.html#af34bc168bdd4da488fd9f0daef383624">holder</a> (T &amp;&amp;<a class="el" href="namespacestan_1_1math_a7c8ad2370c5624d7c0700410e6612514.html#a7c8ad2370c5624d7c0700410e6612514">arg</a>)</td></tr>
<tr class="separator:af34bc168bdd4da488fd9f0daef383624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf8e9e8eb72e2d7b85a91f6bd2ddd77"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Args, require_not_plain_type_t&lt; decltype(std::declval&lt; F &gt;()(std::declval&lt; Args &amp; &gt;()...))&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2bf8e9e8eb72e2d7b85a91f6bd2ddd77"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2bf8e9e8eb72e2d7b85a91f6bd2ddd77.html#a2bf8e9e8eb72e2d7b85a91f6bd2ddd77">make_holder</a> (const F &amp;func, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a2bf8e9e8eb72e2d7b85a91f6bd2ddd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an expression from given arguments using given functor.  <a href="namespacestan_1_1math_a2bf8e9e8eb72e2d7b85a91f6bd2ddd77.html#a2bf8e9e8eb72e2d7b85a91f6bd2ddd77">More...</a><br /></td></tr>
<tr class="separator:a2bf8e9e8eb72e2d7b85a91f6bd2ddd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab538359f082f3209ee2b18ed2cec99e2"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, class F &gt; </td></tr>
<tr class="memitem:ab538359f082f3209ee2b18ed2cec99e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab538359f082f3209ee2b18ed2cec99e2.html#ab538359f082f3209ee2b18ed2cec99e2">index_apply</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:ab538359f082f3209ee2b18ed2cec99e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls given callable with an index sequence.  <a href="namespacestan_1_1math_ab538359f082f3209ee2b18ed2cec99e2.html#ab538359f082f3209ee2b18ed2cec99e2">More...</a><br /></td></tr>
<tr class="separator:ab538359f082f3209ee2b18ed2cec99e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfbeada90c8388f054c44532fd4e68e"><td class="memTemplParams" colspan="2">template&lt;typename CondSum , typename T , require_t&lt; CondSum &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9dfbeada90c8388f054c44532fd4e68e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9dfbeada90c8388f054c44532fd4e68e.html#a9dfbeada90c8388f054c44532fd4e68e">possibly_sum</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:a9dfbeada90c8388f054c44532fd4e68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally sum the input at compile time.  <a href="namespacestan_1_1math_a9dfbeada90c8388f054c44532fd4e68e.html#a9dfbeada90c8388f054c44532fd4e68e">More...</a><br /></td></tr>
<tr class="separator:a9dfbeada90c8388f054c44532fd4e68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74152bd0994430700e68c83bd42f5674"><td class="memTemplParams" colspan="2">template&lt;typename CondSum , typename T1 , require_not_t&lt; CondSum &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a74152bd0994430700e68c83bd42f5674"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a74152bd0994430700e68c83bd42f5674.html#a74152bd0994430700e68c83bd42f5674">possibly_sum</a> (T1 &amp;&amp;x)</td></tr>
<tr class="memdesc:a74152bd0994430700e68c83bd42f5674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally sum the input at compile time.  <a href="namespacestan_1_1math_a74152bd0994430700e68c83bd42f5674.html#a74152bd0994430700e68c83bd42f5674">More...</a><br /></td></tr>
<tr class="separator:a74152bd0994430700e68c83bd42f5674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77598ca0189cc2eb170753992871808c"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename T1 , typename T2 , std::enable_if_t&lt; Condition &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a77598ca0189cc2eb170753992871808c"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a77598ca0189cc2eb170753992871808c.html#a77598ca0189cc2eb170753992871808c">static_select</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="memdesc:a77598ca0189cc2eb170753992871808c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of the arguments that can be of different type, depending on the compile time condition.  <a href="namespacestan_1_1math_a77598ca0189cc2eb170753992871808c.html#a77598ca0189cc2eb170753992871808c">More...</a><br /></td></tr>
<tr class="separator:a77598ca0189cc2eb170753992871808c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2f64b7e48cacc08513b024a9acea27"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename T1 , typename T2 , std::enable_if_t&lt;!Condition &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b2f64b7e48cacc08513b024a9acea27"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4b2f64b7e48cacc08513b024a9acea27.html#a4b2f64b7e48cacc08513b024a9acea27">static_select</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:a4b2f64b7e48cacc08513b024a9acea27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga847ddda718b00ddc745affb67fe5ef15"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:ga847ddda718b00ddc745affb67fe5ef15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga847ddda718b00ddc745affb67fe5ef15.html#ga847ddda718b00ddc745affb67fe5ef15">bernoulli_ccdf_log</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga847ddda718b00ddc745affb67fe5ef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3224cf1c32760fe0f5a30e0746a9407"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n, T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae3224cf1c32760fe0f5a30e0746a9407"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae3224cf1c32760fe0f5a30e0746a9407.html#gae3224cf1c32760fe0f5a30e0746a9407">bernoulli_cdf</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:gae3224cf1c32760fe0f5a30e0746a9407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8e79ce9d13ac4528fba9f4711b06f3d"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:gae8e79ce9d13ac4528fba9f4711b06f3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae8e79ce9d13ac4528fba9f4711b06f3d.html#gae8e79ce9d13ac4528fba9f4711b06f3d">bernoulli_cdf_log</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:gae8e79ce9d13ac4528fba9f4711b06f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f5b32a42a62a3adee25dd138ec579bb"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n, T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2f5b32a42a62a3adee25dd138ec579bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga2f5b32a42a62a3adee25dd138ec579bb.html#ga2f5b32a42a62a3adee25dd138ec579bb">bernoulli_lccdf</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga2f5b32a42a62a3adee25dd138ec579bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga565e933a2d240aaedb1c648d2cd21101"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n, T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga565e933a2d240aaedb1c648d2cd21101"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga565e933a2d240aaedb1c648d2cd21101.html#ga565e933a2d240aaedb1c648d2cd21101">bernoulli_lcdf</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga565e933a2d240aaedb1c648d2cd21101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga862f20d38111a24d37aed5a44e5ae34e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:ga862f20d38111a24d37aed5a44e5ae34e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga862f20d38111a24d37aed5a44e5ae34e.html#ga862f20d38111a24d37aed5a44e5ae34e">bernoulli_log</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga862f20d38111a24d37aed5a44e5ae34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c69e4cedcbf08cb262ea13aa0e6c924"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_prob &gt; </td></tr>
<tr class="memitem:ga0c69e4cedcbf08cb262ea13aa0e6c924"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga0c69e4cedcbf08cb262ea13aa0e6c924.html#ga0c69e4cedcbf08cb262ea13aa0e6c924">bernoulli_log</a> (const T_y &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga0c69e4cedcbf08cb262ea13aa0e6c924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d3a0c1398ed337c7979559b1156727"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:ga25d3a0c1398ed337c7979559b1156727"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga25d3a0c1398ed337c7979559b1156727.html#ga25d3a0c1398ed337c7979559b1156727">bernoulli_logit_glm_log</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga25d3a0c1398ed337c7979559b1156727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa134b4fd02e5d004766d37732e7801b4"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:gaa134b4fd02e5d004766d37732e7801b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gaa134b4fd02e5d004766d37732e7801b4.html#gaa134b4fd02e5d004766d37732e7801b4">bernoulli_logit_glm_log</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaa134b4fd02e5d004766d37732e7801b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae708042f23d9a65b9b9d62c41b9c5e8f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , require_matrix_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae708042f23d9a65b9b9d62c41b9c5e8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gae708042f23d9a65b9b9d62c41b9c5e8f.html#gae708042f23d9a65b9b9d62c41b9c5e8f">bernoulli_logit_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gae708042f23d9a65b9b9d62c41b9c5e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad379e6ead9b404114451de2490e64dbc"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:ad379e6ead9b404114451de2490e64dbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_beta, T_alpha &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad379e6ead9b404114451de2490e64dbc.html#ad379e6ead9b404114451de2490e64dbc">bernoulli_logit_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ad379e6ead9b404114451de2490e64dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga305e57f094bad826b293179514f1c7b8"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_alpha , typename T_beta , class RNG &gt; </td></tr>
<tr class="memitem:ga305e57f094bad826b293179514f1c7b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_alpha &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga305e57f094bad826b293179514f1c7b8.html#ga305e57f094bad826b293179514f1c7b8">bernoulli_logit_glm_rng</a> (const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, RNG &amp;rng)</td></tr>
<tr class="separator:ga305e57f094bad826b293179514f1c7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60520414ba8f8dfa79dad1500f61f965"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:ga60520414ba8f8dfa79dad1500f61f965"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga60520414ba8f8dfa79dad1500f61f965.html#ga60520414ba8f8dfa79dad1500f61f965">bernoulli_logit_log</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga60520414ba8f8dfa79dad1500f61f965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e9137fb3cefd3230926703128efebd6"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:ga8e9137fb3cefd3230926703128efebd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga8e9137fb3cefd3230926703128efebd6.html#ga8e9137fb3cefd3230926703128efebd6">bernoulli_logit_log</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga8e9137fb3cefd3230926703128efebd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37f32bcec1607a3ed0c7859c557d951c"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_prob , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n, T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga37f32bcec1607a3ed0c7859c557d951c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga37f32bcec1607a3ed0c7859c557d951c.html#ga37f32bcec1607a3ed0c7859c557d951c">bernoulli_logit_lpmf</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga37f32bcec1607a3ed0c7859c557d951c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85bb13819f1166ef8144501608ae84c"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:ad85bb13819f1166ef8144501608ae84c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad85bb13819f1166ef8144501608ae84c.html#ad85bb13819f1166ef8144501608ae84c">bernoulli_logit_lpmf</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:ad85bb13819f1166ef8144501608ae84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9cef6ba135cbd271d68dc26b005b2e6"><td class="memTemplParams" colspan="2">template&lt;typename T_t , class RNG &gt; </td></tr>
<tr class="memitem:gae9cef6ba135cbd271d68dc26b005b2e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae9cef6ba135cbd271d68dc26b005b2e6.html#gae9cef6ba135cbd271d68dc26b005b2e6">bernoulli_logit_rng</a> (const T_t &amp;t, RNG &amp;rng)</td></tr>
<tr class="separator:gae9cef6ba135cbd271d68dc26b005b2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf340cd76910fb68a7980489f720ee37"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_prob , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n, T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacf340cd76910fb68a7980489f720ee37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gacf340cd76910fb68a7980489f720ee37.html#gacf340cd76910fb68a7980489f720ee37">bernoulli_lpmf</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:gacf340cd76910fb68a7980489f720ee37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af737cd40b466e67dc6c9528b6c26b6a0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_prob &gt; </td></tr>
<tr class="memitem:af737cd40b466e67dc6c9528b6c26b6a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af737cd40b466e67dc6c9528b6c26b6a0.html#af737cd40b466e67dc6c9528b6c26b6a0">bernoulli_lpmf</a> (const T_y &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:af737cd40b466e67dc6c9528b6c26b6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8d632ddc417ff4b874130c2cd006b1c"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , class RNG &gt; </td></tr>
<tr class="memitem:gaa8d632ddc417ff4b874130c2cd006b1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_theta &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaa8d632ddc417ff4b874130c2cd006b1c.html#gaa8d632ddc417ff4b874130c2cd006b1c">bernoulli_rng</a> (const T_theta &amp;theta, RNG &amp;rng)</td></tr>
<tr class="separator:gaa8d632ddc417ff4b874130c2cd006b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53becbeb6d767a768f00a150d23c19e9"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:ga53becbeb6d767a768f00a150d23c19e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_size1, T_size2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga53becbeb6d767a768f00a150d23c19e9.html#ga53becbeb6d767a768f00a150d23c19e9">beta_binomial_ccdf_log</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga53becbeb6d767a768f00a150d23c19e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd4f74c37e5d7318cd0a5050247b9773"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:gadd4f74c37e5d7318cd0a5050247b9773"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_size1, T_size2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gadd4f74c37e5d7318cd0a5050247b9773.html#gadd4f74c37e5d7318cd0a5050247b9773">beta_binomial_cdf</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gadd4f74c37e5d7318cd0a5050247b9773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga098c8e77ee62331a7fd4a16115256d83"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:ga098c8e77ee62331a7fd4a16115256d83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_size1, T_size2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga098c8e77ee62331a7fd4a16115256d83.html#ga098c8e77ee62331a7fd4a16115256d83">beta_binomial_cdf_log</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga098c8e77ee62331a7fd4a16115256d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7954c4391d2731759a7ef9df4064f311"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:ga7954c4391d2731759a7ef9df4064f311"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_size1, T_size2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga7954c4391d2731759a7ef9df4064f311.html#ga7954c4391d2731759a7ef9df4064f311">beta_binomial_lccdf</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga7954c4391d2731759a7ef9df4064f311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26dcc09bea236c6755bc3cf8c2814cf1"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:ga26dcc09bea236c6755bc3cf8c2814cf1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_size1, T_size2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga26dcc09bea236c6755bc3cf8c2814cf1.html#ga26dcc09bea236c6755bc3cf8c2814cf1">beta_binomial_lcdf</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga26dcc09bea236c6755bc3cf8c2814cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac290f0362a633af47814b53e4b6486b3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:gac290f0362a633af47814b53e4b6486b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_size1, T_size2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gac290f0362a633af47814b53e4b6486b3.html#gac290f0362a633af47814b53e4b6486b3">beta_binomial_log</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gac290f0362a633af47814b53e4b6486b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4d2085324e32e5895f62e40871fbbf1"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:gab4d2085324e32e5895f62e40871fbbf1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_size1, T_size2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab4d2085324e32e5895f62e40871fbbf1.html#gab4d2085324e32e5895f62e40871fbbf1">beta_binomial_log</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gab4d2085324e32e5895f62e40871fbbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga274df087cfc63591ccf67679551134e6"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_N , typename T_size1 , typename T_size2 , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n, T_N, T_size1, T_size2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga274df087cfc63591ccf67679551134e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_size1, T_size2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga274df087cfc63591ccf67679551134e6.html#ga274df087cfc63591ccf67679551134e6">beta_binomial_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga274df087cfc63591ccf67679551134e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc56160e724c55db00cb0de1b189d0d"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:a9cc56160e724c55db00cb0de1b189d0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_size1, T_size2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9cc56160e724c55db00cb0de1b189d0d.html#a9cc56160e724c55db00cb0de1b189d0d">beta_binomial_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a9cc56160e724c55db00cb0de1b189d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga187a5a4814150c777e3cb637ab449bfc"><td class="memTemplParams" colspan="2">template&lt;typename T_N , typename T_shape1 , typename T_shape2 , class RNG &gt; </td></tr>
<tr class="memitem:ga187a5a4814150c777e3cb637ab449bfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_N, T_shape1, T_shape2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga187a5a4814150c777e3cb637ab449bfc.html#ga187a5a4814150c777e3cb637ab449bfc">beta_binomial_rng</a> (const T_N &amp;N, const T_shape1 &amp;alpha, const T_shape2 &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, RNG &amp;rng)</td></tr>
<tr class="separator:ga187a5a4814150c777e3cb637ab449bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb7de9c26e7ba0fc2c32867592cb20a3"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:gadb7de9c26e7ba0fc2c32867592cb20a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale_succ, T_scale_fail &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gadb7de9c26e7ba0fc2c32867592cb20a3.html#gadb7de9c26e7ba0fc2c32867592cb20a3">beta_ccdf_log</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gadb7de9c26e7ba0fc2c32867592cb20a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd8156c2adcd81f755e743fa1237b204"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:gacd8156c2adcd81f755e743fa1237b204"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale_succ, T_scale_fail &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gacd8156c2adcd81f755e743fa1237b204.html#gacd8156c2adcd81f755e743fa1237b204">beta_cdf</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gacd8156c2adcd81f755e743fa1237b204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2472de3e9e124f5d7a26caa9a896760"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:gad2472de3e9e124f5d7a26caa9a896760"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale_succ, T_scale_fail &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad2472de3e9e124f5d7a26caa9a896760.html#gad2472de3e9e124f5d7a26caa9a896760">beta_cdf_log</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gad2472de3e9e124f5d7a26caa9a896760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1697a0c18721213276aee6d9b958ecfb"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:ga1697a0c18721213276aee6d9b958ecfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale_succ, T_scale_fail &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga1697a0c18721213276aee6d9b958ecfb.html#ga1697a0c18721213276aee6d9b958ecfb">beta_lccdf</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;beta_param)</td></tr>
<tr class="separator:ga1697a0c18721213276aee6d9b958ecfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfedfa726aafb121cee54fcddb028056"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:gadfedfa726aafb121cee54fcddb028056"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale_succ, T_scale_fail &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gadfedfa726aafb121cee54fcddb028056.html#gadfedfa726aafb121cee54fcddb028056">beta_lcdf</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;beta_param)</td></tr>
<tr class="separator:gadfedfa726aafb121cee54fcddb028056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacecc5020a36c47d63cbae9fb5f9ad363"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:gacecc5020a36c47d63cbae9fb5f9ad363"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale_succ, T_scale_fail &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gacecc5020a36c47d63cbae9fb5f9ad363.html#gacecc5020a36c47d63cbae9fb5f9ad363">beta_log</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gacecc5020a36c47d63cbae9fb5f9ad363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a0df391c148f0a55926e2bf9928131"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:ga27a0df391c148f0a55926e2bf9928131"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale_succ, T_scale_fail &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga27a0df391c148f0a55926e2bf9928131.html#ga27a0df391c148f0a55926e2bf9928131">beta_log</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga27a0df391c148f0a55926e2bf9928131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a31fcb3d991d3db321ab0700f068795"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_scale_succ , typename T_scale_fail , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_scale_succ, T_scale_fail &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9a31fcb3d991d3db321ab0700f068795"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale_succ, T_scale_fail &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga9a31fcb3d991d3db321ab0700f068795.html#ga9a31fcb3d991d3db321ab0700f068795">beta_lpdf</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga9a31fcb3d991d3db321ab0700f068795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f64f9e543c3570663d306cad91614bc"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:a9f64f9e543c3570663d306cad91614bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale_succ, T_scale_fail &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9f64f9e543c3570663d306cad91614bc.html#a9f64f9e543c3570663d306cad91614bc">beta_lpdf</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a9f64f9e543c3570663d306cad91614bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab05d23263a6a6f24dabd3bc4ea9872ed"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_prec &gt; </td></tr>
<tr class="memitem:gab05d23263a6a6f24dabd3bc4ea9872ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_prec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab05d23263a6a6f24dabd3bc4ea9872ed.html#gab05d23263a6a6f24dabd3bc4ea9872ed">beta_proportion_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_prec &amp;kappa)</td></tr>
<tr class="separator:gab05d23263a6a6f24dabd3bc4ea9872ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c8611e48c176233a0db4ed8b12abc48"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_prec &gt; </td></tr>
<tr class="memitem:ga3c8611e48c176233a0db4ed8b12abc48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_prec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3c8611e48c176233a0db4ed8b12abc48.html#ga3c8611e48c176233a0db4ed8b12abc48">beta_proportion_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_prec &amp;kappa)</td></tr>
<tr class="separator:ga3c8611e48c176233a0db4ed8b12abc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cedc43508fde3e3eb387ae90a9ad574"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_prec &gt; </td></tr>
<tr class="memitem:ga8cedc43508fde3e3eb387ae90a9ad574"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_prec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga8cedc43508fde3e3eb387ae90a9ad574.html#ga8cedc43508fde3e3eb387ae90a9ad574">beta_proportion_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_prec &amp;kappa)</td></tr>
<tr class="separator:ga8cedc43508fde3e3eb387ae90a9ad574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac68785964bcd66e8b98d54e76c74cfb0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_prec &gt; </td></tr>
<tr class="memitem:gac68785964bcd66e8b98d54e76c74cfb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_prec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gac68785964bcd66e8b98d54e76c74cfb0.html#gac68785964bcd66e8b98d54e76c74cfb0">beta_proportion_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_prec &amp;kappa)</td></tr>
<tr class="separator:gac68785964bcd66e8b98d54e76c74cfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa6af3186fef2cf1a1b8b79f0065702b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_prec &gt; </td></tr>
<tr class="memitem:gaaa6af3186fef2cf1a1b8b79f0065702b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_prec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaaa6af3186fef2cf1a1b8b79f0065702b.html#gaaa6af3186fef2cf1a1b8b79f0065702b">beta_proportion_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_prec &amp;kappa)</td></tr>
<tr class="separator:gaaa6af3186fef2cf1a1b8b79f0065702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aea6d0bf460366e6225e5f006a7bc32"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_prec &gt; </td></tr>
<tr class="memitem:ga0aea6d0bf460366e6225e5f006a7bc32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_prec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga0aea6d0bf460366e6225e5f006a7bc32.html#ga0aea6d0bf460366e6225e5f006a7bc32">beta_proportion_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_prec &amp;kappa)</td></tr>
<tr class="separator:ga0aea6d0bf460366e6225e5f006a7bc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66e82740760f45aadd11ab932b849bb8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_prec , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_prec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga66e82740760f45aadd11ab932b849bb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_prec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga66e82740760f45aadd11ab932b849bb8.html#ga66e82740760f45aadd11ab932b849bb8">beta_proportion_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_prec &amp;kappa)</td></tr>
<tr class="separator:ga66e82740760f45aadd11ab932b849bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9030882167c7467f1d87b3512efe91b4"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_prec &gt; </td></tr>
<tr class="memitem:a9030882167c7467f1d87b3512efe91b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_prec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9030882167c7467f1d87b3512efe91b4.html#a9030882167c7467f1d87b3512efe91b4">beta_proportion_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_prec &amp;kappa)</td></tr>
<tr class="separator:a9030882167c7467f1d87b3512efe91b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga427104371206841b7f031debf036a1b7"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_prec , class RNG &gt; </td></tr>
<tr class="memitem:ga427104371206841b7f031debf036a1b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_prec &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga427104371206841b7f031debf036a1b7.html#ga427104371206841b7f031debf036a1b7">beta_proportion_rng</a> (const T_loc &amp;mu, const T_prec &amp;kappa, RNG &amp;rng)</td></tr>
<tr class="separator:ga427104371206841b7f031debf036a1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8bda52fd1119c82001c583ccdf1f083"><td class="memTemplParams" colspan="2">template&lt;typename T_shape1 , typename T_shape2 , class RNG &gt; </td></tr>
<tr class="memitem:gad8bda52fd1119c82001c583ccdf1f083"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_shape1, T_shape2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad8bda52fd1119c82001c583ccdf1f083.html#gad8bda52fd1119c82001c583ccdf1f083">beta_rng</a> (const T_shape1 &amp;alpha, const T_shape2 &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, RNG &amp;rng)</td></tr>
<tr class="separator:gad8bda52fd1119c82001c583ccdf1f083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1661e6edcb8922c233eca8d341cd635"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:gaa1661e6edcb8922c233eca8d341cd635"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaa1661e6edcb8922c233eca8d341cd635.html#gaa1661e6edcb8922c233eca8d341cd635">binomial_ccdf_log</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="separator:gaa1661e6edcb8922c233eca8d341cd635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf5e3d07f619b69900bb595d85fa14c7"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:gabf5e3d07f619b69900bb595d85fa14c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gabf5e3d07f619b69900bb595d85fa14c7.html#gabf5e3d07f619b69900bb595d85fa14c7">binomial_cdf</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="separator:gabf5e3d07f619b69900bb595d85fa14c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga232cfedb37087addeac6fcccf103fdee"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:ga232cfedb37087addeac6fcccf103fdee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga232cfedb37087addeac6fcccf103fdee.html#ga232cfedb37087addeac6fcccf103fdee">binomial_cdf_log</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga232cfedb37087addeac6fcccf103fdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfdeaf6b6d86c2c5f7ddc138bea4923f"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:gadfdeaf6b6d86c2c5f7ddc138bea4923f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gadfdeaf6b6d86c2c5f7ddc138bea4923f.html#gadfdeaf6b6d86c2c5f7ddc138bea4923f">binomial_lccdf</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="separator:gadfdeaf6b6d86c2c5f7ddc138bea4923f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6094cbf3193978d043de1584139cfc8b"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:ga6094cbf3193978d043de1584139cfc8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga6094cbf3193978d043de1584139cfc8b.html#ga6094cbf3193978d043de1584139cfc8b">binomial_lcdf</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga6094cbf3193978d043de1584139cfc8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a424b8e24b0b87e2955ca8880f7b7ca"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:ga4a424b8e24b0b87e2955ca8880f7b7ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga4a424b8e24b0b87e2955ca8880f7b7ca.html#ga4a424b8e24b0b87e2955ca8880f7b7ca">binomial_log</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga4a424b8e24b0b87e2955ca8880f7b7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65ff7e09bf15e1ff10a498b3e1a9f58e"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:ga65ff7e09bf15e1ff10a498b3e1a9f58e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga65ff7e09bf15e1ff10a498b3e1a9f58e.html#ga65ff7e09bf15e1ff10a498b3e1a9f58e">binomial_log</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga65ff7e09bf15e1ff10a498b3e1a9f58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8427698cc51bc70c87191db00339a93c"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:ga8427698cc51bc70c87191db00339a93c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga8427698cc51bc70c87191db00339a93c.html#ga8427698cc51bc70c87191db00339a93c">binomial_logit_log</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;alpha)</td></tr>
<tr class="separator:ga8427698cc51bc70c87191db00339a93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga596229bc9c1b94fd219ef5620e613718"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:ga596229bc9c1b94fd219ef5620e613718"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga596229bc9c1b94fd219ef5620e613718.html#ga596229bc9c1b94fd219ef5620e613718">binomial_logit_log</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;alpha)</td></tr>
<tr class="separator:ga596229bc9c1b94fd219ef5620e613718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ed3a1c2af400e72c5fcc44226e453c8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_N , typename T_prob , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n, T_N, T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7ed3a1c2af400e72c5fcc44226e453c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga7ed3a1c2af400e72c5fcc44226e453c8.html#ga7ed3a1c2af400e72c5fcc44226e453c8">binomial_logit_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;alpha)</td></tr>
<tr class="separator:ga7ed3a1c2af400e72c5fcc44226e453c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e2b653a268071e7dc1141c0f7872b1"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:af1e2b653a268071e7dc1141c0f7872b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af1e2b653a268071e7dc1141c0f7872b1.html#af1e2b653a268071e7dc1141c0f7872b1">binomial_logit_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;alpha)</td></tr>
<tr class="separator:af1e2b653a268071e7dc1141c0f7872b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6986ad0ea7c35899d7e10b4c33218711"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_N , typename T_prob , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n, T_N, T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6986ad0ea7c35899d7e10b4c33218711"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga6986ad0ea7c35899d7e10b4c33218711.html#ga6986ad0ea7c35899d7e10b4c33218711">binomial_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga6986ad0ea7c35899d7e10b4c33218711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf65d0995eaf459b6364705c53301bc"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:addf65d0995eaf459b6364705c53301bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_addf65d0995eaf459b6364705c53301bc.html#addf65d0995eaf459b6364705c53301bc">binomial_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="separator:addf65d0995eaf459b6364705c53301bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb294c58c23efd02ac48a170cb7675b7"><td class="memTemplParams" colspan="2">template&lt;typename T_N , typename T_theta , class RNG &gt; </td></tr>
<tr class="memitem:gabb294c58c23efd02ac48a170cb7675b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_N, T_theta &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gabb294c58c23efd02ac48a170cb7675b7.html#gabb294c58c23efd02ac48a170cb7675b7">binomial_rng</a> (const T_N &amp;N, const T_theta &amp;theta, RNG &amp;rng)</td></tr>
<tr class="separator:gabb294c58c23efd02ac48a170cb7675b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59609a885c7799e09536dfaac422408d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:ga59609a885c7799e09536dfaac422408d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga59609a885c7799e09536dfaac422408d.html#ga59609a885c7799e09536dfaac422408d">categorical_log</a> (const T_n &amp;ns, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga59609a885c7799e09536dfaac422408d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f9fccab8df853934c6e093ed07562d1"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:ga4f9fccab8df853934c6e093ed07562d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga4f9fccab8df853934c6e093ed07562d1.html#ga4f9fccab8df853934c6e093ed07562d1">categorical_log</a> (const T_n &amp;ns, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga4f9fccab8df853934c6e093ed07562d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17b9cdb8336f173a13db846c509e5412"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , require_matrix_t&lt; T_x &gt; *  = nullptr, require_col_vector_t&lt; T_alpha &gt; *  = nullptr, require_matrix_t&lt; T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga17b9cdb8336f173a13db846c509e5412"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga17b9cdb8336f173a13db846c509e5412.html#ga17b9cdb8336f173a13db846c509e5412">categorical_logit_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga17b9cdb8336f173a13db846c509e5412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892bde4628ca0febd0f1f54727ed359c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:a892bde4628ca0febd0f1f54727ed359c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a892bde4628ca0febd0f1f54727ed359c.html#a892bde4628ca0febd0f1f54727ed359c">categorical_logit_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a892bde4628ca0febd0f1f54727ed359c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9baba3b60a4d1e78c1ab36d797d36cc"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:gaa9baba3b60a4d1e78c1ab36d797d36cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gaa9baba3b60a4d1e78c1ab36d797d36cc.html#gaa9baba3b60a4d1e78c1ab36d797d36cc">categorical_logit_log</a> (const T_n &amp;ns, const T_prob &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaa9baba3b60a4d1e78c1ab36d797d36cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga801751852f64866699bcf2242813c026"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:ga801751852f64866699bcf2242813c026"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga801751852f64866699bcf2242813c026.html#ga801751852f64866699bcf2242813c026">categorical_logit_log</a> (const T_n &amp;ns, const T_prob &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga801751852f64866699bcf2242813c026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768c8af0ff021b05c142a7798345019e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , require_col_vector_t&lt; T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a768c8af0ff021b05c142a7798345019e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a768c8af0ff021b05c142a7798345019e.html#a768c8af0ff021b05c142a7798345019e">categorical_logit_lpmf</a> (int n, const T_prob &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a768c8af0ff021b05c142a7798345019e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de6a1d87c679c424cd82bc921891afc"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , require_col_vector_t&lt; T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4de6a1d87c679c424cd82bc921891afc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4de6a1d87c679c424cd82bc921891afc.html#a4de6a1d87c679c424cd82bc921891afc">categorical_logit_lpmf</a> (const std::vector&lt; int &gt; &amp;ns, const T_prob &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a4de6a1d87c679c424cd82bc921891afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d9b13e7d30da5af7bdd3f6cea9194a"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob , require_st_integral&lt; T_n &gt; *  = nullptr, require_col_vector_t&lt; T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae6d9b13e7d30da5af7bdd3f6cea9194a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae6d9b13e7d30da5af7bdd3f6cea9194a.html#ae6d9b13e7d30da5af7bdd3f6cea9194a">categorical_logit_lpmf</a> (const T_n &amp;ns, const T_prob &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ae6d9b13e7d30da5af7bdd3f6cea9194a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga735693bdf47c855697175ca6f5698929"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ga735693bdf47c855697175ca6f5698929"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga735693bdf47c855697175ca6f5698929.html#ga735693bdf47c855697175ca6f5698929">categorical_logit_rng</a> (const Eigen::VectorXd &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, RNG &amp;rng)</td></tr>
<tr class="separator:ga735693bdf47c855697175ca6f5698929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031a7880eb1c5325757f4901be8a1498"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , require_eigen_col_vector_t&lt; T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a031a7880eb1c5325757f4901be8a1498"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a031a7880eb1c5325757f4901be8a1498.html#a031a7880eb1c5325757f4901be8a1498">categorical_lpmf</a> (int n, const T_prob &amp;theta)</td></tr>
<tr class="separator:a031a7880eb1c5325757f4901be8a1498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ab9a2dca4862da5b3dcd7361e6bcdb"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , require_eigen_col_vector_t&lt; T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a09ab9a2dca4862da5b3dcd7361e6bcdb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a09ab9a2dca4862da5b3dcd7361e6bcdb.html#a09ab9a2dca4862da5b3dcd7361e6bcdb">categorical_lpmf</a> (const std::vector&lt; int &gt; &amp;ns, const T_prob &amp;theta)</td></tr>
<tr class="separator:a09ab9a2dca4862da5b3dcd7361e6bcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19433a5b768e9d0f4e66b4fa1224b6d"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob , require_st_integral&lt; T_n &gt; *  = nullptr, require_eigen_col_vector_t&lt; T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab19433a5b768e9d0f4e66b4fa1224b6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab19433a5b768e9d0f4e66b4fa1224b6d.html#ab19433a5b768e9d0f4e66b4fa1224b6d">categorical_lpmf</a> (const T_n &amp;ns, const T_prob &amp;theta)</td></tr>
<tr class="separator:ab19433a5b768e9d0f4e66b4fa1224b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8b55cdaa59f3fe7718d5b45889cda6"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a1f8b55cdaa59f3fe7718d5b45889cda6"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1f8b55cdaa59f3fe7718d5b45889cda6.html#a1f8b55cdaa59f3fe7718d5b45889cda6">categorical_rng</a> (const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;theta, RNG &amp;rng)</td></tr>
<tr class="separator:a1f8b55cdaa59f3fe7718d5b45889cda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga557f62fa15ba858d2574dcf8ed174728"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga557f62fa15ba858d2574dcf8ed174728"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga557f62fa15ba858d2574dcf8ed174728.html#ga557f62fa15ba858d2574dcf8ed174728">cauchy_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga557f62fa15ba858d2574dcf8ed174728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6274df1fcbf672357c82467d2d23cc45"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6274df1fcbf672357c82467d2d23cc45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga6274df1fcbf672357c82467d2d23cc45.html#ga6274df1fcbf672357c82467d2d23cc45">cauchy_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga6274df1fcbf672357c82467d2d23cc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fce057e24229598d13c927f465afd55"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga7fce057e24229598d13c927f465afd55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga7fce057e24229598d13c927f465afd55.html#ga7fce057e24229598d13c927f465afd55">cauchy_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga7fce057e24229598d13c927f465afd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8e8e45e0323373076e8c3a11c7b8e86"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac8e8e45e0323373076e8c3a11c7b8e86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gac8e8e45e0323373076e8c3a11c7b8e86.html#gac8e8e45e0323373076e8c3a11c7b8e86">cauchy_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gac8e8e45e0323373076e8c3a11c7b8e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga995bd20c8b575004574df11386f7239c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga995bd20c8b575004574df11386f7239c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga995bd20c8b575004574df11386f7239c.html#ga995bd20c8b575004574df11386f7239c">cauchy_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga995bd20c8b575004574df11386f7239c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga391fa685211c6cf650cb79a7a31b331d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga391fa685211c6cf650cb79a7a31b331d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga391fa685211c6cf650cb79a7a31b331d.html#ga391fa685211c6cf650cb79a7a31b331d">cauchy_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga391fa685211c6cf650cb79a7a31b331d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69023dce35b54fc427afe27969a16af6"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga69023dce35b54fc427afe27969a16af6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga69023dce35b54fc427afe27969a16af6.html#ga69023dce35b54fc427afe27969a16af6">cauchy_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga69023dce35b54fc427afe27969a16af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba6c1956ae6213a7f065ccc5eeb7097b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaba6c1956ae6213a7f065ccc5eeb7097b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaba6c1956ae6213a7f065ccc5eeb7097b.html#gaba6c1956ae6213a7f065ccc5eeb7097b">cauchy_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gaba6c1956ae6213a7f065ccc5eeb7097b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf9fe140e1560fa1aa380b551a379a7"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:acaf9fe140e1560fa1aa380b551a379a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acaf9fe140e1560fa1aa380b551a379a7.html#acaf9fe140e1560fa1aa380b551a379a7">cauchy_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:acaf9fe140e1560fa1aa380b551a379a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a41ec53cecf8950ef8ac5609ef804de"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga8a41ec53cecf8950ef8ac5609ef804de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga8a41ec53cecf8950ef8ac5609ef804de.html#ga8a41ec53cecf8950ef8ac5609ef804de">cauchy_rng</a> (const T_loc &amp;mu, const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="separator:ga8a41ec53cecf8950ef8ac5609ef804de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5170cd9480287f8d5a867a1575ab478d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:ga5170cd9480287f8d5a867a1575ab478d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga5170cd9480287f8d5a867a1575ab478d.html#ga5170cd9480287f8d5a867a1575ab478d">chi_square_ccdf_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:ga5170cd9480287f8d5a867a1575ab478d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a2ca103f3dd48bb544ca82a4078a35c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:ga2a2ca103f3dd48bb544ca82a4078a35c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga2a2ca103f3dd48bb544ca82a4078a35c.html#ga2a2ca103f3dd48bb544ca82a4078a35c">chi_square_cdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:ga2a2ca103f3dd48bb544ca82a4078a35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ca1805f4efa0d9afb1a90981314d02"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:gae6ca1805f4efa0d9afb1a90981314d02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae6ca1805f4efa0d9afb1a90981314d02.html#gae6ca1805f4efa0d9afb1a90981314d02">chi_square_cdf_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:gae6ca1805f4efa0d9afb1a90981314d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc07683311d6cffc0afb02c738791fa1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:gafc07683311d6cffc0afb02c738791fa1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gafc07683311d6cffc0afb02c738791fa1.html#gafc07683311d6cffc0afb02c738791fa1">chi_square_lccdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:gafc07683311d6cffc0afb02c738791fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ab5999deef6e944b190a473c66ab020"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:ga9ab5999deef6e944b190a473c66ab020"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga9ab5999deef6e944b190a473c66ab020.html#ga9ab5999deef6e944b190a473c66ab020">chi_square_lcdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:ga9ab5999deef6e944b190a473c66ab020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa200dc03540fbcd54acefa0b2cb1c1"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:ga1aa200dc03540fbcd54acefa0b2cb1c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga1aa200dc03540fbcd54acefa0b2cb1c1.html#ga1aa200dc03540fbcd54acefa0b2cb1c1">chi_square_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:ga1aa200dc03540fbcd54acefa0b2cb1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f70d6388cc67bd1ecf6ed00f6d00c2d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:ga2f70d6388cc67bd1ecf6ed00f6d00c2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga2f70d6388cc67bd1ecf6ed00f6d00c2d.html#ga2f70d6388cc67bd1ecf6ed00f6d00c2d">chi_square_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:ga2f70d6388cc67bd1ecf6ed00f6d00c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac07b9ab76a53f8660bb2e2d524517ee8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_dof &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac07b9ab76a53f8660bb2e2d524517ee8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gac07b9ab76a53f8660bb2e2d524517ee8.html#gac07b9ab76a53f8660bb2e2d524517ee8">chi_square_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:gac07b9ab76a53f8660bb2e2d524517ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5e0528eb8f663335252ddc5ab918a9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:ace5e0528eb8f663335252ddc5ab918a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ace5e0528eb8f663335252ddc5ab918a9.html#ace5e0528eb8f663335252ddc5ab918a9">chi_square_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:ace5e0528eb8f663335252ddc5ab918a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33131791295612773581563c9045cf21"><td class="memTemplParams" colspan="2">template&lt;typename T_deg , class RNG &gt; </td></tr>
<tr class="memitem:ga33131791295612773581563c9045cf21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_deg &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga33131791295612773581563c9045cf21.html#ga33131791295612773581563c9045cf21">chi_square_rng</a> (const T_deg &amp;nu, RNG &amp;rng)</td></tr>
<tr class="separator:ga33131791295612773581563c9045cf21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3d5bb184fcb8329ec0b157ef7845321"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , typename T_prior_size &gt; </td></tr>
<tr class="memitem:gae3d5bb184fcb8329ec0b157ef7845321"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob, T_prior_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gae3d5bb184fcb8329ec0b157ef7845321.html#gae3d5bb184fcb8329ec0b157ef7845321">dirichlet_log</a> (const T_prob &amp;theta, const T_prior_size &amp;alpha)</td></tr>
<tr class="separator:gae3d5bb184fcb8329ec0b157ef7845321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa63ffb06e9e808dda50ee7494e25b7"><td class="memTemplParams" colspan="2">template&lt;typename T_prob , typename T_prior_size &gt; </td></tr>
<tr class="memitem:ga1aa63ffb06e9e808dda50ee7494e25b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob, T_prior_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga1aa63ffb06e9e808dda50ee7494e25b7.html#ga1aa63ffb06e9e808dda50ee7494e25b7">dirichlet_log</a> (const T_prob &amp;theta, const T_prior_size &amp;alpha)</td></tr>
<tr class="separator:ga1aa63ffb06e9e808dda50ee7494e25b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga993200aac080067864439bb59dc12bd4"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , typename T_prior_size , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_prob, T_prior_size &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga993200aac080067864439bb59dc12bd4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob, T_prior_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga993200aac080067864439bb59dc12bd4.html#ga993200aac080067864439bb59dc12bd4">dirichlet_lpdf</a> (const T_prob &amp;theta, const T_prior_size &amp;alpha)</td></tr>
<tr class="separator:ga993200aac080067864439bb59dc12bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ce507e28681e068003c6a719694381"><td class="memTemplParams" colspan="2">template&lt;typename T_prob , typename T_prior_size &gt; </td></tr>
<tr class="memitem:a76ce507e28681e068003c6a719694381"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob, T_prior_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a76ce507e28681e068003c6a719694381.html#a76ce507e28681e068003c6a719694381">dirichlet_lpdf</a> (const T_prob &amp;theta, const T_prior_size &amp;alpha)</td></tr>
<tr class="separator:a76ce507e28681e068003c6a719694381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56d91749cc27fb49662ff50e1112ef9f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , typename T_prior_size &gt; </td></tr>
<tr class="memitem:ga56d91749cc27fb49662ff50e1112ef9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob, T_prior_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga56d91749cc27fb49662ff50e1112ef9f.html#ga56d91749cc27fb49662ff50e1112ef9f">dirichlet_lpmf</a> (const T_prob &amp;theta, const T_prior_size &amp;alpha)</td></tr>
<tr class="separator:ga56d91749cc27fb49662ff50e1112ef9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733a63cd67982be461c7bde0ab214639"><td class="memTemplParams" colspan="2">template&lt;typename T_prob , typename T_prior_size &gt; </td></tr>
<tr class="memitem:a733a63cd67982be461c7bde0ab214639"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob, T_prior_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a733a63cd67982be461c7bde0ab214639.html#a733a63cd67982be461c7bde0ab214639">dirichlet_lpmf</a> (const T_prob &amp;theta, const T_prior_size &amp;alpha)</td></tr>
<tr class="separator:a733a63cd67982be461c7bde0ab214639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb288324f889b7da57f2960570f459ea"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:gacb288324f889b7da57f2960570f459ea"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gacb288324f889b7da57f2960570f459ea.html#gacb288324f889b7da57f2960570f459ea">dirichlet_rng</a> (const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;alpha, RNG &amp;rng)</td></tr>
<tr class="separator:gacb288324f889b7da57f2960570f459ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7621b6ab8cbcc4349c5c2be9c1ec42e1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_lower , typename T_upper &gt; </td></tr>
<tr class="memitem:ga7621b6ab8cbcc4349c5c2be9c1ec42e1"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga7621b6ab8cbcc4349c5c2be9c1ec42e1.html#ga7621b6ab8cbcc4349c5c2be9c1ec42e1">discrete_range_ccdf_log</a> (const T_y &amp;y, const T_lower &amp;lower, const T_upper &amp;upper)</td></tr>
<tr class="separator:ga7621b6ab8cbcc4349c5c2be9c1ec42e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7cc6ceebeb08c343f18bab11942ff28"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_lower , typename T_upper &gt; </td></tr>
<tr class="memitem:gaf7cc6ceebeb08c343f18bab11942ff28"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaf7cc6ceebeb08c343f18bab11942ff28.html#gaf7cc6ceebeb08c343f18bab11942ff28">discrete_range_cdf</a> (const T_y &amp;y, const T_lower &amp;lower, const T_upper &amp;upper)</td></tr>
<tr class="separator:gaf7cc6ceebeb08c343f18bab11942ff28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf813f3e5c20172f6cceed446f096a326"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_lower , typename T_upper &gt; </td></tr>
<tr class="memitem:gaf813f3e5c20172f6cceed446f096a326"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaf813f3e5c20172f6cceed446f096a326.html#gaf813f3e5c20172f6cceed446f096a326">discrete_range_cdf_log</a> (const T_y &amp;y, const T_lower &amp;lower, const T_upper &amp;upper)</td></tr>
<tr class="separator:gaf813f3e5c20172f6cceed446f096a326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab63d42319276a30b3b06721fe60daa8d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_lower , typename T_upper &gt; </td></tr>
<tr class="memitem:gab63d42319276a30b3b06721fe60daa8d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab63d42319276a30b3b06721fe60daa8d.html#gab63d42319276a30b3b06721fe60daa8d">discrete_range_lccdf</a> (const T_y &amp;y, const T_lower &amp;lower, const T_upper &amp;upper)</td></tr>
<tr class="separator:gab63d42319276a30b3b06721fe60daa8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga034e6456b6fe522ba26bf9df45517b90"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_lower , typename T_upper &gt; </td></tr>
<tr class="memitem:ga034e6456b6fe522ba26bf9df45517b90"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga034e6456b6fe522ba26bf9df45517b90.html#ga034e6456b6fe522ba26bf9df45517b90">discrete_range_lcdf</a> (const T_y &amp;y, const T_lower &amp;lower, const T_upper &amp;upper)</td></tr>
<tr class="separator:ga034e6456b6fe522ba26bf9df45517b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab297c5642d16945997a70ec26e05f8db"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_lower , typename T_upper &gt; </td></tr>
<tr class="memitem:gab297c5642d16945997a70ec26e05f8db"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab297c5642d16945997a70ec26e05f8db.html#gab297c5642d16945997a70ec26e05f8db">discrete_range_log</a> (const T_y &amp;y, const T_lower &amp;lower, const T_upper &amp;upper)</td></tr>
<tr class="separator:gab297c5642d16945997a70ec26e05f8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfb318ea353641898bbde6b3b3615e08"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_lower , typename T_upper &gt; </td></tr>
<tr class="memitem:gabfb318ea353641898bbde6b3b3615e08"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gabfb318ea353641898bbde6b3b3615e08.html#gabfb318ea353641898bbde6b3b3615e08">discrete_range_log</a> (const T_y &amp;y, const T_lower &amp;lower, const T_upper &amp;upper)</td></tr>
<tr class="separator:gabfb318ea353641898bbde6b3b3615e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e44514f76d23b96c80f75857579f86"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_lower , typename T_upper &gt; </td></tr>
<tr class="memitem:ga98e44514f76d23b96c80f75857579f86"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga98e44514f76d23b96c80f75857579f86.html#ga98e44514f76d23b96c80f75857579f86">discrete_range_lpmf</a> (const T_y &amp;y, const T_lower &amp;lower, const T_upper &amp;upper)</td></tr>
<tr class="separator:ga98e44514f76d23b96c80f75857579f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af071177a90fab33367de7a7b84904a4a"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_lower , typename T_upper &gt; </td></tr>
<tr class="memitem:af071177a90fab33367de7a7b84904a4a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af071177a90fab33367de7a7b84904a4a.html#af071177a90fab33367de7a7b84904a4a">discrete_range_lpmf</a> (const T_y &amp;y, const T_lower &amp;lower, const T_upper &amp;upper)</td></tr>
<tr class="separator:af071177a90fab33367de7a7b84904a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24581f62c280e94bb892e6bfbceceb3f"><td class="memTemplParams" colspan="2">template&lt;typename T_lower , typename T_upper , class RNG &gt; </td></tr>
<tr class="memitem:ga24581f62c280e94bb892e6bfbceceb3f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_lower, T_upper &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga24581f62c280e94bb892e6bfbceceb3f.html#ga24581f62c280e94bb892e6bfbceceb3f">discrete_range_rng</a> (const T_lower &amp;lower, const T_upper &amp;upper, RNG &amp;rng)</td></tr>
<tr class="separator:ga24581f62c280e94bb892e6bfbceceb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf91a55a0f26e66185d590cf7c4a4ca55"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gaf91a55a0f26e66185d590cf7c4a4ca55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaf91a55a0f26e66185d590cf7c4a4ca55.html#gaf91a55a0f26e66185d590cf7c4a4ca55">double_exponential_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gaf91a55a0f26e66185d590cf7c4a4ca55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a337da3d0708d20225f3f8609100794"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7a337da3d0708d20225f3f8609100794"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga7a337da3d0708d20225f3f8609100794.html#ga7a337da3d0708d20225f3f8609100794">double_exponential_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga7a337da3d0708d20225f3f8609100794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7755d0f597ed14918ed5bd4868acf50e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga7755d0f597ed14918ed5bd4868acf50e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga7755d0f597ed14918ed5bd4868acf50e.html#ga7755d0f597ed14918ed5bd4868acf50e">double_exponential_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga7755d0f597ed14918ed5bd4868acf50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b97956cd6217cb0821f67212067c3e6"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3b97956cd6217cb0821f67212067c3e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3b97956cd6217cb0821f67212067c3e6.html#ga3b97956cd6217cb0821f67212067c3e6">double_exponential_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga3b97956cd6217cb0821f67212067c3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab166bf7bb5a223c99f7ebf5658631546"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab166bf7bb5a223c99f7ebf5658631546"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab166bf7bb5a223c99f7ebf5658631546.html#gab166bf7bb5a223c99f7ebf5658631546">double_exponential_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gab166bf7bb5a223c99f7ebf5658631546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5617fe6ae69d903acc69668c87d8df4"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gad5617fe6ae69d903acc69668c87d8df4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad5617fe6ae69d903acc69668c87d8df4.html#gad5617fe6ae69d903acc69668c87d8df4">double_exponential_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gad5617fe6ae69d903acc69668c87d8df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0a8853226772e3ea5f7b48e47b85f99"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gad0a8853226772e3ea5f7b48e47b85f99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad0a8853226772e3ea5f7b48e47b85f99.html#gad0a8853226772e3ea5f7b48e47b85f99">double_exponential_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gad0a8853226772e3ea5f7b48e47b85f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06b26909d80fd4cd16067a8745e65297"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga06b26909d80fd4cd16067a8745e65297"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga06b26909d80fd4cd16067a8745e65297.html#ga06b26909d80fd4cd16067a8745e65297">double_exponential_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga06b26909d80fd4cd16067a8745e65297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acbcad5e2dc3fddcc8b05a30246160a"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a7acbcad5e2dc3fddcc8b05a30246160a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7acbcad5e2dc3fddcc8b05a30246160a.html#a7acbcad5e2dc3fddcc8b05a30246160a">double_exponential_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a7acbcad5e2dc3fddcc8b05a30246160a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga361aaaf65886138185f47e4aa5757529"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga361aaaf65886138185f47e4aa5757529"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga361aaaf65886138185f47e4aa5757529.html#ga361aaaf65886138185f47e4aa5757529">double_exponential_rng</a> (const T_loc &amp;mu, const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="separator:ga361aaaf65886138185f47e4aa5757529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13f85db1a8372d85153e8839f58dd66b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:ga13f85db1a8372d85153e8839f58dd66b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga13f85db1a8372d85153e8839f58dd66b.html#ga13f85db1a8372d85153e8839f58dd66b">exp_mod_normal_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:ga13f85db1a8372d85153e8839f58dd66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f9edd00b482438087bb18e9ea56660"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa0f9edd00b482438087bb18e9ea56660"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa0f9edd00b482438087bb18e9ea56660.html#aa0f9edd00b482438087bb18e9ea56660">exp_mod_normal_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:aa0f9edd00b482438087bb18e9ea56660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe4f73413b08835a8a27a777d723154c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:gafe4f73413b08835a8a27a777d723154c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gafe4f73413b08835a8a27a777d723154c.html#gafe4f73413b08835a8a27a777d723154c">exp_mod_normal_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:gafe4f73413b08835a8a27a777d723154c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa133a12415fc8deb18b7e90464497c7f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa133a12415fc8deb18b7e90464497c7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa133a12415fc8deb18b7e90464497c7f.html#aa133a12415fc8deb18b7e90464497c7f">exp_mod_normal_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:aa133a12415fc8deb18b7e90464497c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb12214ac12fff79d506e6498d76f89b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adb12214ac12fff79d506e6498d76f89b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adb12214ac12fff79d506e6498d76f89b.html#adb12214ac12fff79d506e6498d76f89b">exp_mod_normal_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:adb12214ac12fff79d506e6498d76f89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab06bf2bd3ee8e2fa5c3d3f3aa85a77aa"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:gab06bf2bd3ee8e2fa5c3d3f3aa85a77aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab06bf2bd3ee8e2fa5c3d3f3aa85a77aa.html#gab06bf2bd3ee8e2fa5c3d3f3aa85a77aa">exp_mod_normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:gab06bf2bd3ee8e2fa5c3d3f3aa85a77aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeca383625ec3216179164c804719164"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:gafeca383625ec3216179164c804719164"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gafeca383625ec3216179164c804719164.html#gafeca383625ec3216179164c804719164">exp_mod_normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:gafeca383625ec3216179164c804719164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0324ebbd7611951e0a23c998c3c7896e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_inv_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0324ebbd7611951e0a23c998c3c7896e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0324ebbd7611951e0a23c998c3c7896e.html#a0324ebbd7611951e0a23c998c3c7896e">exp_mod_normal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:a0324ebbd7611951e0a23c998c3c7896e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f9a9d149a1df1f02c3a55fbe726a38"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:ad2f9a9d149a1df1f02c3a55fbe726a38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad2f9a9d149a1df1f02c3a55fbe726a38.html#ad2f9a9d149a1df1f02c3a55fbe726a38">exp_mod_normal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:ad2f9a9d149a1df1f02c3a55fbe726a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0e7a7b1a133e6ef0dee461a17da8d58"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , typename T_inv_scale , class RNG &gt; </td></tr>
<tr class="memitem:gaf0e7a7b1a133e6ef0dee461a17da8d58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale, T_inv_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaf0e7a7b1a133e6ef0dee461a17da8d58.html#gaf0e7a7b1a133e6ef0dee461a17da8d58">exp_mod_normal_rng</a> (const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda, RNG &amp;rng)</td></tr>
<tr class="separator:gaf0e7a7b1a133e6ef0dee461a17da8d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac8ea2417402d965eefcf165d41f06a5"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:gaac8ea2417402d965eefcf165d41f06a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaac8ea2417402d965eefcf165d41f06a5.html#gaac8ea2417402d965eefcf165d41f06a5">exponential_ccdf_log</a> (const T_y &amp;y, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaac8ea2417402d965eefcf165d41f06a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc440debcf74d41a8c6594a559b95dc1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_inv_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabc440debcf74d41a8c6594a559b95dc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gabc440debcf74d41a8c6594a559b95dc1.html#gabc440debcf74d41a8c6594a559b95dc1">exponential_cdf</a> (const T_y &amp;y, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gabc440debcf74d41a8c6594a559b95dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be0970905c12187c78e4291a076ee2f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:ga2be0970905c12187c78e4291a076ee2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga2be0970905c12187c78e4291a076ee2f.html#ga2be0970905c12187c78e4291a076ee2f">exponential_cdf_log</a> (const T_y &amp;y, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga2be0970905c12187c78e4291a076ee2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7713b61d602a60745a5c42528625d830"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_inv_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7713b61d602a60745a5c42528625d830"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7713b61d602a60745a5c42528625d830.html#a7713b61d602a60745a5c42528625d830">exponential_lccdf</a> (const T_y &amp;y, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a7713b61d602a60745a5c42528625d830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e411ca2fc08c75d547093636199069b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_inv_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2e411ca2fc08c75d547093636199069b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2e411ca2fc08c75d547093636199069b.html#a2e411ca2fc08c75d547093636199069b">exponential_lcdf</a> (const T_y &amp;y, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a2e411ca2fc08c75d547093636199069b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadee663da0b2a03565819ef4e44303cb6"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:gadee663da0b2a03565819ef4e44303cb6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gadee663da0b2a03565819ef4e44303cb6.html#gadee663da0b2a03565819ef4e44303cb6">exponential_log</a> (const T_y &amp;y, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gadee663da0b2a03565819ef4e44303cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbc6faed9f03b908cac8eeb3d8bd400e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:gafbc6faed9f03b908cac8eeb3d8bd400e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gafbc6faed9f03b908cac8eeb3d8bd400e.html#gafbc6faed9f03b908cac8eeb3d8bd400e">exponential_log</a> (const T_y &amp;y, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gafbc6faed9f03b908cac8eeb3d8bd400e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea3f581a82273dab3c5e8c5f36154e54"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_inv_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaea3f581a82273dab3c5e8c5f36154e54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaea3f581a82273dab3c5e8c5f36154e54.html#gaea3f581a82273dab3c5e8c5f36154e54">exponential_lpdf</a> (const T_y &amp;y, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaea3f581a82273dab3c5e8c5f36154e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfee953242d4fe657ba064399e55e48"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:afdfee953242d4fe657ba064399e55e48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afdfee953242d4fe657ba064399e55e48.html#afdfee953242d4fe657ba064399e55e48">exponential_lpdf</a> (const T_y &amp;y, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:afdfee953242d4fe657ba064399e55e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1fed38166a1218739d58ec6e59b7738"><td class="memTemplParams" colspan="2">template&lt;typename T_inv , class RNG &gt; </td></tr>
<tr class="memitem:gac1fed38166a1218739d58ec6e59b7738"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_inv &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gac1fed38166a1218739d58ec6e59b7738.html#gac1fed38166a1218739d58ec6e59b7738">exponential_rng</a> (const T_inv &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, RNG &amp;rng)</td></tr>
<tr class="separator:gac1fed38166a1218739d58ec6e59b7738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56bcc1738a42decc9ee105b2d65b1127"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ga56bcc1738a42decc9ee105b2d65b1127"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga56bcc1738a42decc9ee105b2d65b1127.html#ga56bcc1738a42decc9ee105b2d65b1127">frechet_ccdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga56bcc1738a42decc9ee105b2d65b1127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8eb8756fa094edab79cc0d56ca0764"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2f8eb8756fa094edab79cc0d56ca0764"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f8eb8756fa094edab79cc0d56ca0764.html#a2f8eb8756fa094edab79cc0d56ca0764">frechet_cdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a2f8eb8756fa094edab79cc0d56ca0764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09b0c55af59b77defd3aa5b7113426b6"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ga09b0c55af59b77defd3aa5b7113426b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga09b0c55af59b77defd3aa5b7113426b6.html#ga09b0c55af59b77defd3aa5b7113426b6">frechet_cdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga09b0c55af59b77defd3aa5b7113426b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8815176bc5b571ae15eb3af3d60acec"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae8815176bc5b571ae15eb3af3d60acec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae8815176bc5b571ae15eb3af3d60acec.html#ae8815176bc5b571ae15eb3af3d60acec">frechet_lccdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ae8815176bc5b571ae15eb3af3d60acec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10543363d1423c85f98a589405c59867"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a10543363d1423c85f98a589405c59867"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a10543363d1423c85f98a589405c59867.html#a10543363d1423c85f98a589405c59867">frechet_lcdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a10543363d1423c85f98a589405c59867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9faa7825ff5fd274993fd9e165c1adf"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:gae9faa7825ff5fd274993fd9e165c1adf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae9faa7825ff5fd274993fd9e165c1adf.html#gae9faa7825ff5fd274993fd9e165c1adf">frechet_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gae9faa7825ff5fd274993fd9e165c1adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5666e72b7e36cbcb0d82197c0175ec2a"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ga5666e72b7e36cbcb0d82197c0175ec2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga5666e72b7e36cbcb0d82197c0175ec2a.html#ga5666e72b7e36cbcb0d82197c0175ec2a">frechet_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga5666e72b7e36cbcb0d82197c0175ec2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18e3119e6484f80b7ad70b641f5b8c9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae18e3119e6484f80b7ad70b641f5b8c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae18e3119e6484f80b7ad70b641f5b8c9.html#ae18e3119e6484f80b7ad70b641f5b8c9">frechet_lpdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ae18e3119e6484f80b7ad70b641f5b8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89998c5c945ded5581b03e80589635d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:aa89998c5c945ded5581b03e80589635d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa89998c5c945ded5581b03e80589635d.html#aa89998c5c945ded5581b03e80589635d">frechet_lpdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aa89998c5c945ded5581b03e80589635d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e46def88bff7dba3862b61f91cbd09"><td class="memTemplParams" colspan="2">template&lt;typename T_shape , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:gad4e46def88bff7dba3862b61f91cbd09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_shape, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad4e46def88bff7dba3862b61f91cbd09.html#gad4e46def88bff7dba3862b61f91cbd09">frechet_rng</a> (const T_shape &amp;alpha, const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="separator:gad4e46def88bff7dba3862b61f91cbd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae399be455706c152ce33b8a427048dc0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:gae399be455706c152ce33b8a427048dc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae399be455706c152ce33b8a427048dc0.html#gae399be455706c152ce33b8a427048dc0">gamma_ccdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gae399be455706c152ce33b8a427048dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf595485288f8421c5796424c5915a95"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:gaaf595485288f8421c5796424c5915a95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaaf595485288f8421c5796424c5915a95.html#gaaf595485288f8421c5796424c5915a95">gamma_cdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaaf595485288f8421c5796424c5915a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebddeedd361815f60493204a691b0bc0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:gaebddeedd361815f60493204a691b0bc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaebddeedd361815f60493204a691b0bc0.html#gaebddeedd361815f60493204a691b0bc0">gamma_cdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaebddeedd361815f60493204a691b0bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac414e8a5e7e2a01d3409485950d4fd0c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:ac414e8a5e7e2a01d3409485950d4fd0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac414e8a5e7e2a01d3409485950d4fd0c.html#ac414e8a5e7e2a01d3409485950d4fd0c">gamma_lccdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ac414e8a5e7e2a01d3409485950d4fd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c4ab7c9e3147b5b10ebdda9bd1c80d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a81c4ab7c9e3147b5b10ebdda9bd1c80d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a81c4ab7c9e3147b5b10ebdda9bd1c80d.html#a81c4ab7c9e3147b5b10ebdda9bd1c80d">gamma_lcdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a81c4ab7c9e3147b5b10ebdda9bd1c80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2937f51d6c139a4248144cf3d634527c"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:ga2937f51d6c139a4248144cf3d634527c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga2937f51d6c139a4248144cf3d634527c.html#ga2937f51d6c139a4248144cf3d634527c">gamma_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga2937f51d6c139a4248144cf3d634527c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec742c844bada3faf9ed21bb388612f2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:gaec742c844bada3faf9ed21bb388612f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaec742c844bada3faf9ed21bb388612f2.html#gaec742c844bada3faf9ed21bb388612f2">gamma_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaec742c844bada3faf9ed21bb388612f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dcc5a9a2a06549826d696109f5a321a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape , typename T_inv_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_shape, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2dcc5a9a2a06549826d696109f5a321a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga2dcc5a9a2a06549826d696109f5a321a.html#ga2dcc5a9a2a06549826d696109f5a321a">gamma_lpdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga2dcc5a9a2a06549826d696109f5a321a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852b64f9850c1b1fe01427fe23a8effd"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a852b64f9850c1b1fe01427fe23a8effd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a852b64f9850c1b1fe01427fe23a8effd.html#a852b64f9850c1b1fe01427fe23a8effd">gamma_lpdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a852b64f9850c1b1fe01427fe23a8effd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c20860e4cf1dbf537596d4f50957a1d"><td class="memTemplParams" colspan="2">template&lt;typename T_shape , typename T_inv , class RNG &gt; </td></tr>
<tr class="memitem:ga6c20860e4cf1dbf537596d4f50957a1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_shape, T_inv &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga6c20860e4cf1dbf537596d4f50957a1d.html#ga6c20860e4cf1dbf537596d4f50957a1d">gamma_rng</a> (const T_shape &amp;alpha, const T_inv &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, RNG &amp;rng)</td></tr>
<tr class="separator:ga6c20860e4cf1dbf537596d4f50957a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86f952dd3635d180de80428f9350a35b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 &gt; </td></tr>
<tr class="memitem:ga86f952dd3635d180de80428f9350a35b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_F, T_G, T_V, T_W, T_m0, T_C0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga86f952dd3635d180de80428f9350a35b.html#ga86f952dd3635d180de80428f9350a35b">gaussian_dlm_obs_log</a> (const T_y &amp;y, const T_F &amp;F, const T_G &amp;G, const T_V &amp;V, const T_W &amp;W, const T_m0 &amp;m0, const T_C0 &amp;C0)</td></tr>
<tr class="separator:ga86f952dd3635d180de80428f9350a35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b1ca42a98c13529b45c3ca2af0b75c3"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 &gt; </td></tr>
<tr class="memitem:ga9b1ca42a98c13529b45c3ca2af0b75c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_F, T_G, T_V, T_W, T_m0, T_C0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga9b1ca42a98c13529b45c3ca2af0b75c3.html#ga9b1ca42a98c13529b45c3ca2af0b75c3">gaussian_dlm_obs_log</a> (const T_y &amp;y, const T_F &amp;F, const T_G &amp;G, const T_V &amp;V, const T_W &amp;W, const T_m0 &amp;m0, const T_C0 &amp;C0)</td></tr>
<tr class="separator:ga9b1ca42a98c13529b45c3ca2af0b75c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa04df98134e973d4d3ce2e6ba814b18a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 , require_all_eigen_matrix_dynamic_t&lt; T_y, T_F, T_G, T_V, T_W, T_C0 &gt; *  = nullptr, require_eigen_col_vector_t&lt; T_m0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa04df98134e973d4d3ce2e6ba814b18a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_F, T_G, T_V, T_W, T_m0, T_C0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gaa04df98134e973d4d3ce2e6ba814b18a.html#gaa04df98134e973d4d3ce2e6ba814b18a">gaussian_dlm_obs_lpdf</a> (const T_y &amp;y, const T_F &amp;F, const T_G &amp;G, const T_V &amp;V, const T_W &amp;W, const T_m0 &amp;m0, const T_C0 &amp;C0)</td></tr>
<tr class="separator:gaa04df98134e973d4d3ce2e6ba814b18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6934fc9602ce46f9d5aeff1cd177dd9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 &gt; </td></tr>
<tr class="memitem:aa6934fc9602ce46f9d5aeff1cd177dd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_F, T_G, T_V, T_W, T_m0, T_C0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa6934fc9602ce46f9d5aeff1cd177dd9.html#aa6934fc9602ce46f9d5aeff1cd177dd9">gaussian_dlm_obs_lpdf</a> (const T_y &amp;y, const T_F &amp;F, const T_G &amp;G, const T_V &amp;V, const T_W &amp;W, const T_m0 &amp;m0, const T_C0 &amp;C0)</td></tr>
<tr class="separator:aa6934fc9602ce46f9d5aeff1cd177dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ce72e12b0f414f6c82f82f492db728"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ga38ce72e12b0f414f6c82f82f492db728"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga38ce72e12b0f414f6c82f82f492db728.html#ga38ce72e12b0f414f6c82f82f492db728">gaussian_dlm_obs_rng</a> (const Eigen::MatrixXd &amp;F, const Eigen::MatrixXd &amp;G, const Eigen::MatrixXd &amp;V, const Eigen::MatrixXd &amp;W, const Eigen::VectorXd &amp;m0, const Eigen::MatrixXd &amp;C0, const int T, RNG &amp;rng)</td></tr>
<tr class="separator:ga38ce72e12b0f414f6c82f82f492db728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e2a50622c4fd051bd31206f7c5d284"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:af8e2a50622c4fd051bd31206f7c5d284"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af8e2a50622c4fd051bd31206f7c5d284.html#af8e2a50622c4fd051bd31206f7c5d284">gaussian_dlm_obs_rng</a> (const Eigen::MatrixXd &amp;F, const Eigen::MatrixXd &amp;G, const Eigen::VectorXd &amp;V, const Eigen::MatrixXd &amp;W, const Eigen::VectorXd &amp;m0, const Eigen::MatrixXd &amp;C0, const int T, RNG &amp;rng)</td></tr>
<tr class="separator:af8e2a50622c4fd051bd31206f7c5d284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8be8a146d48f15f9478890bffc791caa"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga8be8a146d48f15f9478890bffc791caa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga8be8a146d48f15f9478890bffc791caa.html#ga8be8a146d48f15f9478890bffc791caa">gumbel_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga8be8a146d48f15f9478890bffc791caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75adc0e37b06d67b7ca98f5e56b3344b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga75adc0e37b06d67b7ca98f5e56b3344b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga75adc0e37b06d67b7ca98f5e56b3344b.html#ga75adc0e37b06d67b7ca98f5e56b3344b">gumbel_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga75adc0e37b06d67b7ca98f5e56b3344b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bef87063cf5bb813d4f5c06085e0b55"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga0bef87063cf5bb813d4f5c06085e0b55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga0bef87063cf5bb813d4f5c06085e0b55.html#ga0bef87063cf5bb813d4f5c06085e0b55">gumbel_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga0bef87063cf5bb813d4f5c06085e0b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e1c9649b547ab8e9a7dabf00cef1937"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3e1c9649b547ab8e9a7dabf00cef1937"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3e1c9649b547ab8e9a7dabf00cef1937.html#ga3e1c9649b547ab8e9a7dabf00cef1937">gumbel_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga3e1c9649b547ab8e9a7dabf00cef1937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b51015c5e0ac30b2eddddf55d9d6ea6"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8b51015c5e0ac30b2eddddf55d9d6ea6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga8b51015c5e0ac30b2eddddf55d9d6ea6.html#ga8b51015c5e0ac30b2eddddf55d9d6ea6">gumbel_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga8b51015c5e0ac30b2eddddf55d9d6ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9368c2bc40c0df41c65dee9908707c27"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga9368c2bc40c0df41c65dee9908707c27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga9368c2bc40c0df41c65dee9908707c27.html#ga9368c2bc40c0df41c65dee9908707c27">gumbel_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga9368c2bc40c0df41c65dee9908707c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae91d11e26a574bbaabf6857168f5d98c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gae91d11e26a574bbaabf6857168f5d98c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae91d11e26a574bbaabf6857168f5d98c.html#gae91d11e26a574bbaabf6857168f5d98c">gumbel_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gae91d11e26a574bbaabf6857168f5d98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2e25e81b8a0cc41cd0623d12394df66"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad2e25e81b8a0cc41cd0623d12394df66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad2e25e81b8a0cc41cd0623d12394df66.html#gad2e25e81b8a0cc41cd0623d12394df66">gumbel_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gad2e25e81b8a0cc41cd0623d12394df66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8728dcc0ad9b6006771a1eeddb52cdb7"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a8728dcc0ad9b6006771a1eeddb52cdb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8728dcc0ad9b6006771a1eeddb52cdb7.html#a8728dcc0ad9b6006771a1eeddb52cdb7">gumbel_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a8728dcc0ad9b6006771a1eeddb52cdb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae194f19e6b3f4b002e9eda5a1e1435f4"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:gae194f19e6b3f4b002e9eda5a1e1435f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae194f19e6b3f4b002e9eda5a1e1435f4.html#gae194f19e6b3f4b002e9eda5a1e1435f4">gumbel_rng</a> (const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, RNG &amp;rng)</td></tr>
<tr class="separator:gae194f19e6b3f4b002e9eda5a1e1435f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4d90af00a90b8416fe91015083d80b"><td class="memTemplParams" colspan="2">template&lt;typename T_omega , typename T_Gamma , typename T_rho , require_all_eigen_t&lt; T_omega, T_Gamma &gt; *  = nullptr, require_eigen_col_vector_t&lt; T_rho &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8c4d90af00a90b8416fe91015083d80b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8c4d90af00a90b8416fe91015083d80b.html#a8c4d90af00a90b8416fe91015083d80b">hmm_hidden_state_prob</a> (const T_omega &amp;log_omegas, const T_Gamma &amp;Gamma, const T_rho &amp;rho)</td></tr>
<tr class="memdesc:a8c4d90af00a90b8416fe91015083d80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a hidden Markov model with observation y, hidden state x, and parameters theta, compute the marginal probability vector for each x, given y and theta, p(x_i | y, theta).  <a href="namespacestan_1_1math_a8c4d90af00a90b8416fe91015083d80b.html#a8c4d90af00a90b8416fe91015083d80b">More...</a><br /></td></tr>
<tr class="separator:a8c4d90af00a90b8416fe91015083d80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269ef4cbc88b5a5e871240e5f4c1f5a2"><td class="memTemplParams" colspan="2">template&lt;typename T_omega , typename T_Gamma , typename T_rho , class RNG , require_all_eigen_t&lt; T_omega, T_Gamma &gt; *  = nullptr, require_eigen_col_vector_t&lt; T_rho &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a269ef4cbc88b5a5e871240e5f4c1f5a2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a269ef4cbc88b5a5e871240e5f4c1f5a2.html#a269ef4cbc88b5a5e871240e5f4c1f5a2">hmm_latent_rng</a> (const T_omega &amp;log_omegas, const T_Gamma &amp;Gamma, const T_rho &amp;rho, RNG &amp;rng)</td></tr>
<tr class="memdesc:a269ef4cbc88b5a5e871240e5f4c1f5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a hidden Markov model with observation y, hidden state x, and parameters theta, generate samples from the posterior distribution of the hidden states, x.  <a href="namespacestan_1_1math_a269ef4cbc88b5a5e871240e5f4c1f5a2.html#a269ef4cbc88b5a5e871240e5f4c1f5a2">More...</a><br /></td></tr>
<tr class="separator:a269ef4cbc88b5a5e871240e5f4c1f5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eaf3b46b9cc7ae34676432a48861885"><td class="memTemplParams" colspan="2">template&lt;typename T_omega , typename T_Gamma , typename T_rho , typename T_alpha &gt; </td></tr>
<tr class="memitem:a5eaf3b46b9cc7ae34676432a48861885"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5eaf3b46b9cc7ae34676432a48861885.html#a5eaf3b46b9cc7ae34676432a48861885">hmm_marginal_val</a> (const Eigen::Matrix&lt; T_omega, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;omegas, const T_Gamma &amp;Gamma_val, const T_rho &amp;rho_val, Eigen::Matrix&lt; T_alpha, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;alphas, Eigen::Matrix&lt; T_alpha, Eigen::Dynamic, 1 &gt; &amp;alpha_log_norms, T_alpha &amp;norm_norm)</td></tr>
<tr class="separator:a5eaf3b46b9cc7ae34676432a48861885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8399d29cac9cd55ba9ef337d635029"><td class="memTemplParams" colspan="2">template&lt;typename T_omega , typename T_Gamma , typename T_rho , require_all_eigen_t&lt; T_omega, T_Gamma &gt; *  = nullptr, require_eigen_col_vector_t&lt; T_rho &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3c8399d29cac9cd55ba9ef337d635029"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3c8399d29cac9cd55ba9ef337d635029.html#a3c8399d29cac9cd55ba9ef337d635029">hmm_marginal</a> (const T_omega &amp;log_omegas, const T_Gamma &amp;Gamma, const T_rho &amp;rho)</td></tr>
<tr class="memdesc:a3c8399d29cac9cd55ba9ef337d635029"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a Hidden Markov Model with observation y, hidden state x, and parameters theta, return the log marginal density, log p(y | theta).  <a href="namespacestan_1_1math_a3c8399d29cac9cd55ba9ef337d635029.html#a3c8399d29cac9cd55ba9ef337d635029">More...</a><br /></td></tr>
<tr class="separator:a3c8399d29cac9cd55ba9ef337d635029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf091835ddc913687ab4d34c3eee662e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_N , typename T_a , typename T_b &gt; </td></tr>
<tr class="memitem:gacf091835ddc913687ab4d34c3eee662e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gacf091835ddc913687ab4d34c3eee662e.html#gacf091835ddc913687ab4d34c3eee662e">hypergeometric_log</a> (const T_n &amp;n, const T_N &amp;N, const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:gacf091835ddc913687ab4d34c3eee662e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28d194254677d4503c2f5d7c6c4f6224"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_a , typename T_b &gt; </td></tr>
<tr class="memitem:ga28d194254677d4503c2f5d7c6c4f6224"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga28d194254677d4503c2f5d7c6c4f6224.html#ga28d194254677d4503c2f5d7c6c4f6224">hypergeometric_log</a> (const T_n &amp;n, const T_N &amp;N, const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:ga28d194254677d4503c2f5d7c6c4f6224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122d20a5a9f185c9bc37291e00fc13d5"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_N , typename T_a , typename T_b &gt; </td></tr>
<tr class="memitem:a122d20a5a9f185c9bc37291e00fc13d5"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a122d20a5a9f185c9bc37291e00fc13d5.html#a122d20a5a9f185c9bc37291e00fc13d5">hypergeometric_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:a122d20a5a9f185c9bc37291e00fc13d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538aabd76ed5749ca24a6a1ce7bc2f1a"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_a , typename T_b &gt; </td></tr>
<tr class="memitem:a538aabd76ed5749ca24a6a1ce7bc2f1a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a538aabd76ed5749ca24a6a1ce7bc2f1a.html#a538aabd76ed5749ca24a6a1ce7bc2f1a">hypergeometric_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:a538aabd76ed5749ca24a6a1ce7bc2f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3878889879be4781cc8d560f534ab123"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a3878889879be4781cc8d560f534ab123"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3878889879be4781cc8d560f534ab123.html#a3878889879be4781cc8d560f534ab123">hypergeometric_rng</a> (int N, int a, int b, RNG &amp;rng)</td></tr>
<tr class="separator:a3878889879be4781cc8d560f534ab123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34d4f6912a78ff5341a7566017282757"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:ga34d4f6912a78ff5341a7566017282757"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga34d4f6912a78ff5341a7566017282757.html#ga34d4f6912a78ff5341a7566017282757">inv_chi_square_ccdf_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:ga34d4f6912a78ff5341a7566017282757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6bdb9f631f0aa028fbca67833014463"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:gab6bdb9f631f0aa028fbca67833014463"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab6bdb9f631f0aa028fbca67833014463.html#gab6bdb9f631f0aa028fbca67833014463">inv_chi_square_cdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:gab6bdb9f631f0aa028fbca67833014463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65e7d8dffa7e6f9e32de3879b283c48f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:ga65e7d8dffa7e6f9e32de3879b283c48f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga65e7d8dffa7e6f9e32de3879b283c48f.html#ga65e7d8dffa7e6f9e32de3879b283c48f">inv_chi_square_cdf_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:ga65e7d8dffa7e6f9e32de3879b283c48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9388cd0b7ba81de141bf3feb243aa497"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:ga9388cd0b7ba81de141bf3feb243aa497"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga9388cd0b7ba81de141bf3feb243aa497.html#ga9388cd0b7ba81de141bf3feb243aa497">inv_chi_square_lccdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:ga9388cd0b7ba81de141bf3feb243aa497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade2cdcd692aa9fdd37554a65296fc07b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:gade2cdcd692aa9fdd37554a65296fc07b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gade2cdcd692aa9fdd37554a65296fc07b.html#gade2cdcd692aa9fdd37554a65296fc07b">inv_chi_square_lcdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:gade2cdcd692aa9fdd37554a65296fc07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee5f42f1add2083418fa6e4cce8f2e2e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:gaee5f42f1add2083418fa6e4cce8f2e2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaee5f42f1add2083418fa6e4cce8f2e2e.html#gaee5f42f1add2083418fa6e4cce8f2e2e">inv_chi_square_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:gaee5f42f1add2083418fa6e4cce8f2e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8742d4ede40e378ba65eb919765b814"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:gab8742d4ede40e378ba65eb919765b814"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab8742d4ede40e378ba65eb919765b814.html#gab8742d4ede40e378ba65eb919765b814">inv_chi_square_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:gab8742d4ede40e378ba65eb919765b814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d62bf9d289353e39aeea701b7c7ea68"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_dof &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0d62bf9d289353e39aeea701b7c7ea68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga0d62bf9d289353e39aeea701b7c7ea68.html#ga0d62bf9d289353e39aeea701b7c7ea68">inv_chi_square_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:ga0d62bf9d289353e39aeea701b7c7ea68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c58ff5348570c7869c8c048ffba031"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:ae4c58ff5348570c7869c8c048ffba031"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae4c58ff5348570c7869c8c048ffba031.html#ae4c58ff5348570c7869c8c048ffba031">inv_chi_square_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:ae4c58ff5348570c7869c8c048ffba031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3c1ee327e993ad4dbc08be9d876b3ff"><td class="memTemplParams" colspan="2">template&lt;typename T_deg , class RNG &gt; </td></tr>
<tr class="memitem:gac3c1ee327e993ad4dbc08be9d876b3ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_deg &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gac3c1ee327e993ad4dbc08be9d876b3ff.html#gac3c1ee327e993ad4dbc08be9d876b3ff">inv_chi_square_rng</a> (const T_deg &amp;nu, RNG &amp;rng)</td></tr>
<tr class="separator:gac3c1ee327e993ad4dbc08be9d876b3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad69d6321fb3b4eddbfd96e6442b2ca93"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:gad69d6321fb3b4eddbfd96e6442b2ca93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad69d6321fb3b4eddbfd96e6442b2ca93.html#gad69d6321fb3b4eddbfd96e6442b2ca93">inv_gamma_ccdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gad69d6321fb3b4eddbfd96e6442b2ca93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1da95543e6dea26fe34497fbd9b063d5"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ga1da95543e6dea26fe34497fbd9b063d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga1da95543e6dea26fe34497fbd9b063d5.html#ga1da95543e6dea26fe34497fbd9b063d5">inv_gamma_cdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga1da95543e6dea26fe34497fbd9b063d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e5f2519f3df90e2a10c150089d0ec0e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ga9e5f2519f3df90e2a10c150089d0ec0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga9e5f2519f3df90e2a10c150089d0ec0e.html#ga9e5f2519f3df90e2a10c150089d0ec0e">inv_gamma_cdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga9e5f2519f3df90e2a10c150089d0ec0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995a63464ce875b6209be47ada3356f5"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:a995a63464ce875b6209be47ada3356f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a995a63464ce875b6209be47ada3356f5.html#a995a63464ce875b6209be47ada3356f5">inv_gamma_lccdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a995a63464ce875b6209be47ada3356f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57695031c7d472c1ee4876a0ba8ee3e5"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:a57695031c7d472c1ee4876a0ba8ee3e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a57695031c7d472c1ee4876a0ba8ee3e5.html#a57695031c7d472c1ee4876a0ba8ee3e5">inv_gamma_lcdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a57695031c7d472c1ee4876a0ba8ee3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b563fa702c99f60857c9a5cdca58deb"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ga4b563fa702c99f60857c9a5cdca58deb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga4b563fa702c99f60857c9a5cdca58deb.html#ga4b563fa702c99f60857c9a5cdca58deb">inv_gamma_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga4b563fa702c99f60857c9a5cdca58deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ebad8e555ba5beec57462f8fbf432fe"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ga7ebad8e555ba5beec57462f8fbf432fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga7ebad8e555ba5beec57462f8fbf432fe.html#ga7ebad8e555ba5beec57462f8fbf432fe">inv_gamma_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga7ebad8e555ba5beec57462f8fbf432fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f2b3598a214eaa23441577befef2cc7"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3f2b3598a214eaa23441577befef2cc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3f2b3598a214eaa23441577befef2cc7.html#ga3f2b3598a214eaa23441577befef2cc7">inv_gamma_lpdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga3f2b3598a214eaa23441577befef2cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f861c0b68dbab22a93a5b35098f0fd1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:a2f861c0b68dbab22a93a5b35098f0fd1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f861c0b68dbab22a93a5b35098f0fd1.html#a2f861c0b68dbab22a93a5b35098f0fd1">inv_gamma_lpdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a2f861c0b68dbab22a93a5b35098f0fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9a0ca1aa6a7ec3943e8041ae5f5ec50"><td class="memTemplParams" colspan="2">template&lt;typename T_shape , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:gac9a0ca1aa6a7ec3943e8041ae5f5ec50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_shape, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gac9a0ca1aa6a7ec3943e8041ae5f5ec50.html#gac9a0ca1aa6a7ec3943e8041ae5f5ec50">inv_gamma_rng</a> (const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, RNG &amp;rng)</td></tr>
<tr class="separator:gac9a0ca1aa6a7ec3943e8041ae5f5ec50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20428ab1d29b65d9904ee11515af5d41"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale , require_stan_scalar_t&lt; T_dof &gt; *  = nullptr, require_all_matrix_t&lt; T_y, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga20428ab1d29b65d9904ee11515af5d41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga20428ab1d29b65d9904ee11515af5d41.html#ga20428ab1d29b65d9904ee11515af5d41">inv_wishart_cholesky_lpdf</a> (const T_y &amp;L_Y, const T_dof &amp;nu, const T_scale &amp;L_S)</td></tr>
<tr class="separator:ga20428ab1d29b65d9904ee11515af5d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9c65f9dc8ce3cf53a4e2e51b104735"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:aec9c65f9dc8ce3cf53a4e2e51b104735"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aec9c65f9dc8ce3cf53a4e2e51b104735.html#aec9c65f9dc8ce3cf53a4e2e51b104735">inv_wishart_cholesky_lpdf</a> (const T_y &amp;L_Y, const T_dof &amp;nu, const T_scale &amp;L_S)</td></tr>
<tr class="separator:aec9c65f9dc8ce3cf53a4e2e51b104735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9efca9c1665e598b602eb1885a69680"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:gad9efca9c1665e598b602eb1885a69680"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gad9efca9c1665e598b602eb1885a69680.html#gad9efca9c1665e598b602eb1885a69680">inv_wishart_cholesky_rng</a> (double nu, const Eigen::MatrixXd &amp;L_S, RNG &amp;rng)</td></tr>
<tr class="separator:gad9efca9c1665e598b602eb1885a69680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40f6b9636708f5cf52428890f2b62c2"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:gaa40f6b9636708f5cf52428890f2b62c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gaa40f6b9636708f5cf52428890f2b62c2.html#gaa40f6b9636708f5cf52428890f2b62c2">inv_wishart_log</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="separator:gaa40f6b9636708f5cf52428890f2b62c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b83a2e763ad50ebace73c003cdffee2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:ga7b83a2e763ad50ebace73c003cdffee2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga7b83a2e763ad50ebace73c003cdffee2.html#ga7b83a2e763ad50ebace73c003cdffee2">inv_wishart_log</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="separator:ga7b83a2e763ad50ebace73c003cdffee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bab1543379d2e07160d395b2e0a832c"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:ga3bab1543379d2e07160d395b2e0a832c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga3bab1543379d2e07160d395b2e0a832c.html#ga3bab1543379d2e07160d395b2e0a832c">inv_wishart_lpdf</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="separator:ga3bab1543379d2e07160d395b2e0a832c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d30cbde107286d764a9f121a34b478f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:a7d30cbde107286d764a9f121a34b478f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7d30cbde107286d764a9f121a34b478f.html#a7d30cbde107286d764a9f121a34b478f">inv_wishart_lpdf</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="separator:a7d30cbde107286d764a9f121a34b478f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717784073dda2d26fdd3cc127c29b5df"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a717784073dda2d26fdd3cc127c29b5df"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a717784073dda2d26fdd3cc127c29b5df.html#a717784073dda2d26fdd3cc127c29b5df">inv_wishart_rng</a> (double nu, const Eigen::MatrixXd &amp;S, RNG &amp;rng)</td></tr>
<tr class="separator:a717784073dda2d26fdd3cc127c29b5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4f34ffe4fb4185f64f05b28899bf1be"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_covar , typename T_shape &gt; </td></tr>
<tr class="memitem:gad4f34ffe4fb4185f64f05b28899bf1be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_covar, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gad4f34ffe4fb4185f64f05b28899bf1be.html#gad4f34ffe4fb4185f64f05b28899bf1be">lkj_corr_cholesky_log</a> (const T_covar &amp;L, const T_shape &amp;eta)</td></tr>
<tr class="separator:gad4f34ffe4fb4185f64f05b28899bf1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf932f9050e5cd92af767842e35978ec9"><td class="memTemplParams" colspan="2">template&lt;typename T_covar , typename T_shape &gt; </td></tr>
<tr class="memitem:gaf932f9050e5cd92af767842e35978ec9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_covar, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gaf932f9050e5cd92af767842e35978ec9.html#gaf932f9050e5cd92af767842e35978ec9">lkj_corr_cholesky_log</a> (const T_covar &amp;L, const T_shape &amp;eta)</td></tr>
<tr class="separator:gaf932f9050e5cd92af767842e35978ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e7ada882eba62874d4a0ac708b8845"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_covar , typename T_shape &gt; </td></tr>
<tr class="memitem:a18e7ada882eba62874d4a0ac708b8845"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_covar, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a18e7ada882eba62874d4a0ac708b8845.html#a18e7ada882eba62874d4a0ac708b8845">lkj_corr_cholesky_lpdf</a> (const T_covar &amp;L, const T_shape &amp;eta)</td></tr>
<tr class="separator:a18e7ada882eba62874d4a0ac708b8845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a62fcd9d19c3ae6c55359f9285e99a1"><td class="memTemplParams" colspan="2">template&lt;typename T_covar , typename T_shape &gt; </td></tr>
<tr class="memitem:a4a62fcd9d19c3ae6c55359f9285e99a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_covar, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a62fcd9d19c3ae6c55359f9285e99a1.html#a4a62fcd9d19c3ae6c55359f9285e99a1">lkj_corr_cholesky_lpdf</a> (const T_covar &amp;L, const T_shape &amp;eta)</td></tr>
<tr class="separator:a4a62fcd9d19c3ae6c55359f9285e99a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924c168990c6fa25b9443788655cc73d"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a924c168990c6fa25b9443788655cc73d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a924c168990c6fa25b9443788655cc73d.html#a924c168990c6fa25b9443788655cc73d">lkj_corr_cholesky_rng</a> (size_t K, double eta, RNG &amp;rng)</td></tr>
<tr class="separator:a924c168990c6fa25b9443788655cc73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42a03d6d4728db20bc6ba51f6890004f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape &gt; </td></tr>
<tr class="memitem:ga42a03d6d4728db20bc6ba51f6890004f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga42a03d6d4728db20bc6ba51f6890004f.html#ga42a03d6d4728db20bc6ba51f6890004f">lkj_corr_log</a> (const T_y &amp;y, const T_shape &amp;eta)</td></tr>
<tr class="separator:ga42a03d6d4728db20bc6ba51f6890004f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae537974c3f5c4d51df02883faf940514"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape &gt; </td></tr>
<tr class="memitem:gae537974c3f5c4d51df02883faf940514"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gae537974c3f5c4d51df02883faf940514.html#gae537974c3f5c4d51df02883faf940514">lkj_corr_log</a> (const T_y &amp;y, const T_shape &amp;eta)</td></tr>
<tr class="separator:gae537974c3f5c4d51df02883faf940514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c8ef8898b00351737a17f63dc18de5"><td class="memTemplParams" colspan="2">template&lt;typename T_shape &gt; </td></tr>
<tr class="memitem:ae0c8ef8898b00351737a17f63dc18de5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; double, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae0c8ef8898b00351737a17f63dc18de5.html#ae0c8ef8898b00351737a17f63dc18de5">do_lkj_constant</a> (const T_shape &amp;eta, const unsigned int &amp;K)</td></tr>
<tr class="separator:ae0c8ef8898b00351737a17f63dc18de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013afc7e4feb412c450d8d9ffc7ec6a5"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape &gt; </td></tr>
<tr class="memitem:a013afc7e4feb412c450d8d9ffc7ec6a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a013afc7e4feb412c450d8d9ffc7ec6a5.html#a013afc7e4feb412c450d8d9ffc7ec6a5">lkj_corr_lpdf</a> (const T_y &amp;y, const T_shape &amp;eta)</td></tr>
<tr class="separator:a013afc7e4feb412c450d8d9ffc7ec6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1eee2d171e8c78f85292bc9619cc266"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape &gt; </td></tr>
<tr class="memitem:af1eee2d171e8c78f85292bc9619cc266"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af1eee2d171e8c78f85292bc9619cc266.html#af1eee2d171e8c78f85292bc9619cc266">lkj_corr_lpdf</a> (const T_y &amp;y, const T_shape &amp;eta)</td></tr>
<tr class="separator:af1eee2d171e8c78f85292bc9619cc266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5570fda8e3d07213840dc2a9f4155e18"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ga5570fda8e3d07213840dc2a9f4155e18"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga5570fda8e3d07213840dc2a9f4155e18.html#ga5570fda8e3d07213840dc2a9f4155e18">lkj_corr_rng</a> (size_t K, double eta, RNG &amp;rng)</td></tr>
<tr class="separator:ga5570fda8e3d07213840dc2a9f4155e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf76c55d89307f751df515b9b11df006c"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:gaf76c55d89307f751df515b9b11df006c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gaf76c55d89307f751df515b9b11df006c.html#gaf76c55d89307f751df515b9b11df006c">lkj_cov_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;eta)</td></tr>
<tr class="separator:gaf76c55d89307f751df515b9b11df006c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1263a19d3a44357832c1baafe3fb4df2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ga1263a19d3a44357832c1baafe3fb4df2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga1263a19d3a44357832c1baafe3fb4df2.html#ga1263a19d3a44357832c1baafe3fb4df2">lkj_cov_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;eta)</td></tr>
<tr class="separator:ga1263a19d3a44357832c1baafe3fb4df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ca6e33a747117a587f44348ed94409"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape , require_eigen_matrix_dynamic_t&lt; T_y &gt; *  = nullptr, require_all_eigen_col_vector_t&lt; T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a42ca6e33a747117a587f44348ed94409"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a42ca6e33a747117a587f44348ed94409.html#a42ca6e33a747117a587f44348ed94409">lkj_cov_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;eta)</td></tr>
<tr class="separator:a42ca6e33a747117a587f44348ed94409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd6c0c23c8e18e9ebaa67bc05253773"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:acbd6c0c23c8e18e9ebaa67bc05253773"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acbd6c0c23c8e18e9ebaa67bc05253773.html#acbd6c0c23c8e18e9ebaa67bc05253773">lkj_cov_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;eta)</td></tr>
<tr class="separator:acbd6c0c23c8e18e9ebaa67bc05253773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7b9a7c8ccb2e58943f54212cd02694c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gaf7b9a7c8ccb2e58943f54212cd02694c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaf7b9a7c8ccb2e58943f54212cd02694c.html#gaf7b9a7c8ccb2e58943f54212cd02694c">logistic_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gaf7b9a7c8ccb2e58943f54212cd02694c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab62716ac05c47ff698b253c01010e3e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aab62716ac05c47ff698b253c01010e3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab62716ac05c47ff698b253c01010e3e.html#aab62716ac05c47ff698b253c01010e3e">logistic_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aab62716ac05c47ff698b253c01010e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa38b7464840b2c821727797594d8233"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gafa38b7464840b2c821727797594d8233"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gafa38b7464840b2c821727797594d8233.html#gafa38b7464840b2c821727797594d8233">logistic_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gafa38b7464840b2c821727797594d8233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389b87eb46db3622fcd1dc539bf9dc60"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a389b87eb46db3622fcd1dc539bf9dc60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a389b87eb46db3622fcd1dc539bf9dc60.html#a389b87eb46db3622fcd1dc539bf9dc60">logistic_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a389b87eb46db3622fcd1dc539bf9dc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f4e8422377fc80b73140c3e181bf70"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a93f4e8422377fc80b73140c3e181bf70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a93f4e8422377fc80b73140c3e181bf70.html#a93f4e8422377fc80b73140c3e181bf70">logistic_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a93f4e8422377fc80b73140c3e181bf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafadb55e8d2c5de5d0d2980ea2c403175"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gafadb55e8d2c5de5d0d2980ea2c403175"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gafadb55e8d2c5de5d0d2980ea2c403175.html#gafadb55e8d2c5de5d0d2980ea2c403175">logistic_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gafadb55e8d2c5de5d0d2980ea2c403175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bfec49457e114d7df411965efe953b8"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga4bfec49457e114d7df411965efe953b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga4bfec49457e114d7df411965efe953b8.html#ga4bfec49457e114d7df411965efe953b8">logistic_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga4bfec49457e114d7df411965efe953b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481202d1a37a905ad5cd6cd19baff674"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a481202d1a37a905ad5cd6cd19baff674"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a481202d1a37a905ad5cd6cd19baff674.html#a481202d1a37a905ad5cd6cd19baff674">logistic_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a481202d1a37a905ad5cd6cd19baff674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c7b3d6752d62a6503d865012087861"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a30c7b3d6752d62a6503d865012087861"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a30c7b3d6752d62a6503d865012087861.html#a30c7b3d6752d62a6503d865012087861">logistic_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a30c7b3d6752d62a6503d865012087861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab861f93a22414e7b7a63bcde7c14474c"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:gab861f93a22414e7b7a63bcde7c14474c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab861f93a22414e7b7a63bcde7c14474c.html#gab861f93a22414e7b7a63bcde7c14474c">logistic_rng</a> (const T_loc &amp;mu, const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="separator:gab861f93a22414e7b7a63bcde7c14474c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d6bd462326ae3c6b95c59e0a57f8b67"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0d6bd462326ae3c6b95c59e0a57f8b67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga0d6bd462326ae3c6b95c59e0a57f8b67.html#ga0d6bd462326ae3c6b95c59e0a57f8b67">loglogistic_cdf</a> (const T_y &amp;y, const T_scale &amp;alpha, const T_shape &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga0d6bd462326ae3c6b95c59e0a57f8b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e9d039c7b11afe3ae1acd8b674258a9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_scale , typename T_shape , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1e9d039c7b11afe3ae1acd8b674258a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga1e9d039c7b11afe3ae1acd8b674258a9.html#ga1e9d039c7b11afe3ae1acd8b674258a9">loglogistic_log</a> (const T_y &amp;y, const T_scale &amp;alpha, const T_shape &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga1e9d039c7b11afe3ae1acd8b674258a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8ee851a9542f669b00275617503d665"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:gac8ee851a9542f669b00275617503d665"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gac8ee851a9542f669b00275617503d665.html#gac8ee851a9542f669b00275617503d665">loglogistic_log</a> (const T_y &amp;y, const T_scale &amp;alpha, const T_shape &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gac8ee851a9542f669b00275617503d665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6307db607d22c311b2a66f73327cfb7"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_scale , typename T_shape , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa6307db607d22c311b2a66f73327cfb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaa6307db607d22c311b2a66f73327cfb7.html#gaa6307db607d22c311b2a66f73327cfb7">loglogistic_lpdf</a> (const T_y &amp;y, const T_scale &amp;alpha, const T_shape &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaa6307db607d22c311b2a66f73327cfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedf5f3754bc051592d933e588c85b5e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:afedf5f3754bc051592d933e588c85b5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afedf5f3754bc051592d933e588c85b5e.html#afedf5f3754bc051592d933e588c85b5e">loglogistic_lpdf</a> (const T_y &amp;y, const T_scale &amp;alpha, const T_shape &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:afedf5f3754bc051592d933e588c85b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1584c31ff67d497009a58172fcfbdb99"><td class="memTemplParams" colspan="2">template&lt;typename T_scale , typename T_shape , class RNG &gt; </td></tr>
<tr class="memitem:ga1584c31ff67d497009a58172fcfbdb99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_scale, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga1584c31ff67d497009a58172fcfbdb99.html#ga1584c31ff67d497009a58172fcfbdb99">loglogistic_rng</a> (const T_scale &amp;alpha, const T_shape &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, RNG &amp;rng)</td></tr>
<tr class="separator:ga1584c31ff67d497009a58172fcfbdb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5413325be11d6684ed173880dd7c4d39"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga5413325be11d6684ed173880dd7c4d39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga5413325be11d6684ed173880dd7c4d39.html#ga5413325be11d6684ed173880dd7c4d39">lognormal_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga5413325be11d6684ed173880dd7c4d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dda456447c5258c694804371ea3c35"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa8dda456447c5258c694804371ea3c35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa8dda456447c5258c694804371ea3c35.html#aa8dda456447c5258c694804371ea3c35">lognormal_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aa8dda456447c5258c694804371ea3c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1a9f64bdcb7cc6eb94b5bda93c8f34e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gaf1a9f64bdcb7cc6eb94b5bda93c8f34e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaf1a9f64bdcb7cc6eb94b5bda93c8f34e.html#gaf1a9f64bdcb7cc6eb94b5bda93c8f34e">lognormal_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gaf1a9f64bdcb7cc6eb94b5bda93c8f34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eb52b2c18de41bb28e93a152673d69"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa1eb52b2c18de41bb28e93a152673d69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa1eb52b2c18de41bb28e93a152673d69.html#aa1eb52b2c18de41bb28e93a152673d69">lognormal_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aa1eb52b2c18de41bb28e93a152673d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef4ca22d98432b9ff7f63ac971f0320"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afef4ca22d98432b9ff7f63ac971f0320"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afef4ca22d98432b9ff7f63ac971f0320.html#afef4ca22d98432b9ff7f63ac971f0320">lognormal_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:afef4ca22d98432b9ff7f63ac971f0320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc1785246d3aecb6f53cf7f6c8537cf9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gadc1785246d3aecb6f53cf7f6c8537cf9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gadc1785246d3aecb6f53cf7f6c8537cf9.html#gadc1785246d3aecb6f53cf7f6c8537cf9">lognormal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gadc1785246d3aecb6f53cf7f6c8537cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad486fa6a812f8d9ed18a332fd720585"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gaad486fa6a812f8d9ed18a332fd720585"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaad486fa6a812f8d9ed18a332fd720585.html#gaad486fa6a812f8d9ed18a332fd720585">lognormal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gaad486fa6a812f8d9ed18a332fd720585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf784cb53cbdf7465afd583676a2eb15"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abf784cb53cbdf7465afd583676a2eb15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abf784cb53cbdf7465afd583676a2eb15.html#abf784cb53cbdf7465afd583676a2eb15">lognormal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:abf784cb53cbdf7465afd583676a2eb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e8c1d8b532f96162b9a91d0d79969e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ae1e8c1d8b532f96162b9a91d0d79969e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae1e8c1d8b532f96162b9a91d0d79969e.html#ae1e8c1d8b532f96162b9a91d0d79969e">lognormal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ae1e8c1d8b532f96162b9a91d0d79969e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd3038da2e11fedd93af3906ee585e0b"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:gacd3038da2e11fedd93af3906ee585e0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gacd3038da2e11fedd93af3906ee585e0b.html#gacd3038da2e11fedd93af3906ee585e0b">lognormal_rng</a> (const T_loc &amp;mu, const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="separator:gacd3038da2e11fedd93af3906ee585e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64262a3799093d51c79227c7ef409094"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_Mu , typename T_Sigma , typename T_D , require_all_matrix_t&lt; T_y, T_Mu, T_Sigma, T_D &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga64262a3799093d51c79227c7ef409094"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_Mu, T_Sigma, T_D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga64262a3799093d51c79227c7ef409094.html#ga64262a3799093d51c79227c7ef409094">matrix_normal_prec_log</a> (const T_y &amp;y, const T_Mu &amp;Mu, const T_Sigma &amp;Sigma, const T_D &amp;D)</td></tr>
<tr class="separator:ga64262a3799093d51c79227c7ef409094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c0d07cf387dd011b3d244907813488"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_Mu , typename T_Sigma , typename T_D , require_all_matrix_t&lt; T_y, T_Mu, T_Sigma, T_D &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab7c0d07cf387dd011b3d244907813488"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_Mu, T_Sigma, T_D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gab7c0d07cf387dd011b3d244907813488.html#gab7c0d07cf387dd011b3d244907813488">matrix_normal_prec_log</a> (const T_y &amp;y, const T_Mu &amp;Mu, const T_Sigma &amp;Sigma, const T_D &amp;D)</td></tr>
<tr class="separator:gab7c0d07cf387dd011b3d244907813488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafacda7490d4f642b087dbf55274bcb9a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_Mu , typename T_Sigma , typename T_D , require_all_matrix_t&lt; T_y, T_Mu, T_Sigma, T_D &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gafacda7490d4f642b087dbf55274bcb9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_Mu, T_Sigma, T_D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gafacda7490d4f642b087dbf55274bcb9a.html#gafacda7490d4f642b087dbf55274bcb9a">matrix_normal_prec_lpdf</a> (const T_y &amp;y, const T_Mu &amp;Mu, const T_Sigma &amp;Sigma, const T_D &amp;D)</td></tr>
<tr class="separator:gafacda7490d4f642b087dbf55274bcb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2851eae2252ed4f2e27eb57c42e5c31"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_Mu , typename T_Sigma , typename T_D , require_all_matrix_t&lt; T_y, T_Mu, T_Sigma, T_D &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac2851eae2252ed4f2e27eb57c42e5c31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_Mu, T_Sigma, T_D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac2851eae2252ed4f2e27eb57c42e5c31.html#ac2851eae2252ed4f2e27eb57c42e5c31">matrix_normal_prec_lpdf</a> (const T_y &amp;y, const T_Mu &amp;Mu, const T_Sigma &amp;Sigma, const T_D &amp;D)</td></tr>
<tr class="separator:ac2851eae2252ed4f2e27eb57c42e5c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e4ff308feab4aaf90dd7036f85667d2"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ga3e4ff308feab4aaf90dd7036f85667d2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga3e4ff308feab4aaf90dd7036f85667d2.html#ga3e4ff308feab4aaf90dd7036f85667d2">matrix_normal_prec_rng</a> (const Eigen::MatrixXd &amp;Mu, const Eigen::MatrixXd &amp;Sigma, const Eigen::MatrixXd &amp;D, RNG &amp;rng)</td></tr>
<tr class="separator:ga3e4ff308feab4aaf90dd7036f85667d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92e43d15693f5421f3a8a85b903e8a22"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_covar , typename T_w &gt; </td></tr>
<tr class="memitem:ga92e43d15693f5421f3a8a85b903e8a22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga92e43d15693f5421f3a8a85b903e8a22.html#ga92e43d15693f5421f3a8a85b903e8a22">multi_gp_cholesky_log</a> (const T_y &amp;y, const T_covar &amp;L, const T_w &amp;w)</td></tr>
<tr class="separator:ga92e43d15693f5421f3a8a85b903e8a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80d0035ddc21ae34c30faeee40995456"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_covar , typename T_w &gt; </td></tr>
<tr class="memitem:ga80d0035ddc21ae34c30faeee40995456"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga80d0035ddc21ae34c30faeee40995456.html#ga80d0035ddc21ae34c30faeee40995456">multi_gp_cholesky_log</a> (const T_y &amp;y, const T_covar &amp;L, const T_w &amp;w)</td></tr>
<tr class="separator:ga80d0035ddc21ae34c30faeee40995456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac52b7477faba2eb49537ec31d4d5461f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_covar , typename T_w , require_all_eigen_matrix_dynamic_t&lt; T_y, T_covar &gt; *  = nullptr, require_eigen_col_vector_t&lt; T_w &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac52b7477faba2eb49537ec31d4d5461f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gac52b7477faba2eb49537ec31d4d5461f.html#gac52b7477faba2eb49537ec31d4d5461f">multi_gp_cholesky_lpdf</a> (const T_y &amp;y, const T_covar &amp;L, const T_w &amp;w)</td></tr>
<tr class="separator:gac52b7477faba2eb49537ec31d4d5461f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ede451bdd049f72e59d17fa5f027ad"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_covar , typename T_w &gt; </td></tr>
<tr class="memitem:aa9ede451bdd049f72e59d17fa5f027ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa9ede451bdd049f72e59d17fa5f027ad.html#aa9ede451bdd049f72e59d17fa5f027ad">multi_gp_cholesky_lpdf</a> (const T_y &amp;y, const T_covar &amp;L, const T_w &amp;w)</td></tr>
<tr class="separator:aa9ede451bdd049f72e59d17fa5f027ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac395a822d38d24a39ef02e695435c7f4"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_covar , typename T_w &gt; </td></tr>
<tr class="memitem:gac395a822d38d24a39ef02e695435c7f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gac395a822d38d24a39ef02e695435c7f4.html#gac395a822d38d24a39ef02e695435c7f4">multi_gp_log</a> (const T_y &amp;y, const T_covar &amp;Sigma, const T_w &amp;w)</td></tr>
<tr class="separator:gac395a822d38d24a39ef02e695435c7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa0a8ceba99d5354ab0fa1fc385b44e9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_covar , typename T_w &gt; </td></tr>
<tr class="memitem:gaaa0a8ceba99d5354ab0fa1fc385b44e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gaaa0a8ceba99d5354ab0fa1fc385b44e9.html#gaaa0a8ceba99d5354ab0fa1fc385b44e9">multi_gp_log</a> (const T_y &amp;y, const T_covar &amp;Sigma, const T_w &amp;w)</td></tr>
<tr class="separator:gaaa0a8ceba99d5354ab0fa1fc385b44e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9a55dfe7ed454e7972010da608c530"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_covar , typename T_w , require_all_matrix_t&lt; T_y, T_covar &gt; *  = nullptr, require_col_vector_t&lt; T_w &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0d9a55dfe7ed454e7972010da608c530"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga0d9a55dfe7ed454e7972010da608c530.html#ga0d9a55dfe7ed454e7972010da608c530">multi_gp_lpdf</a> (const T_y &amp;y, const T_covar &amp;Sigma, const T_w &amp;w)</td></tr>
<tr class="separator:ga0d9a55dfe7ed454e7972010da608c530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d6d9bbae381689683bea858849c9b7"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_covar , typename T_w &gt; </td></tr>
<tr class="memitem:a22d6d9bbae381689683bea858849c9b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a22d6d9bbae381689683bea858849c9b7.html#a22d6d9bbae381689683bea858849c9b7">multi_gp_lpdf</a> (const T_y &amp;y, const T_covar &amp;Sigma, const T_w &amp;w)</td></tr>
<tr class="separator:a22d6d9bbae381689683bea858849c9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace251fa4176a6620b0cc601eea04c0c5"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:gace251fa4176a6620b0cc601eea04c0c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gace251fa4176a6620b0cc601eea04c0c5.html#gace251fa4176a6620b0cc601eea04c0c5">multi_normal_cholesky_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;L)</td></tr>
<tr class="separator:gace251fa4176a6620b0cc601eea04c0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ee11ca85a43b351e4d8975a665f6328"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:ga6ee11ca85a43b351e4d8975a665f6328"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga6ee11ca85a43b351e4d8975a665f6328.html#ga6ee11ca85a43b351e4d8975a665f6328">multi_normal_cholesky_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;L)</td></tr>
<tr class="separator:ga6ee11ca85a43b351e4d8975a665f6328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eb6d17039a2b39b4a571176da01480d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_covar , require_any_not_vector_vt&lt; is_stan_scalar, T_y, T_loc &gt; *  = nullptr, require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_covar &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6eb6d17039a2b39b4a571176da01480d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga6eb6d17039a2b39b4a571176da01480d.html#ga6eb6d17039a2b39b4a571176da01480d">multi_normal_cholesky_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;L)</td></tr>
<tr class="separator:ga6eb6d17039a2b39b4a571176da01480d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb6afc33d163f94b2717e76aad54474"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:a4bb6afc33d163f94b2717e76aad54474"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4bb6afc33d163f94b2717e76aad54474.html#a4bb6afc33d163f94b2717e76aad54474">multi_normal_cholesky_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;L)</td></tr>
<tr class="separator:a4bb6afc33d163f94b2717e76aad54474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8768d74289b60b1a89cfc60050e137d9"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , class RNG &gt; </td></tr>
<tr class="memitem:ga8768d74289b60b1a89cfc60050e137d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_std_vector_builder.html">StdVectorBuilder</a>&lt; true, Eigen::VectorXd, T_loc &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga8768d74289b60b1a89cfc60050e137d9.html#ga8768d74289b60b1a89cfc60050e137d9">multi_normal_cholesky_rng</a> (const T_loc &amp;mu, const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;L, RNG &amp;rng)</td></tr>
<tr class="separator:ga8768d74289b60b1a89cfc60050e137d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea7c9f516fd2163ec5021d2731b6a18a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:gaea7c9f516fd2163ec5021d2731b6a18a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gaea7c9f516fd2163ec5021d2731b6a18a.html#gaea7c9f516fd2163ec5021d2731b6a18a">multi_normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:gaea7c9f516fd2163ec5021d2731b6a18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e1d2d523388bc94abb1d7925c10643"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:ga46e1d2d523388bc94abb1d7925c10643"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga46e1d2d523388bc94abb1d7925c10643.html#ga46e1d2d523388bc94abb1d7925c10643">multi_normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:ga46e1d2d523388bc94abb1d7925c10643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4c17658c695893af975217ab030c11"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:a2e4c17658c695893af975217ab030c11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2e4c17658c695893af975217ab030c11.html#a2e4c17658c695893af975217ab030c11">multi_normal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:a2e4c17658c695893af975217ab030c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8af3394f0700d603f5930f3932e067"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:a1b8af3394f0700d603f5930f3932e067"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1b8af3394f0700d603f5930f3932e067.html#a1b8af3394f0700d603f5930f3932e067">multi_normal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:a1b8af3394f0700d603f5930f3932e067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae01340614eb63292b100327af71f2626"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:gae01340614eb63292b100327af71f2626"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gae01340614eb63292b100327af71f2626.html#gae01340614eb63292b100327af71f2626">multi_normal_prec_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:gae01340614eb63292b100327af71f2626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8a791079717a70af1ceb21d240c85df"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:gad8a791079717a70af1ceb21d240c85df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gad8a791079717a70af1ceb21d240c85df.html#gad8a791079717a70af1ceb21d240c85df">multi_normal_prec_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:gad8a791079717a70af1ceb21d240c85df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6fa417054e6b259dbd2f62b8a55532"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:a7e6fa417054e6b259dbd2f62b8a55532"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7e6fa417054e6b259dbd2f62b8a55532.html#a7e6fa417054e6b259dbd2f62b8a55532">multi_normal_prec_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:a7e6fa417054e6b259dbd2f62b8a55532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9b687c7c2419f5eeab106e14c790bd"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:aff9b687c7c2419f5eeab106e14c790bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aff9b687c7c2419f5eeab106e14c790bd.html#aff9b687c7c2419f5eeab106e14c790bd">multi_normal_prec_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:aff9b687c7c2419f5eeab106e14c790bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc2a15a609c6e3967046385e6c411041"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , class RNG &gt; </td></tr>
<tr class="memitem:gadc2a15a609c6e3967046385e6c411041"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_std_vector_builder.html">StdVectorBuilder</a>&lt; true, Eigen::VectorXd, T_loc &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gadc2a15a609c6e3967046385e6c411041.html#gadc2a15a609c6e3967046385e6c411041">multi_normal_prec_rng</a> (const T_loc &amp;mu, const Eigen::MatrixXd &amp;S, RNG &amp;rng)</td></tr>
<tr class="separator:gadc2a15a609c6e3967046385e6c411041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d5464fa79ab08a7731cef29ded7e384"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , class RNG &gt; </td></tr>
<tr class="memitem:ga8d5464fa79ab08a7731cef29ded7e384"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_std_vector_builder.html">StdVectorBuilder</a>&lt; true, Eigen::VectorXd, T_loc &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga8d5464fa79ab08a7731cef29ded7e384.html#ga8d5464fa79ab08a7731cef29ded7e384">multi_normal_rng</a> (const T_loc &amp;mu, const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;S, RNG &amp;rng)</td></tr>
<tr class="separator:ga8d5464fa79ab08a7731cef29ded7e384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc497db7bbf82dc92e580bc31c345e0e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gafc497db7bbf82dc92e580bc31c345e0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gafc497db7bbf82dc92e580bc31c345e0e.html#gafc497db7bbf82dc92e580bc31c345e0e">multi_student_t_cholesky_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;L)</td></tr>
<tr class="separator:gafc497db7bbf82dc92e580bc31c345e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190bd39593f4658cc3db357d4eeb701d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a190bd39593f4658cc3db357d4eeb701d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a190bd39593f4658cc3db357d4eeb701d.html#a190bd39593f4658cc3db357d4eeb701d">multi_student_t_cholesky_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;L)</td></tr>
<tr class="separator:a190bd39593f4658cc3db357d4eeb701d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17b8582bb95b94003a83681e759297f3"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , class RNG &gt; </td></tr>
<tr class="memitem:ga17b8582bb95b94003a83681e759297f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_std_vector_builder.html">StdVectorBuilder</a>&lt; true, Eigen::VectorXd, T_loc &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga17b8582bb95b94003a83681e759297f3.html#ga17b8582bb95b94003a83681e759297f3">multi_student_t_cholesky_rng</a> (double nu, const T_loc &amp;mu, const Eigen::MatrixXd &amp;L, RNG &amp;rng)</td></tr>
<tr class="separator:ga17b8582bb95b94003a83681e759297f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ad01e45f4c8eabe5c813e0cc4eece98"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga5ad01e45f4c8eabe5c813e0cc4eece98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga5ad01e45f4c8eabe5c813e0cc4eece98.html#ga5ad01e45f4c8eabe5c813e0cc4eece98">multi_student_t_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;Sigma)</td></tr>
<tr class="separator:ga5ad01e45f4c8eabe5c813e0cc4eece98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21dabf2487a3e696c03c2faada3a6e92"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga21dabf2487a3e696c03c2faada3a6e92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga21dabf2487a3e696c03c2faada3a6e92.html#ga21dabf2487a3e696c03c2faada3a6e92">multi_student_t_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;Sigma)</td></tr>
<tr class="separator:ga21dabf2487a3e696c03c2faada3a6e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95c2aa50c01a2eb18d3ec107fb58fabc"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga95c2aa50c01a2eb18d3ec107fb58fabc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga95c2aa50c01a2eb18d3ec107fb58fabc.html#ga95c2aa50c01a2eb18d3ec107fb58fabc">multi_student_t_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;Sigma)</td></tr>
<tr class="separator:ga95c2aa50c01a2eb18d3ec107fb58fabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69c8c146043dd8306d953d4ee4df972"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ab69c8c146043dd8306d953d4ee4df972"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab69c8c146043dd8306d953d4ee4df972.html#ab69c8c146043dd8306d953d4ee4df972">multi_student_t_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;Sigma)</td></tr>
<tr class="separator:ab69c8c146043dd8306d953d4ee4df972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga098f5cc8afde056925944720d5295fd2"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , class RNG &gt; </td></tr>
<tr class="memitem:ga098f5cc8afde056925944720d5295fd2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_std_vector_builder.html">StdVectorBuilder</a>&lt; true, Eigen::VectorXd, T_loc &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga098f5cc8afde056925944720d5295fd2.html#ga098f5cc8afde056925944720d5295fd2">multi_student_t_rng</a> (double nu, const T_loc &amp;mu, const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;S, RNG &amp;rng)</td></tr>
<tr class="separator:ga098f5cc8afde056925944720d5295fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec16418a01064477e58f33a044043016"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob &gt; </td></tr>
<tr class="memitem:gaec16418a01064477e58f33a044043016"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gaec16418a01064477e58f33a044043016.html#gaec16418a01064477e58f33a044043016">multinomial_log</a> (const std::vector&lt; int &gt; &amp;ns, const T_prob &amp;theta)</td></tr>
<tr class="separator:gaec16418a01064477e58f33a044043016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab017f8f0887aa6c9a2ca92e5a4a2a1ee"><td class="memTemplParams" colspan="2">template&lt;typename T_prob &gt; </td></tr>
<tr class="memitem:gab017f8f0887aa6c9a2ca92e5a4a2a1ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gab017f8f0887aa6c9a2ca92e5a4a2a1ee.html#gab017f8f0887aa6c9a2ca92e5a4a2a1ee">multinomial_log</a> (const std::vector&lt; int &gt; &amp;ns, const T_prob &amp;theta)</td></tr>
<tr class="separator:gab017f8f0887aa6c9a2ca92e5a4a2a1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbefda25fc43e26d3a5d2818bb086dd3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_beta , require_eigen_col_vector_t&lt; T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gafbefda25fc43e26d3a5d2818bb086dd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gafbefda25fc43e26d3a5d2818bb086dd3.html#gafbefda25fc43e26d3a5d2818bb086dd3">multinomial_logit_log</a> (const std::vector&lt; int &gt; &amp;ns, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gafbefda25fc43e26d3a5d2818bb086dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb6cb28e7a16a526f9467941e6cf88e"><td class="memTemplParams" colspan="2">template&lt;typename T_beta , require_eigen_col_vector_t&lt; T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4fb6cb28e7a16a526f9467941e6cf88e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga4fb6cb28e7a16a526f9467941e6cf88e.html#ga4fb6cb28e7a16a526f9467941e6cf88e">multinomial_logit_log</a> (const std::vector&lt; int &gt; &amp;ns, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga4fb6cb28e7a16a526f9467941e6cf88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabe7d1ac7913e83814c3294d996e91c9"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_beta , typename T_prob  = scalar_type_t&lt;T_beta&gt;, require_eigen_col_vector_t&lt; T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaabe7d1ac7913e83814c3294d996e91c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gaabe7d1ac7913e83814c3294d996e91c9.html#gaabe7d1ac7913e83814c3294d996e91c9">multinomial_logit_lpmf</a> (const std::vector&lt; int &gt; &amp;ns, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaabe7d1ac7913e83814c3294d996e91c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccde8c01a19a120231763f38f0f66df"><td class="memTemplParams" colspan="2">template&lt;typename T_beta , require_eigen_col_vector_t&lt; T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0ccde8c01a19a120231763f38f0f66df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0ccde8c01a19a120231763f38f0f66df.html#a0ccde8c01a19a120231763f38f0f66df">multinomial_logit_lpmf</a> (const std::vector&lt; int &gt; &amp;ns, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a0ccde8c01a19a120231763f38f0f66df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04d59be2c49c48a314b727ee2e3831cf"><td class="memTemplParams" colspan="2">template&lt;class RNG , typename T_beta , require_eigen_col_vector_t&lt; T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga04d59be2c49c48a314b727ee2e3831cf"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga04d59be2c49c48a314b727ee2e3831cf.html#ga04d59be2c49c48a314b727ee2e3831cf">multinomial_logit_rng</a> (const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, int N, RNG &amp;rng)</td></tr>
<tr class="separator:ga04d59be2c49c48a314b727ee2e3831cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabde6502c07e1f8bca009eca76f096b5"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , require_eigen_col_vector_t&lt; T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aabde6502c07e1f8bca009eca76f096b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aabde6502c07e1f8bca009eca76f096b5.html#aabde6502c07e1f8bca009eca76f096b5">multinomial_lpmf</a> (const std::vector&lt; int &gt; &amp;ns, const T_prob &amp;theta)</td></tr>
<tr class="separator:aabde6502c07e1f8bca009eca76f096b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6e78d7749823cdf78b09f40ef3a3d3"><td class="memTemplParams" colspan="2">template&lt;typename T_prob &gt; </td></tr>
<tr class="memitem:aeb6e78d7749823cdf78b09f40ef3a3d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeb6e78d7749823cdf78b09f40ef3a3d3.html#aeb6e78d7749823cdf78b09f40ef3a3d3">multinomial_lpmf</a> (const std::vector&lt; int &gt; &amp;ns, const T_prob &amp;theta)</td></tr>
<tr class="separator:aeb6e78d7749823cdf78b09f40ef3a3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567c143fc9fc21527e348a1d25bbf194"><td class="memTemplParams" colspan="2">template&lt;class T_theta , class RNG , require_eigen_col_vector_t&lt; T_theta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a567c143fc9fc21527e348a1d25bbf194"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a567c143fc9fc21527e348a1d25bbf194.html#a567c143fc9fc21527e348a1d25bbf194">multinomial_rng</a> (const T_theta &amp;theta, int N, RNG &amp;rng)</td></tr>
<tr class="separator:a567c143fc9fc21527e348a1d25bbf194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc44532b95101b41939326d4334b975b"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:gadc44532b95101b41939326d4334b975b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gadc44532b95101b41939326d4334b975b.html#gadc44532b95101b41939326d4334b975b">neg_binomial_2_ccdf_log</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:gadc44532b95101b41939326d4334b975b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ab6af0db833a2d707a9476c448c6b6"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:ae4ab6af0db833a2d707a9476c448c6b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae4ab6af0db833a2d707a9476c448c6b6.html#ae4ab6af0db833a2d707a9476c448c6b6">neg_binomial_2_cdf</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:ae4ab6af0db833a2d707a9476c448c6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga741065a849d78191a3c7fdc1d6627a0a"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:ga741065a849d78191a3c7fdc1d6627a0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga741065a849d78191a3c7fdc1d6627a0a.html#ga741065a849d78191a3c7fdc1d6627a0a">neg_binomial_2_cdf_log</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:ga741065a849d78191a3c7fdc1d6627a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018a6a4f4b80729e9e76a09fcf109deb"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:a018a6a4f4b80729e9e76a09fcf109deb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a018a6a4f4b80729e9e76a09fcf109deb.html#a018a6a4f4b80729e9e76a09fcf109deb">neg_binomial_2_lccdf</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:a018a6a4f4b80729e9e76a09fcf109deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222543a78a53a53ed9363dd7812c9116"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:a222543a78a53a53ed9363dd7812c9116"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a222543a78a53a53ed9363dd7812c9116.html#a222543a78a53a53ed9363dd7812c9116">neg_binomial_2_lcdf</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:a222543a78a53a53ed9363dd7812c9116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bb8ed0b0947df7c1950310888ea8a3e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:ga8bb8ed0b0947df7c1950310888ea8a3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga8bb8ed0b0947df7c1950310888ea8a3e.html#ga8bb8ed0b0947df7c1950310888ea8a3e">neg_binomial_2_log</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:ga8bb8ed0b0947df7c1950310888ea8a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0e6f22307fbe9fb06867d67c12bd239"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:gad0e6f22307fbe9fb06867d67c12bd239"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad0e6f22307fbe9fb06867d67c12bd239.html#gad0e6f22307fbe9fb06867d67c12bd239">neg_binomial_2_log</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:gad0e6f22307fbe9fb06867d67c12bd239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec367ab511061785e827db08b413fee"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_precision &gt; </td></tr>
<tr class="memitem:ga9ec367ab511061785e827db08b413fee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga9ec367ab511061785e827db08b413fee.html#ga9ec367ab511061785e827db08b413fee">neg_binomial_2_log_glm_log</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_precision &amp;phi)</td></tr>
<tr class="separator:ga9ec367ab511061785e827db08b413fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28bbe881fe2967522f7ea474c7f3cab1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_precision &gt; </td></tr>
<tr class="memitem:ga28bbe881fe2967522f7ea474c7f3cab1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga28bbe881fe2967522f7ea474c7f3cab1.html#ga28bbe881fe2967522f7ea474c7f3cab1">neg_binomial_2_log_glm_log</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_precision &amp;phi)</td></tr>
<tr class="separator:ga28bbe881fe2967522f7ea474c7f3cab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5c3fd7ac58ea81db866febba20fec6d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_precision , require_matrix_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab5c3fd7ac58ea81db866febba20fec6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gab5c3fd7ac58ea81db866febba20fec6d.html#gab5c3fd7ac58ea81db866febba20fec6d">neg_binomial_2_log_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_precision &amp;phi)</td></tr>
<tr class="separator:gab5c3fd7ac58ea81db866febba20fec6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56540730d5a83fc1a5bac7331726d35"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_precision &gt; </td></tr>
<tr class="memitem:af56540730d5a83fc1a5bac7331726d35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af56540730d5a83fc1a5bac7331726d35.html#af56540730d5a83fc1a5bac7331726d35">neg_binomial_2_log_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_precision &amp;phi)</td></tr>
<tr class="separator:af56540730d5a83fc1a5bac7331726d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga580ad55536d171086c1c6335b932c7a1"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_log_location , typename T_precision &gt; </td></tr>
<tr class="memitem:ga580ad55536d171086c1c6335b932c7a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_log_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga580ad55536d171086c1c6335b932c7a1.html#ga580ad55536d171086c1c6335b932c7a1">neg_binomial_2_log_log</a> (const T_n &amp;n, const T_log_location &amp;eta, const T_precision &amp;phi)</td></tr>
<tr class="separator:ga580ad55536d171086c1c6335b932c7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45eff6dfc0b1459f3352f986241ab7cf"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_log_location , typename T_precision &gt; </td></tr>
<tr class="memitem:ga45eff6dfc0b1459f3352f986241ab7cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_log_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga45eff6dfc0b1459f3352f986241ab7cf.html#ga45eff6dfc0b1459f3352f986241ab7cf">neg_binomial_2_log_log</a> (const T_n &amp;n, const T_log_location &amp;eta, const T_precision &amp;phi)</td></tr>
<tr class="separator:ga45eff6dfc0b1459f3352f986241ab7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae593e066ba8bf2fe4e83b998850363"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_log_location , typename T_precision , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n, T_log_location, T_precision &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3ae593e066ba8bf2fe4e83b998850363"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_log_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3ae593e066ba8bf2fe4e83b998850363.html#a3ae593e066ba8bf2fe4e83b998850363">neg_binomial_2_log_lpmf</a> (const T_n &amp;n, const T_log_location &amp;eta, const T_precision &amp;phi)</td></tr>
<tr class="separator:a3ae593e066ba8bf2fe4e83b998850363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad492a302477b3c3c9e05b4a987cd84b9"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_log_location , typename T_precision &gt; </td></tr>
<tr class="memitem:ad492a302477b3c3c9e05b4a987cd84b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_log_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad492a302477b3c3c9e05b4a987cd84b9.html#ad492a302477b3c3c9e05b4a987cd84b9">neg_binomial_2_log_lpmf</a> (const T_n &amp;n, const T_log_location &amp;eta, const T_precision &amp;phi)</td></tr>
<tr class="separator:ad492a302477b3c3c9e05b4a987cd84b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24a9e79b2f9172f8ee83077f7de1d689"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_inv , class RNG &gt; </td></tr>
<tr class="memitem:ga24a9e79b2f9172f8ee83077f7de1d689"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_loc, T_inv &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga24a9e79b2f9172f8ee83077f7de1d689.html#ga24a9e79b2f9172f8ee83077f7de1d689">neg_binomial_2_log_rng</a> (const T_loc &amp;eta, const T_inv &amp;phi, RNG &amp;rng)</td></tr>
<tr class="separator:ga24a9e79b2f9172f8ee83077f7de1d689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185bb9a62ba07a1090e6ba0e853a0000"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_location , typename T_precision , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n, T_location, T_precision &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a185bb9a62ba07a1090e6ba0e853a0000"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a185bb9a62ba07a1090e6ba0e853a0000.html#a185bb9a62ba07a1090e6ba0e853a0000">neg_binomial_2_lpmf</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:a185bb9a62ba07a1090e6ba0e853a0000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0740e48663779e94855c410277f10a1e"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:a0740e48663779e94855c410277f10a1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0740e48663779e94855c410277f10a1e.html#a0740e48663779e94855c410277f10a1e">neg_binomial_2_lpmf</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:a0740e48663779e94855c410277f10a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c147c55ba65274828852b0c25a341c6"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_prec , class RNG &gt; </td></tr>
<tr class="memitem:ga9c147c55ba65274828852b0c25a341c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_loc, T_prec &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga9c147c55ba65274828852b0c25a341c6.html#ga9c147c55ba65274828852b0c25a341c6">neg_binomial_2_rng</a> (const T_loc &amp;mu, const T_prec &amp;phi, RNG &amp;rng)</td></tr>
<tr class="separator:ga9c147c55ba65274828852b0c25a341c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga350287dfa103a6f76b840fecbc0a1767"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:ga350287dfa103a6f76b840fecbc0a1767"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga350287dfa103a6f76b840fecbc0a1767.html#ga350287dfa103a6f76b840fecbc0a1767">neg_binomial_ccdf_log</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga350287dfa103a6f76b840fecbc0a1767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5e439175e5c51cf03d35d3712e9cba"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a8c5e439175e5c51cf03d35d3712e9cba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8c5e439175e5c51cf03d35d3712e9cba.html#a8c5e439175e5c51cf03d35d3712e9cba">neg_binomial_cdf</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a8c5e439175e5c51cf03d35d3712e9cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa18fc5b317064ba339cbbcfce70e99c0"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:gaa18fc5b317064ba339cbbcfce70e99c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaa18fc5b317064ba339cbbcfce70e99c0.html#gaa18fc5b317064ba339cbbcfce70e99c0">neg_binomial_cdf_log</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gaa18fc5b317064ba339cbbcfce70e99c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecde65e6c386dc4b76b489bcdcc3d2f"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a5ecde65e6c386dc4b76b489bcdcc3d2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5ecde65e6c386dc4b76b489bcdcc3d2f.html#a5ecde65e6c386dc4b76b489bcdcc3d2f">neg_binomial_lccdf</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;beta_param)</td></tr>
<tr class="separator:a5ecde65e6c386dc4b76b489bcdcc3d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0feb137e474342f18a126586bf05a10a"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a0feb137e474342f18a126586bf05a10a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0feb137e474342f18a126586bf05a10a.html#a0feb137e474342f18a126586bf05a10a">neg_binomial_lcdf</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;beta_param)</td></tr>
<tr class="separator:a0feb137e474342f18a126586bf05a10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1526a1680bb9ff28880a040aaa227660"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:ga1526a1680bb9ff28880a040aaa227660"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga1526a1680bb9ff28880a040aaa227660.html#ga1526a1680bb9ff28880a040aaa227660">neg_binomial_log</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga1526a1680bb9ff28880a040aaa227660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfcd1a4c09db3287aeecc54f40534773"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:gacfcd1a4c09db3287aeecc54f40534773"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gacfcd1a4c09db3287aeecc54f40534773.html#gacfcd1a4c09db3287aeecc54f40534773">neg_binomial_log</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gacfcd1a4c09db3287aeecc54f40534773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0520c40b471dce47b800a79734cdb0b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_shape , typename T_inv_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n, T_shape, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af0520c40b471dce47b800a79734cdb0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af0520c40b471dce47b800a79734cdb0b.html#af0520c40b471dce47b800a79734cdb0b">neg_binomial_lpmf</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:af0520c40b471dce47b800a79734cdb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e62fb2f69a1abc5023d556a14728eb9"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a1e62fb2f69a1abc5023d556a14728eb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1e62fb2f69a1abc5023d556a14728eb9.html#a1e62fb2f69a1abc5023d556a14728eb9">neg_binomial_lpmf</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a1e62fb2f69a1abc5023d556a14728eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f3b5407eb594a5e4b8a2c89488e4ead"><td class="memTemplParams" colspan="2">template&lt;typename T_shape , typename T_inv , class RNG &gt; </td></tr>
<tr class="memitem:ga3f3b5407eb594a5e4b8a2c89488e4ead"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_shape, T_inv &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3f3b5407eb594a5e4b8a2c89488e4ead.html#ga3f3b5407eb594a5e4b8a2c89488e4ead">neg_binomial_rng</a> (const T_shape &amp;alpha, const T_inv &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, RNG &amp;rng)</td></tr>
<tr class="separator:ga3f3b5407eb594a5e4b8a2c89488e4ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga187d433e6b7cccfa698e02d0e910fa81"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga187d433e6b7cccfa698e02d0e910fa81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga187d433e6b7cccfa698e02d0e910fa81.html#ga187d433e6b7cccfa698e02d0e910fa81">normal_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga187d433e6b7cccfa698e02d0e910fa81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga364185d49699ac29fa6d469920fccab7"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga364185d49699ac29fa6d469920fccab7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga364185d49699ac29fa6d469920fccab7.html#ga364185d49699ac29fa6d469920fccab7">normal_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga364185d49699ac29fa6d469920fccab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e1a8b0bd1a462336f564f5210fa7eb0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga4e1a8b0bd1a462336f564f5210fa7eb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga4e1a8b0bd1a462336f564f5210fa7eb0.html#ga4e1a8b0bd1a462336f564f5210fa7eb0">normal_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga4e1a8b0bd1a462336f564f5210fa7eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4473e11ac43137c4e42f785b610f070b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_scale &gt; </td></tr>
<tr class="memitem:ga4473e11ac43137c4e42f785b610f070b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_x, T_alpha, T_beta, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga4473e11ac43137c4e42f785b610f070b.html#ga4473e11ac43137c4e42f785b610f070b">normal_id_glm_log</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga4473e11ac43137c4e42f785b610f070b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57b3d600f49fc423fa936b7fa3c9e379"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_scale &gt; </td></tr>
<tr class="memitem:ga57b3d600f49fc423fa936b7fa3c9e379"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_x, T_alpha, T_beta, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga57b3d600f49fc423fa936b7fa3c9e379.html#ga57b3d600f49fc423fa936b7fa3c9e379">normal_id_glm_log</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga57b3d600f49fc423fa936b7fa3c9e379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5abfa04756222a7b66c2567d12182aea"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_scale , require_matrix_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5abfa04756222a7b66c2567d12182aea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_x, T_alpha, T_beta, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga5abfa04756222a7b66c2567d12182aea.html#ga5abfa04756222a7b66c2567d12182aea">normal_id_glm_lpdf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga5abfa04756222a7b66c2567d12182aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ab904be0fe66e97bdde2b14593c78c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_scale &gt; </td></tr>
<tr class="memitem:a01ab904be0fe66e97bdde2b14593c78c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_x, T_alpha, T_beta, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a01ab904be0fe66e97bdde2b14593c78c.html#a01ab904be0fe66e97bdde2b14593c78c">normal_id_glm_lpdf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a01ab904be0fe66e97bdde2b14593c78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0db868e49b68f4e834f89681c0048d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aae0db868e49b68f4e834f89681c0048d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aae0db868e49b68f4e834f89681c0048d.html#aae0db868e49b68f4e834f89681c0048d">normal_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aae0db868e49b68f4e834f89681c0048d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65944ffe67672b6fc7cba61c0e318a58"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a65944ffe67672b6fc7cba61c0e318a58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a65944ffe67672b6fc7cba61c0e318a58.html#a65944ffe67672b6fc7cba61c0e318a58">normal_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a65944ffe67672b6fc7cba61c0e318a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cd21352e848871cf93fc56ab0fccc83"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga4cd21352e848871cf93fc56ab0fccc83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga4cd21352e848871cf93fc56ab0fccc83.html#ga4cd21352e848871cf93fc56ab0fccc83">normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga4cd21352e848871cf93fc56ab0fccc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b271280afe57e5e4d45150c89857c84"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga8b271280afe57e5e4d45150c89857c84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga8b271280afe57e5e4d45150c89857c84.html#ga8b271280afe57e5e4d45150c89857c84">normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga8b271280afe57e5e4d45150c89857c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4979c3f97d50ede99162c6c124c85be8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4979c3f97d50ede99162c6c124c85be8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga4979c3f97d50ede99162c6c124c85be8.html#ga4979c3f97d50ede99162c6c124c85be8">normal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga4979c3f97d50ede99162c6c124c85be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b1423b4521a7e864cfba3dd6240f53"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a35b1423b4521a7e864cfba3dd6240f53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a35b1423b4521a7e864cfba3dd6240f53.html#a35b1423b4521a7e864cfba3dd6240f53">normal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a35b1423b4521a7e864cfba3dd6240f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40945f939d66ecbd743cb333231a2c2c"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga40945f939d66ecbd743cb333231a2c2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga40945f939d66ecbd743cb333231a2c2c.html#ga40945f939d66ecbd743cb333231a2c2c">normal_rng</a> (const T_loc &amp;mu, const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="separator:ga40945f939d66ecbd743cb333231a2c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae531b026beca9ea865e6ef236de477d2"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_s , typename T_n , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gae531b026beca9ea865e6ef236de477d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_s, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae531b026beca9ea865e6ef236de477d2.html#gae531b026beca9ea865e6ef236de477d2">normal_sufficient_log</a> (const T_y &amp;y_bar, const T_s &amp;s_squared, const T_n &amp;n_obs, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gae531b026beca9ea865e6ef236de477d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dd4dea4dd46f2f42a38f07bb28b8be3"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_s , typename T_n , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga9dd4dea4dd46f2f42a38f07bb28b8be3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_s, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga9dd4dea4dd46f2f42a38f07bb28b8be3.html#ga9dd4dea4dd46f2f42a38f07bb28b8be3">normal_sufficient_log</a> (const T_y &amp;y_bar, const T_s &amp;s_squared, const T_n &amp;n_obs, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga9dd4dea4dd46f2f42a38f07bb28b8be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8df6e083c26ff06a72f524fe2de3ab66"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_s , typename T_n , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga8df6e083c26ff06a72f524fe2de3ab66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_s, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga8df6e083c26ff06a72f524fe2de3ab66.html#ga8df6e083c26ff06a72f524fe2de3ab66">normal_sufficient_lpdf</a> (const T_y &amp;y_bar, const T_s &amp;s_squared, const T_n &amp;n_obs, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga8df6e083c26ff06a72f524fe2de3ab66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b67f5f5c0590bf732d291e84e2076f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_s , typename T_n , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ab3b67f5f5c0590bf732d291e84e2076f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_s, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab3b67f5f5c0590bf732d291e84e2076f.html#ab3b67f5f5c0590bf732d291e84e2076f">normal_sufficient_lpdf</a> (const T_y &amp;y_bar, const T_s &amp;s_squared, const T_n &amp;n_obs, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ab3b67f5f5c0590bf732d291e84e2076f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9b0f885af3060f53d14e9e113729fc"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_beta , typename T_cuts , require_matrix_t&lt; T_x &gt; *  = nullptr, require_all_col_vector_t&lt; T_beta, T_cuts &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gace9b0f885af3060f53d14e9e113729fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_beta, T_cuts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gace9b0f885af3060f53d14e9e113729fc.html#gace9b0f885af3060f53d14e9e113729fc">ordered_logistic_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_cuts &amp;cuts)</td></tr>
<tr class="separator:gace9b0f885af3060f53d14e9e113729fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8579159ff2de1cfa9723545bcb48ba3"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_beta , typename T_cuts &gt; </td></tr>
<tr class="memitem:ae8579159ff2de1cfa9723545bcb48ba3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_beta, T_cuts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae8579159ff2de1cfa9723545bcb48ba3.html#ae8579159ff2de1cfa9723545bcb48ba3">ordered_logistic_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_cuts &amp;cuts)</td></tr>
<tr class="separator:ae8579159ff2de1cfa9723545bcb48ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b3433b23d80fd5d7289e4922a21060"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_cut &gt; </td></tr>
<tr class="memitem:ga23b3433b23d80fd5d7289e4922a21060"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga23b3433b23d80fd5d7289e4922a21060.html#ga23b3433b23d80fd5d7289e4922a21060">ordered_logistic_log</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="separator:ga23b3433b23d80fd5d7289e4922a21060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3d5dfc0ac36a7701b5fb2b616850837"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_cut &gt; </td></tr>
<tr class="memitem:gae3d5dfc0ac36a7701b5fb2b616850837"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gae3d5dfc0ac36a7701b5fb2b616850837.html#gae3d5dfc0ac36a7701b5fb2b616850837">ordered_logistic_log</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="separator:gae3d5dfc0ac36a7701b5fb2b616850837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b2bd081aa551947d0b5c96d3928d92"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_cut , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_cut &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab0b2bd081aa551947d0b5c96d3928d92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gab0b2bd081aa551947d0b5c96d3928d92.html#gab0b2bd081aa551947d0b5c96d3928d92">ordered_logistic_lpmf</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="separator:gab0b2bd081aa551947d0b5c96d3928d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d4599a17418e5fa03414104243b080"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_cut &gt; </td></tr>
<tr class="memitem:a61d4599a17418e5fa03414104243b080"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a61d4599a17418e5fa03414104243b080.html#a61d4599a17418e5fa03414104243b080">ordered_logistic_lpmf</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="separator:a61d4599a17418e5fa03414104243b080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c484614e5c64ca762f733e031afd880"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a1c484614e5c64ca762f733e031afd880"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c484614e5c64ca762f733e031afd880.html#a1c484614e5c64ca762f733e031afd880">ordered_logistic_rng</a> (double eta, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;c, RNG &amp;rng)</td></tr>
<tr class="separator:a1c484614e5c64ca762f733e031afd880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56dd2feeb184d8ec2b6b62eabfe237f8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_cut &gt; </td></tr>
<tr class="memitem:ga56dd2feeb184d8ec2b6b62eabfe237f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga56dd2feeb184d8ec2b6b62eabfe237f8.html#ga56dd2feeb184d8ec2b6b62eabfe237f8">ordered_probit_log</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="separator:ga56dd2feeb184d8ec2b6b62eabfe237f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf76d0e635a7190c1a13da2b3ddbd468"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_cut &gt; </td></tr>
<tr class="memitem:gadf76d0e635a7190c1a13da2b3ddbd468"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gadf76d0e635a7190c1a13da2b3ddbd468.html#gadf76d0e635a7190c1a13da2b3ddbd468">ordered_probit_log</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="separator:gadf76d0e635a7190c1a13da2b3ddbd468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44b1065be3677f5745ae216896cf59ca"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_cut &gt; </td></tr>
<tr class="memitem:ga44b1065be3677f5745ae216896cf59ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga44b1065be3677f5745ae216896cf59ca.html#ga44b1065be3677f5745ae216896cf59ca">ordered_probit_lpmf</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="separator:ga44b1065be3677f5745ae216896cf59ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639d8c170f8589cc7f6f5a7b760d4575"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_cut &gt; </td></tr>
<tr class="memitem:a639d8c170f8589cc7f6f5a7b760d4575"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a639d8c170f8589cc7f6f5a7b760d4575.html#a639d8c170f8589cc7f6f5a7b760d4575">ordered_probit_lpmf</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="separator:a639d8c170f8589cc7f6f5a7b760d4575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9006c39e8500322d89c16a79d64c6f7e"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a9006c39e8500322d89c16a79d64c6f7e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9006c39e8500322d89c16a79d64c6f7e.html#a9006c39e8500322d89c16a79d64c6f7e">ordered_probit_rng</a> (double eta, const Eigen::VectorXd &amp;c, RNG &amp;rng)</td></tr>
<tr class="separator:a9006c39e8500322d89c16a79d64c6f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410a3a0a17792b81ae4e04896e2d3402"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ga410a3a0a17792b81ae4e04896e2d3402"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga410a3a0a17792b81ae4e04896e2d3402.html#ga410a3a0a17792b81ae4e04896e2d3402">pareto_ccdf_log</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ga410a3a0a17792b81ae4e04896e2d3402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90ca2bf5cb6b750a836a2012f198a84"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad90ca2bf5cb6b750a836a2012f198a84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad90ca2bf5cb6b750a836a2012f198a84.html#ad90ca2bf5cb6b750a836a2012f198a84">pareto_cdf</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ad90ca2bf5cb6b750a836a2012f198a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cd0dabfdf7edb8a769edab4326d09c2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ga5cd0dabfdf7edb8a769edab4326d09c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga5cd0dabfdf7edb8a769edab4326d09c2.html#ga5cd0dabfdf7edb8a769edab4326d09c2">pareto_cdf_log</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ga5cd0dabfdf7edb8a769edab4326d09c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac681cd88c66766f1d1d8e7dff941d413"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac681cd88c66766f1d1d8e7dff941d413"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac681cd88c66766f1d1d8e7dff941d413.html#ac681cd88c66766f1d1d8e7dff941d413">pareto_lccdf</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ac681cd88c66766f1d1d8e7dff941d413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7906523b271e8c2e5cc274b74c0a71d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae7906523b271e8c2e5cc274b74c0a71d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae7906523b271e8c2e5cc274b74c0a71d.html#ae7906523b271e8c2e5cc274b74c0a71d">pareto_lcdf</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ae7906523b271e8c2e5cc274b74c0a71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97da9d639dc5b8def82e501d9be3f5d7"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ga97da9d639dc5b8def82e501d9be3f5d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga97da9d639dc5b8def82e501d9be3f5d7.html#ga97da9d639dc5b8def82e501d9be3f5d7">pareto_log</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ga97da9d639dc5b8def82e501d9be3f5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4900a3e54a11bec0ca2d534869379986"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ga4900a3e54a11bec0ca2d534869379986"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga4900a3e54a11bec0ca2d534869379986.html#ga4900a3e54a11bec0ca2d534869379986">pareto_log</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ga4900a3e54a11bec0ca2d534869379986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e97ab4f3e511bba192166e67e6e2f6"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_scale , typename T_shape , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa1e97ab4f3e511bba192166e67e6e2f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa1e97ab4f3e511bba192166e67e6e2f6.html#aa1e97ab4f3e511bba192166e67e6e2f6">pareto_lpdf</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:aa1e97ab4f3e511bba192166e67e6e2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a332dcb415c6a0e908af0f535f6dcc"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ab0a332dcb415c6a0e908af0f535f6dcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab0a332dcb415c6a0e908af0f535f6dcc.html#ab0a332dcb415c6a0e908af0f535f6dcc">pareto_lpdf</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ab0a332dcb415c6a0e908af0f535f6dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4b9efb12af32bf6531d1da7073b83ca"><td class="memTemplParams" colspan="2">template&lt;typename T_shape , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:gad4b9efb12af32bf6531d1da7073b83ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_shape, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad4b9efb12af32bf6531d1da7073b83ca.html#gad4b9efb12af32bf6531d1da7073b83ca">pareto_rng</a> (const T_scale &amp;y_min, const T_shape &amp;alpha, RNG &amp;rng)</td></tr>
<tr class="separator:gad4b9efb12af32bf6531d1da7073b83ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea233695051161b2bceb7de81cc258a0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:gaea233695051161b2bceb7de81cc258a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaea233695051161b2bceb7de81cc258a0.html#gaea233695051161b2bceb7de81cc258a0">pareto_type_2_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:gaea233695051161b2bceb7de81cc258a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb137826b7fbf02d2004b00c2e3c30e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afdb137826b7fbf02d2004b00c2e3c30e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afdb137826b7fbf02d2004b00c2e3c30e.html#afdb137826b7fbf02d2004b00c2e3c30e">pareto_type_2_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:afdb137826b7fbf02d2004b00c2e3c30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa82fcf006a7c2868bbeefdc29b4a33e2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:gaa82fcf006a7c2868bbeefdc29b4a33e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaa82fcf006a7c2868bbeefdc29b4a33e2.html#gaa82fcf006a7c2868bbeefdc29b4a33e2">pareto_type_2_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:gaa82fcf006a7c2868bbeefdc29b4a33e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4587d08c2283adef6c38cefa8b1f94c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab4587d08c2283adef6c38cefa8b1f94c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab4587d08c2283adef6c38cefa8b1f94c.html#ab4587d08c2283adef6c38cefa8b1f94c">pareto_type_2_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ab4587d08c2283adef6c38cefa8b1f94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ad871af54d565b779e1373ce86cbc9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a27ad871af54d565b779e1373ce86cbc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a27ad871af54d565b779e1373ce86cbc9.html#a27ad871af54d565b779e1373ce86cbc9">pareto_type_2_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a27ad871af54d565b779e1373ce86cbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaece2b0c1cc984def0f8fb24720cc497d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:gaece2b0c1cc984def0f8fb24720cc497d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaece2b0c1cc984def0f8fb24720cc497d.html#gaece2b0c1cc984def0f8fb24720cc497d">pareto_type_2_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:gaece2b0c1cc984def0f8fb24720cc497d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga411dd2cf2a24f2e45a2f3910be860d2b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ga411dd2cf2a24f2e45a2f3910be860d2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga411dd2cf2a24f2e45a2f3910be860d2b.html#ga411dd2cf2a24f2e45a2f3910be860d2b">pareto_type_2_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ga411dd2cf2a24f2e45a2f3910be860d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e53c8201580b10d92f33a23dcdb45c7"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7e53c8201580b10d92f33a23dcdb45c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7e53c8201580b10d92f33a23dcdb45c7.html#a7e53c8201580b10d92f33a23dcdb45c7">pareto_type_2_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a7e53c8201580b10d92f33a23dcdb45c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab634bcdaa6f75454c9b0df3651b234be"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ab634bcdaa6f75454c9b0df3651b234be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab634bcdaa6f75454c9b0df3651b234be.html#ab634bcdaa6f75454c9b0df3651b234be">pareto_type_2_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ab634bcdaa6f75454c9b0df3651b234be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aee6038fd9584ad0cc828c495886873"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , typename T_shape , class RNG &gt; </td></tr>
<tr class="memitem:ga6aee6038fd9584ad0cc828c495886873"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga6aee6038fd9584ad0cc828c495886873.html#ga6aee6038fd9584ad0cc828c495886873">pareto_type_2_rng</a> (const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha, RNG &amp;rng)</td></tr>
<tr class="separator:ga6aee6038fd9584ad0cc828c495886873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga743ca3d5a9403d785198b3d41db0601a"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:ga743ca3d5a9403d785198b3d41db0601a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga743ca3d5a9403d785198b3d41db0601a.html#ga743ca3d5a9403d785198b3d41db0601a">poisson_binomial_ccdf_log</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:ga743ca3d5a9403d785198b3d41db0601a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75172146efd1090ebe035bb5b24c2a45"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:ga75172146efd1090ebe035bb5b24c2a45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga75172146efd1090ebe035bb5b24c2a45.html#ga75172146efd1090ebe035bb5b24c2a45">poisson_binomial_cdf</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:ga75172146efd1090ebe035bb5b24c2a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0448c80fc61a11b744cc714afcf8764"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:ab0448c80fc61a11b744cc714afcf8764"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab0448c80fc61a11b744cc714afcf8764.html#ab0448c80fc61a11b744cc714afcf8764">poisson_binomial_cdf</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:ab0448c80fc61a11b744cc714afcf8764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d287c77623c6c441f710d6b104a5a96"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:ga0d287c77623c6c441f710d6b104a5a96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga0d287c77623c6c441f710d6b104a5a96.html#ga0d287c77623c6c441f710d6b104a5a96">poisson_binomial_cdf_log</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:ga0d287c77623c6c441f710d6b104a5a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa36d1361fc83a2e87822af37ce9ce8b7"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:gaa36d1361fc83a2e87822af37ce9ce8b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaa36d1361fc83a2e87822af37ce9ce8b7.html#gaa36d1361fc83a2e87822af37ce9ce8b7">poisson_binomial_lccdf</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:gaa36d1361fc83a2e87822af37ce9ce8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45e3005ad5b09cb5981c9089f18a72b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:aa45e3005ad5b09cb5981c9089f18a72b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa45e3005ad5b09cb5981c9089f18a72b.html#aa45e3005ad5b09cb5981c9089f18a72b">poisson_binomial_lccdf</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:aa45e3005ad5b09cb5981c9089f18a72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a3c31c8e45257b8e65236deaa732e93"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:ga7a3c31c8e45257b8e65236deaa732e93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga7a3c31c8e45257b8e65236deaa732e93.html#ga7a3c31c8e45257b8e65236deaa732e93">poisson_binomial_lcdf</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:ga7a3c31c8e45257b8e65236deaa732e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52494a84b052c2090328d3c67cb17ee6"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:a52494a84b052c2090328d3c67cb17ee6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a52494a84b052c2090328d3c67cb17ee6.html#a52494a84b052c2090328d3c67cb17ee6">poisson_binomial_lcdf</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:a52494a84b052c2090328d3c67cb17ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae45f32b50b1036b084cb87aca40a005d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:gae45f32b50b1036b084cb87aca40a005d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae45f32b50b1036b084cb87aca40a005d.html#gae45f32b50b1036b084cb87aca40a005d">poisson_binomial_log</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:gae45f32b50b1036b084cb87aca40a005d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbf4ef7db2a7bc3b2e18556f13434511"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:gadbf4ef7db2a7bc3b2e18556f13434511"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gadbf4ef7db2a7bc3b2e18556f13434511.html#gadbf4ef7db2a7bc3b2e18556f13434511">poisson_binomial_log</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:gadbf4ef7db2a7bc3b2e18556f13434511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3092bb480782e0c6b6af7a0ae6b5fe7"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:gab3092bb480782e0c6b6af7a0ae6b5fe7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab3092bb480782e0c6b6af7a0ae6b5fe7.html#gab3092bb480782e0c6b6af7a0ae6b5fe7">poisson_binomial_lpmf</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:gab3092bb480782e0c6b6af7a0ae6b5fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4e62261db53f4b3f42767def6f13f0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:a7a4e62261db53f4b3f42767def6f13f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7a4e62261db53f4b3f42767def6f13f0.html#a7a4e62261db53f4b3f42767def6f13f0">poisson_binomial_lpmf</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:a7a4e62261db53f4b3f42767def6f13f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b0850b7e78c613d0800bace9cbf7e85"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , typename RNG , require_eigen_vt&lt; std::is_arithmetic, T_theta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3b0850b7e78c613d0800bace9cbf7e85"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3b0850b7e78c613d0800bace9cbf7e85.html#ga3b0850b7e78c613d0800bace9cbf7e85">poisson_binomial_rng</a> (const T_theta &amp;theta, RNG &amp;rng)</td></tr>
<tr class="separator:ga3b0850b7e78c613d0800bace9cbf7e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04b333b7bc609e9eb4be089cd1b384ab"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:ga04b333b7bc609e9eb4be089cd1b384ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga04b333b7bc609e9eb4be089cd1b384ab.html#ga04b333b7bc609e9eb4be089cd1b384ab">poisson_ccdf_log</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:ga04b333b7bc609e9eb4be089cd1b384ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ae006768333d67bd3c3033737e7e35"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:af9ae006768333d67bd3c3033737e7e35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af9ae006768333d67bd3c3033737e7e35.html#af9ae006768333d67bd3c3033737e7e35">poisson_cdf</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:af9ae006768333d67bd3c3033737e7e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb277791155460e398441ce2d7c0c911"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:gafb277791155460e398441ce2d7c0c911"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gafb277791155460e398441ce2d7c0c911.html#gafb277791155460e398441ce2d7c0c911">poisson_cdf_log</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:gafb277791155460e398441ce2d7c0c911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6316191f3637297e22688b010ba7cd42"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:a6316191f3637297e22688b010ba7cd42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6316191f3637297e22688b010ba7cd42.html#a6316191f3637297e22688b010ba7cd42">poisson_lccdf</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:a6316191f3637297e22688b010ba7cd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c87c70c14dd1ddc41bcad650a37f4d"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:a49c87c70c14dd1ddc41bcad650a37f4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a49c87c70c14dd1ddc41bcad650a37f4d.html#a49c87c70c14dd1ddc41bcad650a37f4d">poisson_lcdf</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:a49c87c70c14dd1ddc41bcad650a37f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa31ebfd694eeb1c8dd19a8878610c3a3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:gaa31ebfd694eeb1c8dd19a8878610c3a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaa31ebfd694eeb1c8dd19a8878610c3a3.html#gaa31ebfd694eeb1c8dd19a8878610c3a3">poisson_log</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:gaa31ebfd694eeb1c8dd19a8878610c3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ca0f027aaa6d3846e1ac2a1480399ce"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:ga1ca0f027aaa6d3846e1ac2a1480399ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga1ca0f027aaa6d3846e1ac2a1480399ce.html#ga1ca0f027aaa6d3846e1ac2a1480399ce">poisson_log</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:ga1ca0f027aaa6d3846e1ac2a1480399ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ec719b8f6c82108959c6c8668ef4027"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:ga4ec719b8f6c82108959c6c8668ef4027"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga4ec719b8f6c82108959c6c8668ef4027.html#ga4ec719b8f6c82108959c6c8668ef4027">poisson_log_glm_log</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga4ec719b8f6c82108959c6c8668ef4027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c49cb4ea519606e1432989b0ddaef9b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:ga9c49cb4ea519606e1432989b0ddaef9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga9c49cb4ea519606e1432989b0ddaef9b.html#ga9c49cb4ea519606e1432989b0ddaef9b">poisson_log_glm_log</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga9c49cb4ea519606e1432989b0ddaef9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdac9b18cd635354f25b6a4208b4ccbc"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , require_matrix_t&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabdac9b18cd635354f25b6a4208b4ccbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gabdac9b18cd635354f25b6a4208b4ccbc.html#gabdac9b18cd635354f25b6a4208b4ccbc">poisson_log_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gabdac9b18cd635354f25b6a4208b4ccbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1decd33426032caf5587c1860049128d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:a1decd33426032caf5587c1860049128d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1decd33426032caf5587c1860049128d.html#a1decd33426032caf5587c1860049128d">poisson_log_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a1decd33426032caf5587c1860049128d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65322e796ac55edf2c1eb673d1cbdce8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_log_rate &gt; </td></tr>
<tr class="memitem:ga65322e796ac55edf2c1eb673d1cbdce8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_log_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga65322e796ac55edf2c1eb673d1cbdce8.html#ga65322e796ac55edf2c1eb673d1cbdce8">poisson_log_log</a> (const T_n &amp;n, const T_log_rate &amp;alpha)</td></tr>
<tr class="separator:ga65322e796ac55edf2c1eb673d1cbdce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8825443d44807e9074f7ddb9f1266201"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_log_rate &gt; </td></tr>
<tr class="memitem:ga8825443d44807e9074f7ddb9f1266201"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_log_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga8825443d44807e9074f7ddb9f1266201.html#ga8825443d44807e9074f7ddb9f1266201">poisson_log_log</a> (const T_n &amp;n, const T_log_rate &amp;alpha)</td></tr>
<tr class="separator:ga8825443d44807e9074f7ddb9f1266201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead28f122b835fd5a252ccfc860ef729"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_log_rate , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n, T_log_rate &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aead28f122b835fd5a252ccfc860ef729"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_log_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aead28f122b835fd5a252ccfc860ef729.html#aead28f122b835fd5a252ccfc860ef729">poisson_log_lpmf</a> (const T_n &amp;n, const T_log_rate &amp;alpha)</td></tr>
<tr class="separator:aead28f122b835fd5a252ccfc860ef729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9be6be6646538f01b6968911b1bd7cc"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_log_rate &gt; </td></tr>
<tr class="memitem:af9be6be6646538f01b6968911b1bd7cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_log_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af9be6be6646538f01b6968911b1bd7cc.html#af9be6be6646538f01b6968911b1bd7cc">poisson_log_lpmf</a> (const T_n &amp;n, const T_log_rate &amp;alpha)</td></tr>
<tr class="separator:af9be6be6646538f01b6968911b1bd7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ae81b13f1c3642287c82d63ebfd75d1"><td class="memTemplParams" colspan="2">template&lt;typename T_rate , class RNG &gt; </td></tr>
<tr class="memitem:ga9ae81b13f1c3642287c82d63ebfd75d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_rate &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga9ae81b13f1c3642287c82d63ebfd75d1.html#ga9ae81b13f1c3642287c82d63ebfd75d1">poisson_log_rng</a> (const T_rate &amp;alpha, RNG &amp;rng)</td></tr>
<tr class="separator:ga9ae81b13f1c3642287c82d63ebfd75d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7670f4dab2ea21a689eaf8156d4943a4"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_rate , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_n, T_rate &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7670f4dab2ea21a689eaf8156d4943a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7670f4dab2ea21a689eaf8156d4943a4.html#a7670f4dab2ea21a689eaf8156d4943a4">poisson_lpmf</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:a7670f4dab2ea21a689eaf8156d4943a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f48f4c7773ae3bd3e13515e1d6ff5c"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:ac1f48f4c7773ae3bd3e13515e1d6ff5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac1f48f4c7773ae3bd3e13515e1d6ff5c.html#ac1f48f4c7773ae3bd3e13515e1d6ff5c">poisson_lpmf</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:ac1f48f4c7773ae3bd3e13515e1d6ff5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga917009e6e4c7ab209a3896ab42c7978e"><td class="memTemplParams" colspan="2">template&lt;typename T_rate , class RNG &gt; </td></tr>
<tr class="memitem:ga917009e6e4c7ab209a3896ab42c7978e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_rate &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga917009e6e4c7ab209a3896ab42c7978e.html#ga917009e6e4c7ab209a3896ab42c7978e">poisson_rng</a> (const T_rate &amp;lambda, RNG &amp;rng)</td></tr>
<tr class="separator:ga917009e6e4c7ab209a3896ab42c7978e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41781f18929b48f2feecead4aa35a966"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale &gt; </td></tr>
<tr class="memitem:ga41781f18929b48f2feecead4aa35a966"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga41781f18929b48f2feecead4aa35a966.html#ga41781f18929b48f2feecead4aa35a966">rayleigh_ccdf_log</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga41781f18929b48f2feecead4aa35a966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea059d2deb56cde93d66d5a46e792f59"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aea059d2deb56cde93d66d5a46e792f59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aea059d2deb56cde93d66d5a46e792f59.html#aea059d2deb56cde93d66d5a46e792f59">rayleigh_cdf</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aea059d2deb56cde93d66d5a46e792f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b2ae50d13901b55d23f11cafd4befbe"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale &gt; </td></tr>
<tr class="memitem:ga9b2ae50d13901b55d23f11cafd4befbe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga9b2ae50d13901b55d23f11cafd4befbe.html#ga9b2ae50d13901b55d23f11cafd4befbe">rayleigh_cdf_log</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga9b2ae50d13901b55d23f11cafd4befbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6aea5f3024a6ac19ce8439aa254f74"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aef6aea5f3024a6ac19ce8439aa254f74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aef6aea5f3024a6ac19ce8439aa254f74.html#aef6aea5f3024a6ac19ce8439aa254f74">rayleigh_lccdf</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aef6aea5f3024a6ac19ce8439aa254f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bddccb173c761c3b0a4138010fb9faa"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7bddccb173c761c3b0a4138010fb9faa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7bddccb173c761c3b0a4138010fb9faa.html#a7bddccb173c761c3b0a4138010fb9faa">rayleigh_lcdf</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a7bddccb173c761c3b0a4138010fb9faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab796798f586a3425f97cb7de6f0016fb"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_scale &gt; </td></tr>
<tr class="memitem:gab796798f586a3425f97cb7de6f0016fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab796798f586a3425f97cb7de6f0016fb.html#gab796798f586a3425f97cb7de6f0016fb">rayleigh_log</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gab796798f586a3425f97cb7de6f0016fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e46c32e5693a0891eac48606c7ba17"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale &gt; </td></tr>
<tr class="memitem:ga12e46c32e5693a0891eac48606c7ba17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga12e46c32e5693a0891eac48606c7ba17.html#ga12e46c32e5693a0891eac48606c7ba17">rayleigh_log</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga12e46c32e5693a0891eac48606c7ba17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb7ebab4fdc3b954bcba993126db9ae"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4eb7ebab4fdc3b954bcba993126db9ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4eb7ebab4fdc3b954bcba993126db9ae.html#a4eb7ebab4fdc3b954bcba993126db9ae">rayleigh_lpdf</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a4eb7ebab4fdc3b954bcba993126db9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab152f8b55c4f7495f09d09807c476b70"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale &gt; </td></tr>
<tr class="memitem:ab152f8b55c4f7495f09d09807c476b70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab152f8b55c4f7495f09d09807c476b70.html#ab152f8b55c4f7495f09d09807c476b70">rayleigh_lpdf</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ab152f8b55c4f7495f09d09807c476b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga214e2fc7a81e17d4d811454dd8073a8f"><td class="memTemplParams" colspan="2">template&lt;typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga214e2fc7a81e17d4d811454dd8073a8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga214e2fc7a81e17d4d811454dd8073a8f.html#ga214e2fc7a81e17d4d811454dd8073a8f">rayleigh_rng</a> (const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="separator:ga214e2fc7a81e17d4d811454dd8073a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3b69835316fb07d536ed95339cf5cea"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:gad3b69835316fb07d536ed95339cf5cea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad3b69835316fb07d536ed95339cf5cea.html#gad3b69835316fb07d536ed95339cf5cea">scaled_inv_chi_square_ccdf_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="separator:gad3b69835316fb07d536ed95339cf5cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga038c1835362c845027255ad5fdf0ec92"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:ga038c1835362c845027255ad5fdf0ec92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga038c1835362c845027255ad5fdf0ec92.html#ga038c1835362c845027255ad5fdf0ec92">scaled_inv_chi_square_cdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="separator:ga038c1835362c845027255ad5fdf0ec92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d74dc850a075ad55125c8435fccce1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:gad4d74dc850a075ad55125c8435fccce1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad4d74dc850a075ad55125c8435fccce1.html#gad4d74dc850a075ad55125c8435fccce1">scaled_inv_chi_square_cdf_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="separator:gad4d74dc850a075ad55125c8435fccce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f702c4d3648d23cff56211720a9408"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:ab3f702c4d3648d23cff56211720a9408"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab3f702c4d3648d23cff56211720a9408.html#ab3f702c4d3648d23cff56211720a9408">scaled_inv_chi_square_lccdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="separator:ab3f702c4d3648d23cff56211720a9408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f890ad4fdb012b8615edc46c7d3c43"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:a35f890ad4fdb012b8615edc46c7d3c43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a35f890ad4fdb012b8615edc46c7d3c43.html#a35f890ad4fdb012b8615edc46c7d3c43">scaled_inv_chi_square_lcdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="separator:a35f890ad4fdb012b8615edc46c7d3c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84128e61ac96e532dfdac0d08f799a35"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:ga84128e61ac96e532dfdac0d08f799a35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga84128e61ac96e532dfdac0d08f799a35.html#ga84128e61ac96e532dfdac0d08f799a35">scaled_inv_chi_square_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="separator:ga84128e61ac96e532dfdac0d08f799a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f1178eecd1f2be184d1655eee761b46"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:ga3f1178eecd1f2be184d1655eee761b46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3f1178eecd1f2be184d1655eee761b46.html#ga3f1178eecd1f2be184d1655eee761b46">scaled_inv_chi_square_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="separator:ga3f1178eecd1f2be184d1655eee761b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47dc5f29bf1673e88ada4b8f2bb45b20"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_dof, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga47dc5f29bf1673e88ada4b8f2bb45b20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga47dc5f29bf1673e88ada4b8f2bb45b20.html#ga47dc5f29bf1673e88ada4b8f2bb45b20">scaled_inv_chi_square_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="separator:ga47dc5f29bf1673e88ada4b8f2bb45b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe95aa91f13263a5acdf0bfe20ec3061"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:afe95aa91f13263a5acdf0bfe20ec3061"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afe95aa91f13263a5acdf0bfe20ec3061.html#afe95aa91f13263a5acdf0bfe20ec3061">scaled_inv_chi_square_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="separator:afe95aa91f13263a5acdf0bfe20ec3061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b9c48add43b6426b6bc72ae2c664c45"><td class="memTemplParams" colspan="2">template&lt;typename T_deg , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga9b9c48add43b6426b6bc72ae2c664c45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_deg, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga9b9c48add43b6426b6bc72ae2c664c45.html#ga9b9c48add43b6426b6bc72ae2c664c45">scaled_inv_chi_square_rng</a> (const T_deg &amp;nu, const T_scale &amp;s, RNG &amp;rng)</td></tr>
<tr class="separator:ga9b9c48add43b6426b6bc72ae2c664c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fbe82b0fd3572eeba5ae829a7bc5863"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_skewness &gt; </td></tr>
<tr class="memitem:ga6fbe82b0fd3572eeba5ae829a7bc5863"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga6fbe82b0fd3572eeba5ae829a7bc5863.html#ga6fbe82b0fd3572eeba5ae829a7bc5863">skew_double_exponential_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau)</td></tr>
<tr class="separator:ga6fbe82b0fd3572eeba5ae829a7bc5863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd6bdd4035aa70fea885f67b878566af"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_skewness , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale, T_skewness &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gafd6bdd4035aa70fea885f67b878566af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gafd6bdd4035aa70fea885f67b878566af.html#gafd6bdd4035aa70fea885f67b878566af">skew_double_exponential_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau)</td></tr>
<tr class="separator:gafd6bdd4035aa70fea885f67b878566af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7277a4da41c0648497af8022abb38023"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_skewness &gt; </td></tr>
<tr class="memitem:ga7277a4da41c0648497af8022abb38023"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga7277a4da41c0648497af8022abb38023.html#ga7277a4da41c0648497af8022abb38023">skew_double_exponential_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau)</td></tr>
<tr class="separator:ga7277a4da41c0648497af8022abb38023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2af1cef206bdd67be66a50bb0e0f80e2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_skewness , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale, T_skewness &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2af1cef206bdd67be66a50bb0e0f80e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga2af1cef206bdd67be66a50bb0e0f80e2.html#ga2af1cef206bdd67be66a50bb0e0f80e2">skew_double_exponential_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau)</td></tr>
<tr class="separator:ga2af1cef206bdd67be66a50bb0e0f80e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bfe73d357641c351216e40b08a0dcbd"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_skewness , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale, T_skewness &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3bfe73d357641c351216e40b08a0dcbd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3bfe73d357641c351216e40b08a0dcbd.html#ga3bfe73d357641c351216e40b08a0dcbd">skew_double_exponential_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau)</td></tr>
<tr class="separator:ga3bfe73d357641c351216e40b08a0dcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac1dfbababf2d2ff9a068e7f58e2f4b5"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_skewness &gt; </td></tr>
<tr class="memitem:gaac1dfbababf2d2ff9a068e7f58e2f4b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaac1dfbababf2d2ff9a068e7f58e2f4b5.html#gaac1dfbababf2d2ff9a068e7f58e2f4b5">skew_double_exponential_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau)</td></tr>
<tr class="separator:gaac1dfbababf2d2ff9a068e7f58e2f4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22f02ac910f637e6b8e2ef6df6ff6c34"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_skewness &gt; </td></tr>
<tr class="memitem:ga22f02ac910f637e6b8e2ef6df6ff6c34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga22f02ac910f637e6b8e2ef6df6ff6c34.html#ga22f02ac910f637e6b8e2ef6df6ff6c34">skew_double_exponential_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau)</td></tr>
<tr class="separator:ga22f02ac910f637e6b8e2ef6df6ff6c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02323a61708355015408e780b1782183"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_skewness , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale, T_skewness &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga02323a61708355015408e780b1782183"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga02323a61708355015408e780b1782183.html#ga02323a61708355015408e780b1782183">skew_double_exponential_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau)</td></tr>
<tr class="separator:ga02323a61708355015408e780b1782183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9726e9c6eb1d908a39add3fdd843b1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_skewness &gt; </td></tr>
<tr class="memitem:a2f9726e9c6eb1d908a39add3fdd843b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f9726e9c6eb1d908a39add3fdd843b1.html#a2f9726e9c6eb1d908a39add3fdd843b1">skew_double_exponential_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau)</td></tr>
<tr class="separator:a2f9726e9c6eb1d908a39add3fdd843b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1a4a5435dcd5b0fff34ebb5b55c5d49"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , typename T_skewness , class RNG &gt; </td></tr>
<tr class="memitem:gab1a4a5435dcd5b0fff34ebb5b55c5d49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale, T_skewness &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab1a4a5435dcd5b0fff34ebb5b55c5d49.html#gab1a4a5435dcd5b0fff34ebb5b55c5d49">skew_double_exponential_rng</a> (const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau, RNG &amp;rng)</td></tr>
<tr class="separator:gab1a4a5435dcd5b0fff34ebb5b55c5d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b7279049af2e7246285d26f6f6f21f0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ga2b7279049af2e7246285d26f6f6f21f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga2b7279049af2e7246285d26f6f6f21f0.html#ga2b7279049af2e7246285d26f6f6f21f0">skew_normal_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ga2b7279049af2e7246285d26f6f6f21f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512ed8327cb2af9390c2906a3ad0b536"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a512ed8327cb2af9390c2906a3ad0b536"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a512ed8327cb2af9390c2906a3ad0b536.html#a512ed8327cb2af9390c2906a3ad0b536">skew_normal_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a512ed8327cb2af9390c2906a3ad0b536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga302d6a6174ac45b42ac366fd46020c2c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ga302d6a6174ac45b42ac366fd46020c2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga302d6a6174ac45b42ac366fd46020c2c.html#ga302d6a6174ac45b42ac366fd46020c2c">skew_normal_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ga302d6a6174ac45b42ac366fd46020c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48a6558f38a9dbd32ad690ad6ced5c2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ae48a6558f38a9dbd32ad690ad6ced5c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae48a6558f38a9dbd32ad690ad6ced5c2.html#ae48a6558f38a9dbd32ad690ad6ced5c2">skew_normal_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ae48a6558f38a9dbd32ad690ad6ced5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf239e2c3fabdf414caa12182c80282f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:abf239e2c3fabdf414caa12182c80282f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abf239e2c3fabdf414caa12182c80282f.html#abf239e2c3fabdf414caa12182c80282f">skew_normal_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:abf239e2c3fabdf414caa12182c80282f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e97e7510fdd2f22c66fdba9cb92ab8d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ga4e97e7510fdd2f22c66fdba9cb92ab8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga4e97e7510fdd2f22c66fdba9cb92ab8d.html#ga4e97e7510fdd2f22c66fdba9cb92ab8d">skew_normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ga4e97e7510fdd2f22c66fdba9cb92ab8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec3ea1babb7c01a8b2d498f5239ae2df"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:gaec3ea1babb7c01a8b2d498f5239ae2df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaec3ea1babb7c01a8b2d498f5239ae2df.html#gaec3ea1babb7c01a8b2d498f5239ae2df">skew_normal_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:gaec3ea1babb7c01a8b2d498f5239ae2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac444148d8c85d0e486c147490ca530d7"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_loc, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac444148d8c85d0e486c147490ca530d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac444148d8c85d0e486c147490ca530d7.html#ac444148d8c85d0e486c147490ca530d7">skew_normal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ac444148d8c85d0e486c147490ca530d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009ca16c70278dd47a2491630031eae7"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a009ca16c70278dd47a2491630031eae7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a009ca16c70278dd47a2491630031eae7.html#a009ca16c70278dd47a2491630031eae7">skew_normal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a009ca16c70278dd47a2491630031eae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5c3bc9fa1efe31f6081aa87241f326"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , typename T_shape , class RNG &gt; </td></tr>
<tr class="memitem:gaac5c3bc9fa1efe31f6081aa87241f326"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaac5c3bc9fa1efe31f6081aa87241f326.html#gaac5c3bc9fa1efe31f6081aa87241f326">skew_normal_rng</a> (const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha, RNG &amp;rng)</td></tr>
<tr class="separator:gaac5c3bc9fa1efe31f6081aa87241f326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga412a140aaef58a19f63c2663659fe387"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:ga412a140aaef58a19f63c2663659fe387"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga412a140aaef58a19f63c2663659fe387.html#ga412a140aaef58a19f63c2663659fe387">std_normal_ccdf_log</a> (const T_y &amp;y)</td></tr>
<tr class="separator:ga412a140aaef58a19f63c2663659fe387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf10a7a84b4c6598687fe0e6d72e0378c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf10a7a84b4c6598687fe0e6d72e0378c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaf10a7a84b4c6598687fe0e6d72e0378c.html#gaf10a7a84b4c6598687fe0e6d72e0378c">std_normal_cdf</a> (const T_y &amp;y)</td></tr>
<tr class="separator:gaf10a7a84b4c6598687fe0e6d72e0378c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a73db7cffdb04ac5c13e91c6dd4e287"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:ga9a73db7cffdb04ac5c13e91c6dd4e287"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga9a73db7cffdb04ac5c13e91c6dd4e287.html#ga9a73db7cffdb04ac5c13e91c6dd4e287">std_normal_cdf_log</a> (const T_y &amp;y)</td></tr>
<tr class="separator:ga9a73db7cffdb04ac5c13e91c6dd4e287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb72e2c97fc7291a91ec2e313b9ca1fb"><td class="memTemplParams" colspan="2">template&lt;typename T_y , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afb72e2c97fc7291a91ec2e313b9ca1fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afb72e2c97fc7291a91ec2e313b9ca1fb.html#afb72e2c97fc7291a91ec2e313b9ca1fb">std_normal_lccdf</a> (const T_y &amp;y)</td></tr>
<tr class="separator:afb72e2c97fc7291a91ec2e313b9ca1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273a8fee357ed6b9f275f4bb727e18d7"><td class="memTemplParams" colspan="2">template&lt;typename T_y , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a273a8fee357ed6b9f275f4bb727e18d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a273a8fee357ed6b9f275f4bb727e18d7.html#a273a8fee357ed6b9f275f4bb727e18d7">std_normal_lcdf</a> (const T_y &amp;y)</td></tr>
<tr class="separator:a273a8fee357ed6b9f275f4bb727e18d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab17d81f98764c21b231feff906633363"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y &gt; </td></tr>
<tr class="memitem:gab17d81f98764c21b231feff906633363"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab17d81f98764c21b231feff906633363.html#gab17d81f98764c21b231feff906633363">std_normal_log</a> (const T_y &amp;y)</td></tr>
<tr class="separator:gab17d81f98764c21b231feff906633363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0a8bce4e28557df0ac36b46962b848d"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:gaa0a8bce4e28557df0ac36b46962b848d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaa0a8bce4e28557df0ac36b46962b848d.html#gaa0a8bce4e28557df0ac36b46962b848d">std_normal_log</a> (const T_y &amp;y)</td></tr>
<tr class="separator:gaa0a8bce4e28557df0ac36b46962b848d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992d8a59f95bb03c02cabaa39ca31e6a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a992d8a59f95bb03c02cabaa39ca31e6a.html#a992d8a59f95bb03c02cabaa39ca31e6a">std_normal_log_qf</a> (double log_p)</td></tr>
<tr class="memdesc:a992d8a59f95bb03c02cabaa39ca31e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of the unit normal cumulative distribution function evaluated at the log probability.  <a href="namespacestan_1_1math_a992d8a59f95bb03c02cabaa39ca31e6a.html#a992d8a59f95bb03c02cabaa39ca31e6a">More...</a><br /></td></tr>
<tr class="separator:a992d8a59f95bb03c02cabaa39ca31e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcab7604d818420f4222f28f7c593d87"><td class="memTemplParams" colspan="2">template&lt;typename T , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T &gt; *  = nullptr, require_not_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abcab7604d818420f4222f28f7c593d87"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abcab7604d818420f4222f28f7c593d87.html#abcab7604d818420f4222f28f7c593d87">std_normal_log_qf</a> (const T &amp;x)</td></tr>
<tr class="memdesc:abcab7604d818420f4222f28f7c593d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vectorized version of <a class="el" href="namespacestan_1_1math_a4cd6e40d63f90cc814b22b6560ab4e51.html#a4cd6e40d63f90cc814b22b6560ab4e51">std_normal_log_qf()</a> that accepts std::vectors, <a class="el" href="namespace_eigen.html">Eigen</a> Matrix/Array objects, or expressions, and containers of these.  <a href="namespacestan_1_1math_abcab7604d818420f4222f28f7c593d87.html#abcab7604d818420f4222f28f7c593d87">More...</a><br /></td></tr>
<tr class="separator:abcab7604d818420f4222f28f7c593d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f3fd379de9377381cfb25e4bfffbe93"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1f3fd379de9377381cfb25e4bfffbe93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga1f3fd379de9377381cfb25e4bfffbe93.html#ga1f3fd379de9377381cfb25e4bfffbe93">std_normal_lpdf</a> (const T_y &amp;y)</td></tr>
<tr class="separator:ga1f3fd379de9377381cfb25e4bfffbe93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b6c58a50b07b2c5bcf3e84711a0df1"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a09b6c58a50b07b2c5bcf3e84711a0df1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a09b6c58a50b07b2c5bcf3e84711a0df1.html#a09b6c58a50b07b2c5bcf3e84711a0df1">std_normal_lpdf</a> (const T_y &amp;y)</td></tr>
<tr class="separator:a09b6c58a50b07b2c5bcf3e84711a0df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga817cc9eafbbbea3ff44586ab9c54222e"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ga817cc9eafbbbea3ff44586ab9c54222e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga817cc9eafbbbea3ff44586ab9c54222e.html#ga817cc9eafbbbea3ff44586ab9c54222e">std_normal_rng</a> (RNG &amp;rng)</td></tr>
<tr class="separator:ga817cc9eafbbbea3ff44586ab9c54222e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880e24fdc44adb0338a0e5c1faaf950f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga880e24fdc44adb0338a0e5c1faaf950f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga880e24fdc44adb0338a0e5c1faaf950f.html#ga880e24fdc44adb0338a0e5c1faaf950f">student_t_ccdf_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga880e24fdc44adb0338a0e5c1faaf950f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ec4a4d484250b744cc83c83afa053e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a48ec4a4d484250b744cc83c83afa053e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a48ec4a4d484250b744cc83c83afa053e.html#a48ec4a4d484250b744cc83c83afa053e">student_t_cdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a48ec4a4d484250b744cc83c83afa053e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaade619adfb7306fc2cf2e535639b9e94"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gaade619adfb7306fc2cf2e535639b9e94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaade619adfb7306fc2cf2e535639b9e94.html#gaade619adfb7306fc2cf2e535639b9e94">student_t_cdf_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gaade619adfb7306fc2cf2e535639b9e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526eab4b9c16975b1728bebafd98907b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a526eab4b9c16975b1728bebafd98907b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a526eab4b9c16975b1728bebafd98907b.html#a526eab4b9c16975b1728bebafd98907b">student_t_lccdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a526eab4b9c16975b1728bebafd98907b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ec6d17f7fbb18f6eb3738d054cc3ae"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a87ec6d17f7fbb18f6eb3738d054cc3ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a87ec6d17f7fbb18f6eb3738d054cc3ae.html#a87ec6d17f7fbb18f6eb3738d054cc3ae">student_t_lcdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a87ec6d17f7fbb18f6eb3738d054cc3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420cfe53d82ad24acd81d83f86fc91c0"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga420cfe53d82ad24acd81d83f86fc91c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga420cfe53d82ad24acd81d83f86fc91c0.html#ga420cfe53d82ad24acd81d83f86fc91c0">student_t_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga420cfe53d82ad24acd81d83f86fc91c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72486494493913afd09ced24af9f8a65"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga72486494493913afd09ced24af9f8a65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga72486494493913afd09ced24af9f8a65.html#ga72486494493913afd09ced24af9f8a65">student_t_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga72486494493913afd09ced24af9f8a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5de4b570216fc967a1256f55c24a87aa"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_loc , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_dof, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5de4b570216fc967a1256f55c24a87aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga5de4b570216fc967a1256f55c24a87aa.html#ga5de4b570216fc967a1256f55c24a87aa">student_t_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga5de4b570216fc967a1256f55c24a87aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83821ed5f6b9dcde59b9d445abfd6408"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a83821ed5f6b9dcde59b9d445abfd6408"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a83821ed5f6b9dcde59b9d445abfd6408.html#a83821ed5f6b9dcde59b9d445abfd6408">student_t_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a83821ed5f6b9dcde59b9d445abfd6408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54af83af6c6747bad1033a07d5746c74"><td class="memTemplParams" colspan="2">template&lt;typename T_deg , typename T_loc , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga54af83af6c6747bad1033a07d5746c74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_deg, T_loc, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga54af83af6c6747bad1033a07d5746c74.html#ga54af83af6c6747bad1033a07d5746c74">student_t_rng</a> (const T_deg &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="separator:ga54af83af6c6747bad1033a07d5746c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabae6c82c4c90184b5c3cb35ae79bc9b7"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:gabae6c82c4c90184b5c3cb35ae79bc9b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_low, T_high &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gabae6c82c4c90184b5c3cb35ae79bc9b7.html#gabae6c82c4c90184b5c3cb35ae79bc9b7">uniform_ccdf_log</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gabae6c82c4c90184b5c3cb35ae79bc9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7244f82f86bd39bed3dc24844c5cc779"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_low, T_high &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7244f82f86bd39bed3dc24844c5cc779"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_low, T_high &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7244f82f86bd39bed3dc24844c5cc779.html#a7244f82f86bd39bed3dc24844c5cc779">uniform_cdf</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a7244f82f86bd39bed3dc24844c5cc779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad224199415cae8a7f6ab7d450c99514d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:gad224199415cae8a7f6ab7d450c99514d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_low, T_high &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad224199415cae8a7f6ab7d450c99514d.html#gad224199415cae8a7f6ab7d450c99514d">uniform_cdf_log</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gad224199415cae8a7f6ab7d450c99514d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343642a50e94ef52f5629fca8b471328"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_low, T_high &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a343642a50e94ef52f5629fca8b471328"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_low, T_high &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a343642a50e94ef52f5629fca8b471328.html#a343642a50e94ef52f5629fca8b471328">uniform_lccdf</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a343642a50e94ef52f5629fca8b471328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbf167d98f9322877e93a7c0846820f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_low, T_high &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5cbf167d98f9322877e93a7c0846820f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_low, T_high &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5cbf167d98f9322877e93a7c0846820f.html#a5cbf167d98f9322877e93a7c0846820f">uniform_lcdf</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a5cbf167d98f9322877e93a7c0846820f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5417d5d7463f9e5c90eee4b1027f1c6d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:ga5417d5d7463f9e5c90eee4b1027f1c6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_low, T_high &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga5417d5d7463f9e5c90eee4b1027f1c6d.html#ga5417d5d7463f9e5c90eee4b1027f1c6d">uniform_log</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga5417d5d7463f9e5c90eee4b1027f1c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81f4b7598ccfa9410e4fd142862e425e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:ga81f4b7598ccfa9410e4fd142862e425e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_low, T_high &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga81f4b7598ccfa9410e4fd142862e425e.html#ga81f4b7598ccfa9410e4fd142862e425e">uniform_log</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:ga81f4b7598ccfa9410e4fd142862e425e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad41f132773c26694616fc2cd749fd43b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_low , typename T_high , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_low, T_high &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad41f132773c26694616fc2cd749fd43b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_low, T_high &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad41f132773c26694616fc2cd749fd43b.html#gad41f132773c26694616fc2cd749fd43b">uniform_lpdf</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:gad41f132773c26694616fc2cd749fd43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2899cdf71c00b15260d3bc7ff1a3c016"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:a2899cdf71c00b15260d3bc7ff1a3c016"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_low, T_high &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2899cdf71c00b15260d3bc7ff1a3c016.html#a2899cdf71c00b15260d3bc7ff1a3c016">uniform_lpdf</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="separator:a2899cdf71c00b15260d3bc7ff1a3c016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2be3c17e5285ae1615aa77ea9f5b0d9"><td class="memTemplParams" colspan="2">template&lt;typename T_alpha , typename T_beta , class RNG &gt; </td></tr>
<tr class="memitem:gad2be3c17e5285ae1615aa77ea9f5b0d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_alpha, T_beta &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad2be3c17e5285ae1615aa77ea9f5b0d9.html#gad2be3c17e5285ae1615aa77ea9f5b0d9">uniform_rng</a> (const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, RNG &amp;rng)</td></tr>
<tr class="separator:gad2be3c17e5285ae1615aa77ea9f5b0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15866de3088aac75af549aa44b12f120"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_mu , typename T_k &gt; </td></tr>
<tr class="memitem:ga15866de3088aac75af549aa44b12f120"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_mu, T_k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga15866de3088aac75af549aa44b12f120.html#ga15866de3088aac75af549aa44b12f120">von_mises_ccdf_log</a> (const T_x &amp;x, const T_mu &amp;mu, const T_k &amp;k)</td></tr>
<tr class="separator:ga15866de3088aac75af549aa44b12f120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga206e0ba915755e884d9ea96cf8ae9cd8"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_mu , typename T_k &gt; </td></tr>
<tr class="memitem:ga206e0ba915755e884d9ea96cf8ae9cd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_mu, T_k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga206e0ba915755e884d9ea96cf8ae9cd8.html#ga206e0ba915755e884d9ea96cf8ae9cd8">von_mises_cdf</a> (const T_x &amp;x, const T_mu &amp;mu, const T_k &amp;k)</td></tr>
<tr class="separator:ga206e0ba915755e884d9ea96cf8ae9cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga376915fecbd6e7a534956137b446ee76"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_mu , typename T_k &gt; </td></tr>
<tr class="memitem:ga376915fecbd6e7a534956137b446ee76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_mu, T_k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga376915fecbd6e7a534956137b446ee76.html#ga376915fecbd6e7a534956137b446ee76">von_mises_cdf_log</a> (const T_x &amp;x, const T_mu &amp;mu, const T_k &amp;k)</td></tr>
<tr class="separator:ga376915fecbd6e7a534956137b446ee76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61683b59d12a37982d0888ff73c83d09"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_mu , typename T_k &gt; </td></tr>
<tr class="memitem:ga61683b59d12a37982d0888ff73c83d09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_mu, T_k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga61683b59d12a37982d0888ff73c83d09.html#ga61683b59d12a37982d0888ff73c83d09">von_mises_lccdf</a> (const T_x &amp;x, const T_mu &amp;mu, const T_k &amp;k)</td></tr>
<tr class="separator:ga61683b59d12a37982d0888ff73c83d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab41de7bba3df8fa140e15116b34331d5"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_mu , typename T_k &gt; </td></tr>
<tr class="memitem:gab41de7bba3df8fa140e15116b34331d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_mu, T_k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab41de7bba3df8fa140e15116b34331d5.html#gab41de7bba3df8fa140e15116b34331d5">von_mises_lcdf</a> (const T_x &amp;x, const T_mu &amp;mu, const T_k &amp;k)</td></tr>
<tr class="separator:gab41de7bba3df8fa140e15116b34331d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e181f0a22851d90bf80ed18b1d22dea"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga7e181f0a22851d90bf80ed18b1d22dea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga7e181f0a22851d90bf80ed18b1d22dea.html#ga7e181f0a22851d90bf80ed18b1d22dea">von_mises_log</a> (T_y const &amp;y, T_loc const &amp;mu, T_scale const &amp;kappa)</td></tr>
<tr class="separator:ga7e181f0a22851d90bf80ed18b1d22dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb9020cca027554d452f5778c80ed14"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga0eb9020cca027554d452f5778c80ed14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga0eb9020cca027554d452f5778c80ed14.html#ga0eb9020cca027554d452f5778c80ed14">von_mises_log</a> (T_y const &amp;y, T_loc const &amp;mu, T_scale const &amp;kappa)</td></tr>
<tr class="separator:ga0eb9020cca027554d452f5778c80ed14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f632435ed8258265333a476962c3d5f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a2f632435ed8258265333a476962c3d5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f632435ed8258265333a476962c3d5f.html#a2f632435ed8258265333a476962c3d5f">von_mises_lpdf</a> (T_y const &amp;y, T_loc const &amp;mu, T_scale const &amp;kappa)</td></tr>
<tr class="separator:a2f632435ed8258265333a476962c3d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e09e56eb6999d33d3d103d4795d9b31"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a0e09e56eb6999d33d3d103d4795d9b31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0e09e56eb6999d33d3d103d4795d9b31.html#a0e09e56eb6999d33d3d103d4795d9b31">von_mises_lpdf</a> (T_y const &amp;y, T_loc const &amp;mu, T_scale const &amp;kappa)</td></tr>
<tr class="separator:a0e09e56eb6999d33d3d103d4795d9b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc51e800d2871c42c33ae57cac8773f7"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_conc , class RNG &gt; </td></tr>
<tr class="memitem:gadc51e800d2871c42c33ae57cac8773f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_conc &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gadc51e800d2871c42c33ae57cac8773f7.html#gadc51e800d2871c42c33ae57cac8773f7">von_mises_rng</a> (const T_loc &amp;mu, const T_conc &amp;kappa, RNG &amp;rng)</td></tr>
<tr class="separator:gadc51e800d2871c42c33ae57cac8773f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c6042351102640bac486ffacd27eaaf"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ga0c6042351102640bac486ffacd27eaaf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga0c6042351102640bac486ffacd27eaaf.html#ga0c6042351102640bac486ffacd27eaaf">weibull_ccdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga0c6042351102640bac486ffacd27eaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19282d0fd2c9db0f2b41e3dc8ffc21e7"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga19282d0fd2c9db0f2b41e3dc8ffc21e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga19282d0fd2c9db0f2b41e3dc8ffc21e7.html#ga19282d0fd2c9db0f2b41e3dc8ffc21e7">weibull_cdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga19282d0fd2c9db0f2b41e3dc8ffc21e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga224b0ce3076125cbf59d46f19a1661f8"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ga224b0ce3076125cbf59d46f19a1661f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga224b0ce3076125cbf59d46f19a1661f8.html#ga224b0ce3076125cbf59d46f19a1661f8">weibull_cdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga224b0ce3076125cbf59d46f19a1661f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga605d557caf532d30bd359b511aa6b24a"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga605d557caf532d30bd359b511aa6b24a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga605d557caf532d30bd359b511aa6b24a.html#ga605d557caf532d30bd359b511aa6b24a">weibull_lccdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga605d557caf532d30bd359b511aa6b24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga073a4c653887c5aecd5f31a80f679085"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga073a4c653887c5aecd5f31a80f679085"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga073a4c653887c5aecd5f31a80f679085.html#ga073a4c653887c5aecd5f31a80f679085">weibull_lcdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga073a4c653887c5aecd5f31a80f679085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44ea9aa8a94ab414ef9a6b8163bcf85d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ga44ea9aa8a94ab414ef9a6b8163bcf85d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga44ea9aa8a94ab414ef9a6b8163bcf85d.html#ga44ea9aa8a94ab414ef9a6b8163bcf85d">weibull_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga44ea9aa8a94ab414ef9a6b8163bcf85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eece0c346ffdffe03b9bccf948fae9e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ga1eece0c346ffdffe03b9bccf948fae9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga1eece0c346ffdffe03b9bccf948fae9e.html#ga1eece0c346ffdffe03b9bccf948fae9e">weibull_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga1eece0c346ffdffe03b9bccf948fae9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga002e55db6f04e1d7d7ccc5c5f560cc30"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape , typename T_scale , require_all_not_nonscalar_prim_or_rev_kernel_expression_t&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga002e55db6f04e1d7d7ccc5c5f560cc30"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga002e55db6f04e1d7d7ccc5c5f560cc30.html#ga002e55db6f04e1d7d7ccc5c5f560cc30">weibull_lpdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga002e55db6f04e1d7d7ccc5c5f560cc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362ae928986c48154ed3a74a5ed939fc"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:a362ae928986c48154ed3a74a5ed939fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a362ae928986c48154ed3a74a5ed939fc.html#a362ae928986c48154ed3a74a5ed939fc">weibull_lpdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a362ae928986c48154ed3a74a5ed939fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27b202d00ff0b255e718bccc4dbe4465"><td class="memTemplParams" colspan="2">template&lt;typename T_shape , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga27b202d00ff0b255e718bccc4dbe4465"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_shape, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga27b202d00ff0b255e718bccc4dbe4465.html#ga27b202d00ff0b255e718bccc4dbe4465">weibull_rng</a> (const T_shape &amp;alpha, const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="separator:ga27b202d00ff0b255e718bccc4dbe4465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61e07e3d42fe418aa8cf827fc19d550e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_alpha , typename T_tau , typename T_beta , typename T_delta &gt; </td></tr>
<tr class="memitem:ga61e07e3d42fe418aa8cf827fc19d550e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_alpha, T_tau, T_beta, T_delta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga61e07e3d42fe418aa8cf827fc19d550e.html#ga61e07e3d42fe418aa8cf827fc19d550e">wiener_log</a> (const T_y &amp;y, const T_alpha &amp;alpha, const T_tau &amp;tau, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_delta &amp;delta)</td></tr>
<tr class="separator:ga61e07e3d42fe418aa8cf827fc19d550e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56338d5889fc4dfe02eef4967a9274cf"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_alpha , typename T_tau , typename T_beta , typename T_delta &gt; </td></tr>
<tr class="memitem:ga56338d5889fc4dfe02eef4967a9274cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_alpha, T_tau, T_beta, T_delta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga56338d5889fc4dfe02eef4967a9274cf.html#ga56338d5889fc4dfe02eef4967a9274cf">wiener_log</a> (const T_y &amp;y, const T_alpha &amp;alpha, const T_tau &amp;tau, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_delta &amp;delta)</td></tr>
<tr class="separator:ga56338d5889fc4dfe02eef4967a9274cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccd61b4dd530c96e95da436b4465dd93"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_alpha , typename T_tau , typename T_beta , typename T_delta &gt; </td></tr>
<tr class="memitem:gaccd61b4dd530c96e95da436b4465dd93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_alpha, T_tau, T_beta, T_delta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaccd61b4dd530c96e95da436b4465dd93.html#gaccd61b4dd530c96e95da436b4465dd93">wiener_lpdf</a> (const T_y &amp;y, const T_alpha &amp;alpha, const T_tau &amp;tau, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_delta &amp;delta)</td></tr>
<tr class="separator:gaccd61b4dd530c96e95da436b4465dd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e69421f7c7684330c26c4c3744f0e3"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_alpha , typename T_tau , typename T_beta , typename T_delta &gt; </td></tr>
<tr class="memitem:a22e69421f7c7684330c26c4c3744f0e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_alpha, T_tau, T_beta, T_delta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a22e69421f7c7684330c26c4c3744f0e3.html#a22e69421f7c7684330c26c4c3744f0e3">wiener_lpdf</a> (const T_y &amp;y, const T_alpha &amp;alpha, const T_tau &amp;tau, const T_beta &amp;<a class="el" href="namespacestan_1_1math_a7c292999da7b2d1eb7a5b3d94f75525a.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_delta &amp;delta)</td></tr>
<tr class="separator:a22e69421f7c7684330c26c4c3744f0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21cac8ddcdaf76b1b20cd49f73e55313"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale , require_stan_scalar_t&lt; T_dof &gt; *  = nullptr, require_all_matrix_t&lt; T_y, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga21cac8ddcdaf76b1b20cd49f73e55313"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga21cac8ddcdaf76b1b20cd49f73e55313.html#ga21cac8ddcdaf76b1b20cd49f73e55313">wishart_cholesky_lpdf</a> (const T_y &amp;L_Y, const T_dof &amp;nu, const T_scale &amp;L_S)</td></tr>
<tr class="separator:ga21cac8ddcdaf76b1b20cd49f73e55313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e9ecaccf83d159ccfb73c6bcd4ef8c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:ac5e9ecaccf83d159ccfb73c6bcd4ef8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac5e9ecaccf83d159ccfb73c6bcd4ef8c.html#ac5e9ecaccf83d159ccfb73c6bcd4ef8c">wishart_cholesky_lpdf</a> (const T_y &amp;LW, const T_dof &amp;nu, const T_scale &amp;L_S)</td></tr>
<tr class="separator:ac5e9ecaccf83d159ccfb73c6bcd4ef8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6268c64d1f5d09c928bdefffa49b9371"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ga6268c64d1f5d09c928bdefffa49b9371"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga6268c64d1f5d09c928bdefffa49b9371.html#ga6268c64d1f5d09c928bdefffa49b9371">wishart_cholesky_rng</a> (double nu, const Eigen::MatrixXd &amp;L_S, RNG &amp;rng)</td></tr>
<tr class="separator:ga6268c64d1f5d09c928bdefffa49b9371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87c0dd922ca1264e0a9edf696b1c1df5"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:ga87c0dd922ca1264e0a9edf696b1c1df5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga87c0dd922ca1264e0a9edf696b1c1df5.html#ga87c0dd922ca1264e0a9edf696b1c1df5">wishart_log</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="separator:ga87c0dd922ca1264e0a9edf696b1c1df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb976f445cd5d31069393ee76d763d14"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:gabb976f445cd5d31069393ee76d763d14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gabb976f445cd5d31069393ee76d763d14.html#gabb976f445cd5d31069393ee76d763d14">wishart_log</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="separator:gabb976f445cd5d31069393ee76d763d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2ed3c31ff75e645d1b12662685a9492"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale , require_stan_scalar_t&lt; T_dof &gt; *  = nullptr, require_all_matrix_t&lt; T_y, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad2ed3c31ff75e645d1b12662685a9492"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gad2ed3c31ff75e645d1b12662685a9492.html#gad2ed3c31ff75e645d1b12662685a9492">wishart_lpdf</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="separator:gad2ed3c31ff75e645d1b12662685a9492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f0cb3210cff31242d0babf840f74f4"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:ac1f0cb3210cff31242d0babf840f74f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac1f0cb3210cff31242d0babf840f74f4.html#ac1f0cb3210cff31242d0babf840f74f4">wishart_lpdf</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="separator:ac1f0cb3210cff31242d0babf840f74f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb86f966da896e53db32813047d5bcf"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:aebb86f966da896e53db32813047d5bcf"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aebb86f966da896e53db32813047d5bcf.html#aebb86f966da896e53db32813047d5bcf">wishart_rng</a> (double nu, const Eigen::MatrixXd &amp;S, RNG &amp;rng)</td></tr>
<tr class="separator:aebb86f966da896e53db32813047d5bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad694c462755d951d8aae2e76a6d91c99"><td class="memTemplParams" colspan="2">template&lt;typename... Pargs&gt; </td></tr>
<tr class="memitem:ad694c462755d951d8aae2e76a6d91c99"><td class="memTemplItemLeft" align="right" valign="top">double *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad694c462755d951d8aae2e76a6d91c99.html#ad694c462755d951d8aae2e76a6d91c99">accumulate_adjoints</a> (double *dest, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad694c462755d951d8aae2e76a6d91c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate adjoints from x into storage pointed to by dest, increment the adjoint storage pointer, recursively accumulate the adjoints of the rest of the arguments, and return final position of storage pointer.  <a href="namespacestan_1_1math_ad694c462755d951d8aae2e76a6d91c99.html#ad694c462755d951d8aae2e76a6d91c99">More...</a><br /></td></tr>
<tr class="separator:ad694c462755d951d8aae2e76a6d91c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ed4abe0efd57f9fa5e5ca28c4511bf"><td class="memTemplParams" colspan="2">template&lt;typename VarVec , require_std_vector_vt&lt; is_var, VarVec &gt; *  = nullptr, typename... Pargs&gt; </td></tr>
<tr class="memitem:a64ed4abe0efd57f9fa5e5ca28c4511bf"><td class="memTemplItemLeft" align="right" valign="top">double *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a64ed4abe0efd57f9fa5e5ca28c4511bf.html#a64ed4abe0efd57f9fa5e5ca28c4511bf">accumulate_adjoints</a> (double *dest, VarVec &amp;&amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a64ed4abe0efd57f9fa5e5ca28c4511bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate adjoints from std::vector x into storage pointed to by dest, increment the adjoint storage pointer, recursively accumulate the adjoints of the rest of the arguments, and return final position of storage pointer.  <a href="namespacestan_1_1math_a64ed4abe0efd57f9fa5e5ca28c4511bf.html#a64ed4abe0efd57f9fa5e5ca28c4511bf">More...</a><br /></td></tr>
<tr class="separator:a64ed4abe0efd57f9fa5e5ca28c4511bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72556ebf9e5e07f90c16f5a0cf5086f3"><td class="memTemplParams" colspan="2">template&lt;typename VecContainer , require_std_vector_st&lt; is_var, VecContainer &gt; *  = nullptr, require_std_vector_vt&lt; is_container, VecContainer &gt; *  = nullptr, typename... Pargs&gt; </td></tr>
<tr class="memitem:a72556ebf9e5e07f90c16f5a0cf5086f3"><td class="memTemplItemLeft" align="right" valign="top">double *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a72556ebf9e5e07f90c16f5a0cf5086f3.html#a72556ebf9e5e07f90c16f5a0cf5086f3">accumulate_adjoints</a> (double *dest, VecContainer &amp;&amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a72556ebf9e5e07f90c16f5a0cf5086f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate adjoints from x (a std::vector of containers containing vars) into storage pointed to by dest, increment the adjoint storage pointer, recursively accumulate the adjoints of the rest of the arguments, and return final position of storage pointer.  <a href="namespacestan_1_1math_a72556ebf9e5e07f90c16f5a0cf5086f3.html#a72556ebf9e5e07f90c16f5a0cf5086f3">More...</a><br /></td></tr>
<tr class="separator:a72556ebf9e5e07f90c16f5a0cf5086f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e37bf3dbcabc2d866f0e1885b2c34b"><td class="memTemplParams" colspan="2">template&lt;typename EigT , require_eigen_vt&lt; is_var, EigT &gt; *  = nullptr, typename... Pargs&gt; </td></tr>
<tr class="memitem:ab2e37bf3dbcabc2d866f0e1885b2c34b"><td class="memTemplItemLeft" align="right" valign="top">double *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab2e37bf3dbcabc2d866f0e1885b2c34b.html#ab2e37bf3dbcabc2d866f0e1885b2c34b">accumulate_adjoints</a> (double *dest, EigT &amp;&amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab2e37bf3dbcabc2d866f0e1885b2c34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate adjoints from x (an <a class="el" href="namespace_eigen.html">Eigen</a> type containing vars) into storage pointed to by dest, increment the adjoint storage pointer, recursively accumulate the adjoints of the rest of the arguments, and return final position of storage pointer.  <a href="namespacestan_1_1math_ab2e37bf3dbcabc2d866f0e1885b2c34b.html#ab2e37bf3dbcabc2d866f0e1885b2c34b">More...</a><br /></td></tr>
<tr class="separator:ab2e37bf3dbcabc2d866f0e1885b2c34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9040b37752a6e6c50ace71a4979ad071"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_st_arithmetic&lt; Arith &gt; *  = nullptr, typename... Pargs&gt; </td></tr>
<tr class="memitem:a9040b37752a6e6c50ace71a4979ad071"><td class="memTemplItemLeft" align="right" valign="top">double *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9040b37752a6e6c50ace71a4979ad071.html#a9040b37752a6e6c50ace71a4979ad071">accumulate_adjoints</a> (double *dest, Arith &amp;&amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9040b37752a6e6c50ace71a4979ad071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore arithmetic types.  <a href="namespacestan_1_1math_a9040b37752a6e6c50ace71a4979ad071.html#a9040b37752a6e6c50ace71a4979ad071">More...</a><br /></td></tr>
<tr class="separator:a9040b37752a6e6c50ace71a4979ad071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fab0c7f17b4e5dbda5d7ec4ab822a38"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1fab0c7f17b4e5dbda5d7ec4ab822a38.html#a1fab0c7f17b4e5dbda5d7ec4ab822a38">accumulate_adjoints</a> (double *dest)</td></tr>
<tr class="memdesc:a1fab0c7f17b4e5dbda5d7ec4ab822a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">End accumulate_adjoints recursion and return pointer.  <a href="namespacestan_1_1math_a1fab0c7f17b4e5dbda5d7ec4ab822a38.html#a1fab0c7f17b4e5dbda5d7ec4ab822a38">More...</a><br /></td></tr>
<tr class="separator:a1fab0c7f17b4e5dbda5d7ec4ab822a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d379f499cd081ab48b54c382a3b741"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:ae7d379f499cd081ab48b54c382a3b741"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae7d379f499cd081ab48b54c382a3b741.html#ae7d379f499cd081ab48b54c382a3b741">build_vari_array</a> (const Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, R, C &gt; &amp;x)</td></tr>
<tr class="memdesc:ae7d379f499cd081ab48b54c382a3b741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and populates a flat array of vari pointers in the autodiff arena with the varis pointed to by the vars in the input <a class="el" href="namespace_eigen.html">Eigen</a> matrix.  <a href="namespacestan_1_1math_ae7d379f499cd081ab48b54c382a3b741.html#ae7d379f499cd081ab48b54c382a3b741">More...</a><br /></td></tr>
<tr class="separator:ae7d379f499cd081ab48b54c382a3b741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286702f6efaf9773ece83c315c2710d7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a286702f6efaf9773ece83c315c2710d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1internal_1_1callback__vari.html">internal::callback_vari</a>&lt; <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;, F &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a286702f6efaf9773ece83c315c2710d7.html#a286702f6efaf9773ece83c315c2710d7">make_callback_vari</a> (T &amp;&amp;value, F &amp;&amp;functor)</td></tr>
<tr class="memdesc:a286702f6efaf9773ece83c315c2710d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vari with given value and a callback that implements the reverse pass (chain).  <a href="namespacestan_1_1math_a286702f6efaf9773ece83c315c2710d7.html#a286702f6efaf9773ece83c315c2710d7">More...</a><br /></td></tr>
<tr class="separator:a286702f6efaf9773ece83c315c2710d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12dd8270b3ffc0ee066d306b240f4bb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ab12dd8270b3ffc0ee066d306b240f4bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab12dd8270b3ffc0ee066d306b240f4bb.html#ab12dd8270b3ffc0ee066d306b240f4bb">make_callback_var</a> (T &amp;&amp;value, F &amp;&amp;functor)</td></tr>
<tr class="memdesc:ab12dd8270b3ffc0ee066d306b240f4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new var initialized with a callback_vari with a given value and reverse-pass callback functor.  <a href="namespacestan_1_1math_ab12dd8270b3ffc0ee066d306b240f4bb.html#ab12dd8270b3ffc0ee066d306b240f4bb">More...</a><br /></td></tr>
<tr class="separator:ab12dd8270b3ffc0ee066d306b240f4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746b7da3f8dc730469bcde9c6dd47459"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a746b7da3f8dc730469bcde9c6dd47459"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a746b7da3f8dc730469bcde9c6dd47459.html#a746b7da3f8dc730469bcde9c6dd47459">make_chainable_ptr</a> (T &amp;&amp;obj)</td></tr>
<tr class="memdesc:a746b7da3f8dc730469bcde9c6dd47459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the given object in a <code><a class="el" href="classstan_1_1math_1_1chainable__object.html" title="chainable_object hold another object is useful for connecting the lifetime of a specific object to th...">chainable_object</a></code> so it is destructed only when the chainable stack memory is recovered and return a pointer to the underlying object.  <a href="namespacestan_1_1math_a746b7da3f8dc730469bcde9c6dd47459.html#a746b7da3f8dc730469bcde9c6dd47459">More...</a><br /></td></tr>
<tr class="separator:a746b7da3f8dc730469bcde9c6dd47459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de4be1cc4ea694a0bda0dd238f7914f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3de4be1cc4ea694a0bda0dd238f7914f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3de4be1cc4ea694a0bda0dd238f7914f.html#a3de4be1cc4ea694a0bda0dd238f7914f">make_unsafe_chainable_ptr</a> (T &amp;&amp;obj)</td></tr>
<tr class="memdesc:a3de4be1cc4ea694a0bda0dd238f7914f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the given object in a <code><a class="el" href="classstan_1_1math_1_1chainable__object.html" title="chainable_object hold another object is useful for connecting the lifetime of a specific object to th...">chainable_object</a></code> so it is destructed only when the chainable stack memory is recovered and return a pointer to the underlying object This function differs from <code>make_chainable_object</code> in that this class does not evaluate expressions.  <a href="namespacestan_1_1math_a3de4be1cc4ea694a0bda0dd238f7914f.html#a3de4be1cc4ea694a0bda0dd238f7914f">More...</a><br /></td></tr>
<tr class="separator:a3de4be1cc4ea694a0bda0dd238f7914f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc22cd48b0aa1ae063adbb600c8a198"><td class="memTemplParams" colspan="2">template&lt;typename... Pargs&gt; </td></tr>
<tr class="memitem:a7cc22cd48b0aa1ae063adbb600c8a198"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7cc22cd48b0aa1ae063adbb600c8a198.html#a7cc22cd48b0aa1ae063adbb600c8a198">count_vars</a> (Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7cc22cd48b0aa1ae063adbb600c8a198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of vars in the input argument list.  <a href="namespacestan_1_1math_a7cc22cd48b0aa1ae063adbb600c8a198.html#a7cc22cd48b0aa1ae063adbb600c8a198">More...</a><br /></td></tr>
<tr class="separator:a7cc22cd48b0aa1ae063adbb600c8a198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ff0e8a272893ba0a5e27511036f741"><td class="memTemplParams" colspan="2">template&lt;typename Arith , typename  = require_arithmetic_t&lt;scalar_type_t&lt;Arith&gt;&gt;&gt; </td></tr>
<tr class="memitem:a70ff0e8a272893ba0a5e27511036f741"><td class="memTemplItemLeft" align="right" valign="top">Arith&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a70ff0e8a272893ba0a5e27511036f741.html#a70ff0e8a272893ba0a5e27511036f741">deep_copy_vars</a> (Arith &amp;&amp;<a class="el" href="namespacestan_1_1math_a7c8ad2370c5624d7c0700410e6612514.html#a7c8ad2370c5624d7c0700410e6612514">arg</a>)</td></tr>
<tr class="memdesc:a70ff0e8a272893ba0a5e27511036f741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward arguments that do not contain vars.  <a href="namespacestan_1_1math_a70ff0e8a272893ba0a5e27511036f741.html#a70ff0e8a272893ba0a5e27511036f741">More...</a><br /></td></tr>
<tr class="separator:a70ff0e8a272893ba0a5e27511036f741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b29686f4388da084bd14c6fe1989e3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a22b29686f4388da084bd14c6fe1989e3.html#a22b29686f4388da084bd14c6fe1989e3">deep_copy_vars</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;<a class="el" href="namespacestan_1_1math_a7c8ad2370c5624d7c0700410e6612514.html#a7c8ad2370c5624d7c0700410e6612514">arg</a>)</td></tr>
<tr class="memdesc:a22b29686f4388da084bd14c6fe1989e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the value of a var but reallocate a new vari.  <a href="namespacestan_1_1math_a22b29686f4388da084bd14c6fe1989e3.html#a22b29686f4388da084bd14c6fe1989e3">More...</a><br /></td></tr>
<tr class="separator:a22b29686f4388da084bd14c6fe1989e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fec3c27eaf386d6aaa91f630a216cf3"><td class="memTemplParams" colspan="2">template&lt;typename VarVec , require_std_vector_vt&lt; is_var, VarVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5fec3c27eaf386d6aaa91f630a216cf3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5fec3c27eaf386d6aaa91f630a216cf3.html#a5fec3c27eaf386d6aaa91f630a216cf3">deep_copy_vars</a> (VarVec &amp;&amp;<a class="el" href="namespacestan_1_1math_a7c8ad2370c5624d7c0700410e6612514.html#a7c8ad2370c5624d7c0700410e6612514">arg</a>)</td></tr>
<tr class="memdesc:a5fec3c27eaf386d6aaa91f630a216cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the vars in arg but reallocate new varis for them.  <a href="namespacestan_1_1math_a5fec3c27eaf386d6aaa91f630a216cf3.html#a5fec3c27eaf386d6aaa91f630a216cf3">More...</a><br /></td></tr>
<tr class="separator:a5fec3c27eaf386d6aaa91f630a216cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc7f8b0db0b97d8a6409d1091207d24"><td class="memTemplParams" colspan="2">template&lt;typename VecContainer , require_std_vector_st&lt; is_var, VecContainer &gt; *  = nullptr, require_std_vector_vt&lt; is_container, VecContainer &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1dc7f8b0db0b97d8a6409d1091207d24"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1dc7f8b0db0b97d8a6409d1091207d24.html#a1dc7f8b0db0b97d8a6409d1091207d24">deep_copy_vars</a> (VecContainer &amp;&amp;<a class="el" href="namespacestan_1_1math_a7c8ad2370c5624d7c0700410e6612514.html#a7c8ad2370c5624d7c0700410e6612514">arg</a>)</td></tr>
<tr class="memdesc:a1dc7f8b0db0b97d8a6409d1091207d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the vars in arg but reallocate new varis for them.  <a href="namespacestan_1_1math_a1dc7f8b0db0b97d8a6409d1091207d24.html#a1dc7f8b0db0b97d8a6409d1091207d24">More...</a><br /></td></tr>
<tr class="separator:a1dc7f8b0db0b97d8a6409d1091207d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1ecbbf258a467d2023f151e1bee6df"><td class="memTemplParams" colspan="2">template&lt;typename EigT , require_eigen_vt&lt; is_var, EigT &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b1ecbbf258a467d2023f151e1bee6df"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4b1ecbbf258a467d2023f151e1bee6df.html#a4b1ecbbf258a467d2023f151e1bee6df">deep_copy_vars</a> (EigT &amp;&amp;<a class="el" href="namespacestan_1_1math_a7c8ad2370c5624d7c0700410e6612514.html#a7c8ad2370c5624d7c0700410e6612514">arg</a>)</td></tr>
<tr class="memdesc:a4b1ecbbf258a467d2023f151e1bee6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the vars in arg but reallocate new varis for them.  <a href="namespacestan_1_1math_a4b1ecbbf258a467d2023f151e1bee6df.html#a4b1ecbbf258a467d2023f151e1bee6df">More...</a><br /></td></tr>
<tr class="separator:a4b1ecbbf258a467d2023f151e1bee6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430f171295b91277dc60dfa2177c7c0b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a430f171295b91277dc60dfa2177c7c0b.html#a430f171295b91277dc60dfa2177c7c0b">empty_nested</a> ()</td></tr>
<tr class="memdesc:a430f171295b91277dc60dfa2177c7c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there is no nested autodiff being executed.  <a href="namespacestan_1_1math_a430f171295b91277dc60dfa2177c7c0b.html#a430f171295b91277dc60dfa2177c7c0b">More...</a><br /></td></tr>
<tr class="separator:a430f171295b91277dc60dfa2177c7c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47da1792e5d3b1564c57ecb3a0de900"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae47da1792e5d3b1564c57ecb3a0de900.html#ae47da1792e5d3b1564c57ecb3a0de900">grad</a> ()</td></tr>
<tr class="memdesc:ae47da1792e5d3b1564c57ecb3a0de900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient for all variables starting from the end of the AD tape.  <a href="namespacestan_1_1math_ae47da1792e5d3b1564c57ecb3a0de900.html#ae47da1792e5d3b1564c57ecb3a0de900">More...</a><br /></td></tr>
<tr class="separator:ae47da1792e5d3b1564c57ecb3a0de900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4214c4dd4dc198260d7f4f7fbb8b9fdd"><td class="memTemplParams" colspan="2">template&lt;typename Vari &gt; </td></tr>
<tr class="memitem:a4214c4dd4dc198260d7f4f7fbb8b9fdd"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4214c4dd4dc198260d7f4f7fbb8b9fdd.html#a4214c4dd4dc198260d7f4f7fbb8b9fdd">grad</a> (Vari *vi)</td></tr>
<tr class="memdesc:a4214c4dd4dc198260d7f4f7fbb8b9fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient for all variables starting from the specified root variable implementation.  <a href="namespacestan_1_1math_a4214c4dd4dc198260d7f4f7fbb8b9fdd.html#a4214c4dd4dc198260d7f4f7fbb8b9fdd">More...</a><br /></td></tr>
<tr class="separator:a4214c4dd4dc198260d7f4f7fbb8b9fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f68ac575a2b8dff3a7a2359962c607"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac0f68ac575a2b8dff3a7a2359962c607.html#ac0f68ac575a2b8dff3a7a2359962c607">nested_size</a> ()</td></tr>
<tr class="separator:ac0f68ac575a2b8dff3a7a2359962c607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb4c7bced043de79d94676dac3cfc4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afcb4c7bced043de79d94676dac3cfc4b.html#afcb4c7bced043de79d94676dac3cfc4b">operator+</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:afcb4c7bced043de79d94676dac3cfc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for variables (C++).  <a href="namespacestan_1_1math_afcb4c7bced043de79d94676dac3cfc4b.html#afcb4c7bced043de79d94676dac3cfc4b">More...</a><br /></td></tr>
<tr class="separator:afcb4c7bced043de79d94676dac3cfc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802c5b7e20e2f8fad99c97dbdb55b01c"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a802c5b7e20e2f8fad99c97dbdb55b01c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a802c5b7e20e2f8fad99c97dbdb55b01c.html#a802c5b7e20e2f8fad99c97dbdb55b01c">operator+</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:a802c5b7e20e2f8fad99c97dbdb55b01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for variable and scalar (C++).  <a href="namespacestan_1_1math_a802c5b7e20e2f8fad99c97dbdb55b01c.html#a802c5b7e20e2f8fad99c97dbdb55b01c">More...</a><br /></td></tr>
<tr class="separator:a802c5b7e20e2f8fad99c97dbdb55b01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835916f3b004d05e6e6d93fb13c631bb"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a835916f3b004d05e6e6d93fb13c631bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a835916f3b004d05e6e6d93fb13c631bb.html#a835916f3b004d05e6e6d93fb13c631bb">operator+</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a835916f3b004d05e6e6d93fb13c631bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for scalar and variable (C++).  <a href="namespacestan_1_1math_a835916f3b004d05e6e6d93fb13c631bb.html#a835916f3b004d05e6e6d93fb13c631bb">More...</a><br /></td></tr>
<tr class="separator:a835916f3b004d05e6e6d93fb13c631bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fa37fd1e2a6b9a106b6b26e0155230"><td class="memTemplParams" colspan="2">template&lt;typename VarMat1 , typename VarMat2 , require_all_rev_matrix_t&lt; VarMat1, VarMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa5fa37fd1e2a6b9a106b6b26e0155230"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa5fa37fd1e2a6b9a106b6b26e0155230.html#aa5fa37fd1e2a6b9a106b6b26e0155230">add</a> (const VarMat1 &amp;a, const VarMat2 &amp;b)</td></tr>
<tr class="memdesc:aa5fa37fd1e2a6b9a106b6b26e0155230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for matrix variables (C++).  <a href="namespacestan_1_1math_aa5fa37fd1e2a6b9a106b6b26e0155230.html#aa5fa37fd1e2a6b9a106b6b26e0155230">More...</a><br /></td></tr>
<tr class="separator:aa5fa37fd1e2a6b9a106b6b26e0155230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38acd7b85b9566c59a7045cf81ba59f5"><td class="memTemplParams" colspan="2">template&lt;typename Arith , typename VarMat , require_st_arithmetic&lt; Arith &gt; *  = nullptr, require_rev_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a38acd7b85b9566c59a7045cf81ba59f5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a38acd7b85b9566c59a7045cf81ba59f5.html#a38acd7b85b9566c59a7045cf81ba59f5">add</a> (const VarMat &amp;a, const Arith &amp;b)</td></tr>
<tr class="memdesc:a38acd7b85b9566c59a7045cf81ba59f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for a matrix variable and arithmetic (C++).  <a href="namespacestan_1_1math_a38acd7b85b9566c59a7045cf81ba59f5.html#a38acd7b85b9566c59a7045cf81ba59f5">More...</a><br /></td></tr>
<tr class="separator:a38acd7b85b9566c59a7045cf81ba59f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9141096c3c60884cc1c62f489b105365"><td class="memTemplParams" colspan="2">template&lt;typename Arith , typename VarMat , require_st_arithmetic&lt; Arith &gt; *  = nullptr, require_rev_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9141096c3c60884cc1c62f489b105365"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9141096c3c60884cc1c62f489b105365.html#a9141096c3c60884cc1c62f489b105365">add</a> (const Arith &amp;a, const VarMat &amp;b)</td></tr>
<tr class="memdesc:a9141096c3c60884cc1c62f489b105365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for an arithmetic type and matrix variable (C++).  <a href="namespacestan_1_1math_a9141096c3c60884cc1c62f489b105365.html#a9141096c3c60884cc1c62f489b105365">More...</a><br /></td></tr>
<tr class="separator:a9141096c3c60884cc1c62f489b105365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1736b421c1d5a0303405cb9353ecc46f"><td class="memTemplParams" colspan="2">template&lt;typename Var , typename EigMat , require_var_vt&lt; std::is_arithmetic, Var &gt; *  = nullptr, require_eigen_vt&lt; std::is_arithmetic, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1736b421c1d5a0303405cb9353ecc46f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1736b421c1d5a0303405cb9353ecc46f.html#a1736b421c1d5a0303405cb9353ecc46f">add</a> (const Var &amp;a, const EigMat &amp;b)</td></tr>
<tr class="memdesc:a1736b421c1d5a0303405cb9353ecc46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for an arithmetic matrix and variable (C++).  <a href="namespacestan_1_1math_a1736b421c1d5a0303405cb9353ecc46f.html#a1736b421c1d5a0303405cb9353ecc46f">More...</a><br /></td></tr>
<tr class="separator:a1736b421c1d5a0303405cb9353ecc46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9216d97f0985aa12f09da88b855b3e"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename Var , require_eigen_vt&lt; std::is_arithmetic, EigMat &gt; *  = nullptr, require_var_vt&lt; std::is_arithmetic, Var &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1c9216d97f0985aa12f09da88b855b3e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c9216d97f0985aa12f09da88b855b3e.html#a1c9216d97f0985aa12f09da88b855b3e">add</a> (const EigMat &amp;a, const Var &amp;b)</td></tr>
<tr class="memdesc:a1c9216d97f0985aa12f09da88b855b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for a variable and arithmetic matrix (C++).  <a href="namespacestan_1_1math_a1c9216d97f0985aa12f09da88b855b3e.html#a1c9216d97f0985aa12f09da88b855b3e">More...</a><br /></td></tr>
<tr class="separator:a1c9216d97f0985aa12f09da88b855b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e69adb67fcc3dec01de621ea10f81d6"><td class="memTemplParams" colspan="2">template&lt;typename Var , typename VarMat , require_var_vt&lt; std::is_arithmetic, Var &gt; *  = nullptr, require_rev_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7e69adb67fcc3dec01de621ea10f81d6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7e69adb67fcc3dec01de621ea10f81d6.html#a7e69adb67fcc3dec01de621ea10f81d6">add</a> (const Var &amp;a, const VarMat &amp;b)</td></tr>
<tr class="memdesc:a7e69adb67fcc3dec01de621ea10f81d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for a variable and variable matrix (C++).  <a href="namespacestan_1_1math_a7e69adb67fcc3dec01de621ea10f81d6.html#a7e69adb67fcc3dec01de621ea10f81d6">More...</a><br /></td></tr>
<tr class="separator:a7e69adb67fcc3dec01de621ea10f81d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab08618e41109ce4766c013242ea606"><td class="memTemplParams" colspan="2">template&lt;typename Var , typename VarMat , require_var_vt&lt; std::is_arithmetic, Var &gt; *  = nullptr, require_rev_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3ab08618e41109ce4766c013242ea606"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3ab08618e41109ce4766c013242ea606.html#a3ab08618e41109ce4766c013242ea606">add</a> (const VarMat &amp;a, const Var &amp;b)</td></tr>
<tr class="memdesc:a3ab08618e41109ce4766c013242ea606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for a variable matrix and variable (C++).  <a href="namespacestan_1_1math_a3ab08618e41109ce4766c013242ea606.html#a3ab08618e41109ce4766c013242ea606">More...</a><br /></td></tr>
<tr class="separator:a3ab08618e41109ce4766c013242ea606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7c254794c6691b98f8f0ddeb75e170"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_var_vt&lt; std::is_arithmetic, T1, T2 &gt; *  = nullptr, require_any_arithmetic_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4a7c254794c6691b98f8f0ddeb75e170"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a7c254794c6691b98f8f0ddeb75e170.html#a4a7c254794c6691b98f8f0ddeb75e170">add</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:a4a7c254794c6691b98f8f0ddeb75e170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fc80944536f1612f56f155d421e42a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_var_vt&lt; std::is_arithmetic, T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a78fc80944536f1612f56f155d421e42a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a78fc80944536f1612f56f155d421e42a.html#a78fc80944536f1612f56f155d421e42a">add</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:a78fc80944536f1612f56f155d421e42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c75a8bcd33551e59f01ced5c379d4d"><td class="memTemplParams" colspan="2">template&lt;typename VarMat1 , typename VarMat2 , require_any_var_matrix_t&lt; VarMat1, VarMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a56c75a8bcd33551e59f01ced5c379d4d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a56c75a8bcd33551e59f01ced5c379d4d.html#a56c75a8bcd33551e59f01ced5c379d4d">operator+</a> (const VarMat1 &amp;a, const VarMat2 &amp;b)</td></tr>
<tr class="memdesc:a56c75a8bcd33551e59f01ced5c379d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for matrix variables.  <a href="namespacestan_1_1math_a56c75a8bcd33551e59f01ced5c379d4d.html#a56c75a8bcd33551e59f01ced5c379d4d">More...</a><br /></td></tr>
<tr class="separator:a56c75a8bcd33551e59f01ced5c379d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b3de6d6b6852949d5cf4220989e544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa3b3de6d6b6852949d5cf4220989e544.html#aa3b3de6d6b6852949d5cf4220989e544">operator/</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;dividend, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;divisor)</td></tr>
<tr class="memdesc:aa3b3de6d6b6852949d5cf4220989e544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for two variables (C++).  <a href="namespacestan_1_1math_aa3b3de6d6b6852949d5cf4220989e544.html#aa3b3de6d6b6852949d5cf4220989e544">More...</a><br /></td></tr>
<tr class="separator:aa3b3de6d6b6852949d5cf4220989e544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f51599a0b355459c04ecc5c8896323"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae3f51599a0b355459c04ecc5c8896323"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae3f51599a0b355459c04ecc5c8896323.html#ae3f51599a0b355459c04ecc5c8896323">operator/</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;dividend, Arith divisor)</td></tr>
<tr class="memdesc:ae3f51599a0b355459c04ecc5c8896323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for dividing a variable by a scalar (C++).  <a href="namespacestan_1_1math_ae3f51599a0b355459c04ecc5c8896323.html#ae3f51599a0b355459c04ecc5c8896323">More...</a><br /></td></tr>
<tr class="separator:ae3f51599a0b355459c04ecc5c8896323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6daa52c8ac63dd9dbe446d84dfe3e7"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1c6daa52c8ac63dd9dbe446d84dfe3e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c6daa52c8ac63dd9dbe446d84dfe3e7.html#a1c6daa52c8ac63dd9dbe446d84dfe3e7">operator/</a> (Arith dividend, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;divisor)</td></tr>
<tr class="memdesc:a1c6daa52c8ac63dd9dbe446d84dfe3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for dividing a scalar by a variable (C++).  <a href="namespacestan_1_1math_a1c6daa52c8ac63dd9dbe446d84dfe3e7.html#a1c6daa52c8ac63dd9dbe446d84dfe3e7">More...</a><br /></td></tr>
<tr class="separator:a1c6daa52c8ac63dd9dbe446d84dfe3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8dc0569ffa3197b5e44729d435adfea"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Mat , require_matrix_t&lt; Mat &gt; *  = nullptr, require_stan_scalar_t&lt; Scalar &gt; *  = nullptr, require_all_st_var_or_arithmetic&lt; Scalar, Mat &gt; *  = nullptr, require_any_st_var&lt; Scalar, Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae8dc0569ffa3197b5e44729d435adfea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae8dc0569ffa3197b5e44729d435adfea.html#ae8dc0569ffa3197b5e44729d435adfea">divide</a> (const Mat &amp;m, Scalar c)</td></tr>
<tr class="memdesc:ae8dc0569ffa3197b5e44729d435adfea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return matrix divided by scalar.  <a href="namespacestan_1_1math_ae8dc0569ffa3197b5e44729d435adfea.html#ae8dc0569ffa3197b5e44729d435adfea">More...</a><br /></td></tr>
<tr class="separator:ae8dc0569ffa3197b5e44729d435adfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80daa979a1dae4d8564e53a45db9897"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Mat , require_matrix_t&lt; Mat &gt; *  = nullptr, require_stan_scalar_t&lt; Scalar &gt; *  = nullptr, require_all_st_var_or_arithmetic&lt; Scalar, Mat &gt; *  = nullptr, require_any_st_var&lt; Scalar, Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae80daa979a1dae4d8564e53a45db9897"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae80daa979a1dae4d8564e53a45db9897.html#ae80daa979a1dae4d8564e53a45db9897">divide</a> (Scalar c, const Mat &amp;m)</td></tr>
<tr class="memdesc:ae80daa979a1dae4d8564e53a45db9897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return scalar divided by matrix.  <a href="namespacestan_1_1math_ae80daa979a1dae4d8564e53a45db9897.html#ae80daa979a1dae4d8564e53a45db9897">More...</a><br /></td></tr>
<tr class="separator:ae80daa979a1dae4d8564e53a45db9897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180300a44d352de562e5d21ae3339610"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , require_all_matrix_st&lt; is_var_or_arithmetic, Mat1, Mat2 &gt; *  = nullptr, require_any_matrix_st&lt; is_var, Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a180300a44d352de562e5d21ae3339610"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a180300a44d352de562e5d21ae3339610.html#a180300a44d352de562e5d21ae3339610">divide</a> (const Mat1 &amp;m1, const Mat2 &amp;m2)</td></tr>
<tr class="memdesc:a180300a44d352de562e5d21ae3339610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix divided by a matrix elementwise.  <a href="namespacestan_1_1math_a180300a44d352de562e5d21ae3339610.html#a180300a44d352de562e5d21ae3339610">More...</a><br /></td></tr>
<tr class="separator:a180300a44d352de562e5d21ae3339610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c19bc019d40676cb2285305c3e20980"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_var_matrix_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1c19bc019d40676cb2285305c3e20980"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c19bc019d40676cb2285305c3e20980.html#a1c19bc019d40676cb2285305c3e20980">operator/</a> (const T1 &amp;dividend, const T2 &amp;divisor)</td></tr>
<tr class="separator:a1c19bc019d40676cb2285305c3e20980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224420a2b8276222a5b65c18bcc28e65"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a224420a2b8276222a5b65c18bcc28e65.html#a224420a2b8276222a5b65c18bcc28e65">operator/</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;x1, const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;x2)</td></tr>
<tr class="separator:a224420a2b8276222a5b65c18bcc28e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e8c00dc01b2df161d0d242c124b046"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a62e8c00dc01b2df161d0d242c124b046.html#a62e8c00dc01b2df161d0d242c124b046">operator==</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a62e8c00dc01b2df161d0d242c124b046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator comparing two variables' values (C++).  <a href="namespacestan_1_1math_a62e8c00dc01b2df161d0d242c124b046.html#a62e8c00dc01b2df161d0d242c124b046">More...</a><br /></td></tr>
<tr class="separator:a62e8c00dc01b2df161d0d242c124b046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ae79b05ad30420cbbb652a20d36690"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa3ae79b05ad30420cbbb652a20d36690"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa3ae79b05ad30420cbbb652a20d36690.html#aa3ae79b05ad30420cbbb652a20d36690">operator==</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:aa3ae79b05ad30420cbbb652a20d36690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator comparing a variable's value and a double (C++).  <a href="namespacestan_1_1math_aa3ae79b05ad30420cbbb652a20d36690.html#aa3ae79b05ad30420cbbb652a20d36690">More...</a><br /></td></tr>
<tr class="separator:aa3ae79b05ad30420cbbb652a20d36690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cc5073731a06162dfe7f26b05a60ec"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa8cc5073731a06162dfe7f26b05a60ec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa8cc5073731a06162dfe7f26b05a60ec.html#aa8cc5073731a06162dfe7f26b05a60ec">operator==</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:aa8cc5073731a06162dfe7f26b05a60ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator comparing a scalar and a variable's value (C++).  <a href="namespacestan_1_1math_aa8cc5073731a06162dfe7f26b05a60ec.html#aa8cc5073731a06162dfe7f26b05a60ec">More...</a><br /></td></tr>
<tr class="separator:aa8cc5073731a06162dfe7f26b05a60ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda3df3819326bb89481d016398d4b47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abda3df3819326bb89481d016398d4b47.html#abda3df3819326bb89481d016398d4b47">operator==</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:abda3df3819326bb89481d016398d4b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the real number is equal to the real part of the complex number, and the imaginary part of the complex number is zero.  <a href="namespacestan_1_1math_abda3df3819326bb89481d016398d4b47.html#abda3df3819326bb89481d016398d4b47">More...</a><br /></td></tr>
<tr class="separator:abda3df3819326bb89481d016398d4b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a3edc747df56e196b71b84059c5ed3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a05a3edc747df56e196b71b84059c5ed3.html#a05a3edc747df56e196b71b84059c5ed3">operator==</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y)</td></tr>
<tr class="memdesc:a05a3edc747df56e196b71b84059c5ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the real number is equal to the real part of the complex number, and the imaginary part of the complex number is zero.  <a href="namespacestan_1_1math_a05a3edc747df56e196b71b84059c5ed3.html#a05a3edc747df56e196b71b84059c5ed3">More...</a><br /></td></tr>
<tr class="separator:a05a3edc747df56e196b71b84059c5ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465afbe6fb2692b02b60d9760e5cbda9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a465afbe6fb2692b02b60d9760e5cbda9.html#a465afbe6fb2692b02b60d9760e5cbda9">operator&gt;</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a465afbe6fb2692b02b60d9760e5cbda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than operator comparing variables' values (C++).  <a href="namespacestan_1_1math_a465afbe6fb2692b02b60d9760e5cbda9.html#a465afbe6fb2692b02b60d9760e5cbda9">More...</a><br /></td></tr>
<tr class="separator:a465afbe6fb2692b02b60d9760e5cbda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b902ca384f40fe7822633a5f2d6ac61"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3b902ca384f40fe7822633a5f2d6ac61"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3b902ca384f40fe7822633a5f2d6ac61.html#a3b902ca384f40fe7822633a5f2d6ac61">operator&gt;</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:a3b902ca384f40fe7822633a5f2d6ac61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than operator comparing variable's value and double (C++).  <a href="namespacestan_1_1math_a3b902ca384f40fe7822633a5f2d6ac61.html#a3b902ca384f40fe7822633a5f2d6ac61">More...</a><br /></td></tr>
<tr class="separator:a3b902ca384f40fe7822633a5f2d6ac61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6571d13d322f40de8d8f498ffba1d8"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7b6571d13d322f40de8d8f498ffba1d8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7b6571d13d322f40de8d8f498ffba1d8.html#a7b6571d13d322f40de8d8f498ffba1d8">operator&gt;</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a7b6571d13d322f40de8d8f498ffba1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than operator comparing a double and a variable's value (C++).  <a href="namespacestan_1_1math_a7b6571d13d322f40de8d8f498ffba1d8.html#a7b6571d13d322f40de8d8f498ffba1d8">More...</a><br /></td></tr>
<tr class="separator:a7b6571d13d322f40de8d8f498ffba1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938fb84cef113596828ad131e513fa1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a938fb84cef113596828ad131e513fa1e.html#a938fb84cef113596828ad131e513fa1e">operator&gt;=</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a938fb84cef113596828ad131e513fa1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal operator comparing two variables' values (C++).  <a href="namespacestan_1_1math_a938fb84cef113596828ad131e513fa1e.html#a938fb84cef113596828ad131e513fa1e">More...</a><br /></td></tr>
<tr class="separator:a938fb84cef113596828ad131e513fa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac769b51a2c48934c842202f0e0da1123"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac769b51a2c48934c842202f0e0da1123"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac769b51a2c48934c842202f0e0da1123.html#ac769b51a2c48934c842202f0e0da1123">operator&gt;=</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:ac769b51a2c48934c842202f0e0da1123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal operator comparing variable's value and double (C++).  <a href="namespacestan_1_1math_ac769b51a2c48934c842202f0e0da1123.html#ac769b51a2c48934c842202f0e0da1123">More...</a><br /></td></tr>
<tr class="separator:ac769b51a2c48934c842202f0e0da1123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431f61029137d350d6b186af1ec00aa1"><td class="memTemplParams" colspan="2">template&lt;typename Arith , typename Var , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a431f61029137d350d6b186af1ec00aa1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a431f61029137d350d6b186af1ec00aa1.html#a431f61029137d350d6b186af1ec00aa1">operator&gt;=</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a431f61029137d350d6b186af1ec00aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal operator comparing double and variable's value (C++).  <a href="namespacestan_1_1math_a431f61029137d350d6b186af1ec00aa1.html#a431f61029137d350d6b186af1ec00aa1">More...</a><br /></td></tr>
<tr class="separator:a431f61029137d350d6b186af1ec00aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe39e7c1b0831663418188ab23b98965"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afe39e7c1b0831663418188ab23b98965.html#afe39e7c1b0831663418188ab23b98965">operator&lt;</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:afe39e7c1b0831663418188ab23b98965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than operator comparing variables' values (C++).  <a href="namespacestan_1_1math_afe39e7c1b0831663418188ab23b98965.html#afe39e7c1b0831663418188ab23b98965">More...</a><br /></td></tr>
<tr class="separator:afe39e7c1b0831663418188ab23b98965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574a38e726f3a0ea6f197e36de064048"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a574a38e726f3a0ea6f197e36de064048"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a574a38e726f3a0ea6f197e36de064048.html#a574a38e726f3a0ea6f197e36de064048">operator&lt;</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:a574a38e726f3a0ea6f197e36de064048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than operator comparing variable's value and a double (C++).  <a href="namespacestan_1_1math_a574a38e726f3a0ea6f197e36de064048.html#a574a38e726f3a0ea6f197e36de064048">More...</a><br /></td></tr>
<tr class="separator:a574a38e726f3a0ea6f197e36de064048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57de9842352add5a2dbda05822b6d2db"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a57de9842352add5a2dbda05822b6d2db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a57de9842352add5a2dbda05822b6d2db.html#a57de9842352add5a2dbda05822b6d2db">operator&lt;</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a57de9842352add5a2dbda05822b6d2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than operator comparing a double and variable's value (C++).  <a href="namespacestan_1_1math_a57de9842352add5a2dbda05822b6d2db.html#a57de9842352add5a2dbda05822b6d2db">More...</a><br /></td></tr>
<tr class="separator:a57de9842352add5a2dbda05822b6d2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee09427479a707c4e715677d5036307b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aee09427479a707c4e715677d5036307b.html#aee09427479a707c4e715677d5036307b">operator&lt;=</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:aee09427479a707c4e715677d5036307b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal operator comparing two variables' values (C++).  <a href="namespacestan_1_1math_aee09427479a707c4e715677d5036307b.html#aee09427479a707c4e715677d5036307b">More...</a><br /></td></tr>
<tr class="separator:aee09427479a707c4e715677d5036307b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a9e90ff941aed983bc663e3a5a938d"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a48a9e90ff941aed983bc663e3a5a938d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a48a9e90ff941aed983bc663e3a5a938d.html#a48a9e90ff941aed983bc663e3a5a938d">operator&lt;=</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:a48a9e90ff941aed983bc663e3a5a938d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal operator comparing a variable's value and a scalar (C++).  <a href="namespacestan_1_1math_a48a9e90ff941aed983bc663e3a5a938d.html#a48a9e90ff941aed983bc663e3a5a938d">More...</a><br /></td></tr>
<tr class="separator:a48a9e90ff941aed983bc663e3a5a938d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19267d82a42272fa76a16612b81dd5b7"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a19267d82a42272fa76a16612b81dd5b7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a19267d82a42272fa76a16612b81dd5b7.html#a19267d82a42272fa76a16612b81dd5b7">operator&lt;=</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a19267d82a42272fa76a16612b81dd5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal operator comparing a double and variable's value (C++).  <a href="namespacestan_1_1math_a19267d82a42272fa76a16612b81dd5b7.html#a19267d82a42272fa76a16612b81dd5b7">More...</a><br /></td></tr>
<tr class="separator:a19267d82a42272fa76a16612b81dd5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966da3c5b004c346624544f9c6e087a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a966da3c5b004c346624544f9c6e087a0.html#a966da3c5b004c346624544f9c6e087a0">operator&amp;&amp;</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y)</td></tr>
<tr class="memdesc:a966da3c5b004c346624544f9c6e087a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical conjunction of the values of the two arguments as defined by <code>&amp;&amp;</code>.  <a href="namespacestan_1_1math_a966da3c5b004c346624544f9c6e087a0.html#a966da3c5b004c346624544f9c6e087a0">More...</a><br /></td></tr>
<tr class="separator:a966da3c5b004c346624544f9c6e087a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc393a1c1dc20e7e14c2ca81e5c356f"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:accc393a1c1dc20e7e14c2ca81e5c356f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_accc393a1c1dc20e7e14c2ca81e5c356f.html#accc393a1c1dc20e7e14c2ca81e5c356f">operator&amp;&amp;</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, Arith y)</td></tr>
<tr class="memdesc:accc393a1c1dc20e7e14c2ca81e5c356f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical conjunction of the values of the two arguments as defined by <code>&amp;&amp;</code>.  <a href="namespacestan_1_1math_accc393a1c1dc20e7e14c2ca81e5c356f.html#accc393a1c1dc20e7e14c2ca81e5c356f">More...</a><br /></td></tr>
<tr class="separator:accc393a1c1dc20e7e14c2ca81e5c356f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b01ec0670181cea3bf7347d3371f05"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a59b01ec0670181cea3bf7347d3371f05"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a59b01ec0670181cea3bf7347d3371f05.html#a59b01ec0670181cea3bf7347d3371f05">operator&amp;&amp;</a> (Arith x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y)</td></tr>
<tr class="memdesc:a59b01ec0670181cea3bf7347d3371f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical conjunction of the values of the two arguments as defined by <code>&amp;&amp;</code>.  <a href="namespacestan_1_1math_a59b01ec0670181cea3bf7347d3371f05.html#a59b01ec0670181cea3bf7347d3371f05">More...</a><br /></td></tr>
<tr class="separator:a59b01ec0670181cea3bf7347d3371f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3536c09f9def5f5a4784db14dcfacd02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3536c09f9def5f5a4784db14dcfacd02.html#a3536c09f9def5f5a4784db14dcfacd02">operator||</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y)</td></tr>
<tr class="memdesc:a3536c09f9def5f5a4784db14dcfacd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical disjunction of the values of the two arguments as defined by <code>||</code>.  <a href="namespacestan_1_1math_a3536c09f9def5f5a4784db14dcfacd02.html#a3536c09f9def5f5a4784db14dcfacd02">More...</a><br /></td></tr>
<tr class="separator:a3536c09f9def5f5a4784db14dcfacd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5027158dabf25d8cb9c500961cf2f8"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b5027158dabf25d8cb9c500961cf2f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4b5027158dabf25d8cb9c500961cf2f8.html#a4b5027158dabf25d8cb9c500961cf2f8">operator||</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, Arith y)</td></tr>
<tr class="memdesc:a4b5027158dabf25d8cb9c500961cf2f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical disjunction of the values of the two arguments as defined by <code>||</code>.  <a href="namespacestan_1_1math_a4b5027158dabf25d8cb9c500961cf2f8.html#a4b5027158dabf25d8cb9c500961cf2f8">More...</a><br /></td></tr>
<tr class="separator:a4b5027158dabf25d8cb9c500961cf2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab165a8cb3e10de571cab846cb2d5cb"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1ab165a8cb3e10de571cab846cb2d5cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1ab165a8cb3e10de571cab846cb2d5cb.html#a1ab165a8cb3e10de571cab846cb2d5cb">operator||</a> (Arith x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y)</td></tr>
<tr class="memdesc:a1ab165a8cb3e10de571cab846cb2d5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical disjunction of the values of the two arguments as defined by <code>||</code>.  <a href="namespacestan_1_1math_a1ab165a8cb3e10de571cab846cb2d5cb.html#a1ab165a8cb3e10de571cab846cb2d5cb">More...</a><br /></td></tr>
<tr class="separator:a1ab165a8cb3e10de571cab846cb2d5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436203414c825bb8765ea82786313909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a436203414c825bb8765ea82786313909.html#a436203414c825bb8765ea82786313909">operator*</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a436203414c825bb8765ea82786313909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for two variables (C++).  <a href="namespacestan_1_1math_a436203414c825bb8765ea82786313909.html#a436203414c825bb8765ea82786313909">More...</a><br /></td></tr>
<tr class="separator:a436203414c825bb8765ea82786313909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130428db257a3686d37290c07c2929a3"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a130428db257a3686d37290c07c2929a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a130428db257a3686d37290c07c2929a3.html#a130428db257a3686d37290c07c2929a3">operator*</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:a130428db257a3686d37290c07c2929a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for a variable and a scalar (C++).  <a href="namespacestan_1_1math_a130428db257a3686d37290c07c2929a3.html#a130428db257a3686d37290c07c2929a3">More...</a><br /></td></tr>
<tr class="separator:a130428db257a3686d37290c07c2929a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50518a6fbac05859782970593d06ad4d"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a50518a6fbac05859782970593d06ad4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a50518a6fbac05859782970593d06ad4d.html#a50518a6fbac05859782970593d06ad4d">operator*</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a50518a6fbac05859782970593d06ad4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for a scalar and a variable (C++).  <a href="namespacestan_1_1math_a50518a6fbac05859782970593d06ad4d.html#a50518a6fbac05859782970593d06ad4d">More...</a><br /></td></tr>
<tr class="separator:a50518a6fbac05859782970593d06ad4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23eb5d64637b32c92292456aa006ff0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae23eb5d64637b32c92292456aa006ff0.html#ae23eb5d64637b32c92292456aa006ff0">operator!=</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:ae23eb5d64637b32c92292456aa006ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator comparing two variables' values (C++).  <a href="namespacestan_1_1math_ae23eb5d64637b32c92292456aa006ff0.html#ae23eb5d64637b32c92292456aa006ff0">More...</a><br /></td></tr>
<tr class="separator:ae23eb5d64637b32c92292456aa006ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3220ced29c732a3562248f3f0ececc43"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3220ced29c732a3562248f3f0ececc43"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3220ced29c732a3562248f3f0ececc43.html#a3220ced29c732a3562248f3f0ececc43">operator!=</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:a3220ced29c732a3562248f3f0ececc43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator comparing a variable's value and a double (C++).  <a href="namespacestan_1_1math_a3220ced29c732a3562248f3f0ececc43.html#a3220ced29c732a3562248f3f0ececc43">More...</a><br /></td></tr>
<tr class="separator:a3220ced29c732a3562248f3f0ececc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f285944ba65c7fca7b50ad3b643373"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a48f285944ba65c7fca7b50ad3b643373"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a48f285944ba65c7fca7b50ad3b643373.html#a48f285944ba65c7fca7b50ad3b643373">operator!=</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a48f285944ba65c7fca7b50ad3b643373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator comparing a double and a variable's value (C++).  <a href="namespacestan_1_1math_a48f285944ba65c7fca7b50ad3b643373.html#a48f285944ba65c7fca7b50ad3b643373">More...</a><br /></td></tr>
<tr class="separator:a48f285944ba65c7fca7b50ad3b643373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b4e1b42071835672201d4a968b3515"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af2b4e1b42071835672201d4a968b3515.html#af2b4e1b42071835672201d4a968b3515">operator!=</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:af2b4e1b42071835672201d4a968b3515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>false</code> if the real number is equal to the real part of the complex number, and the imaginary part of the complex number is zero.  <a href="namespacestan_1_1math_af2b4e1b42071835672201d4a968b3515.html#af2b4e1b42071835672201d4a968b3515">More...</a><br /></td></tr>
<tr class="separator:af2b4e1b42071835672201d4a968b3515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9ad9621946946982d9e2f1088a4dcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aba9ad9621946946982d9e2f1088a4dcc.html#aba9ad9621946946982d9e2f1088a4dcc">operator!=</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y)</td></tr>
<tr class="memdesc:aba9ad9621946946982d9e2f1088a4dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>false</code> if the real number is equal to the real part of the complex number, and the imaginary part of the complex number is zero.  <a href="namespacestan_1_1math_aba9ad9621946946982d9e2f1088a4dcc.html#aba9ad9621946946982d9e2f1088a4dcc">More...</a><br /></td></tr>
<tr class="separator:aba9ad9621946946982d9e2f1088a4dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971b741313ecc65a639076acc188614a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a971b741313ecc65a639076acc188614a.html#a971b741313ecc65a639076acc188614a">operator-</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a971b741313ecc65a639076acc188614a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for variables.  <a href="namespacestan_1_1math_a971b741313ecc65a639076acc188614a.html#a971b741313ecc65a639076acc188614a">More...</a><br /></td></tr>
<tr class="separator:a971b741313ecc65a639076acc188614a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea55dfc43d8efb199b8ec26720e93a5"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adea55dfc43d8efb199b8ec26720e93a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adea55dfc43d8efb199b8ec26720e93a5.html#adea55dfc43d8efb199b8ec26720e93a5">operator-</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:adea55dfc43d8efb199b8ec26720e93a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for variable and scalar.  <a href="namespacestan_1_1math_adea55dfc43d8efb199b8ec26720e93a5.html#adea55dfc43d8efb199b8ec26720e93a5">More...</a><br /></td></tr>
<tr class="separator:adea55dfc43d8efb199b8ec26720e93a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75f2b829c5124ca90d4951716fe5973"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_arithmetic_t&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa75f2b829c5124ca90d4951716fe5973"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa75f2b829c5124ca90d4951716fe5973.html#aa75f2b829c5124ca90d4951716fe5973">operator-</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:aa75f2b829c5124ca90d4951716fe5973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for scalar and variable.  <a href="namespacestan_1_1math_aa75f2b829c5124ca90d4951716fe5973.html#aa75f2b829c5124ca90d4951716fe5973">More...</a><br /></td></tr>
<tr class="separator:aa75f2b829c5124ca90d4951716fe5973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85653ede9e653213494444ee89c6e07"><td class="memTemplParams" colspan="2">template&lt;typename VarMat1 , typename VarMat2 , require_all_rev_matrix_t&lt; VarMat1, VarMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae85653ede9e653213494444ee89c6e07"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae85653ede9e653213494444ee89c6e07.html#ae85653ede9e653213494444ee89c6e07">subtract</a> (const VarMat1 &amp;a, const VarMat2 &amp;b)</td></tr>
<tr class="memdesc:ae85653ede9e653213494444ee89c6e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for matrix variables.  <a href="namespacestan_1_1math_ae85653ede9e653213494444ee89c6e07.html#ae85653ede9e653213494444ee89c6e07">More...</a><br /></td></tr>
<tr class="separator:ae85653ede9e653213494444ee89c6e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf42375b9226e0fab3ca820bfbbe864"><td class="memTemplParams" colspan="2">template&lt;typename Arith , typename VarMat , require_st_arithmetic&lt; Arith &gt; *  = nullptr, require_rev_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5cf42375b9226e0fab3ca820bfbbe864"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5cf42375b9226e0fab3ca820bfbbe864.html#a5cf42375b9226e0fab3ca820bfbbe864">subtract</a> (const VarMat &amp;a, const Arith &amp;b)</td></tr>
<tr class="memdesc:a5cf42375b9226e0fab3ca820bfbbe864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for a matrix variable and arithmetic.  <a href="namespacestan_1_1math_a5cf42375b9226e0fab3ca820bfbbe864.html#a5cf42375b9226e0fab3ca820bfbbe864">More...</a><br /></td></tr>
<tr class="separator:a5cf42375b9226e0fab3ca820bfbbe864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebd98058c82169301f9ef08644083da"><td class="memTemplParams" colspan="2">template&lt;typename Arith , typename VarMat , require_st_arithmetic&lt; Arith &gt; *  = nullptr, require_rev_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acebd98058c82169301f9ef08644083da"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acebd98058c82169301f9ef08644083da.html#acebd98058c82169301f9ef08644083da">subtract</a> (const Arith &amp;a, const VarMat &amp;b)</td></tr>
<tr class="memdesc:acebd98058c82169301f9ef08644083da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for an arithmetic type and matrix variable.  <a href="namespacestan_1_1math_acebd98058c82169301f9ef08644083da.html#acebd98058c82169301f9ef08644083da">More...</a><br /></td></tr>
<tr class="separator:acebd98058c82169301f9ef08644083da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80189bc29a1d289b6c9d8f065a4fca9c"><td class="memTemplParams" colspan="2">template&lt;typename Var , typename EigMat , require_var_vt&lt; std::is_arithmetic, Var &gt; *  = nullptr, require_eigen_vt&lt; std::is_arithmetic, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a80189bc29a1d289b6c9d8f065a4fca9c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a80189bc29a1d289b6c9d8f065a4fca9c.html#a80189bc29a1d289b6c9d8f065a4fca9c">subtract</a> (const Var &amp;a, const EigMat &amp;b)</td></tr>
<tr class="memdesc:a80189bc29a1d289b6c9d8f065a4fca9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for an arithmetic matrix and variable.  <a href="namespacestan_1_1math_a80189bc29a1d289b6c9d8f065a4fca9c.html#a80189bc29a1d289b6c9d8f065a4fca9c">More...</a><br /></td></tr>
<tr class="separator:a80189bc29a1d289b6c9d8f065a4fca9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a66f932616754d972ccf166a85b247"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename Var , require_eigen_vt&lt; std::is_arithmetic, EigMat &gt; *  = nullptr, require_var_vt&lt; std::is_arithmetic, Var &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a88a66f932616754d972ccf166a85b247"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a88a66f932616754d972ccf166a85b247.html#a88a66f932616754d972ccf166a85b247">subtract</a> (const EigMat &amp;a, const Var &amp;b)</td></tr>
<tr class="memdesc:a88a66f932616754d972ccf166a85b247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for a variable and arithmetic matrix.  <a href="namespacestan_1_1math_a88a66f932616754d972ccf166a85b247.html#a88a66f932616754d972ccf166a85b247">More...</a><br /></td></tr>
<tr class="separator:a88a66f932616754d972ccf166a85b247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3acf4c4c4b5e093597f88f7b66c6b2c"><td class="memTemplParams" colspan="2">template&lt;typename Var , typename VarMat , require_var_vt&lt; std::is_arithmetic, Var &gt; *  = nullptr, require_rev_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac3acf4c4c4b5e093597f88f7b66c6b2c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac3acf4c4c4b5e093597f88f7b66c6b2c.html#ac3acf4c4c4b5e093597f88f7b66c6b2c">subtract</a> (const Var &amp;a, const VarMat &amp;b)</td></tr>
<tr class="memdesc:ac3acf4c4c4b5e093597f88f7b66c6b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for a variable and variable matrix.  <a href="namespacestan_1_1math_ac3acf4c4c4b5e093597f88f7b66c6b2c.html#ac3acf4c4c4b5e093597f88f7b66c6b2c">More...</a><br /></td></tr>
<tr class="separator:ac3acf4c4c4b5e093597f88f7b66c6b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8059a838288e540da5aeebcb9caee9fc"><td class="memTemplParams" colspan="2">template&lt;typename Var , typename VarMat , require_rev_matrix_t&lt; VarMat &gt; *  = nullptr, require_var_vt&lt; std::is_arithmetic, Var &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8059a838288e540da5aeebcb9caee9fc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8059a838288e540da5aeebcb9caee9fc.html#a8059a838288e540da5aeebcb9caee9fc">subtract</a> (const VarMat &amp;a, const Var &amp;b)</td></tr>
<tr class="memdesc:a8059a838288e540da5aeebcb9caee9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for a variable matrix and variable.  <a href="namespacestan_1_1math_a8059a838288e540da5aeebcb9caee9fc.html#a8059a838288e540da5aeebcb9caee9fc">More...</a><br /></td></tr>
<tr class="separator:a8059a838288e540da5aeebcb9caee9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a4cae25a673cdda949d83970decf81"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_var_vt&lt; std::is_arithmetic, T1, T2 &gt; *  = nullptr, require_any_arithmetic_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a88a4cae25a673cdda949d83970decf81"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a88a4cae25a673cdda949d83970decf81.html#a88a4cae25a673cdda949d83970decf81">subtract</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:a88a4cae25a673cdda949d83970decf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eef85281388cf99b5afc6b49fdfecc2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_var_vt&lt; std::is_arithmetic, T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1eef85281388cf99b5afc6b49fdfecc2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1eef85281388cf99b5afc6b49fdfecc2.html#a1eef85281388cf99b5afc6b49fdfecc2">subtract</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:a1eef85281388cf99b5afc6b49fdfecc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3e70f96daccfcb40ded372a62fe24d"><td class="memTemplParams" colspan="2">template&lt;typename VarMat1 , typename VarMat2 , require_any_var_matrix_t&lt; VarMat1, VarMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afc3e70f96daccfcb40ded372a62fe24d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afc3e70f96daccfcb40ded372a62fe24d.html#afc3e70f96daccfcb40ded372a62fe24d">operator-</a> (const VarMat1 &amp;a, const VarMat2 &amp;b)</td></tr>
<tr class="memdesc:afc3e70f96daccfcb40ded372a62fe24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for matrix variables.  <a href="namespacestan_1_1math_afc3e70f96daccfcb40ded372a62fe24d.html#afc3e70f96daccfcb40ded372a62fe24d">More...</a><br /></td></tr>
<tr class="separator:afc3e70f96daccfcb40ded372a62fe24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e496e6e1fd02a0378a729ada4f39df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a10e496e6e1fd02a0378a729ada4f39df.html#a10e496e6e1fd02a0378a729ada4f39df">operator--</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a10e496e6e1fd02a0378a729ada4f39df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix decrement operator for variables (C++).  <a href="namespacestan_1_1math_a10e496e6e1fd02a0378a729ada4f39df.html#a10e496e6e1fd02a0378a729ada4f39df">More...</a><br /></td></tr>
<tr class="separator:a10e496e6e1fd02a0378a729ada4f39df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcadc96f506e9f1408647cdce4d09092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abcadc96f506e9f1408647cdce4d09092.html#abcadc96f506e9f1408647cdce4d09092">operator--</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, int)</td></tr>
<tr class="memdesc:abcadc96f506e9f1408647cdce4d09092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix decrement operator for variables (C++).  <a href="namespacestan_1_1math_abcadc96f506e9f1408647cdce4d09092.html#abcadc96f506e9f1408647cdce4d09092">More...</a><br /></td></tr>
<tr class="separator:abcadc96f506e9f1408647cdce4d09092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab33c64042765d924f07e7490788e6d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab33c64042765d924f07e7490788e6d4.html#aab33c64042765d924f07e7490788e6d4">operator++</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:aab33c64042765d924f07e7490788e6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix increment operator for variables (C++).  <a href="namespacestan_1_1math_aab33c64042765d924f07e7490788e6d4.html#aab33c64042765d924f07e7490788e6d4">More...</a><br /></td></tr>
<tr class="separator:aab33c64042765d924f07e7490788e6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3597f71f364d94814268d4911f111674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3597f71f364d94814268d4911f111674.html#a3597f71f364d94814268d4911f111674">operator++</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, int)</td></tr>
<tr class="memdesc:a3597f71f364d94814268d4911f111674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix increment operator for variables (C++).  <a href="namespacestan_1_1math_a3597f71f364d94814268d4911f111674.html#a3597f71f364d94814268d4911f111674">More...</a><br /></td></tr>
<tr class="separator:a3597f71f364d94814268d4911f111674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8564365599db5cea0b51b635ea482a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f8564365599db5cea0b51b635ea482a.html#a2f8564365599db5cea0b51b635ea482a">operator-</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a2f8564365599db5cea0b51b635ea482a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary negation operator for variables (C++).  <a href="namespacestan_1_1math_a2f8564365599db5cea0b51b635ea482a.html#a2f8564365599db5cea0b51b635ea482a">More...</a><br /></td></tr>
<tr class="separator:a2f8564365599db5cea0b51b635ea482a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831e7a461560284293196bfb7a3d247a"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a831e7a461560284293196bfb7a3d247a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a831e7a461560284293196bfb7a3d247a.html#a831e7a461560284293196bfb7a3d247a">operator-</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a831e7a461560284293196bfb7a3d247a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute additive inverse of input.  <a href="namespacestan_1_1math_a831e7a461560284293196bfb7a3d247a.html#a831e7a461560284293196bfb7a3d247a">More...</a><br /></td></tr>
<tr class="separator:a831e7a461560284293196bfb7a3d247a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab717b1a12ae84baa53d6c38aefe13c49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab717b1a12ae84baa53d6c38aefe13c49.html#ab717b1a12ae84baa53d6c38aefe13c49">operator!</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:ab717b1a12ae84baa53d6c38aefe13c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negation of the value of the argument as defined by <code>!</code>.  <a href="namespacestan_1_1math_ab717b1a12ae84baa53d6c38aefe13c49.html#ab717b1a12ae84baa53d6c38aefe13c49">More...</a><br /></td></tr>
<tr class="separator:ab717b1a12ae84baa53d6c38aefe13c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f17a8253887d3b573fd59c5a4c6769"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a28f17a8253887d3b573fd59c5a4c6769.html#a28f17a8253887d3b573fd59c5a4c6769">operator+</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a28f17a8253887d3b573fd59c5a4c6769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary plus operator for variables (C++).  <a href="namespacestan_1_1math_a28f17a8253887d3b573fd59c5a4c6769.html#a28f17a8253887d3b573fd59c5a4c6769">More...</a><br /></td></tr>
<tr class="separator:a28f17a8253887d3b573fd59c5a4c6769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93af44658d035b95d4d82e8db047b70"><td class="memTemplParams" colspan="2">template&lt;typename Arith , typename VecVar , typename VecArith , typename... ContainerOperands, typename... ContainerGradients&gt; </td></tr>
<tr class="memitem:ae93af44658d035b95d4d82e8db047b70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae93af44658d035b95d4d82e8db047b70.html#ae93af44658d035b95d4d82e8db047b70">precomputed_gradients</a> (Arith value, const VecVar &amp;operands, const VecArith &amp;gradients, const std::tuple&lt; ContainerOperands... &gt; &amp;container_operands=std::tuple&lt;&gt;(), const std::tuple&lt; ContainerGradients... &gt; &amp;container_gradients=std::tuple&lt;&gt;())</td></tr>
<tr class="memdesc:ae93af44658d035b95d4d82e8db047b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a var for an expression that has the specified value, vector of operands, and vector of partial derivatives of value with respect to the operands.  <a href="namespacestan_1_1math_ae93af44658d035b95d4d82e8db047b70.html#ae93af44658d035b95d4d82e8db047b70">More...</a><br /></td></tr>
<tr class="separator:ae93af44658d035b95d4d82e8db047b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0611cecb5356e187818c1901134c7665"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0611cecb5356e187818c1901134c7665.html#a0611cecb5356e187818c1901134c7665">print_stack</a> (std::ostream &amp;o)</td></tr>
<tr class="memdesc:a0611cecb5356e187818c1901134c7665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the autodiff variable stack.  <a href="namespacestan_1_1math_a0611cecb5356e187818c1901134c7665.html#a0611cecb5356e187818c1901134c7665">More...</a><br /></td></tr>
<tr class="separator:a0611cecb5356e187818c1901134c7665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4341face977eceb2c8cdb2bac8d5ac00"><td class="memTemplParams" colspan="2">template&lt;typename EigVar , typename EigVari , typename EigDbl &gt; </td></tr>
<tr class="memitem:a4341face977eceb2c8cdb2bac8d5ac00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4341face977eceb2c8cdb2bac8d5ac00.html#a4341face977eceb2c8cdb2bac8d5ac00">read_vi_val_adj</a> (const EigVar &amp;VarMat, EigVari &amp;VariMat, EigDbl &amp;ValMat, EigDbl &amp;AdjMat)</td></tr>
<tr class="memdesc:a4341face977eceb2c8cdb2bac8d5ac00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function applying the <a class="el" href="classstan_1_1math_1_1vi__val__adj__functor.html" title="Functor for extracting the vari*, values, and adjoints from a matrix of var.">vi_val_adj_functor</a> to extract the vari*, values, and adjoints of a given var matrix into separate matrices.  <a href="namespacestan_1_1math_a4341face977eceb2c8cdb2bac8d5ac00.html#a4341face977eceb2c8cdb2bac8d5ac00">More...</a><br /></td></tr>
<tr class="separator:a4341face977eceb2c8cdb2bac8d5ac00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fc20028e53ce0b51bc15f84bac57ea"><td class="memTemplParams" colspan="2">template&lt;typename EigRev , typename EigDbl &gt; </td></tr>
<tr class="memitem:a14fc20028e53ce0b51bc15f84bac57ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a14fc20028e53ce0b51bc15f84bac57ea.html#a14fc20028e53ce0b51bc15f84bac57ea">read_val_adj</a> (const EigRev &amp;VarMat, EigDbl &amp;ValMat, EigDbl &amp;AdjMat)</td></tr>
<tr class="memdesc:a14fc20028e53ce0b51bc15f84bac57ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function applying the <a class="el" href="classstan_1_1math_1_1val__adj__functor.html" title="Functor for extracting the values and adjoints from a matrix of var or vari.">val_adj_functor</a> to extract the values and adjoints of a given var or vari matrix into separate matrices.  <a href="namespacestan_1_1math_a14fc20028e53ce0b51bc15f84bac57ea.html#a14fc20028e53ce0b51bc15f84bac57ea">More...</a><br /></td></tr>
<tr class="separator:a14fc20028e53ce0b51bc15f84bac57ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f7f51add356024c680a8bf95e79796"><td class="memTemplParams" colspan="2">template&lt;typename EigVar , typename EigVari , typename EigDbl &gt; </td></tr>
<tr class="memitem:a87f7f51add356024c680a8bf95e79796"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a87f7f51add356024c680a8bf95e79796.html#a87f7f51add356024c680a8bf95e79796">read_vi_val</a> (const EigVar &amp;VarMat, EigVari &amp;VariMat, EigDbl &amp;ValMat)</td></tr>
<tr class="memdesc:a87f7f51add356024c680a8bf95e79796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function applying the <a class="el" href="classstan_1_1math_1_1vi__val__functor.html" title="Functor for extracting the varis and values from a matrix of var.">vi_val_functor</a> to extract the varis and and values of a given var matrix into separate matrices.  <a href="namespacestan_1_1math_a87f7f51add356024c680a8bf95e79796.html#a87f7f51add356024c680a8bf95e79796">More...</a><br /></td></tr>
<tr class="separator:a87f7f51add356024c680a8bf95e79796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12d9a6dbf51074b656fcf1f0d416429"><td class="memTemplParams" colspan="2">template&lt;typename EigVar , typename EigVari , typename EigDbl &gt; </td></tr>
<tr class="memitem:af12d9a6dbf51074b656fcf1f0d416429"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af12d9a6dbf51074b656fcf1f0d416429.html#af12d9a6dbf51074b656fcf1f0d416429">read_vi_adj</a> (const EigVar &amp;VarMat, EigVari &amp;VariMat, EigDbl &amp;AdjMat)</td></tr>
<tr class="memdesc:af12d9a6dbf51074b656fcf1f0d416429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function applying the <a class="el" href="classstan_1_1math_1_1vi__adj__functor.html" title="Functor for extracting the varis and adjoints from a matrix of var.">vi_adj_functor</a> to extract the varis and and adjoints of a given var matrix into separate matrices.  <a href="namespacestan_1_1math_af12d9a6dbf51074b656fcf1f0d416429.html#af12d9a6dbf51074b656fcf1f0d416429">More...</a><br /></td></tr>
<tr class="separator:af12d9a6dbf51074b656fcf1f0d416429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2cbb83ac9ef52296755690e61f4298"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afe2cbb83ac9ef52296755690e61f4298.html#afe2cbb83ac9ef52296755690e61f4298">recover_memory</a> ()</td></tr>
<tr class="memdesc:afe2cbb83ac9ef52296755690e61f4298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover memory used for all variables for reuse.  <a href="namespacestan_1_1math_afe2cbb83ac9ef52296755690e61f4298.html#afe2cbb83ac9ef52296755690e61f4298">More...</a><br /></td></tr>
<tr class="separator:afe2cbb83ac9ef52296755690e61f4298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebf2b2bc0f63dcb46a176b43e8b369a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8ebf2b2bc0f63dcb46a176b43e8b369a.html#a8ebf2b2bc0f63dcb46a176b43e8b369a">recover_memory_nested</a> ()</td></tr>
<tr class="memdesc:a8ebf2b2bc0f63dcb46a176b43e8b369a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover only the memory used for the top nested call.  <a href="namespacestan_1_1math_a8ebf2b2bc0f63dcb46a176b43e8b369a.html#a8ebf2b2bc0f63dcb46a176b43e8b369a">More...</a><br /></td></tr>
<tr class="separator:a8ebf2b2bc0f63dcb46a176b43e8b369a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc059c1f55cae403aba50db7866e80e"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a4dc059c1f55cae403aba50db7866e80e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4dc059c1f55cae403aba50db7866e80e.html#a4dc059c1f55cae403aba50db7866e80e">reverse_pass_callback</a> (F &amp;&amp;functor)</td></tr>
<tr class="memdesc:a4dc059c1f55cae403aba50db7866e80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts a callback on the autodiff stack to be called in reverse pass.  <a href="namespacestan_1_1math_a4dc059c1f55cae403aba50db7866e80e.html#a4dc059c1f55cae403aba50db7866e80e">More...</a><br /></td></tr>
<tr class="separator:a4dc059c1f55cae403aba50db7866e80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e84a20bead947f253490be5f981b930"><td class="memTemplParams" colspan="2">template&lt;typename... Pargs&gt; </td></tr>
<tr class="memitem:a7e84a20bead947f253490be5f981b930"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7e84a20bead947f253490be5f981b930.html#a7e84a20bead947f253490be5f981b930">save_varis</a> (<a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **dest, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7e84a20bead947f253490be5f981b930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the vari pointer in x into the memory pointed to by dest, increment the dest storage pointer, recursively call save_varis on the rest of the arguments, and return the final value of the dest storage pointer.  <a href="namespacestan_1_1math_a7e84a20bead947f253490be5f981b930.html#a7e84a20bead947f253490be5f981b930">More...</a><br /></td></tr>
<tr class="separator:a7e84a20bead947f253490be5f981b930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072501534406f649504ac1bb4345d7ad"><td class="memTemplParams" colspan="2">template&lt;typename VarVec , require_std_vector_vt&lt; is_var, VarVec &gt; *  = nullptr, typename... Pargs&gt; </td></tr>
<tr class="memitem:a072501534406f649504ac1bb4345d7ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a072501534406f649504ac1bb4345d7ad.html#a072501534406f649504ac1bb4345d7ad">save_varis</a> (<a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **dest, VarVec &amp;&amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a072501534406f649504ac1bb4345d7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the vari pointers in x into the memory pointed to by dest, increment the dest storage pointer, recursively call save_varis on the rest of the arguments, and return the final value of the dest storage pointer.  <a href="namespacestan_1_1math_a072501534406f649504ac1bb4345d7ad.html#a072501534406f649504ac1bb4345d7ad">More...</a><br /></td></tr>
<tr class="separator:a072501534406f649504ac1bb4345d7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9d91d02eca52003754b2075250b9d4"><td class="memTemplParams" colspan="2">template&lt;typename VecContainer , require_std_vector_st&lt; is_var, VecContainer &gt; *  = nullptr, require_std_vector_vt&lt; is_container, VecContainer &gt; *  = nullptr, typename... Pargs&gt; </td></tr>
<tr class="memitem:a3b9d91d02eca52003754b2075250b9d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3b9d91d02eca52003754b2075250b9d4.html#a3b9d91d02eca52003754b2075250b9d4">save_varis</a> (<a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **dest, VecContainer &amp;&amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3b9d91d02eca52003754b2075250b9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the vari pointers in x into the memory pointed to by dest, increment the dest storage pointer, recursively call save_varis on the rest of the arguments, and return the final value of the dest storage pointer.  <a href="namespacestan_1_1math_a3b9d91d02eca52003754b2075250b9d4.html#a3b9d91d02eca52003754b2075250b9d4">More...</a><br /></td></tr>
<tr class="separator:a3b9d91d02eca52003754b2075250b9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276f79c8325dff8c887a438ffdb184d1"><td class="memTemplParams" colspan="2">template&lt;typename EigT , require_eigen_vt&lt; is_var, EigT &gt; *  = nullptr, typename... Pargs&gt; </td></tr>
<tr class="memitem:a276f79c8325dff8c887a438ffdb184d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a276f79c8325dff8c887a438ffdb184d1.html#a276f79c8325dff8c887a438ffdb184d1">save_varis</a> (<a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **dest, EigT &amp;&amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a276f79c8325dff8c887a438ffdb184d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the vari pointers in x into the memory pointed to by dest, increment the dest storage pointer, recursively call save_varis on the rest of the arguments, and return the final value of the dest storage pointer.  <a href="namespacestan_1_1math_a276f79c8325dff8c887a438ffdb184d1.html#a276f79c8325dff8c887a438ffdb184d1">More...</a><br /></td></tr>
<tr class="separator:a276f79c8325dff8c887a438ffdb184d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb47f7357ee2c4b35c9be30c07bf6497"><td class="memTemplParams" colspan="2">template&lt;typename Arith , require_st_arithmetic&lt; Arith &gt; *  = nullptr, typename... Pargs&gt; </td></tr>
<tr class="memitem:abb47f7357ee2c4b35c9be30c07bf6497"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abb47f7357ee2c4b35c9be30c07bf6497.html#abb47f7357ee2c4b35c9be30c07bf6497">save_varis</a> (<a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **dest, Arith &amp;&amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:abb47f7357ee2c4b35c9be30c07bf6497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore arithmetic types.  <a href="namespacestan_1_1math_abb47f7357ee2c4b35c9be30c07bf6497.html#abb47f7357ee2c4b35c9be30c07bf6497">More...</a><br /></td></tr>
<tr class="separator:abb47f7357ee2c4b35c9be30c07bf6497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafeadb090e8d2409aebe7f25ea43b669"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aafeadb090e8d2409aebe7f25ea43b669.html#aafeadb090e8d2409aebe7f25ea43b669">save_varis</a> (<a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **dest)</td></tr>
<tr class="memdesc:aafeadb090e8d2409aebe7f25ea43b669"><td class="mdescLeft">&#160;</td><td class="mdescRight">End save_varis recursion and return pointer.  <a href="namespacestan_1_1math_aafeadb090e8d2409aebe7f25ea43b669.html#aafeadb090e8d2409aebe7f25ea43b669">More...</a><br /></td></tr>
<tr class="separator:aafeadb090e8d2409aebe7f25ea43b669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9614efc6fd66533b74b43ddb69f21d3b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9614efc6fd66533b74b43ddb69f21d3b.html#a9614efc6fd66533b74b43ddb69f21d3b">set_zero_all_adjoints</a> ()</td></tr>
<tr class="memdesc:a9614efc6fd66533b74b43ddb69f21d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all adjoint values in the stack to zero.  <a href="namespacestan_1_1math_a9614efc6fd66533b74b43ddb69f21d3b.html#a9614efc6fd66533b74b43ddb69f21d3b">More...</a><br /></td></tr>
<tr class="separator:a9614efc6fd66533b74b43ddb69f21d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13a9b09e0bebb14eb30f3c78a95a160"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af13a9b09e0bebb14eb30f3c78a95a160.html#af13a9b09e0bebb14eb30f3c78a95a160">set_zero_all_adjoints_nested</a> ()</td></tr>
<tr class="memdesc:af13a9b09e0bebb14eb30f3c78a95a160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all adjoint values in the top nested portion of the stack to zero.  <a href="namespacestan_1_1math_af13a9b09e0bebb14eb30f3c78a95a160.html#af13a9b09e0bebb14eb30f3c78a95a160">More...</a><br /></td></tr>
<tr class="separator:af13a9b09e0bebb14eb30f3c78a95a160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a72c89ed9143a7760cc3611e8a0df0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad4a72c89ed9143a7760cc3611e8a0df0.html#ad4a72c89ed9143a7760cc3611e8a0df0">start_nested</a> ()</td></tr>
<tr class="memdesc:ad4a72c89ed9143a7760cc3611e8a0df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record the current position so that <code><a class="el" href="namespacestan_1_1math_a8ebf2b2bc0f63dcb46a176b43e8b369a.html#a8ebf2b2bc0f63dcb46a176b43e8b369a" title="Recover only the memory used for the top nested call.">recover_memory_nested()</a></code> can find it.  <a href="namespacestan_1_1math_ad4a72c89ed9143a7760cc3611e8a0df0.html#ad4a72c89ed9143a7760cc3611e8a0df0">More...</a><br /></td></tr>
<tr class="separator:ad4a72c89ed9143a7760cc3611e8a0df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4214c4dd4dc198260d7f4f7fbb8b9fdd"><td class="memTemplParams" colspan="2">template&lt;typename Vari &gt; </td></tr>
<tr class="memitem:a4214c4dd4dc198260d7f4f7fbb8b9fdd"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4214c4dd4dc198260d7f4f7fbb8b9fdd.html#a4214c4dd4dc198260d7f4f7fbb8b9fdd">grad</a> (Vari *vi)</td></tr>
<tr class="separator:a4214c4dd4dc198260d7f4f7fbb8b9fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30b0c1ce970b016f402e0a370b6a241"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab30b0c1ce970b016f402e0a370b6a241.html#ab30b0c1ce970b016f402e0a370b6a241">zero_adjoints</a> () noexcept</td></tr>
<tr class="memdesc:ab30b0c1ce970b016f402e0a370b6a241"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of recursion for set_zero_adjoints.  <a href="namespacestan_1_1math_ab30b0c1ce970b016f402e0a370b6a241.html#ab30b0c1ce970b016f402e0a370b6a241">More...</a><br /></td></tr>
<tr class="separator:ab30b0c1ce970b016f402e0a370b6a241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8e17af2ce48578b81e3201c6da82a5"><td class="memTemplParams" colspan="2">template&lt;typename T , require_st_arithmetic&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aff8e17af2ce48578b81e3201c6da82a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aff8e17af2ce48578b81e3201c6da82a5.html#aff8e17af2ce48578b81e3201c6da82a5">zero_adjoints</a> (T &amp;x) noexcept</td></tr>
<tr class="memdesc:aff8e17af2ce48578b81e3201c6da82a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do nothing for non-autodiff arguments.  <a href="namespacestan_1_1math_aff8e17af2ce48578b81e3201c6da82a5.html#aff8e17af2ce48578b81e3201c6da82a5">More...</a><br /></td></tr>
<tr class="separator:aff8e17af2ce48578b81e3201c6da82a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cece872da916ec03174b9e8e22fe62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a56cece872da916ec03174b9e8e22fe62.html#a56cece872da916ec03174b9e8e22fe62">zero_adjoints</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:a56cece872da916ec03174b9e8e22fe62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero the adjoint of the vari in the first argument.  <a href="namespacestan_1_1math_a56cece872da916ec03174b9e8e22fe62.html#a56cece872da916ec03174b9e8e22fe62">More...</a><br /></td></tr>
<tr class="separator:a56cece872da916ec03174b9e8e22fe62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9022171a124c032600bce2e8049f90"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_vt&lt; is_autodiff, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afa9022171a124c032600bce2e8049f90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afa9022171a124c032600bce2e8049f90.html#afa9022171a124c032600bce2e8049f90">zero_adjoints</a> (EigMat &amp;x)</td></tr>
<tr class="memdesc:afa9022171a124c032600bce2e8049f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero the adjoints of the varis of every var in an Eigen::Matrix container.  <a href="namespacestan_1_1math_afa9022171a124c032600bce2e8049f90.html#afa9022171a124c032600bce2e8049f90">More...</a><br /></td></tr>
<tr class="separator:afa9022171a124c032600bce2e8049f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac46b243e111d00fc750af22fab1f63c"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , require_std_vector_st&lt; is_autodiff, StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aac46b243e111d00fc750af22fab1f63c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aac46b243e111d00fc750af22fab1f63c.html#aac46b243e111d00fc750af22fab1f63c">zero_adjoints</a> (StdVec &amp;x)</td></tr>
<tr class="memdesc:aac46b243e111d00fc750af22fab1f63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero the adjoints of every element in a vector.  <a href="namespacestan_1_1math_aac46b243e111d00fc750af22fab1f63c.html#aac46b243e111d00fc750af22fab1f63c">More...</a><br /></td></tr>
<tr class="separator:aac46b243e111d00fc750af22fab1f63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7015d07b6fbf056e698dc488e058312a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7015d07b6fbf056e698dc488e058312a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7015d07b6fbf056e698dc488e058312a.html#a7015d07b6fbf056e698dc488e058312a">abs</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a7015d07b6fbf056e698dc488e058312a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute value of the variable (std).  <a href="namespacestan_1_1math_a7015d07b6fbf056e698dc488e058312a.html#a7015d07b6fbf056e698dc488e058312a">More...</a><br /></td></tr>
<tr class="separator:a7015d07b6fbf056e698dc488e058312a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fc35f4bfa8535e57f0133ce755495b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af3fc35f4bfa8535e57f0133ce755495b.html#af3fc35f4bfa8535e57f0133ce755495b">abs</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:af3fc35f4bfa8535e57f0133ce755495b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute value of the complex argument.  <a href="namespacestan_1_1math_af3fc35f4bfa8535e57f0133ce755495b.html#af3fc35f4bfa8535e57f0133ce755495b">More...</a><br /></td></tr>
<tr class="separator:af3fc35f4bfa8535e57f0133ce755495b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452d936de09ce7e61947d1df602f8ff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a452d936de09ce7e61947d1df602f8ff9.html#a452d936de09ce7e61947d1df602f8ff9">acos</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:a452d936de09ce7e61947d1df602f8ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc cosine of a variable, in radians (cmath).  <a href="namespacestan_1_1math_a452d936de09ce7e61947d1df602f8ff9.html#a452d936de09ce7e61947d1df602f8ff9">More...</a><br /></td></tr>
<tr class="separator:a452d936de09ce7e61947d1df602f8ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cb02fb2a6866205d81601d6507e22f"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , require_var_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a44cb02fb2a6866205d81601d6507e22f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a44cb02fb2a6866205d81601d6507e22f.html#a44cb02fb2a6866205d81601d6507e22f">acos</a> (const VarMat &amp;x)</td></tr>
<tr class="memdesc:a44cb02fb2a6866205d81601d6507e22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc cosine of a variable, in radians (cmath).  <a href="namespacestan_1_1math_a44cb02fb2a6866205d81601d6507e22f.html#a44cb02fb2a6866205d81601d6507e22f">More...</a><br /></td></tr>
<tr class="separator:a44cb02fb2a6866205d81601d6507e22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a39975245ddb7c3d3d0e8a76558ed8"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa7a39975245ddb7c3d3d0e8a76558ed8.html#aa7a39975245ddb7c3d3d0e8a76558ed8">acos</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:aa7a39975245ddb7c3d3d0e8a76558ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arc cosine of the complex argument.  <a href="namespacestan_1_1math_aa7a39975245ddb7c3d3d0e8a76558ed8.html#aa7a39975245ddb7c3d3d0e8a76558ed8">More...</a><br /></td></tr>
<tr class="separator:aa7a39975245ddb7c3d3d0e8a76558ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11bec2bf17b6d752058352e5631d56df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a11bec2bf17b6d752058352e5631d56df.html#a11bec2bf17b6d752058352e5631d56df">acosh</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:a11bec2bf17b6d752058352e5631d56df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse hyperbolic cosine function for variables (C99).  <a href="namespacestan_1_1math_a11bec2bf17b6d752058352e5631d56df.html#a11bec2bf17b6d752058352e5631d56df">More...</a><br /></td></tr>
<tr class="separator:a11bec2bf17b6d752058352e5631d56df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68492f7471c3d37e33a1d2f8a2eee400"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , require_var_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a68492f7471c3d37e33a1d2f8a2eee400"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a68492f7471c3d37e33a1d2f8a2eee400.html#a68492f7471c3d37e33a1d2f8a2eee400">acosh</a> (const VarMat &amp;x)</td></tr>
<tr class="memdesc:a68492f7471c3d37e33a1d2f8a2eee400"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse hyperbolic cosine function for variables (C99).  <a href="namespacestan_1_1math_a68492f7471c3d37e33a1d2f8a2eee400.html#a68492f7471c3d37e33a1d2f8a2eee400">More...</a><br /></td></tr>
<tr class="separator:a68492f7471c3d37e33a1d2f8a2eee400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9425a93e46beeee898da12c7697d49d"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa9425a93e46beeee898da12c7697d49d.html#aa9425a93e46beeee898da12c7697d49d">acosh</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:aa9425a93e46beeee898da12c7697d49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arc cosine of the complex argument.  <a href="namespacestan_1_1math_aa9425a93e46beeee898da12c7697d49d.html#aa9425a93e46beeee898da12c7697d49d">More...</a><br /></td></tr>
<tr class="separator:aa9425a93e46beeee898da12c7697d49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4d08b3c5aafb7c2263eaf952247fe0"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5d4d08b3c5aafb7c2263eaf952247fe0"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5d4d08b3c5aafb7c2263eaf952247fe0.html#a5d4d08b3c5aafb7c2263eaf952247fe0">adjoint_of</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a5d4d08b3c5aafb7c2263eaf952247fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to a variable's adjoint.  <a href="namespacestan_1_1math_a5d4d08b3c5aafb7c2263eaf952247fe0.html#a5d4d08b3c5aafb7c2263eaf952247fe0">More...</a><br /></td></tr>
<tr class="separator:a5d4d08b3c5aafb7c2263eaf952247fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20ad62aad9415282c6c5ed73cf1cb35"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_var_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae20ad62aad9415282c6c5ed73cf1cb35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1internal_1_1nonexisting__adjoint.html">internal::nonexisting_adjoint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae20ad62aad9415282c6c5ed73cf1cb35.html#ae20ad62aad9415282c6c5ed73cf1cb35">adjoint_of</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae20ad62aad9415282c6c5ed73cf1cb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to a variable's adjoint.  <a href="namespacestan_1_1math_ae20ad62aad9415282c6c5ed73cf1cb35.html#ae20ad62aad9415282c6c5ed73cf1cb35">More...</a><br /></td></tr>
<tr class="separator:ae20ad62aad9415282c6c5ed73cf1cb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbd9cac64e5f2313e80b0727925f465"><td class="memTemplParams" colspan="2">template&lt;typename Scal , typename RowVec , require_stan_scalar_t&lt; Scal &gt; *  = nullptr, require_t&lt; is_eigen_row_vector&lt; RowVec &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9cbd9cac64e5f2313e80b0727925f465"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9cbd9cac64e5f2313e80b0727925f465.html#a9cbd9cac64e5f2313e80b0727925f465">append_col</a> (const Scal &amp;A, const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; RowVec &gt; &amp;B)</td></tr>
<tr class="memdesc:a9cbd9cac64e5f2313e80b0727925f465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking an scalar on top of the a row vector, with the result being a row vector.  <a href="namespacestan_1_1math_a9cbd9cac64e5f2313e80b0727925f465.html#a9cbd9cac64e5f2313e80b0727925f465">More...</a><br /></td></tr>
<tr class="separator:a9cbd9cac64e5f2313e80b0727925f465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7a84898549554f6cb29891fb101124"><td class="memTemplParams" colspan="2">template&lt;typename RowVec , typename Scal , require_t&lt; is_eigen_row_vector&lt; RowVec &gt;&gt; *  = nullptr, require_stan_scalar_t&lt; Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ade7a84898549554f6cb29891fb101124"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade7a84898549554f6cb29891fb101124.html#ade7a84898549554f6cb29891fb101124">append_col</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; RowVec &gt; &amp;A, const Scal &amp;B)</td></tr>
<tr class="memdesc:ade7a84898549554f6cb29891fb101124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking a row vector on top of the an scalar, with the result being a row vector.  <a href="namespacestan_1_1math_ade7a84898549554f6cb29891fb101124.html#ade7a84898549554f6cb29891fb101124">More...</a><br /></td></tr>
<tr class="separator:ade7a84898549554f6cb29891fb101124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad660d3112fe327c0b7d95bc858d6576f"><td class="memTemplParams" colspan="2">template&lt;typename Scal , typename ColVec , require_stan_scalar_t&lt; Scal &gt; *  = nullptr, require_t&lt; is_eigen_col_vector&lt; ColVec &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad660d3112fe327c0b7d95bc858d6576f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad660d3112fe327c0b7d95bc858d6576f.html#ad660d3112fe327c0b7d95bc858d6576f">append_row</a> (const Scal &amp;A, const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; ColVec &gt; &amp;B)</td></tr>
<tr class="memdesc:ad660d3112fe327c0b7d95bc858d6576f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking an scalar on top of the a vector, with the result being a vector.  <a href="namespacestan_1_1math_ad660d3112fe327c0b7d95bc858d6576f.html#ad660d3112fe327c0b7d95bc858d6576f">More...</a><br /></td></tr>
<tr class="separator:ad660d3112fe327c0b7d95bc858d6576f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a0a585b24edd041aa2956eeb9c035f"><td class="memTemplParams" colspan="2">template&lt;typename ColVec , typename Scal , require_t&lt; is_eigen_col_vector&lt; ColVec &gt;&gt; *  = nullptr, require_stan_scalar_t&lt; Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad6a0a585b24edd041aa2956eeb9c035f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad6a0a585b24edd041aa2956eeb9c035f.html#ad6a0a585b24edd041aa2956eeb9c035f">append_row</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; ColVec &gt; &amp;A, const Scal &amp;B)</td></tr>
<tr class="memdesc:ad6a0a585b24edd041aa2956eeb9c035f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking a vector on top of the an scalar, with the result being a vector.  <a href="namespacestan_1_1math_ad6a0a585b24edd041aa2956eeb9c035f.html#ad6a0a585b24edd041aa2956eeb9c035f">More...</a><br /></td></tr>
<tr class="separator:ad6a0a585b24edd041aa2956eeb9c035f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70e91a492cd24ca0ac5f1c703fd5b66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad70e91a492cd24ca0ac5f1c703fd5b66.html#ad70e91a492cd24ca0ac5f1c703fd5b66">arg</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:ad70e91a492cd24ca0ac5f1c703fd5b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the phase angle of the complex argument.  <a href="namespacestan_1_1math_ad70e91a492cd24ca0ac5f1c703fd5b66.html#ad70e91a492cd24ca0ac5f1c703fd5b66">More...</a><br /></td></tr>
<tr class="separator:ad70e91a492cd24ca0ac5f1c703fd5b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d46a5116bd20a9b1cf228d018ae8aec"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3d46a5116bd20a9b1cf228d018ae8aec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3d46a5116bd20a9b1cf228d018ae8aec.html#a3d46a5116bd20a9b1cf228d018ae8aec">as_array_or_scalar</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:a3d46a5116bd20a9b1cf228d018ae8aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;T&gt;</code> with inner <a class="el" href="namespace_eigen.html">Eigen</a> matrix type to an <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;T&gt;</code> with an inner array.  <a href="namespacestan_1_1math_a3d46a5116bd20a9b1cf228d018ae8aec.html#a3d46a5116bd20a9b1cf228d018ae8aec">More...</a><br /></td></tr>
<tr class="separator:a3d46a5116bd20a9b1cf228d018ae8aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ad9c5e9f0b2f99b96133ad7a158f64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab7ad9c5e9f0b2f99b96133ad7a158f64.html#ab7ad9c5e9f0b2f99b96133ad7a158f64">as_bool</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;v)</td></tr>
<tr class="memdesc:ab7ad9c5e9f0b2f99b96133ad7a158f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the argument is unequal to zero and 0 otherwise.  <a href="namespacestan_1_1math_ab7ad9c5e9f0b2f99b96133ad7a158f64.html#ab7ad9c5e9f0b2f99b96133ad7a158f64">More...</a><br /></td></tr>
<tr class="separator:ab7ad9c5e9f0b2f99b96133ad7a158f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f6a9290da4c24198ef67f71a73f289"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af6f6a9290da4c24198ef67f71a73f289.html#af6f6a9290da4c24198ef67f71a73f289">asin</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:af6f6a9290da4c24198ef67f71a73f289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc sine, in radians, of the specified variable (cmath).  <a href="namespacestan_1_1math_af6f6a9290da4c24198ef67f71a73f289.html#af6f6a9290da4c24198ef67f71a73f289">More...</a><br /></td></tr>
<tr class="separator:af6f6a9290da4c24198ef67f71a73f289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568c5b444b0d1797a72524c733c6563d"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , require_var_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a568c5b444b0d1797a72524c733c6563d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a568c5b444b0d1797a72524c733c6563d.html#a568c5b444b0d1797a72524c733c6563d">asin</a> (const VarMat &amp;x)</td></tr>
<tr class="memdesc:a568c5b444b0d1797a72524c733c6563d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc sine, in radians, of the specified variable (cmath).  <a href="namespacestan_1_1math_a568c5b444b0d1797a72524c733c6563d.html#a568c5b444b0d1797a72524c733c6563d">More...</a><br /></td></tr>
<tr class="separator:a568c5b444b0d1797a72524c733c6563d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d750b5af1189137a41b65e36209a5a"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a95d750b5af1189137a41b65e36209a5a.html#a95d750b5af1189137a41b65e36209a5a">asin</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a95d750b5af1189137a41b65e36209a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arc sine of the complex argument.  <a href="namespacestan_1_1math_a95d750b5af1189137a41b65e36209a5a.html#a95d750b5af1189137a41b65e36209a5a">More...</a><br /></td></tr>
<tr class="separator:a95d750b5af1189137a41b65e36209a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83135599ea6bdaea64207222b04dac4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af83135599ea6bdaea64207222b04dac4.html#af83135599ea6bdaea64207222b04dac4">asinh</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:af83135599ea6bdaea64207222b04dac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse hyperbolic sine function for variables (C99).  <a href="namespacestan_1_1math_af83135599ea6bdaea64207222b04dac4.html#af83135599ea6bdaea64207222b04dac4">More...</a><br /></td></tr>
<tr class="separator:af83135599ea6bdaea64207222b04dac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66a25e30a93e06a14c230e0a2eeb5eb"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , require_var_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa66a25e30a93e06a14c230e0a2eeb5eb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa66a25e30a93e06a14c230e0a2eeb5eb.html#aa66a25e30a93e06a14c230e0a2eeb5eb">asinh</a> (const VarMat &amp;x)</td></tr>
<tr class="memdesc:aa66a25e30a93e06a14c230e0a2eeb5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse hyperbolic sine function for variables (C99).  <a href="namespacestan_1_1math_aa66a25e30a93e06a14c230e0a2eeb5eb.html#aa66a25e30a93e06a14c230e0a2eeb5eb">More...</a><br /></td></tr>
<tr class="separator:aa66a25e30a93e06a14c230e0a2eeb5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4382ce963ce4f1ff30ede944e46d67b8"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4382ce963ce4f1ff30ede944e46d67b8.html#a4382ce963ce4f1ff30ede944e46d67b8">asinh</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a4382ce963ce4f1ff30ede944e46d67b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arcsine of the complex argument.  <a href="namespacestan_1_1math_a4382ce963ce4f1ff30ede944e46d67b8.html#a4382ce963ce4f1ff30ede944e46d67b8">More...</a><br /></td></tr>
<tr class="separator:a4382ce963ce4f1ff30ede944e46d67b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3fe8de80841fbcb9cfcf4c9cc4a9e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9d3fe8de80841fbcb9cfcf4c9cc4a9e5.html#a9d3fe8de80841fbcb9cfcf4c9cc4a9e5">atan</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:a9d3fe8de80841fbcb9cfcf4c9cc4a9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc tangent, in radians, of the specified variable (cmath).  <a href="namespacestan_1_1math_a9d3fe8de80841fbcb9cfcf4c9cc4a9e5.html#a9d3fe8de80841fbcb9cfcf4c9cc4a9e5">More...</a><br /></td></tr>
<tr class="separator:a9d3fe8de80841fbcb9cfcf4c9cc4a9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523bc6c4084ecef288e5d0b235394fab"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , require_var_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a523bc6c4084ecef288e5d0b235394fab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a523bc6c4084ecef288e5d0b235394fab.html#a523bc6c4084ecef288e5d0b235394fab">atan</a> (const VarMat &amp;x)</td></tr>
<tr class="memdesc:a523bc6c4084ecef288e5d0b235394fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc tangent, in radians, of the specified variable (cmath).  <a href="namespacestan_1_1math_a523bc6c4084ecef288e5d0b235394fab.html#a523bc6c4084ecef288e5d0b235394fab">More...</a><br /></td></tr>
<tr class="separator:a523bc6c4084ecef288e5d0b235394fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3580dd43474282ca6ab6fb8cd18bef12"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3580dd43474282ca6ab6fb8cd18bef12.html#a3580dd43474282ca6ab6fb8cd18bef12">atan</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a3580dd43474282ca6ab6fb8cd18bef12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arc tangent of the complex argument.  <a href="namespacestan_1_1math_a3580dd43474282ca6ab6fb8cd18bef12.html#a3580dd43474282ca6ab6fb8cd18bef12">More...</a><br /></td></tr>
<tr class="separator:a3580dd43474282ca6ab6fb8cd18bef12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fe21eb929346e553266ceda0a97f23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a32fe21eb929346e553266ceda0a97f23.html#a32fe21eb929346e553266ceda0a97f23">atan2</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a32fe21eb929346e553266ceda0a97f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc tangent, in radians, of the first variable divided by the second (cmath).  <a href="namespacestan_1_1math_a32fe21eb929346e553266ceda0a97f23.html#a32fe21eb929346e553266ceda0a97f23">More...</a><br /></td></tr>
<tr class="separator:a32fe21eb929346e553266ceda0a97f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260938b6b224e8d716009cc1565e8b5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a260938b6b224e8d716009cc1565e8b5e.html#a260938b6b224e8d716009cc1565e8b5e">atan2</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:a260938b6b224e8d716009cc1565e8b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc tangent, in radians, of the first variable divided by the second scalar (cmath).  <a href="namespacestan_1_1math_a260938b6b224e8d716009cc1565e8b5e.html#a260938b6b224e8d716009cc1565e8b5e">More...</a><br /></td></tr>
<tr class="separator:a260938b6b224e8d716009cc1565e8b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94ca3039c321bf8a1016205d7916755"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa94ca3039c321bf8a1016205d7916755.html#aa94ca3039c321bf8a1016205d7916755">atan2</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:aa94ca3039c321bf8a1016205d7916755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc tangent, in radians, of the first scalar divided by the second variable (cmath).  <a href="namespacestan_1_1math_aa94ca3039c321bf8a1016205d7916755.html#aa94ca3039c321bf8a1016205d7916755">More...</a><br /></td></tr>
<tr class="separator:aa94ca3039c321bf8a1016205d7916755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1c841ccce06838813d1edf07ee5640"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aac1c841ccce06838813d1edf07ee5640.html#aac1c841ccce06838813d1edf07ee5640">atanh</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:aac1c841ccce06838813d1edf07ee5640"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse hyperbolic tangent function for variables (C99).  <a href="namespacestan_1_1math_aac1c841ccce06838813d1edf07ee5640.html#aac1c841ccce06838813d1edf07ee5640">More...</a><br /></td></tr>
<tr class="separator:aac1c841ccce06838813d1edf07ee5640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d1fbda2e50f154c081d190d221af94"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , require_var_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad7d1fbda2e50f154c081d190d221af94"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad7d1fbda2e50f154c081d190d221af94.html#ad7d1fbda2e50f154c081d190d221af94">atanh</a> (const VarMat &amp;x)</td></tr>
<tr class="memdesc:ad7d1fbda2e50f154c081d190d221af94"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse hyperbolic tangent function for variables (C99).  <a href="namespacestan_1_1math_ad7d1fbda2e50f154c081d190d221af94.html#ad7d1fbda2e50f154c081d190d221af94">More...</a><br /></td></tr>
<tr class="separator:ad7d1fbda2e50f154c081d190d221af94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279cc61da0d10a223b047e5fb7624dc6"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a279cc61da0d10a223b047e5fb7624dc6.html#a279cc61da0d10a223b047e5fb7624dc6">atanh</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a279cc61da0d10a223b047e5fb7624dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arc tangent of the complex argument.  <a href="namespacestan_1_1math_a279cc61da0d10a223b047e5fb7624dc6.html#a279cc61da0d10a223b047e5fb7624dc6">More...</a><br /></td></tr>
<tr class="separator:a279cc61da0d10a223b047e5fb7624dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672ae58515af44d6b87f2a79c3214643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a672ae58515af44d6b87f2a79c3214643.html#a672ae58515af44d6b87f2a79c3214643">bessel_first_kind</a> (int v, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="separator:a672ae58515af44d6b87f2a79c3214643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8b4801e57f41aad94ddce92bd1c311"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_st_integral&lt; T1 &gt; *  = nullptr, require_eigen_t&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4c8b4801e57f41aad94ddce92bd1c311"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4c8b4801e57f41aad94ddce92bd1c311.html#a4c8b4801e57f41aad94ddce92bd1c311">bessel_first_kind</a> (const T1 &amp;v, const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T2 &gt; &amp;a)</td></tr>
<tr class="memdesc:a4c8b4801e57f41aad94ddce92bd1c311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload with <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Matrix&gt;</code> for <code>int</code>, <code>std::vector&lt;int&gt;</code>, and <code>std::vector&lt;std::vector&lt;int&gt;&gt;</code>  <a href="namespacestan_1_1math_a4c8b4801e57f41aad94ddce92bd1c311.html#a4c8b4801e57f41aad94ddce92bd1c311">More...</a><br /></td></tr>
<tr class="separator:a4c8b4801e57f41aad94ddce92bd1c311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177d5e3051911f4e1026c6b149429f7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a177d5e3051911f4e1026c6b149429f7c.html#a177d5e3051911f4e1026c6b149429f7c">bessel_second_kind</a> (int v, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="separator:a177d5e3051911f4e1026c6b149429f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeab71635eacc084b6ad39f1c79eb8cd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_st_integral&lt; T1 &gt; *  = nullptr, require_eigen_t&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adeab71635eacc084b6ad39f1c79eb8cd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adeab71635eacc084b6ad39f1c79eb8cd.html#adeab71635eacc084b6ad39f1c79eb8cd">bessel_second_kind</a> (const T1 &amp;v, const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T2 &gt; &amp;a)</td></tr>
<tr class="memdesc:adeab71635eacc084b6ad39f1c79eb8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload with <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Matrix&gt;</code> for <code>int</code>, <code>std::vector&lt;int&gt;</code>, and <code>std::vector&lt;std::vector&lt;int&gt;&gt;</code>  <a href="namespacestan_1_1math_adeab71635eacc084b6ad39f1c79eb8cd.html#adeab71635eacc084b6ad39f1c79eb8cd">More...</a><br /></td></tr>
<tr class="separator:adeab71635eacc084b6ad39f1c79eb8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ad6c84ed9eb7db1dbf16ea7f2d062c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af9ad6c84ed9eb7db1dbf16ea7f2d062c.html#af9ad6c84ed9eb7db1dbf16ea7f2d062c">beta</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:af9ad6c84ed9eb7db1dbf16ea7f2d062c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the beta function and gradients for two var inputs.  <a href="namespacestan_1_1math_af9ad6c84ed9eb7db1dbf16ea7f2d062c.html#af9ad6c84ed9eb7db1dbf16ea7f2d062c">More...</a><br /></td></tr>
<tr class="separator:af9ad6c84ed9eb7db1dbf16ea7f2d062c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd299594f5fcb21d39e81a0bf683f32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9bd299594f5fcb21d39e81a0bf683f32.html#a9bd299594f5fcb21d39e81a0bf683f32">beta</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:a9bd299594f5fcb21d39e81a0bf683f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the beta function and gradient for first var input.  <a href="namespacestan_1_1math_a9bd299594f5fcb21d39e81a0bf683f32.html#a9bd299594f5fcb21d39e81a0bf683f32">More...</a><br /></td></tr>
<tr class="separator:a9bd299594f5fcb21d39e81a0bf683f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fa658c9e944079a4b2fd6c05193b9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab0fa658c9e944079a4b2fd6c05193b9b.html#ab0fa658c9e944079a4b2fd6c05193b9b">beta</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:ab0fa658c9e944079a4b2fd6c05193b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the beta function and gradient for second var input.  <a href="namespacestan_1_1math_ab0fa658c9e944079a4b2fd6c05193b9b.html#ab0fa658c9e944079a4b2fd6c05193b9b">More...</a><br /></td></tr>
<tr class="separator:ab0fa658c9e944079a4b2fd6c05193b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4d9718c0d8aac113f17c5fb9076d1c"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , require_any_var_matrix_t&lt; Mat1, Mat2 &gt; *  = nullptr, require_all_matrix_t&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ade4d9718c0d8aac113f17c5fb9076d1c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade4d9718c0d8aac113f17c5fb9076d1c.html#ade4d9718c0d8aac113f17c5fb9076d1c">beta</a> (const Mat1 &amp;a, const Mat2 &amp;b)</td></tr>
<tr class="separator:ade4d9718c0d8aac113f17c5fb9076d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47869482e60d5fc710f07772f7a13da3"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename VarMat , require_var_matrix_t&lt; VarMat &gt; *  = nullptr, require_stan_scalar_t&lt; Scalar &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a47869482e60d5fc710f07772f7a13da3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a47869482e60d5fc710f07772f7a13da3.html#a47869482e60d5fc710f07772f7a13da3">beta</a> (const Scalar &amp;a, const VarMat &amp;b)</td></tr>
<tr class="separator:a47869482e60d5fc710f07772f7a13da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddea87563c2388f31b28e658ea645a5"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , typename Scalar , require_var_matrix_t&lt; VarMat &gt; *  = nullptr, require_stan_scalar_t&lt; Scalar &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8ddea87563c2388f31b28e658ea645a5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8ddea87563c2388f31b28e658ea645a5.html#a8ddea87563c2388f31b28e658ea645a5">beta</a> (const VarMat &amp;a, const Scalar &amp;b)</td></tr>
<tr class="separator:a8ddea87563c2388f31b28e658ea645a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74d44d3337b9f550cd4c666275f0bd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac74d44d3337b9f550cd4c666275f0bd1.html#ac74d44d3337b9f550cd4c666275f0bd1">binary_log_loss</a> (int y, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y_hat)</td></tr>
<tr class="memdesc:ac74d44d3337b9f550cd4c666275f0bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log loss function for variables (stan).  <a href="namespacestan_1_1math_ac74d44d3337b9f550cd4c666275f0bd1.html#ac74d44d3337b9f550cd4c666275f0bd1">More...</a><br /></td></tr>
<tr class="separator:ac74d44d3337b9f550cd4c666275f0bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa534ce67ec8e13fd16ea1add472a7ef3"><td class="memTemplParams" colspan="2">template&lt;typename Mat , require_eigen_t&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa534ce67ec8e13fd16ea1add472a7ef3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa534ce67ec8e13fd16ea1add472a7ef3.html#aa534ce67ec8e13fd16ea1add472a7ef3">binary_log_loss</a> (int y, const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Mat &gt; &amp;y_hat)</td></tr>
<tr class="memdesc:aa534ce67ec8e13fd16ea1add472a7ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload with <code>int</code> and <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Matrix&gt;</code>  <a href="namespacestan_1_1math_aa534ce67ec8e13fd16ea1add472a7ef3.html#aa534ce67ec8e13fd16ea1add472a7ef3">More...</a><br /></td></tr>
<tr class="separator:aa534ce67ec8e13fd16ea1add472a7ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2981ccfb32024a759f8ca014b5ca45"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , typename Mat , require_eigen_t&lt; Mat &gt; *  = nullptr, require_st_integral&lt; StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b2981ccfb32024a759f8ca014b5ca45"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4b2981ccfb32024a759f8ca014b5ca45.html#a4b2981ccfb32024a759f8ca014b5ca45">binary_log_loss</a> (const StdVec &amp;y, const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Mat &gt; &amp;y_hat)</td></tr>
<tr class="memdesc:a4b2981ccfb32024a759f8ca014b5ca45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload with <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Matrix&gt;</code> for <code>std::vector&lt;int&gt;</code> and <code>std::vector&lt;std::vector&lt;int&gt;&gt;</code>  <a href="namespacestan_1_1math_a4b2981ccfb32024a759f8ca014b5ca45.html#a4b2981ccfb32024a759f8ca014b5ca45">More...</a><br /></td></tr>
<tr class="separator:a4b2981ccfb32024a759f8ca014b5ca45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a865962fcd8998de077f4a77b0a4ffa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2a865962fcd8998de077f4a77b0a4ffa.html#a2a865962fcd8998de077f4a77b0a4ffa">cbrt</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a2a865962fcd8998de077f4a77b0a4ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cube root of the specified variable (C99).  <a href="namespacestan_1_1math_a2a865962fcd8998de077f4a77b0a4ffa.html#a2a865962fcd8998de077f4a77b0a4ffa">More...</a><br /></td></tr>
<tr class="separator:a2a865962fcd8998de077f4a77b0a4ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75cfa4b59a3fb5701df679bc65c9a6d"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , require_var_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad75cfa4b59a3fb5701df679bc65c9a6d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad75cfa4b59a3fb5701df679bc65c9a6d.html#ad75cfa4b59a3fb5701df679bc65c9a6d">cbrt</a> (const VarMat &amp;a)</td></tr>
<tr class="memdesc:ad75cfa4b59a3fb5701df679bc65c9a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cube root of the specified variable (C99).  <a href="namespacestan_1_1math_ad75cfa4b59a3fb5701df679bc65c9a6d.html#ad75cfa4b59a3fb5701df679bc65c9a6d">More...</a><br /></td></tr>
<tr class="separator:ad75cfa4b59a3fb5701df679bc65c9a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e924d5a6c94f7593056b5cb1324b66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a06e924d5a6c94f7593056b5cb1324b66.html#a06e924d5a6c94f7593056b5cb1324b66">ceil</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a06e924d5a6c94f7593056b5cb1324b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ceiling of the specified variable (cmath).  <a href="namespacestan_1_1math_a06e924d5a6c94f7593056b5cb1324b66.html#a06e924d5a6c94f7593056b5cb1324b66">More...</a><br /></td></tr>
<tr class="separator:a06e924d5a6c94f7593056b5cb1324b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31addc53acacbe7505d4e0064a75e1c9"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a31addc53acacbe7505d4e0064a75e1c9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a31addc53acacbe7505d4e0064a75e1c9.html#a31addc53acacbe7505d4e0064a75e1c9">ceil</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a31addc53acacbe7505d4e0064a75e1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f4673638c356fc383ff23e92f26077"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a32f4673638c356fc383ff23e92f26077"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a32f4673638c356fc383ff23e92f26077.html#a32f4673638c356fc383ff23e92f26077">cholesky_corr_constrain</a> (const T &amp;y, int K)</td></tr>
<tr class="memdesc:a32f4673638c356fc383ff23e92f26077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the correlation matrix of the sepcified size read from the unconstrained vector <code>y</code>.  <a href="namespacestan_1_1math_a32f4673638c356fc383ff23e92f26077.html#a32f4673638c356fc383ff23e92f26077">More...</a><br /></td></tr>
<tr class="separator:a32f4673638c356fc383ff23e92f26077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623cb298027c795f8f5dea1f0254956d"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a623cb298027c795f8f5dea1f0254956d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a623cb298027c795f8f5dea1f0254956d.html#a623cb298027c795f8f5dea1f0254956d">cholesky_corr_constrain</a> (const T &amp;y, int K, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a623cb298027c795f8f5dea1f0254956d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the correlation matrix of the sepcified size read from the unconstrained vector <code>y</code>.  <a href="namespacestan_1_1math_a623cb298027c795f8f5dea1f0254956d.html#a623cb298027c795f8f5dea1f0254956d">More...</a><br /></td></tr>
<tr class="separator:a623cb298027c795f8f5dea1f0254956d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22a6e2c3240be231212b1b5902fe326"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_vt&lt; is_var, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac22a6e2c3240be231212b1b5902fe326"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac22a6e2c3240be231212b1b5902fe326.html#ac22a6e2c3240be231212b1b5902fe326">cholesky_decompose</a> (const EigMat &amp;A)</td></tr>
<tr class="memdesc:ac22a6e2c3240be231212b1b5902fe326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse mode specialization of cholesky decomposition.  <a href="namespacestan_1_1math_ac22a6e2c3240be231212b1b5902fe326.html#ac22a6e2c3240be231212b1b5902fe326">More...</a><br /></td></tr>
<tr class="separator:ac22a6e2c3240be231212b1b5902fe326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbc2836f96079ddd0512b75176d90ac"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abfbc2836f96079ddd0512b75176d90ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abfbc2836f96079ddd0512b75176d90ac.html#abfbc2836f96079ddd0512b75176d90ac">cholesky_decompose</a> (const T &amp;A)</td></tr>
<tr class="memdesc:abfbc2836f96079ddd0512b75176d90ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse mode specialization of Cholesky decomposition.  <a href="namespacestan_1_1math_abfbc2836f96079ddd0512b75176d90ac.html#abfbc2836f96079ddd0512b75176d90ac">More...</a><br /></td></tr>
<tr class="separator:abfbc2836f96079ddd0512b75176d90ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356333872c04c292c29ee1e93f20cfaa"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a356333872c04c292c29ee1e93f20cfaa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a356333872c04c292c29ee1e93f20cfaa.html#a356333872c04c292c29ee1e93f20cfaa">cholesky_factor_constrain</a> (const T &amp;x, int M, int N)</td></tr>
<tr class="memdesc:a356333872c04c292c29ee1e93f20cfaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the specified size read from the specified vector.  <a href="namespacestan_1_1math_a356333872c04c292c29ee1e93f20cfaa.html#a356333872c04c292c29ee1e93f20cfaa">More...</a><br /></td></tr>
<tr class="separator:a356333872c04c292c29ee1e93f20cfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172886b33fb42ff685415ef7652a06ac"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a172886b33fb42ff685415ef7652a06ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a172886b33fb42ff685415ef7652a06ac.html#a172886b33fb42ff685415ef7652a06ac">cholesky_factor_constrain</a> (const T &amp;x, int M, int N, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a172886b33fb42ff685415ef7652a06ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the specified size read from the specified vector and increment the specified log probability reference with the log Jacobian adjustment of the transform.  <a href="namespacestan_1_1math_a172886b33fb42ff685415ef7652a06ac.html#a172886b33fb42ff685415ef7652a06ac">More...</a><br /></td></tr>
<tr class="separator:a172886b33fb42ff685415ef7652a06ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bea59f00793e29f83f28644694dfa32"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , require_all_matrix_t&lt; Mat1, Mat2 &gt; *  = nullptr, require_any_var_matrix_t&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8bea59f00793e29f83f28644694dfa32"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8bea59f00793e29f83f28644694dfa32.html#a8bea59f00793e29f83f28644694dfa32">columns_dot_product</a> (const Mat1 &amp;v1, const Mat2 &amp;v2)</td></tr>
<tr class="memdesc:a8bea59f00793e29f83f28644694dfa32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of columns of the specified matrices.  <a href="namespacestan_1_1math_a8bea59f00793e29f83f28644694dfa32.html#a8bea59f00793e29f83f28644694dfa32">More...</a><br /></td></tr>
<tr class="separator:a8bea59f00793e29f83f28644694dfa32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e56626287124387a4687c39b3778c5"><td class="memTemplParams" colspan="2">template&lt;typename Mat , require_eigen_vt&lt; is_var, Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a60e56626287124387a4687c39b3778c5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, 1, Mat::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a60e56626287124387a4687c39b3778c5.html#a60e56626287124387a4687c39b3778c5">columns_dot_self</a> (const Mat &amp;x)</td></tr>
<tr class="memdesc:a60e56626287124387a4687c39b3778c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each column of a matrix with itself.  <a href="namespacestan_1_1math_a60e56626287124387a4687c39b3778c5.html#a60e56626287124387a4687c39b3778c5">More...</a><br /></td></tr>
<tr class="separator:a60e56626287124387a4687c39b3778c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0c737773c400e5315224a35d814b87"><td class="memTemplParams" colspan="2">template&lt;typename Mat , require_var_matrix_t&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9e0c737773c400e5315224a35d814b87"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9e0c737773c400e5315224a35d814b87.html#a9e0c737773c400e5315224a35d814b87">columns_dot_self</a> (const Mat &amp;x)</td></tr>
<tr class="memdesc:a9e0c737773c400e5315224a35d814b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each column of a matrix with itself.  <a href="namespacestan_1_1math_a9e0c737773c400e5315224a35d814b87.html#a9e0c737773c400e5315224a35d814b87">More...</a><br /></td></tr>
<tr class="separator:a9e0c737773c400e5315224a35d814b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca51bfa5c43b46d03fb3b9aebc4fc047"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aca51bfa5c43b46d03fb3b9aebc4fc047.html#aca51bfa5c43b46d03fb3b9aebc4fc047">conj</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:aca51bfa5c43b46d03fb3b9aebc4fc047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the complex conjugate of the complex argument.  <a href="namespacestan_1_1math_aca51bfa5c43b46d03fb3b9aebc4fc047.html#aca51bfa5c43b46d03fb3b9aebc4fc047">More...</a><br /></td></tr>
<tr class="separator:aca51bfa5c43b46d03fb3b9aebc4fc047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc3e2531ef7c79d8d6d9a0247faa0b0"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1cc3e2531ef7c79d8d6d9a0247faa0b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1cc3e2531ef7c79d8d6d9a0247faa0b0.html#a1cc3e2531ef7c79d8d6d9a0247faa0b0">corr_matrix_constrain</a> (const T &amp;x, Eigen::Index k)</td></tr>
<tr class="memdesc:a1cc3e2531ef7c79d8d6d9a0247faa0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality derived from the specified vector of unconstrained values.  <a href="namespacestan_1_1math_a1cc3e2531ef7c79d8d6d9a0247faa0b0.html#a1cc3e2531ef7c79d8d6d9a0247faa0b0">More...</a><br /></td></tr>
<tr class="separator:a1cc3e2531ef7c79d8d6d9a0247faa0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19aa124cdbbd9a63e22e77db929b792b"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a19aa124cdbbd9a63e22e77db929b792b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a19aa124cdbbd9a63e22e77db929b792b.html#a19aa124cdbbd9a63e22e77db929b792b">corr_matrix_constrain</a> (const T &amp;x, Eigen::Index k, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a19aa124cdbbd9a63e22e77db929b792b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality derived from the specified vector of unconstrained values.  <a href="namespacestan_1_1math_a19aa124cdbbd9a63e22e77db929b792b.html#a19aa124cdbbd9a63e22e77db929b792b">More...</a><br /></td></tr>
<tr class="separator:a19aa124cdbbd9a63e22e77db929b792b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c4c759177557c050cbdaaf311c20cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af8c4c759177557c050cbdaaf311c20cc.html#af8c4c759177557c050cbdaaf311c20cc">cos</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> a)</td></tr>
<tr class="memdesc:af8c4c759177557c050cbdaaf311c20cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cosine of a radian-scaled variable (cmath).  <a href="namespacestan_1_1math_af8c4c759177557c050cbdaaf311c20cc.html#af8c4c759177557c050cbdaaf311c20cc">More...</a><br /></td></tr>
<tr class="separator:af8c4c759177557c050cbdaaf311c20cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92ab559d766776945608612379fb03b"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , require_var_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad92ab559d766776945608612379fb03b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad92ab559d766776945608612379fb03b.html#ad92ab559d766776945608612379fb03b">cos</a> (const VarMat &amp;a)</td></tr>
<tr class="memdesc:ad92ab559d766776945608612379fb03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cosine of a radian-scaled variable (cmath).  <a href="namespacestan_1_1math_ad92ab559d766776945608612379fb03b.html#ad92ab559d766776945608612379fb03b">More...</a><br /></td></tr>
<tr class="separator:ad92ab559d766776945608612379fb03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900ceb37cc20462d0ee111266163af54"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a900ceb37cc20462d0ee111266163af54.html#a900ceb37cc20462d0ee111266163af54">cos</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a900ceb37cc20462d0ee111266163af54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cosine of the complex argument.  <a href="namespacestan_1_1math_a900ceb37cc20462d0ee111266163af54.html#a900ceb37cc20462d0ee111266163af54">More...</a><br /></td></tr>
<tr class="separator:a900ceb37cc20462d0ee111266163af54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a43fcaf01cfef4c73074e77390a205"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab2a43fcaf01cfef4c73074e77390a205.html#ab2a43fcaf01cfef4c73074e77390a205">cosh</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:ab2a43fcaf01cfef4c73074e77390a205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic cosine of the specified variable (cmath).  <a href="namespacestan_1_1math_ab2a43fcaf01cfef4c73074e77390a205.html#ab2a43fcaf01cfef4c73074e77390a205">More...</a><br /></td></tr>
<tr class="separator:ab2a43fcaf01cfef4c73074e77390a205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6aceec4ffaa1a5dff857f7a6b54d305"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , require_var_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad6aceec4ffaa1a5dff857f7a6b54d305"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad6aceec4ffaa1a5dff857f7a6b54d305.html#ad6aceec4ffaa1a5dff857f7a6b54d305">cosh</a> (const VarMat &amp;a)</td></tr>
<tr class="memdesc:ad6aceec4ffaa1a5dff857f7a6b54d305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic cosine of the specified variable (cmath).  <a href="namespacestan_1_1math_ad6aceec4ffaa1a5dff857f7a6b54d305.html#ad6aceec4ffaa1a5dff857f7a6b54d305">More...</a><br /></td></tr>
<tr class="separator:ad6aceec4ffaa1a5dff857f7a6b54d305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ecf5f6582418aad3663be9fec136f6"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af8ecf5f6582418aad3663be9fec136f6.html#af8ecf5f6582418aad3663be9fec136f6">cosh</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:af8ecf5f6582418aad3663be9fec136f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic cosine of the complex argument.  <a href="namespacestan_1_1math_af8ecf5f6582418aad3663be9fec136f6.html#af8ecf5f6582418aad3663be9fec136f6">More...</a><br /></td></tr>
<tr class="separator:af8ecf5f6582418aad3663be9fec136f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8618931f00576f315270f60232a85a4e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_arithmetic_t&lt;typename scalar_type&lt;T_x&gt;::type&gt;&gt; </td></tr>
<tr class="memitem:a8618931f00576f315270f60232a85a4e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8618931f00576f315270f60232a85a4e.html#a8618931f00576f315270f60232a85a4e">cov_exp_quad</a> (const std::vector&lt; T_x &gt; &amp;x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;sigma, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;l)</td></tr>
<tr class="separator:a8618931f00576f315270f60232a85a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc49bb3768776c4667f697e8efd77d2"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_arithmetic_t&lt;typename scalar_type&lt;T_x&gt;::type&gt;&gt; </td></tr>
<tr class="memitem:a7bc49bb3768776c4667f697e8efd77d2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7bc49bb3768776c4667f697e8efd77d2.html#a7bc49bb3768776c4667f697e8efd77d2">cov_exp_quad</a> (const std::vector&lt; T_x &gt; &amp;x, double sigma, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;l)</td></tr>
<tr class="separator:a7bc49bb3768776c4667f697e8efd77d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa236f70d3bd08321a9dfd3efe051d114"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa236f70d3bd08321a9dfd3efe051d114"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa236f70d3bd08321a9dfd3efe051d114.html#aa236f70d3bd08321a9dfd3efe051d114">cov_matrix_constrain</a> (const T &amp;x, Eigen::Index K)</td></tr>
<tr class="memdesc:aa236f70d3bd08321a9dfd3efe051d114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the symmetric, positive-definite matrix of dimensions K by K resulting from transforming the specified finite vector of size K plus (K choose 2).  <a href="namespacestan_1_1math_aa236f70d3bd08321a9dfd3efe051d114.html#aa236f70d3bd08321a9dfd3efe051d114">More...</a><br /></td></tr>
<tr class="separator:aa236f70d3bd08321a9dfd3efe051d114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b22982ee302a98f96e6b3a33ac9019"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae0b22982ee302a98f96e6b3a33ac9019"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae0b22982ee302a98f96e6b3a33ac9019.html#ae0b22982ee302a98f96e6b3a33ac9019">cov_matrix_constrain</a> (const T &amp;x, Eigen::Index K, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:ae0b22982ee302a98f96e6b3a33ac9019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the symmetric, positive-definite matrix of dimensions K by K resulting from transforming the specified finite vector of size K plus (K choose 2).  <a href="namespacestan_1_1math_ae0b22982ee302a98f96e6b3a33ac9019.html#ae0b22982ee302a98f96e6b3a33ac9019">More...</a><br /></td></tr>
<tr class="separator:ae0b22982ee302a98f96e6b3a33ac9019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72e291c2c0697eeecfdbd379006489d"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad72e291c2c0697eeecfdbd379006489d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad72e291c2c0697eeecfdbd379006489d.html#ad72e291c2c0697eeecfdbd379006489d">cov_matrix_constrain_lkj</a> (const T &amp;x, size_t k)</td></tr>
<tr class="memdesc:ad72e291c2c0697eeecfdbd379006489d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the covariance matrix of the specified dimensionality derived from constraining the specified vector of unconstrained values.  <a href="namespacestan_1_1math_ad72e291c2c0697eeecfdbd379006489d.html#ad72e291c2c0697eeecfdbd379006489d">More...</a><br /></td></tr>
<tr class="separator:ad72e291c2c0697eeecfdbd379006489d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b1da5c0052745151ea3b855d362ddf"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad3b1da5c0052745151ea3b855d362ddf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad3b1da5c0052745151ea3b855d362ddf.html#ad3b1da5c0052745151ea3b855d362ddf">cov_matrix_constrain_lkj</a> (const T &amp;x, size_t k, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:ad3b1da5c0052745151ea3b855d362ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the covariance matrix of the specified dimensionality derived from constraining the specified vector of unconstrained values and increment the specified log probability reference with the log absolute Jacobian determinant.  <a href="namespacestan_1_1math_ad3b1da5c0052745151ea3b855d362ddf.html#ad3b1da5c0052745151ea3b855d362ddf">More...</a><br /></td></tr>
<tr class="separator:ad3b1da5c0052745151ea3b855d362ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96389be6dcf36281bfefd9b69dc5b74"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_rev_matrix_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab96389be6dcf36281bfefd9b69dc5b74"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab96389be6dcf36281bfefd9b69dc5b74.html#ab96389be6dcf36281bfefd9b69dc5b74">csr_matrix_times_vector</a> (int m, int n, const T1 &amp;w, const std::vector&lt; int &gt; &amp;v, const std::vector&lt; int &gt; &amp;u, const T2 &amp;b)</td></tr>
<tr class="separator:ab96389be6dcf36281bfefd9b69dc5b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444630878ddad2511a543aa7e5a85ade"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , require_rev_vector_t&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a444630878ddad2511a543aa7e5a85ade"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a444630878ddad2511a543aa7e5a85ade.html#a444630878ddad2511a543aa7e5a85ade">cumulative_sum</a> (const EigVec &amp;x)</td></tr>
<tr class="memdesc:a444630878ddad2511a543aa7e5a85ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cumulative sum of the specified vector.  <a href="namespacestan_1_1math_a444630878ddad2511a543aa7e5a85ade.html#a444630878ddad2511a543aa7e5a85ade">More...</a><br /></td></tr>
<tr class="separator:a444630878ddad2511a543aa7e5a85ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa007bbb2b70afca96c39a9db56891e96"><td class="memTemplParams" colspan="2">template&lt;typename T , require_rev_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa007bbb2b70afca96c39a9db56891e96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa007bbb2b70afca96c39a9db56891e96.html#aa007bbb2b70afca96c39a9db56891e96">determinant</a> (const T &amp;m)</td></tr>
<tr class="separator:aa007bbb2b70afca96c39a9db56891e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f8a31d51a379e13dffe4db04fbbc3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a67f8a31d51a379e13dffe4db04fbbc3c.html#a67f8a31d51a379e13dffe4db04fbbc3c">digamma</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a67f8a31d51a379e13dffe4db04fbbc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the derivative of the log gamma function at the specified value.  <a href="namespacestan_1_1math_a67f8a31d51a379e13dffe4db04fbbc3c.html#a67f8a31d51a379e13dffe4db04fbbc3c">More...</a><br /></td></tr>
<tr class="separator:a67f8a31d51a379e13dffe4db04fbbc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294f9826a0d22943f3f162f1a4dd6acd"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a294f9826a0d22943f3f162f1a4dd6acd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a294f9826a0d22943f3f162f1a4dd6acd.html#a294f9826a0d22943f3f162f1a4dd6acd">digamma</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a294f9826a0d22943f3f162f1a4dd6acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise derivative of the log gamma function at the given input vector.  <a href="namespacestan_1_1math_a294f9826a0d22943f3f162f1a4dd6acd.html#a294f9826a0d22943f3f162f1a4dd6acd">More...</a><br /></td></tr>
<tr class="separator:a294f9826a0d22943f3f162f1a4dd6acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5204575e698cdc146deba0269c85f857"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5204575e698cdc146deba0269c85f857"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5204575e698cdc146deba0269c85f857.html#a5204575e698cdc146deba0269c85f857">dims</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="memdesc:a5204575e698cdc146deba0269c85f857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes dimensions of given argument into given result vector.  <a href="namespacestan_1_1math_a5204575e698cdc146deba0269c85f857.html#a5204575e698cdc146deba0269c85f857">More...</a><br /></td></tr>
<tr class="separator:a5204575e698cdc146deba0269c85f857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23a41a265b0da541e9c95c47dee39a9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab23a41a265b0da541e9c95c47dee39a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab23a41a265b0da541e9c95c47dee39a9.html#ab23a41a265b0da541e9c95c47dee39a9">dims</a> (const <a class="el" href="classstan_1_1math_1_1vari__value.html">vari_value</a>&lt; T &gt; &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="memdesc:ab23a41a265b0da541e9c95c47dee39a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes dimensions of given argument into given result vector.  <a href="namespacestan_1_1math_ab23a41a265b0da541e9c95c47dee39a9.html#ab23a41a265b0da541e9c95c47dee39a9">More...</a><br /></td></tr>
<tr class="separator:ab23a41a265b0da541e9c95c47dee39a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7720218b0c95dcbd8fc3eddf3dc18a2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_vector_t&lt; T1, T2 &gt; *  = nullptr, require_not_complex_t&lt; return_type_t&lt; T1, T2 &gt;&gt; *  = nullptr, require_all_not_std_vector_t&lt; T1, T2 &gt; *  = nullptr, require_any_st_var&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad7720218b0c95dcbd8fc3eddf3dc18a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad7720218b0c95dcbd8fc3eddf3dc18a2.html#ad7720218b0c95dcbd8fc3eddf3dc18a2">dot_product</a> (const T1 &amp;v1, const T2 &amp;v2)</td></tr>
<tr class="memdesc:ad7720218b0c95dcbd8fc3eddf3dc18a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product.  <a href="namespacestan_1_1math_ad7720218b0c95dcbd8fc3eddf3dc18a2.html#ad7720218b0c95dcbd8fc3eddf3dc18a2">More...</a><br /></td></tr>
<tr class="separator:ad7720218b0c95dcbd8fc3eddf3dc18a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c3b77e281f45807235c6585f9878c8"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vector_vt&lt; is_var, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a59c3b77e281f45807235c6585f9878c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a59c3b77e281f45807235c6585f9878c8.html#a59c3b77e281f45807235c6585f9878c8">dot_self</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a59c3b77e281f45807235c6585f9878c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of a vector of var with itself.  <a href="namespacestan_1_1math_a59c3b77e281f45807235c6585f9878c8.html#a59c3b77e281f45807235c6585f9878c8">More...</a><br /></td></tr>
<tr class="separator:a59c3b77e281f45807235c6585f9878c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23e09b01928acf32720f5351c3496c3"><td class="memTemplParams" colspan="2">template&lt;typename T , require_rev_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab23e09b01928acf32720f5351c3496c3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab23e09b01928acf32720f5351c3496c3.html#ab23e09b01928acf32720f5351c3496c3">eigenvalues_sym</a> (const T &amp;m)</td></tr>
<tr class="memdesc:ab23e09b01928acf32720f5351c3496c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eigenvalues of the specified symmetric matrix.  <a href="namespacestan_1_1math_ab23e09b01928acf32720f5351c3496c3.html#ab23e09b01928acf32720f5351c3496c3">More...</a><br /></td></tr>
<tr class="separator:ab23e09b01928acf32720f5351c3496c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5392dd813b5cda51b8060b415ac16586"><td class="memTemplParams" colspan="2">template&lt;typename T , require_rev_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5392dd813b5cda51b8060b415ac16586"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5392dd813b5cda51b8060b415ac16586.html#a5392dd813b5cda51b8060b415ac16586">eigenvectors_sym</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a5392dd813b5cda51b8060b415ac16586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eigenvectors of the specified symmetric matrix.  <a href="namespacestan_1_1math_a5392dd813b5cda51b8060b415ac16586.html#a5392dd813b5cda51b8060b415ac16586">More...</a><br /></td></tr>
<tr class="separator:a5392dd813b5cda51b8060b415ac16586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759d52872682fdf0d6a7a6d75b4f1d9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a759d52872682fdf0d6a7a6d75b4f1d9e.html#a759d52872682fdf0d6a7a6d75b4f1d9e">erf</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a759d52872682fdf0d6a7a6d75b4f1d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The error function for variables (C99).  <a href="namespacestan_1_1math_a759d52872682fdf0d6a7a6d75b4f1d9e.html#a759d52872682fdf0d6a7a6d75b4f1d9e">More...</a><br /></td></tr>
<tr class="separator:a759d52872682fdf0d6a7a6d75b4f1d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185fa79774b930771ed883f4216c7b98"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a185fa79774b930771ed883f4216c7b98"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a185fa79774b930771ed883f4216c7b98.html#a185fa79774b930771ed883f4216c7b98">erf</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a185fa79774b930771ed883f4216c7b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8543e9c729e794bcbdff2ed223eb45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8a8543e9c729e794bcbdff2ed223eb45.html#a8a8543e9c729e794bcbdff2ed223eb45">erfc</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a8a8543e9c729e794bcbdff2ed223eb45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The complementary error function for variables (C99).  <a href="namespacestan_1_1math_a8a8543e9c729e794bcbdff2ed223eb45.html#a8a8543e9c729e794bcbdff2ed223eb45">More...</a><br /></td></tr>
<tr class="separator:a8a8543e9c729e794bcbdff2ed223eb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047e3ddba7034037840b01cb482b5aeb"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a047e3ddba7034037840b01cb482b5aeb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a047e3ddba7034037840b01cb482b5aeb.html#a047e3ddba7034037840b01cb482b5aeb">erfc</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a047e3ddba7034037840b01cb482b5aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43b048d4a5f53f94501773c93689a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae43b048d4a5f53f94501773c93689a65.html#ae43b048d4a5f53f94501773c93689a65">exp</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:ae43b048d4a5f53f94501773c93689a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exponentiation of the specified variable (cmath).  <a href="namespacestan_1_1math_ae43b048d4a5f53f94501773c93689a65.html#ae43b048d4a5f53f94501773c93689a65">More...</a><br /></td></tr>
<tr class="separator:ae43b048d4a5f53f94501773c93689a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba01d73d501e96d62afefe01b4acf08a"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aba01d73d501e96d62afefe01b4acf08a.html#aba01d73d501e96d62afefe01b4acf08a">exp</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:aba01d73d501e96d62afefe01b4acf08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exponentiation (base e) of the specified complex number.  <a href="namespacestan_1_1math_aba01d73d501e96d62afefe01b4acf08a.html#aba01d73d501e96d62afefe01b4acf08a">More...</a><br /></td></tr>
<tr class="separator:aba01d73d501e96d62afefe01b4acf08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d6fc29468007fea5fb71f1d1fa4dcb"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae4d6fc29468007fea5fb71f1d1fa4dcb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae4d6fc29468007fea5fb71f1d1fa4dcb.html#ae4d6fc29468007fea5fb71f1d1fa4dcb">exp</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae4d6fc29468007fea5fb71f1d1fa4dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exponentiation of the elements of x.  <a href="namespacestan_1_1math_ae4d6fc29468007fea5fb71f1d1fa4dcb.html#ae4d6fc29468007fea5fb71f1d1fa4dcb">More...</a><br /></td></tr>
<tr class="separator:ae4d6fc29468007fea5fb71f1d1fa4dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd4650bbf246a10ac798c71da8b99d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9fd4650bbf246a10ac798c71da8b99d5.html#a9fd4650bbf246a10ac798c71da8b99d5">exp2</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a9fd4650bbf246a10ac798c71da8b99d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponentiation base 2 function for variables (C99).  <a href="namespacestan_1_1math_a9fd4650bbf246a10ac798c71da8b99d5.html#a9fd4650bbf246a10ac798c71da8b99d5">More...</a><br /></td></tr>
<tr class="separator:a9fd4650bbf246a10ac798c71da8b99d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6d86fc5918f1e4ce736d55f83c2e19"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4c6d86fc5918f1e4ce736d55f83c2e19"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4c6d86fc5918f1e4ce736d55f83c2e19.html#a4c6d86fc5918f1e4ce736d55f83c2e19">exp2</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a4c6d86fc5918f1e4ce736d55f83c2e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974d9d6b021e75ee0ba7146d221beed2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a974d9d6b021e75ee0ba7146d221beed2.html#a974d9d6b021e75ee0ba7146d221beed2">expm1</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a974d9d6b021e75ee0ba7146d221beed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exponentiation of the specified variable minus 1 (C99).  <a href="namespacestan_1_1math_a974d9d6b021e75ee0ba7146d221beed2.html#a974d9d6b021e75ee0ba7146d221beed2">More...</a><br /></td></tr>
<tr class="separator:a974d9d6b021e75ee0ba7146d221beed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442b27a359af323af62f92f95f343655"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a442b27a359af323af62f92f95f343655"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a442b27a359af323af62f92f95f343655.html#a442b27a359af323af62f92f95f343655">expm1</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a442b27a359af323af62f92f95f343655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8428395b18c89bc01669915993b8e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aea8428395b18c89bc01669915993b8e7.html#aea8428395b18c89bc01669915993b8e7">fabs</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:aea8428395b18c89bc01669915993b8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute value of the variable (cmath).  <a href="namespacestan_1_1math_aea8428395b18c89bc01669915993b8e7.html#aea8428395b18c89bc01669915993b8e7">More...</a><br /></td></tr>
<tr class="separator:aea8428395b18c89bc01669915993b8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c405343c718f1c07bfad79d40d3f65"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , require_var_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab7c405343c718f1c07bfad79d40d3f65"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab7c405343c718f1c07bfad79d40d3f65.html#ab7c405343c718f1c07bfad79d40d3f65">fabs</a> (const VarMat &amp;a)</td></tr>
<tr class="memdesc:ab7c405343c718f1c07bfad79d40d3f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute value of the variable (cmath).  <a href="namespacestan_1_1math_ab7c405343c718f1c07bfad79d40d3f65.html#ab7c405343c718f1c07bfad79d40d3f65">More...</a><br /></td></tr>
<tr class="separator:ab7c405343c718f1c07bfad79d40d3f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9ba061a64b1c51bb0e196701882920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afe9ba061a64b1c51bb0e196701882920.html#afe9ba061a64b1c51bb0e196701882920">falling_factorial</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, int b)</td></tr>
<tr class="separator:afe9ba061a64b1c51bb0e196701882920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950981f779abb13aedba88d394c9b805"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_eigen_t&lt; T1 &gt; *  = nullptr, require_st_integral&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a950981f779abb13aedba88d394c9b805"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a950981f779abb13aedba88d394c9b805.html#a950981f779abb13aedba88d394c9b805">falling_factorial</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T1 &gt; &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:a950981f779abb13aedba88d394c9b805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67859aea03604f636f079ed1000c59b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a67859aea03604f636f079ed1000c59b5.html#a67859aea03604f636f079ed1000c59b5">fdim</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a67859aea03604f636f079ed1000c59b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference between the first variable's the value and the second's (C99, C++11).  <a href="namespacestan_1_1math_a67859aea03604f636f079ed1000c59b5.html#a67859aea03604f636f079ed1000c59b5">More...</a><br /></td></tr>
<tr class="separator:a67859aea03604f636f079ed1000c59b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f697404813766e2548150ae6ba0f77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a04f697404813766e2548150ae6ba0f77.html#a04f697404813766e2548150ae6ba0f77">fdim</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a04f697404813766e2548150ae6ba0f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference between the first value and the value of the second variable (C99, C++11).  <a href="namespacestan_1_1math_a04f697404813766e2548150ae6ba0f77.html#a04f697404813766e2548150ae6ba0f77">More...</a><br /></td></tr>
<tr class="separator:a04f697404813766e2548150ae6ba0f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdba138717a245e872b72575a2a2838"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5fdba138717a245e872b72575a2a2838.html#a5fdba138717a245e872b72575a2a2838">fdim</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:a5fdba138717a245e872b72575a2a2838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference between the first variable's value and the second value (C99, C++11).  <a href="namespacestan_1_1math_a5fdba138717a245e872b72575a2a2838.html#a5fdba138717a245e872b72575a2a2838">More...</a><br /></td></tr>
<tr class="separator:a5fdba138717a245e872b72575a2a2838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58477ec4ec6137d4525fa43dd4b41628"><td class="memTemplParams" colspan="2">template&lt;typename V , require_eigen_vector_vt&lt; is_complex, V &gt; *  = nullptr, require_var_t&lt; base_type_t&lt; value_type_t&lt; V &gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a58477ec4ec6137d4525fa43dd4b41628"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a58477ec4ec6137d4525fa43dd4b41628.html#a58477ec4ec6137d4525fa43dd4b41628">fft</a> (const V &amp;x)</td></tr>
<tr class="memdesc:a58477ec4ec6137d4525fa43dd4b41628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the discrete Fourier transform of the specified complex vector.  <a href="namespacestan_1_1math_a58477ec4ec6137d4525fa43dd4b41628.html#a58477ec4ec6137d4525fa43dd4b41628">More...</a><br /></td></tr>
<tr class="separator:a58477ec4ec6137d4525fa43dd4b41628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac48afd5f89fd0da2c111d3059703bf3"><td class="memTemplParams" colspan="2">template&lt;typename V , require_eigen_vector_vt&lt; is_complex, V &gt; *  = nullptr, require_var_t&lt; base_type_t&lt; value_type_t&lt; V &gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aac48afd5f89fd0da2c111d3059703bf3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aac48afd5f89fd0da2c111d3059703bf3.html#aac48afd5f89fd0da2c111d3059703bf3">inv_fft</a> (const V &amp;y)</td></tr>
<tr class="memdesc:aac48afd5f89fd0da2c111d3059703bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse discrete Fourier transform of the specified complex vector.  <a href="namespacestan_1_1math_aac48afd5f89fd0da2c111d3059703bf3.html#aac48afd5f89fd0da2c111d3059703bf3">More...</a><br /></td></tr>
<tr class="separator:aac48afd5f89fd0da2c111d3059703bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2efcdc65786197e6b8f4a24759c28d"><td class="memTemplParams" colspan="2">template&lt;typename M , require_eigen_dense_dynamic_vt&lt; is_complex, M &gt; *  = nullptr, require_var_t&lt; base_type_t&lt; value_type_t&lt; M &gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaf2efcdc65786197e6b8f4a24759c28d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaf2efcdc65786197e6b8f4a24759c28d.html#aaf2efcdc65786197e6b8f4a24759c28d">fft2</a> (const M &amp;x)</td></tr>
<tr class="memdesc:aaf2efcdc65786197e6b8f4a24759c28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the two-dimensional discrete Fourier transform of the specified complex matrix.  <a href="namespacestan_1_1math_aaf2efcdc65786197e6b8f4a24759c28d.html#aaf2efcdc65786197e6b8f4a24759c28d">More...</a><br /></td></tr>
<tr class="separator:aaf2efcdc65786197e6b8f4a24759c28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8592457c0db90db814fc201bbbb534b"><td class="memTemplParams" colspan="2">template&lt;typename M , require_eigen_dense_dynamic_vt&lt; is_complex, M &gt; *  = nullptr, require_var_t&lt; base_type_t&lt; value_type_t&lt; M &gt;&gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad8592457c0db90db814fc201bbbb534b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad8592457c0db90db814fc201bbbb534b.html#ad8592457c0db90db814fc201bbbb534b">inv_fft2</a> (const M &amp;y)</td></tr>
<tr class="memdesc:ad8592457c0db90db814fc201bbbb534b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the two-dimensional inverse discrete Fourier transform of the specified complex matrix.  <a href="namespacestan_1_1math_ad8592457c0db90db814fc201bbbb534b.html#ad8592457c0db90db814fc201bbbb534b">More...</a><br /></td></tr>
<tr class="separator:ad8592457c0db90db814fc201bbbb534b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48956e04ac71f11589e263936b6d98a9"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , typename S , require_var_matrix_t&lt; VarMat &gt; *  = nullptr, require_var_t&lt; S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a48956e04ac71f11589e263936b6d98a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a48956e04ac71f11589e263936b6d98a9.html#a48956e04ac71f11589e263936b6d98a9">fill</a> (VarMat &amp;x, const S &amp;y)</td></tr>
<tr class="memdesc:a48956e04ac71f11589e263936b6d98a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <a href="namespacestan_1_1math_a48956e04ac71f11589e263936b6d98a9.html#a48956e04ac71f11589e263936b6d98a9">More...</a><br /></td></tr>
<tr class="separator:a48956e04ac71f11589e263936b6d98a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66dea6b6d18e39c5b0f38d3204aa04d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a66dea6b6d18e39c5b0f38d3204aa04d5.html#a66dea6b6d18e39c5b0f38d3204aa04d5">floor</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a66dea6b6d18e39c5b0f38d3204aa04d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floor of the specified variable (cmath).  <a href="namespacestan_1_1math_a66dea6b6d18e39c5b0f38d3204aa04d5.html#a66dea6b6d18e39c5b0f38d3204aa04d5">More...</a><br /></td></tr>
<tr class="separator:a66dea6b6d18e39c5b0f38d3204aa04d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe819627d159deb1bc0f2d2d21502f9"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aebe819627d159deb1bc0f2d2d21502f9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aebe819627d159deb1bc0f2d2d21502f9.html#aebe819627d159deb1bc0f2d2d21502f9">floor</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:aebe819627d159deb1bc0f2d2d21502f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a6d0bcdbc9a1a83749f8ed176678fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a55a6d0bcdbc9a1a83749f8ed176678fc.html#a55a6d0bcdbc9a1a83749f8ed176678fc">fma</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;z)</td></tr>
<tr class="memdesc:a55a6d0bcdbc9a1a83749f8ed176678fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for three variables (C99).  <a href="namespacestan_1_1math_a55a6d0bcdbc9a1a83749f8ed176678fc.html#a55a6d0bcdbc9a1a83749f8ed176678fc">More...</a><br /></td></tr>
<tr class="separator:a55a6d0bcdbc9a1a83749f8ed176678fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708f1f09e2c113b797491ad0fa2a0601"><td class="memTemplParams" colspan="2">template&lt;typename Tc , require_arithmetic_t&lt; Tc &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a708f1f09e2c113b797491ad0fa2a0601"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a708f1f09e2c113b797491ad0fa2a0601.html#a708f1f09e2c113b797491ad0fa2a0601">fma</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y, Tc &amp;&amp;z)</td></tr>
<tr class="memdesc:a708f1f09e2c113b797491ad0fa2a0601"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for two variables and a value (C99).  <a href="namespacestan_1_1math_a708f1f09e2c113b797491ad0fa2a0601.html#a708f1f09e2c113b797491ad0fa2a0601">More...</a><br /></td></tr>
<tr class="separator:a708f1f09e2c113b797491ad0fa2a0601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867b06260a9c7066241a3c0736cfb415"><td class="memTemplParams" colspan="2">template&lt;typename Tb , require_arithmetic_t&lt; Tb &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a867b06260a9c7066241a3c0736cfb415"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a867b06260a9c7066241a3c0736cfb415.html#a867b06260a9c7066241a3c0736cfb415">fma</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, Tb &amp;&amp;y, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;z)</td></tr>
<tr class="memdesc:a867b06260a9c7066241a3c0736cfb415"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for a variable, value, and variable (C99).  <a href="namespacestan_1_1math_a867b06260a9c7066241a3c0736cfb415.html#a867b06260a9c7066241a3c0736cfb415">More...</a><br /></td></tr>
<tr class="separator:a867b06260a9c7066241a3c0736cfb415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2c7db326e7be850dbc8195f1b49f10"><td class="memTemplParams" colspan="2">template&lt;typename Tb , typename Tc , require_all_arithmetic_t&lt; Tb, Tc &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6d2c7db326e7be850dbc8195f1b49f10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6d2c7db326e7be850dbc8195f1b49f10.html#a6d2c7db326e7be850dbc8195f1b49f10">fma</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, Tb &amp;&amp;y, Tc &amp;&amp;z)</td></tr>
<tr class="memdesc:a6d2c7db326e7be850dbc8195f1b49f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for a variable and two values (C99).  <a href="namespacestan_1_1math_a6d2c7db326e7be850dbc8195f1b49f10.html#a6d2c7db326e7be850dbc8195f1b49f10">More...</a><br /></td></tr>
<tr class="separator:a6d2c7db326e7be850dbc8195f1b49f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e8eedd9f9c307555379726f37c1850"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tc , require_all_arithmetic_t&lt; Ta, Tc &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a83e8eedd9f9c307555379726f37c1850"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a83e8eedd9f9c307555379726f37c1850.html#a83e8eedd9f9c307555379726f37c1850">fma</a> (Ta &amp;&amp;x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y, Tc &amp;&amp;z)</td></tr>
<tr class="memdesc:a83e8eedd9f9c307555379726f37c1850"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for a value, variable, and value (C99).  <a href="namespacestan_1_1math_a83e8eedd9f9c307555379726f37c1850.html#a83e8eedd9f9c307555379726f37c1850">More...</a><br /></td></tr>
<tr class="separator:a83e8eedd9f9c307555379726f37c1850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3455dbaefcdeafd33393026b65c6e3b"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , require_all_arithmetic_t&lt; Ta, Tb &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac3455dbaefcdeafd33393026b65c6e3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac3455dbaefcdeafd33393026b65c6e3b.html#ac3455dbaefcdeafd33393026b65c6e3b">fma</a> (Ta &amp;&amp;x, Tb &amp;&amp;y, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;z)</td></tr>
<tr class="memdesc:ac3455dbaefcdeafd33393026b65c6e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for two values and a variable, and value (C99).  <a href="namespacestan_1_1math_ac3455dbaefcdeafd33393026b65c6e3b.html#ac3455dbaefcdeafd33393026b65c6e3b">More...</a><br /></td></tr>
<tr class="separator:ac3455dbaefcdeafd33393026b65c6e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2357b25e743c440163eead1df1ac38"><td class="memTemplParams" colspan="2">template&lt;typename Ta , require_arithmetic_t&lt; Ta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6b2357b25e743c440163eead1df1ac38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6b2357b25e743c440163eead1df1ac38.html#a6b2357b25e743c440163eead1df1ac38">fma</a> (Ta &amp;&amp;x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;z)</td></tr>
<tr class="memdesc:a6b2357b25e743c440163eead1df1ac38"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for a value and two variables (C99).  <a href="namespacestan_1_1math_a6b2357b25e743c440163eead1df1ac38.html#a6b2357b25e743c440163eead1df1ac38">More...</a><br /></td></tr>
<tr class="separator:a6b2357b25e743c440163eead1df1ac38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7621a9cac916276e0f2843dbbfa61a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_any_matrix_t&lt; T1, T2, T3 &gt; *  = nullptr, require_var_t&lt; return_type_t&lt; T1, T2, T3 &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5d7621a9cac916276e0f2843dbbfa61a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5d7621a9cac916276e0f2843dbbfa61a.html#a5d7621a9cac916276e0f2843dbbfa61a">fma</a> (const T1 &amp;x, const T2 &amp;y, const T3 &amp;z)</td></tr>
<tr class="memdesc:a5d7621a9cac916276e0f2843dbbfa61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for three variables (C99).  <a href="namespacestan_1_1math_a5d7621a9cac916276e0f2843dbbfa61a.html#a5d7621a9cac916276e0f2843dbbfa61a">More...</a><br /></td></tr>
<tr class="separator:a5d7621a9cac916276e0f2843dbbfa61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090ff6b2b6b36510e8e5986d8c452025"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a090ff6b2b6b36510e8e5986d8c452025.html#a090ff6b2b6b36510e8e5986d8c452025">fmax</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a090ff6b2b6b36510e8e5986d8c452025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum of the two variable arguments (C99).  <a href="namespacestan_1_1math_a090ff6b2b6b36510e8e5986d8c452025.html#a090ff6b2b6b36510e8e5986d8c452025">More...</a><br /></td></tr>
<tr class="separator:a090ff6b2b6b36510e8e5986d8c452025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf0992be2ce2165722d060940e3305a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aacf0992be2ce2165722d060940e3305a.html#aacf0992be2ce2165722d060940e3305a">fmax</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:aacf0992be2ce2165722d060940e3305a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum of the variable and scalar, promoting the scalar to a variable if it is larger (C99).  <a href="namespacestan_1_1math_aacf0992be2ce2165722d060940e3305a.html#aacf0992be2ce2165722d060940e3305a">More...</a><br /></td></tr>
<tr class="separator:aacf0992be2ce2165722d060940e3305a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb80ce6aef3b70dd0ed452619bf0ea1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acb80ce6aef3b70dd0ed452619bf0ea1a.html#acb80ce6aef3b70dd0ed452619bf0ea1a">fmax</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:acb80ce6aef3b70dd0ed452619bf0ea1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum of a scalar and variable, promoting the scalar to a variable if it is larger (C99).  <a href="namespacestan_1_1math_acb80ce6aef3b70dd0ed452619bf0ea1a.html#acb80ce6aef3b70dd0ed452619bf0ea1a">More...</a><br /></td></tr>
<tr class="separator:acb80ce6aef3b70dd0ed452619bf0ea1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a002d1861d4fddb98b16ed781bf541b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5a002d1861d4fddb98b16ed781bf541b.html#a5a002d1861d4fddb98b16ed781bf541b">fmin</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a5a002d1861d4fddb98b16ed781bf541b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum of the two variable arguments (C99).  <a href="namespacestan_1_1math_a5a002d1861d4fddb98b16ed781bf541b.html#a5a002d1861d4fddb98b16ed781bf541b">More...</a><br /></td></tr>
<tr class="separator:a5a002d1861d4fddb98b16ed781bf541b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90700a00e5d9829dbd0bd5b2692917c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a90700a00e5d9829dbd0bd5b2692917c4.html#a90700a00e5d9829dbd0bd5b2692917c4">fmin</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:a90700a00e5d9829dbd0bd5b2692917c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum of the variable and scalar, promoting the scalar to a variable if it is larger (C99).  <a href="namespacestan_1_1math_a90700a00e5d9829dbd0bd5b2692917c4.html#a90700a00e5d9829dbd0bd5b2692917c4">More...</a><br /></td></tr>
<tr class="separator:a90700a00e5d9829dbd0bd5b2692917c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59f8682c1537c9f9fa72f49577bd05a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad59f8682c1537c9f9fa72f49577bd05a.html#ad59f8682c1537c9f9fa72f49577bd05a">fmin</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:ad59f8682c1537c9f9fa72f49577bd05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum of a scalar and variable, promoting the scalar to a variable if it is larger (C99).  <a href="namespacestan_1_1math_ad59f8682c1537c9f9fa72f49577bd05a.html#ad59f8682c1537c9f9fa72f49577bd05a">More...</a><br /></td></tr>
<tr class="separator:ad59f8682c1537c9f9fa72f49577bd05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935933626162d429e5a7f06ca0bde103"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a935933626162d429e5a7f06ca0bde103.html#a935933626162d429e5a7f06ca0bde103">fmod</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a935933626162d429e5a7f06ca0bde103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floating point remainder after dividing the first variable by the second (cmath).  <a href="namespacestan_1_1math_a935933626162d429e5a7f06ca0bde103.html#a935933626162d429e5a7f06ca0bde103">More...</a><br /></td></tr>
<tr class="separator:a935933626162d429e5a7f06ca0bde103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8420835869a6fc4f0d0b0f6866b403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7a8420835869a6fc4f0d0b0f6866b403.html#a7a8420835869a6fc4f0d0b0f6866b403">fmod</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:a7a8420835869a6fc4f0d0b0f6866b403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floating point remainder after dividing the the first variable by the second scalar (cmath).  <a href="namespacestan_1_1math_a7a8420835869a6fc4f0d0b0f6866b403.html#a7a8420835869a6fc4f0d0b0f6866b403">More...</a><br /></td></tr>
<tr class="separator:a7a8420835869a6fc4f0d0b0f6866b403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:added805756153e21677750443283bdc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_added805756153e21677750443283bdc1.html#added805756153e21677750443283bdc1">fmod</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:added805756153e21677750443283bdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floating point remainder after dividing the first scalar by the second variable (cmath).  <a href="namespacestan_1_1math_added805756153e21677750443283bdc1.html#added805756153e21677750443283bdc1">More...</a><br /></td></tr>
<tr class="separator:added805756153e21677750443283bdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8509739052e3a941de1891c37de503a"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac8509739052e3a941de1891c37de503a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, T::RowsAtCompileTime, T::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac8509739052e3a941de1891c37de503a.html#ac8509739052e3a941de1891c37de503a">from_var_value</a> (const T &amp;a)</td></tr>
<tr class="memdesc:ac8509739052e3a941de1891c37de503a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code> into an <a class="el" href="namespace_eigen.html">Eigen</a> Matrix.  <a href="namespacestan_1_1math_ac8509739052e3a941de1891c37de503a.html#ac8509739052e3a941de1891c37de503a">More...</a><br /></td></tr>
<tr class="separator:ac8509739052e3a941de1891c37de503a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a4838086f6cb2c59890cdf513e78c2"><td class="memTemplParams" colspan="2">template&lt;typename T , require_any_t&lt; conjunction&lt; is_eigen&lt; T &gt;, is_var&lt; scalar_type_t&lt; T &gt;&gt;&gt;, std::is_same&lt; std::decay_t&lt; T &gt;, var &gt;, bool_constant&lt;!std::is_same&lt; scalar_type_t&lt; T &gt;, var &gt;::value &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a46a4838086f6cb2c59890cdf513e78c2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a46a4838086f6cb2c59890cdf513e78c2.html#a46a4838086f6cb2c59890cdf513e78c2">from_var_value</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a46a4838086f6cb2c59890cdf513e78c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a no-op for <a class="el" href="namespace_eigen.html">Eigen</a> containers of vars, scalars or prim types.  <a href="namespacestan_1_1math_a46a4838086f6cb2c59890cdf513e78c2.html#a46a4838086f6cb2c59890cdf513e78c2">More...</a><br /></td></tr>
<tr class="separator:a46a4838086f6cb2c59890cdf513e78c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa484418490e887bdc814d50d415f8a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa484418490e887bdc814d50d415f8a8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afa484418490e887bdc814d50d415f8a8.html#afa484418490e887bdc814d50d415f8a8">from_var_value</a> (const std::vector&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:afa484418490e887bdc814d50d415f8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the elements of the <code>std::vector</code> input to <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code> types if possible.  <a href="namespacestan_1_1math_afa484418490e887bdc814d50d415f8a8.html#afa484418490e887bdc814d50d415f8a8">More...</a><br /></td></tr>
<tr class="separator:afa484418490e887bdc814d50d415f8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c66b8a83c53e18f4974988d38e41d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6c66b8a83c53e18f4974988d38e41d8f.html#a6c66b8a83c53e18f4974988d38e41d8f">gamma_p</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:a6c66b8a83c53e18f4974988d38e41d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5d71ea3ea8cbe73b3ec087a4858ed7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afd5d71ea3ea8cbe73b3ec087a4858ed7.html#afd5d71ea3ea8cbe73b3ec087a4858ed7">gamma_p</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="separator:afd5d71ea3ea8cbe73b3ec087a4858ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8ada6dde6c69c5435442c9227ade8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3b8ada6dde6c69c5435442c9227ade8b.html#a3b8ada6dde6c69c5435442c9227ade8b">gamma_p</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:a3b8ada6dde6c69c5435442c9227ade8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf59e94075aaffc23e80dfe865bf2f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeaf59e94075aaffc23e80dfe865bf2f4.html#aeaf59e94075aaffc23e80dfe865bf2f4">gamma_q</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:aeaf59e94075aaffc23e80dfe865bf2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977e96802b4cae1bd238ffd3a6887430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a977e96802b4cae1bd238ffd3a6887430.html#a977e96802b4cae1bd238ffd3a6887430">gamma_q</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="separator:a977e96802b4cae1bd238ffd3a6887430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29dcdbbac262f0103ac8bf38205453f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af29dcdbbac262f0103ac8bf38205453f.html#af29dcdbbac262f0103ac8bf38205453f">gamma_q</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:af29dcdbbac262f0103ac8bf38205453f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45baa280de387db8293ea9f150ecd9d4"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , require_rev_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a45baa280de387db8293ea9f150ecd9d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a45baa280de387db8293ea9f150ecd9d4.html#a45baa280de387db8293ea9f150ecd9d4">generalized_inverse</a> (const VarMat &amp;G)</td></tr>
<tr class="separator:a45baa280de387db8293ea9f150ecd9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b055f5a4f274c58bf1f62c9ea1df81"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , require_st_arithmetic&lt; T_x &gt; *  = nullptr, require_stan_scalar_t&lt; T_sigma &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae5b055f5a4f274c58bf1f62c9ea1df81"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae5b055f5a4f274c58bf1f62c9ea1df81.html#ae5b055f5a4f274c58bf1f62c9ea1df81">gp_exp_quad_cov</a> (const std::vector&lt; T_x &gt; &amp;x, const T_sigma sigma, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> length_scale)</td></tr>
<tr class="memdesc:ae5b055f5a4f274c58bf1f62c9ea1df81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a squared exponential kernel.  <a href="namespacestan_1_1math_ae5b055f5a4f274c58bf1f62c9ea1df81.html#ae5b055f5a4f274c58bf1f62c9ea1df81">More...</a><br /></td></tr>
<tr class="separator:ae5b055f5a4f274c58bf1f62c9ea1df81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695775484fed6f6229625dee3974dd9e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , require_st_arithmetic&lt; T_x &gt; *  = nullptr, require_stan_scalar_t&lt; T_sigma &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a695775484fed6f6229625dee3974dd9e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a695775484fed6f6229625dee3974dd9e.html#a695775484fed6f6229625dee3974dd9e">gp_periodic_cov</a> (const std::vector&lt; T_x &gt; &amp;x, const T_sigma sigma, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> l, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> p)</td></tr>
<tr class="memdesc:a695775484fed6f6229625dee3974dd9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a periodic covariance matrix \( \mathbf{K} \) using the input \( \mathbf{X} \).  <a href="namespacestan_1_1math_a695775484fed6f6229625dee3974dd9e.html#a695775484fed6f6229625dee3974dd9e">More...</a><br /></td></tr>
<tr class="separator:a695775484fed6f6229625dee3974dd9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c351f7c1ef5ea39c047fe102f70da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a78c351f7c1ef5ea39c047fe102f70da3.html#a78c351f7c1ef5ea39c047fe102f70da3">grad</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;v, Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Eigen::Dynamic, 1 &gt; &amp;x, Eigen::VectorXd &amp;g)</td></tr>
<tr class="memdesc:a78c351f7c1ef5ea39c047fe102f70da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate chain rule to calculate gradients starting from the specified variable.  <a href="namespacestan_1_1math_a78c351f7c1ef5ea39c047fe102f70da3.html#a78c351f7c1ef5ea39c047fe102f70da3">More...</a><br /></td></tr>
<tr class="separator:a78c351f7c1ef5ea39c047fe102f70da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f15a75139ebb4a3b599a1190d39fc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a25f15a75139ebb4a3b599a1190d39fc1.html#a25f15a75139ebb4a3b599a1190d39fc1">grad_inc_beta</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;g1, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;g2, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;z)</td></tr>
<tr class="memdesc:a25f15a75139ebb4a3b599a1190d39fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradient of the incomplete beta function beta(a, b, z) with respect to the first two arguments.  <a href="namespacestan_1_1math_a25f15a75139ebb4a3b599a1190d39fc1.html#a25f15a75139ebb4a3b599a1190d39fc1">More...</a><br /></td></tr>
<tr class="separator:a25f15a75139ebb4a3b599a1190d39fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cd462920bf488bf26e1a2bda6751ad"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , typename Tz , require_all_matrix_t&lt; Ta, Tb &gt; *  = nullptr, require_return_type_t&lt; is_var, Ta, Tb, Tz &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a67cd462920bf488bf26e1a2bda6751ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a67cd462920bf488bf26e1a2bda6751ad.html#a67cd462920bf488bf26e1a2bda6751ad">hypergeometric_pFq</a> (const Ta &amp;a, const Tb &amp;b, const Tz &amp;z)</td></tr>
<tr class="memdesc:a67cd462920bf488bf26e1a2bda6751ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the generalised hypergeometric function (pFq) applied to the input arguments.  <a href="namespacestan_1_1math_a67cd462920bf488bf26e1a2bda6751ad.html#a67cd462920bf488bf26e1a2bda6751ad">More...</a><br /></td></tr>
<tr class="separator:a67cd462920bf488bf26e1a2bda6751ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0827e995b465dcb291c3de1a77e2b547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0827e995b465dcb291c3de1a77e2b547.html#a0827e995b465dcb291c3de1a77e2b547">hypot</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a0827e995b465dcb291c3de1a77e2b547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the hypotenuse of a right triangle with sides of the specified lengths (C99).  <a href="namespacestan_1_1math_a0827e995b465dcb291c3de1a77e2b547.html#a0827e995b465dcb291c3de1a77e2b547">More...</a><br /></td></tr>
<tr class="separator:a0827e995b465dcb291c3de1a77e2b547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb40e789140be0e0b93a44e055a6cfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abcb40e789140be0e0b93a44e055a6cfc.html#abcb40e789140be0e0b93a44e055a6cfc">hypot</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:abcb40e789140be0e0b93a44e055a6cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the hypotenuse of a right triangle with sides of the specified lengths (C99).  <a href="namespacestan_1_1math_abcb40e789140be0e0b93a44e055a6cfc.html#abcb40e789140be0e0b93a44e055a6cfc">More...</a><br /></td></tr>
<tr class="separator:abcb40e789140be0e0b93a44e055a6cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9d2305ce89a46a7d182e6014fd0b3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5c9d2305ce89a46a7d182e6014fd0b3f.html#a5c9d2305ce89a46a7d182e6014fd0b3f">hypot</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a5c9d2305ce89a46a7d182e6014fd0b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the hypotenuse of a right triangle with sides of the specified lengths (C99).  <a href="namespacestan_1_1math_a5c9d2305ce89a46a7d182e6014fd0b3f.html#a5c9d2305ce89a46a7d182e6014fd0b3f">More...</a><br /></td></tr>
<tr class="separator:a5c9d2305ce89a46a7d182e6014fd0b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb35d5a60bdc11a5d09eb629c50b5db5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abb35d5a60bdc11a5d09eb629c50b5db5.html#abb35d5a60bdc11a5d09eb629c50b5db5">if_else</a> (bool c, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y_true, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y_false)</td></tr>
<tr class="memdesc:abb35d5a60bdc11a5d09eb629c50b5db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specified condition is true, return the first variable, otherwise return the second variable.  <a href="namespacestan_1_1math_abb35d5a60bdc11a5d09eb629c50b5db5.html#abb35d5a60bdc11a5d09eb629c50b5db5">More...</a><br /></td></tr>
<tr class="separator:abb35d5a60bdc11a5d09eb629c50b5db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1dc3a479994402ee1959b75fa2c70f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abc1dc3a479994402ee1959b75fa2c70f.html#abc1dc3a479994402ee1959b75fa2c70f">if_else</a> (bool c, double y_true, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y_false)</td></tr>
<tr class="memdesc:abc1dc3a479994402ee1959b75fa2c70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specified condition is true, return a new variable constructed from the first scalar, otherwise return the second variable.  <a href="namespacestan_1_1math_abc1dc3a479994402ee1959b75fa2c70f.html#abc1dc3a479994402ee1959b75fa2c70f">More...</a><br /></td></tr>
<tr class="separator:abc1dc3a479994402ee1959b75fa2c70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209a6257548b6440d7468bd7cadee89b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a209a6257548b6440d7468bd7cadee89b.html#a209a6257548b6440d7468bd7cadee89b">if_else</a> (bool c, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y_true, double y_false)</td></tr>
<tr class="memdesc:a209a6257548b6440d7468bd7cadee89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specified condition is true, return the first variable, otherwise return a new variable constructed from the second scalar.  <a href="namespacestan_1_1math_a209a6257548b6440d7468bd7cadee89b.html#a209a6257548b6440d7468bd7cadee89b">More...</a><br /></td></tr>
<tr class="separator:a209a6257548b6440d7468bd7cadee89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5ba3e933a20c5ebd6f114cfa27dece"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7f5ba3e933a20c5ebd6f114cfa27dece.html#a7f5ba3e933a20c5ebd6f114cfa27dece">inc_beta</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;c)</td></tr>
<tr class="separator:a7f5ba3e933a20c5ebd6f114cfa27dece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fdaccda77932edc3a2583294c69d10"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , typename S , require_var_matrix_t&lt; VarMat &gt; *  = nullptr, require_stan_scalar_t&lt; S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae7fdaccda77932edc3a2583294c69d10"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae7fdaccda77932edc3a2583294c69d10.html#ae7fdaccda77932edc3a2583294c69d10">initialize_fill</a> (VarMat &amp;x, const S &amp;y)</td></tr>
<tr class="memdesc:ae7fdaccda77932edc3a2583294c69d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <a href="namespacestan_1_1math_ae7fdaccda77932edc3a2583294c69d10.html#ae7fdaccda77932edc3a2583294c69d10">More...</a><br /></td></tr>
<tr class="separator:ae7fdaccda77932edc3a2583294c69d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdf0a5cd40134110da3230d6fdea989"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aebdf0a5cd40134110da3230d6fdea989.html#aebdf0a5cd40134110da3230d6fdea989">initialize_variable</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;variable, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;value)</td></tr>
<tr class="memdesc:aebdf0a5cd40134110da3230d6fdea989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize variable to value.  <a href="namespacestan_1_1math_aebdf0a5cd40134110da3230d6fdea989.html#aebdf0a5cd40134110da3230d6fdea989">More...</a><br /></td></tr>
<tr class="separator:aebdf0a5cd40134110da3230d6fdea989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bb474a393fa5277ff69c9498cb3809"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:ad1bb474a393fa5277ff69c9498cb3809"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad1bb474a393fa5277ff69c9498cb3809.html#ad1bb474a393fa5277ff69c9498cb3809">initialize_variable</a> (Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, R, C &gt; &amp;matrix, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;value)</td></tr>
<tr class="memdesc:ad1bb474a393fa5277ff69c9498cb3809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize every cell in the matrix to the specified value.  <a href="namespacestan_1_1math_ad1bb474a393fa5277ff69c9498cb3809.html#ad1bb474a393fa5277ff69c9498cb3809">More...</a><br /></td></tr>
<tr class="separator:ad1bb474a393fa5277ff69c9498cb3809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada62635d3e2320c9e36ac59a1c4bbdb0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada62635d3e2320c9e36ac59a1c4bbdb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ada62635d3e2320c9e36ac59a1c4bbdb0.html#ada62635d3e2320c9e36ac59a1c4bbdb0">initialize_variable</a> (std::vector&lt; T &gt; &amp;variables, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;value)</td></tr>
<tr class="memdesc:ada62635d3e2320c9e36ac59a1c4bbdb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the variables in the standard vector recursively.  <a href="namespacestan_1_1math_ada62635d3e2320c9e36ac59a1c4bbdb0.html#ada62635d3e2320c9e36ac59a1c4bbdb0">More...</a><br /></td></tr>
<tr class="separator:ada62635d3e2320c9e36ac59a1c4bbdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ffe89f9184bfe3e09eb1376d7fbbae"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_or_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a04ffe89f9184bfe3e09eb1376d7fbbae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a04ffe89f9184bfe3e09eb1376d7fbbae.html#a04ffe89f9184bfe3e09eb1376d7fbbae">inv</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a04ffe89f9184bfe3e09eb1376d7fbbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a98a8a08c82979b7e15e61de66a5f1b"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_or_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9a98a8a08c82979b7e15e61de66a5f1b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9a98a8a08c82979b7e15e61de66a5f1b.html#a9a98a8a08c82979b7e15e61de66a5f1b">inv_cloglog</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a9a98a8a08c82979b7e15e61de66a5f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse complementary log-log function applied specified variable (stan).  <a href="namespacestan_1_1math_a9a98a8a08c82979b7e15e61de66a5f1b.html#a9a98a8a08c82979b7e15e61de66a5f1b">More...</a><br /></td></tr>
<tr class="separator:a9a98a8a08c82979b7e15e61de66a5f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f68363ddbb6b9821cada9414f2fb805"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f68363ddbb6b9821cada9414f2fb805.html#a2f68363ddbb6b9821cada9414f2fb805">inv_erfc</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a2f68363ddbb6b9821cada9414f2fb805"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse complementary error function for variables.  <a href="namespacestan_1_1math_a2f68363ddbb6b9821cada9414f2fb805.html#a2f68363ddbb6b9821cada9414f2fb805">More...</a><br /></td></tr>
<tr class="separator:a2f68363ddbb6b9821cada9414f2fb805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8873af0d3f7b3967b10c88f4e252c1c0"><td class="memTemplParams" colspan="2">template&lt;typename T , require_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8873af0d3f7b3967b10c88f4e252c1c0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8873af0d3f7b3967b10c88f4e252c1c0.html#a8873af0d3f7b3967b10c88f4e252c1c0">inv_erfc</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a8873af0d3f7b3967b10c88f4e252c1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751f4a0ea6cf477870bfc3cf172e5ec1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , require_all_stan_scalar_t&lt; T1, T2, T3 &gt; *  = nullptr, require_any_var_t&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a751f4a0ea6cf477870bfc3cf172e5ec1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a751f4a0ea6cf477870bfc3cf172e5ec1.html#a751f4a0ea6cf477870bfc3cf172e5ec1">inv_inc_beta</a> (const T1 &amp;a, const T2 &amp;b, const T3 &amp;p)</td></tr>
<tr class="memdesc:a751f4a0ea6cf477870bfc3cf172e5ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of the normalized incomplete beta function of a, b, with probability p.  <a href="namespacestan_1_1math_a751f4a0ea6cf477870bfc3cf172e5ec1.html#a751f4a0ea6cf477870bfc3cf172e5ec1">More...</a><br /></td></tr>
<tr class="separator:a751f4a0ea6cf477870bfc3cf172e5ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9a5fc59eb334179dc398d6c435e863"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_or_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adc9a5fc59eb334179dc398d6c435e863"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adc9a5fc59eb334179dc398d6c435e863.html#adc9a5fc59eb334179dc398d6c435e863">inv_logit</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:adc9a5fc59eb334179dc398d6c435e863"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse logit function for variables (stan).  <a href="namespacestan_1_1math_adc9a5fc59eb334179dc398d6c435e863.html#adc9a5fc59eb334179dc398d6c435e863">More...</a><br /></td></tr>
<tr class="separator:adc9a5fc59eb334179dc398d6c435e863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb1ddd4c78517c6bc8ca08832725022"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1cb1ddd4c78517c6bc8ca08832725022.html#a1cb1ddd4c78517c6bc8ca08832725022">inv_Phi</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;p)</td></tr>
<tr class="memdesc:a1cb1ddd4c78517c6bc8ca08832725022"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of unit normal cumulative density function.  <a href="namespacestan_1_1math_a1cb1ddd4c78517c6bc8ca08832725022.html#a1cb1ddd4c78517c6bc8ca08832725022">More...</a><br /></td></tr>
<tr class="separator:a1cb1ddd4c78517c6bc8ca08832725022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4807e86186ca996726214a632c0af9f"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab4807e86186ca996726214a632c0af9f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab4807e86186ca996726214a632c0af9f.html#ab4807e86186ca996726214a632c0af9f">inv_Phi</a> (const T &amp;p)</td></tr>
<tr class="memdesc:ab4807e86186ca996726214a632c0af9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise inverse of unit normal cumulative density function.  <a href="namespacestan_1_1math_ab4807e86186ca996726214a632c0af9f.html#ab4807e86186ca996726214a632c0af9f">More...</a><br /></td></tr>
<tr class="separator:ab4807e86186ca996726214a632c0af9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6233053c65cf125929efa0982aff0485"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_or_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6233053c65cf125929efa0982aff0485"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6233053c65cf125929efa0982aff0485.html#a6233053c65cf125929efa0982aff0485">inv_sqrt</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a6233053c65cf125929efa0982aff0485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa347bbaada35746d4fbd644549416ce3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa347bbaada35746d4fbd644549416ce3.html#aa347bbaada35746d4fbd644549416ce3">inv_square</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="separator:aa347bbaada35746d4fbd644549416ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502dc19f9a468d9754817754806fa803"><td class="memTemplParams" colspan="2">template&lt;typename T , require_rev_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a502dc19f9a468d9754817754806fa803"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a502dc19f9a468d9754817754806fa803.html#a502dc19f9a468d9754817754806fa803">inverse</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a502dc19f9a468d9754817754806fa803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse mode specialization of calculating the inverse of the matrix.  <a href="namespacestan_1_1math_a502dc19f9a468d9754817754806fa803.html#a502dc19f9a468d9754817754806fa803">More...</a><br /></td></tr>
<tr class="separator:a502dc19f9a468d9754817754806fa803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c050932da2e90902bda668170379545"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2c050932da2e90902bda668170379545.html#a2c050932da2e90902bda668170379545">is_inf</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;v)</td></tr>
<tr class="memdesc:a2c050932da2e90902bda668170379545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the input's value is infinite and 0 otherwise.  <a href="namespacestan_1_1math_a2c050932da2e90902bda668170379545.html#a2c050932da2e90902bda668170379545">More...</a><br /></td></tr>
<tr class="separator:a2c050932da2e90902bda668170379545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8ef1e06cddc77c4c56311f937cc183"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acf8ef1e06cddc77c4c56311f937cc183.html#acf8ef1e06cddc77c4c56311f937cc183">is_nan</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;v)</td></tr>
<tr class="memdesc:acf8ef1e06cddc77c4c56311f937cc183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the input's value is NaN and 0 otherwise.  <a href="namespacestan_1_1math_acf8ef1e06cddc77c4c56311f937cc183.html#acf8ef1e06cddc77c4c56311f937cc183">More...</a><br /></td></tr>
<tr class="separator:acf8ef1e06cddc77c4c56311f937cc183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8d228f0969deddaf2c485f07452fd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f8d228f0969deddaf2c485f07452fd5.html#a2f8d228f0969deddaf2c485f07452fd5">is_uninitialized</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> x)</td></tr>
<tr class="memdesc:a2f8d228f0969deddaf2c485f07452fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the specified variable is uninitialized.  <a href="namespacestan_1_1math_a2f8d228f0969deddaf2c485f07452fd5.html#a2f8d228f0969deddaf2c485f07452fd5">More...</a><br /></td></tr>
<tr class="separator:a2f8d228f0969deddaf2c485f07452fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ddaf50712801d40ad1ace6e4a91f5a"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_or_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac5ddaf50712801d40ad1ace6e4a91f5a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac5ddaf50712801d40ad1ace6e4a91f5a.html#ac5ddaf50712801d40ad1ace6e4a91f5a">lambert_w0</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:ac5ddaf50712801d40ad1ace6e4a91f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Lambert W function on W0 branch applied to the specified variable.  <a href="namespacestan_1_1math_ac5ddaf50712801d40ad1ace6e4a91f5a.html#ac5ddaf50712801d40ad1ace6e4a91f5a">More...</a><br /></td></tr>
<tr class="separator:ac5ddaf50712801d40ad1ace6e4a91f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574e9f736da74a8d1c256a46acbc3c66"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_or_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a574e9f736da74a8d1c256a46acbc3c66"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a574e9f736da74a8d1c256a46acbc3c66.html#a574e9f736da74a8d1c256a46acbc3c66">lambert_wm1</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a574e9f736da74a8d1c256a46acbc3c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Lambert W function on W-1 branch applied to the specified variable.  <a href="namespacestan_1_1math_a574e9f736da74a8d1c256a46acbc3c66.html#a574e9f736da74a8d1c256a46acbc3c66">More...</a><br /></td></tr>
<tr class="separator:a574e9f736da74a8d1c256a46acbc3c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011a7e8de04e8dce184dfc29afcbd232"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , require_all_stan_scalar_t&lt; T, L &gt; *  = nullptr, require_any_var_t&lt; T, L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a011a7e8de04e8dce184dfc29afcbd232"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a011a7e8de04e8dce184dfc29afcbd232.html#a011a7e8de04e8dce184dfc29afcbd232">lb_constrain</a> (const T &amp;x, const L &amp;lb, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;lp)</td></tr>
<tr class="memdesc:a011a7e8de04e8dce184dfc29afcbd232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-bounded value for the specified unconstrained input and specified lower bound.  <a href="namespacestan_1_1math_a011a7e8de04e8dce184dfc29afcbd232.html#a011a7e8de04e8dce184dfc29afcbd232">More...</a><br /></td></tr>
<tr class="separator:a011a7e8de04e8dce184dfc29afcbd232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bc788c89dc6032f4db9a2f6cf16689"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , require_matrix_t&lt; T &gt; *  = nullptr, require_stan_scalar_t&lt; L &gt; *  = nullptr, require_any_st_var&lt; T, L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa0bc788c89dc6032f4db9a2f6cf16689"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa0bc788c89dc6032f4db9a2f6cf16689.html#aa0bc788c89dc6032f4db9a2f6cf16689">lb_constrain</a> (const T &amp;x, const L &amp;lb)</td></tr>
<tr class="memdesc:aa0bc788c89dc6032f4db9a2f6cf16689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>lb_constrain</code> to apply a scalar lower bound elementwise to each input.  <a href="namespacestan_1_1math_aa0bc788c89dc6032f4db9a2f6cf16689.html#aa0bc788c89dc6032f4db9a2f6cf16689">More...</a><br /></td></tr>
<tr class="separator:aa0bc788c89dc6032f4db9a2f6cf16689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1926137e835f589aae4bc1de3c38df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0c1926137e835f589aae4bc1de3c38df.html#a0c1926137e835f589aae4bc1de3c38df">lbeta</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a0c1926137e835f589aae4bc1de3c38df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the beta function and its gradients.  <a href="namespacestan_1_1math_a0c1926137e835f589aae4bc1de3c38df.html#a0c1926137e835f589aae4bc1de3c38df">More...</a><br /></td></tr>
<tr class="separator:a0c1926137e835f589aae4bc1de3c38df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0d3b1bc340a39916334d6278cc3af9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aed0d3b1bc340a39916334d6278cc3af9.html#aed0d3b1bc340a39916334d6278cc3af9">lbeta</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:aed0d3b1bc340a39916334d6278cc3af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the beta function and its gradients.  <a href="namespacestan_1_1math_aed0d3b1bc340a39916334d6278cc3af9.html#aed0d3b1bc340a39916334d6278cc3af9">More...</a><br /></td></tr>
<tr class="separator:aed0d3b1bc340a39916334d6278cc3af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e979f59835f8d76fe11c0d965f3e854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6e979f59835f8d76fe11c0d965f3e854.html#a6e979f59835f8d76fe11c0d965f3e854">lbeta</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a6e979f59835f8d76fe11c0d965f3e854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the beta function and its gradients.  <a href="namespacestan_1_1math_a6e979f59835f8d76fe11c0d965f3e854.html#a6e979f59835f8d76fe11c0d965f3e854">More...</a><br /></td></tr>
<tr class="separator:a6e979f59835f8d76fe11c0d965f3e854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3663745044c3881171359fdba082bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae3663745044c3881171359fdba082bf0.html#ae3663745044c3881171359fdba082bf0">ldexp</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, int b)</td></tr>
<tr class="separator:ae3663745044c3881171359fdba082bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410b3274a3dc59d4886e985151f4657c"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_or_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a410b3274a3dc59d4886e985151f4657c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a410b3274a3dc59d4886e985151f4657c.html#a410b3274a3dc59d4886e985151f4657c">lgamma</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a410b3274a3dc59d4886e985151f4657c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log gamma function for variables (C99).  <a href="namespacestan_1_1math_a410b3274a3dc59d4886e985151f4657c.html#a410b3274a3dc59d4886e985151f4657c">More...</a><br /></td></tr>
<tr class="separator:a410b3274a3dc59d4886e985151f4657c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb651f7e7681a1e21bb88ea6ba242cf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeb651f7e7681a1e21bb88ea6ba242cf6.html#aeb651f7e7681a1e21bb88ea6ba242cf6">lmgamma</a> (int a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:aeb651f7e7681a1e21bb88ea6ba242cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa794b0437e78aaf70691215e3797675d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa794b0437e78aaf70691215e3797675d.html#aa794b0437e78aaf70691215e3797675d">lmultiply</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:aa794b0437e78aaf70691215e3797675d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a*log(b).  <a href="namespacestan_1_1math_aa794b0437e78aaf70691215e3797675d.html#aa794b0437e78aaf70691215e3797675d">More...</a><br /></td></tr>
<tr class="separator:aa794b0437e78aaf70691215e3797675d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa731707ebca797a73bb042c4f6ae7cc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa731707ebca797a73bb042c4f6ae7cc2.html#aa731707ebca797a73bb042c4f6ae7cc2">lmultiply</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:aa731707ebca797a73bb042c4f6ae7cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a*log(b).  <a href="namespacestan_1_1math_aa731707ebca797a73bb042c4f6ae7cc2.html#aa731707ebca797a73bb042c4f6ae7cc2">More...</a><br /></td></tr>
<tr class="separator:aa731707ebca797a73bb042c4f6ae7cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbc3c7013e61c68da968ecd7ee68628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3dbc3c7013e61c68da968ecd7ee68628.html#a3dbc3c7013e61c68da968ecd7ee68628">lmultiply</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a3dbc3c7013e61c68da968ecd7ee68628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a*log(b).  <a href="namespacestan_1_1math_a3dbc3c7013e61c68da968ecd7ee68628.html#a3dbc3c7013e61c68da968ecd7ee68628">More...</a><br /></td></tr>
<tr class="separator:a3dbc3c7013e61c68da968ecd7ee68628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888e8c0c2053d796f168688ffb49a530"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_or_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a888e8c0c2053d796f168688ffb49a530"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a888e8c0c2053d796f168688ffb49a530.html#a888e8c0c2053d796f168688ffb49a530">log</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a888e8c0c2053d796f168688ffb49a530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural log of the specified variable (cmath).  <a href="namespacestan_1_1math_a888e8c0c2053d796f168688ffb49a530.html#a888e8c0c2053d796f168688ffb49a530">More...</a><br /></td></tr>
<tr class="separator:a888e8c0c2053d796f168688ffb49a530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15866009accafb3fd8850eae8394a45"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac15866009accafb3fd8850eae8394a45.html#ac15866009accafb3fd8850eae8394a45">log</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:ac15866009accafb3fd8850eae8394a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm (base e) of the specified complex argument.  <a href="namespacestan_1_1math_ac15866009accafb3fd8850eae8394a45.html#ac15866009accafb3fd8850eae8394a45">More...</a><br /></td></tr>
<tr class="separator:ac15866009accafb3fd8850eae8394a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61f3f2628ea6738053a585afd2b6204"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_or_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa61f3f2628ea6738053a585afd2b6204"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa61f3f2628ea6738053a585afd2b6204.html#aa61f3f2628ea6738053a585afd2b6204">log10</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:aa61f3f2628ea6738053a585afd2b6204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base 10 log of the specified variable (cmath).  <a href="namespacestan_1_1math_aa61f3f2628ea6738053a585afd2b6204.html#aa61f3f2628ea6738053a585afd2b6204">More...</a><br /></td></tr>
<tr class="separator:aa61f3f2628ea6738053a585afd2b6204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8edaf8d8efb0b0f345ac2ec903a718"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7c8edaf8d8efb0b0f345ac2ec903a718.html#a7c8edaf8d8efb0b0f345ac2ec903a718">log10</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a7c8edaf8d8efb0b0f345ac2ec903a718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base 10 logarithm of the specified complex number.  <a href="namespacestan_1_1math_a7c8edaf8d8efb0b0f345ac2ec903a718.html#a7c8edaf8d8efb0b0f345ac2ec903a718">More...</a><br /></td></tr>
<tr class="separator:a7c8edaf8d8efb0b0f345ac2ec903a718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5194f1e5ff8c670c7e1e844ab13d8d"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_or_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3b5194f1e5ff8c670c7e1e844ab13d8d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3b5194f1e5ff8c670c7e1e844ab13d8d.html#a3b5194f1e5ff8c670c7e1e844ab13d8d">log1m</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a3b5194f1e5ff8c670c7e1e844ab13d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log (1 - x) function for variables.  <a href="namespacestan_1_1math_a3b5194f1e5ff8c670c7e1e844ab13d8d.html#a3b5194f1e5ff8c670c7e1e844ab13d8d">More...</a><br /></td></tr>
<tr class="separator:a3b5194f1e5ff8c670c7e1e844ab13d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbca625898abc97dc88fd241af38cb0"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_or_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9cbca625898abc97dc88fd241af38cb0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9cbca625898abc97dc88fd241af38cb0.html#a9cbca625898abc97dc88fd241af38cb0">log1m_exp</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a9cbca625898abc97dc88fd241af38cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of 1 minus the exponential of the specified variable.  <a href="namespacestan_1_1math_a9cbca625898abc97dc88fd241af38cb0.html#a9cbca625898abc97dc88fd241af38cb0">More...</a><br /></td></tr>
<tr class="separator:a9cbca625898abc97dc88fd241af38cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295debc5e539aed7163cf533db1a8d43"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_or_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a295debc5e539aed7163cf533db1a8d43"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a295debc5e539aed7163cf533db1a8d43.html#a295debc5e539aed7163cf533db1a8d43">log1m_inv_logit</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;u)</td></tr>
<tr class="memdesc:a295debc5e539aed7163cf533db1a8d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one minus the inverse logit of the specified argument.  <a href="namespacestan_1_1math_a295debc5e539aed7163cf533db1a8d43.html#a295debc5e539aed7163cf533db1a8d43">More...</a><br /></td></tr>
<tr class="separator:a295debc5e539aed7163cf533db1a8d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7c978b9930017bde80a3871ce86107"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_or_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5e7c978b9930017bde80a3871ce86107"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5e7c978b9930017bde80a3871ce86107.html#a5e7c978b9930017bde80a3871ce86107">log1p</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a5e7c978b9930017bde80a3871ce86107"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log (1 + x) function for variables (C99).  <a href="namespacestan_1_1math_a5e7c978b9930017bde80a3871ce86107.html#a5e7c978b9930017bde80a3871ce86107">More...</a><br /></td></tr>
<tr class="separator:a5e7c978b9930017bde80a3871ce86107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef0ceb5289da23b3685612e5dedf344"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_or_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2ef0ceb5289da23b3685612e5dedf344"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2ef0ceb5289da23b3685612e5dedf344.html#a2ef0ceb5289da23b3685612e5dedf344">log1p_exp</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a2ef0ceb5289da23b3685612e5dedf344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of 1 plus the exponential of the specified variable.  <a href="namespacestan_1_1math_a2ef0ceb5289da23b3685612e5dedf344.html#a2ef0ceb5289da23b3685612e5dedf344">More...</a><br /></td></tr>
<tr class="separator:a2ef0ceb5289da23b3685612e5dedf344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaef1edcd42aa9bbe4f44b10a1f5af7c"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_or_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abaef1edcd42aa9bbe4f44b10a1f5af7c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abaef1edcd42aa9bbe4f44b10a1f5af7c.html#abaef1edcd42aa9bbe4f44b10a1f5af7c">log2</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:abaef1edcd42aa9bbe4f44b10a1f5af7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the base 2 logarithm of the specified variable (C99).  <a href="namespacestan_1_1math_abaef1edcd42aa9bbe4f44b10a1f5af7c.html#abaef1edcd42aa9bbe4f44b10a1f5af7c">More...</a><br /></td></tr>
<tr class="separator:abaef1edcd42aa9bbe4f44b10a1f5af7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0859b02976d1968af674a3f78c896f55"><td class="memTemplParams" colspan="2">template&lt;typename T , require_rev_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0859b02976d1968af674a3f78c896f55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0859b02976d1968af674a3f78c896f55.html#a0859b02976d1968af674a3f78c896f55">log_determinant</a> (const T &amp;m)</td></tr>
<tr class="separator:a0859b02976d1968af674a3f78c896f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84bc912cc5e160919fb792981e6ab2c"><td class="memTemplParams" colspan="2">template&lt;typename T , require_rev_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa84bc912cc5e160919fb792981e6ab2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa84bc912cc5e160919fb792981e6ab2c.html#aa84bc912cc5e160919fb792981e6ab2c">log_determinant_ldlt</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aa84bc912cc5e160919fb792981e6ab2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log det of the matrix whose LDLT factorization is given.  <a href="namespacestan_1_1math_aa84bc912cc5e160919fb792981e6ab2c.html#aa84bc912cc5e160919fb792981e6ab2c">More...</a><br /></td></tr>
<tr class="separator:aa84bc912cc5e160919fb792981e6ab2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee476f54e790c60b71d36f2831fa3cb"><td class="memTemplParams" colspan="2">template&lt;typename T , require_rev_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaee476f54e790c60b71d36f2831fa3cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaee476f54e790c60b71d36f2831fa3cb.html#aaee476f54e790c60b71d36f2831fa3cb">log_determinant_spd</a> (const T &amp;M)</td></tr>
<tr class="memdesc:aaee476f54e790c60b71d36f2831fa3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log det of a symmetric, positive-definite matrix.  <a href="namespacestan_1_1math_aaee476f54e790c60b71d36f2831fa3cb.html#aaee476f54e790c60b71d36f2831fa3cb">More...</a><br /></td></tr>
<tr class="separator:aaee476f54e790c60b71d36f2831fa3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6916bb5af6f1aa7ff76fa85f7605fa4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6916bb5af6f1aa7ff76fa85f7605fa4f.html#a6916bb5af6f1aa7ff76fa85f7605fa4f">log_diff_exp</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a6916bb5af6f1aa7ff76fa85f7605fa4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log difference of the exponentiated arguments.  <a href="namespacestan_1_1math_a6916bb5af6f1aa7ff76fa85f7605fa4f.html#a6916bb5af6f1aa7ff76fa85f7605fa4f">More...</a><br /></td></tr>
<tr class="separator:a6916bb5af6f1aa7ff76fa85f7605fa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c386d9b793f1fec1512c0892208a90b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c386d9b793f1fec1512c0892208a90b.html#a1c386d9b793f1fec1512c0892208a90b">log_diff_exp</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:a1c386d9b793f1fec1512c0892208a90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log difference of the exponentiated arguments.  <a href="namespacestan_1_1math_a1c386d9b793f1fec1512c0892208a90b.html#a1c386d9b793f1fec1512c0892208a90b">More...</a><br /></td></tr>
<tr class="separator:a1c386d9b793f1fec1512c0892208a90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4424b6514fe72fed6b9c768df3ad8a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab4424b6514fe72fed6b9c768df3ad8a5.html#ab4424b6514fe72fed6b9c768df3ad8a5">log_diff_exp</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:ab4424b6514fe72fed6b9c768df3ad8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log difference of the exponentiated arguments.  <a href="namespacestan_1_1math_ab4424b6514fe72fed6b9c768df3ad8a5.html#ab4424b6514fe72fed6b9c768df3ad8a5">More...</a><br /></td></tr>
<tr class="separator:ab4424b6514fe72fed6b9c768df3ad8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b3417777ab6e39a1a3a0f092ed8f6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab6b3417777ab6e39a1a3a0f092ed8f6a.html#ab6b3417777ab6e39a1a3a0f092ed8f6a">log_falling_factorial</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="separator:ab6b3417777ab6e39a1a3a0f092ed8f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6fbe2cf74d7dc89d10999d512c3efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1a6fbe2cf74d7dc89d10999d512c3efd.html#a1a6fbe2cf74d7dc89d10999d512c3efd">log_falling_factorial</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:a1a6fbe2cf74d7dc89d10999d512c3efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cf25da5e04a8c887c3d64cf0f3fa78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a31cf25da5e04a8c887c3d64cf0f3fa78.html#a31cf25da5e04a8c887c3d64cf0f3fa78">log_falling_factorial</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:a31cf25da5e04a8c887c3d64cf0f3fa78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b4da983ec6966e6065a6c07de77076"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae0b4da983ec6966e6065a6c07de77076.html#ae0b4da983ec6966e6065a6c07de77076">log_inv_logit</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;u)</td></tr>
<tr class="memdesc:ae0b4da983ec6966e6065a6c07de77076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the inverse logit of the specified argument.  <a href="namespacestan_1_1math_ae0b4da983ec6966e6065a6c07de77076.html#ae0b4da983ec6966e6065a6c07de77076">More...</a><br /></td></tr>
<tr class="separator:ae0b4da983ec6966e6065a6c07de77076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3145fc95d006f95b88b7075e48e0012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab3145fc95d006f95b88b7075e48e0012.html#ab3145fc95d006f95b88b7075e48e0012">log_inv_logit_diff</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="separator:ab3145fc95d006f95b88b7075e48e0012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce0d0a18ea1b0b7eccb5d8903f8238a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adce0d0a18ea1b0b7eccb5d8903f8238a.html#adce0d0a18ea1b0b7eccb5d8903f8238a">log_inv_logit_diff</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:adce0d0a18ea1b0b7eccb5d8903f8238a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefc6cdabf27fe0bf9899d1944b78efa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeefc6cdabf27fe0bf9899d1944b78efa.html#aeefc6cdabf27fe0bf9899d1944b78efa">log_inv_logit_diff</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:aeefc6cdabf27fe0bf9899d1944b78efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225cdbe3feeeaad5db32221e76308b97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a225cdbe3feeeaad5db32221e76308b97.html#a225cdbe3feeeaad5db32221e76308b97">log_mix_partial_helper</a> (double theta_val, double lambda1_val, double lambda2_val, double &amp;one_m_exp_lam2_m_lam1, double &amp;one_m_t_prod_exp_lam2_m_lam1, double &amp;one_d_t_plus_one_m_t_prod_exp_lam2_m_lam1)</td></tr>
<tr class="separator:a225cdbe3feeeaad5db32221e76308b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97e11b9e814d20fdd0ebc257f54a62b"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , typename T_lambda1 , typename T_lambda2 , require_any_var_t&lt; T_theta, T_lambda1, T_lambda2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af97e11b9e814d20fdd0ebc257f54a62b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta, T_lambda1, T_lambda2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af97e11b9e814d20fdd0ebc257f54a62b.html#af97e11b9e814d20fdd0ebc257f54a62b">log_mix</a> (const T_theta &amp;theta, const T_lambda1 &amp;lambda1, const T_lambda2 &amp;lambda2)</td></tr>
<tr class="memdesc:af97e11b9e814d20fdd0ebc257f54a62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log mixture density with specified mixing proportion and log densities and its derivative at each.  <a href="namespacestan_1_1math_af97e11b9e814d20fdd0ebc257f54a62b.html#af97e11b9e814d20fdd0ebc257f54a62b">More...</a><br /></td></tr>
<tr class="separator:af97e11b9e814d20fdd0ebc257f54a62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa081fd14b225407c25d4e449c6f5669c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa081fd14b225407c25d4e449c6f5669c.html#aa081fd14b225407c25d4e449c6f5669c">log_rising_factorial</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="separator:aa081fd14b225407c25d4e449c6f5669c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ff05bb4af6475162c98f06f5ccd186"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a57ff05bb4af6475162c98f06f5ccd186.html#a57ff05bb4af6475162c98f06f5ccd186">log_rising_factorial</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:a57ff05bb4af6475162c98f06f5ccd186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad383a9d188278c83646bc396a7b61667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad383a9d188278c83646bc396a7b61667.html#ad383a9d188278c83646bc396a7b61667">log_rising_factorial</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:ad383a9d188278c83646bc396a7b61667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace802519de7ab3825f5c25a206f0ce90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ace802519de7ab3825f5c25a206f0ce90.html#ace802519de7ab3825f5c25a206f0ce90">log_sum_exp</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:ace802519de7ab3825f5c25a206f0ce90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials.  <a href="namespacestan_1_1math_ace802519de7ab3825f5c25a206f0ce90.html#ace802519de7ab3825f5c25a206f0ce90">More...</a><br /></td></tr>
<tr class="separator:ace802519de7ab3825f5c25a206f0ce90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411ba67a946581565fcf6e7b69792150"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a411ba67a946581565fcf6e7b69792150.html#a411ba67a946581565fcf6e7b69792150">log_sum_exp</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:a411ba67a946581565fcf6e7b69792150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials.  <a href="namespacestan_1_1math_a411ba67a946581565fcf6e7b69792150.html#a411ba67a946581565fcf6e7b69792150">More...</a><br /></td></tr>
<tr class="separator:a411ba67a946581565fcf6e7b69792150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8fa3248ed5b8d83ad12676bec8c91f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c8fa3248ed5b8d83ad12676bec8c91f.html#a1c8fa3248ed5b8d83ad12676bec8c91f">log_sum_exp</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a1c8fa3248ed5b8d83ad12676bec8c91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials.  <a href="namespacestan_1_1math_a1c8fa3248ed5b8d83ad12676bec8c91f.html#a1c8fa3248ed5b8d83ad12676bec8c91f">More...</a><br /></td></tr>
<tr class="separator:a1c8fa3248ed5b8d83ad12676bec8c91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae39ae6449b70b2437c9a55501bd865"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_st&lt; is_var, T &gt; *  = nullptr, require_not_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7ae39ae6449b70b2437c9a55501bd865"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7ae39ae6449b70b2437c9a55501bd865.html#a7ae39ae6449b70b2437c9a55501bd865">log_sum_exp</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a7ae39ae6449b70b2437c9a55501bd865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials of the input.  <a href="namespacestan_1_1math_a7ae39ae6449b70b2437c9a55501bd865.html#a7ae39ae6449b70b2437c9a55501bd865">More...</a><br /></td></tr>
<tr class="separator:a7ae39ae6449b70b2437c9a55501bd865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb7aed98e9802cf82ffbf130e684545"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6bb7aed98e9802cf82ffbf130e684545"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6bb7aed98e9802cf82ffbf130e684545.html#a6bb7aed98e9802cf82ffbf130e684545">log_sum_exp</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a6bb7aed98e9802cf82ffbf130e684545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials of the input.  <a href="namespacestan_1_1math_a6bb7aed98e9802cf82ffbf130e684545.html#a6bb7aed98e9802cf82ffbf130e684545">More...</a><br /></td></tr>
<tr class="separator:a6bb7aed98e9802cf82ffbf130e684545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99df157eadf939eff9ad6cfed7166be"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_or_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae99df157eadf939eff9ad6cfed7166be"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae99df157eadf939eff9ad6cfed7166be.html#ae99df157eadf939eff9ad6cfed7166be">logit</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;u)</td></tr>
<tr class="memdesc:ae99df157eadf939eff9ad6cfed7166be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log odds of the specified argument.  <a href="namespacestan_1_1math_ae99df157eadf939eff9ad6cfed7166be.html#ae99df157eadf939eff9ad6cfed7166be">More...</a><br /></td></tr>
<tr class="separator:ae99df157eadf939eff9ad6cfed7166be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef92526a833d39b00155cc14227b96d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , require_all_matrix_t&lt; T, L &gt; *  = nullptr, require_stan_scalar_t&lt; U &gt; *  = nullptr, require_var_t&lt; return_type_t&lt; T, L, U &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acef92526a833d39b00155cc14227b96d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acef92526a833d39b00155cc14227b96d.html#acef92526a833d39b00155cc14227b96d">lub_constrain</a> (const T &amp;x, const L &amp;lb, const U &amp;ub, std::decay_t&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt;&gt; &amp;lp)</td></tr>
<tr class="memdesc:acef92526a833d39b00155cc14227b96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <a class="el" href="namespace_eigen.html">Eigen</a> matrix with matrix lower bound and scalar upper bound plus lp.  <a href="namespacestan_1_1math_acef92526a833d39b00155cc14227b96d.html#acef92526a833d39b00155cc14227b96d">More...</a><br /></td></tr>
<tr class="separator:acef92526a833d39b00155cc14227b96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82940e44aa50a642c65918d7f96fd43a"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , require_all_eigen_t&lt; Ta, Tb &gt; *  = nullptr, require_any_st_autodiff&lt; Ta, Tb &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a82940e44aa50a642c65918d7f96fd43a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Ta, Tb &gt;, -1, Tb::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a82940e44aa50a642c65918d7f96fd43a.html#a82940e44aa50a642c65918d7f96fd43a">matrix_exp_multiply</a> (const Ta &amp;A, const Tb &amp;B)</td></tr>
<tr class="memdesc:a82940e44aa50a642c65918d7f96fd43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper of matrix_exp_action function for a more literal name.  <a href="namespacestan_1_1math_a82940e44aa50a642c65918d7f96fd43a.html#a82940e44aa50a642c65918d7f96fd43a">More...</a><br /></td></tr>
<tr class="separator:a82940e44aa50a642c65918d7f96fd43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852cc764f2196a8b943e4fd1d58aedcd"><td class="memTemplParams" colspan="2">template&lt;typename T , require_rev_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a852cc764f2196a8b943e4fd1d58aedcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a852cc764f2196a8b943e4fd1d58aedcd.html#a852cc764f2196a8b943e4fd1d58aedcd">matrix_power</a> (const T &amp;M, const int n)</td></tr>
<tr class="memdesc:a852cc764f2196a8b943e4fd1d58aedcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth power of the specific matrix.  <a href="namespacestan_1_1math_a852cc764f2196a8b943e4fd1d58aedcd.html#a852cc764f2196a8b943e4fd1d58aedcd">More...</a><br /></td></tr>
<tr class="separator:a852cc764f2196a8b943e4fd1d58aedcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8181dae88ac0081edbd88cc23b77d3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_matrix_t&lt; T1, T2 &gt; *  = nullptr, require_any_st_var&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4a8181dae88ac0081edbd88cc23b77d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a8181dae88ac0081edbd88cc23b77d3.html#a4a8181dae88ac0081edbd88cc23b77d3">mdivide_left</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:a4a8181dae88ac0081edbd88cc23b77d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution <code>X</code> of <code>AX = B</code>.  <a href="namespacestan_1_1math_a4a8181dae88ac0081edbd88cc23b77d3.html#a4a8181dae88ac0081edbd88cc23b77d3">More...</a><br /></td></tr>
<tr class="separator:a4a8181dae88ac0081edbd88cc23b77d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed89b2ce5e47d085f52db7438f43300"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_matrix_t&lt; T1, T2 &gt; *  = nullptr, require_any_st_var&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abed89b2ce5e47d085f52db7438f43300"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abed89b2ce5e47d085f52db7438f43300.html#abed89b2ce5e47d085f52db7438f43300">mdivide_left_ldlt</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T1 &gt; &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:abed89b2ce5e47d085f52db7438f43300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> of A.  <a href="namespacestan_1_1math_abed89b2ce5e47d085f52db7438f43300.html#abed89b2ce5e47d085f52db7438f43300">More...</a><br /></td></tr>
<tr class="separator:abed89b2ce5e47d085f52db7438f43300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba72e861a9b4058f6444f3089349102"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_eigen_matrix_base_vt&lt; is_var, EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7ba72e861a9b4058f6444f3089349102"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7ba72e861a9b4058f6444f3089349102.html#a7ba72e861a9b4058f6444f3089349102">mdivide_left_spd</a> (const EigMat1 &amp;A, const EigMat2 &amp;b)</td></tr>
<tr class="separator:a7ba72e861a9b4058f6444f3089349102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903d1a68bcba2cd689405f1ce28de093"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_eigen_matrix_base_vt&lt; is_var, EigMat1 &gt; *  = nullptr, require_eigen_matrix_base_vt&lt; std::is_arithmetic, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a903d1a68bcba2cd689405f1ce28de093"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a903d1a68bcba2cd689405f1ce28de093.html#a903d1a68bcba2cd689405f1ce28de093">mdivide_left_spd</a> (const EigMat1 &amp;A, const EigMat2 &amp;b)</td></tr>
<tr class="separator:a903d1a68bcba2cd689405f1ce28de093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb3e0bbefb4bbfc18dbb320c80dab71"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_matrix_t&lt; T1, T2 &gt; *  = nullptr, require_any_var_matrix_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abeb3e0bbefb4bbfc18dbb320c80dab71"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abeb3e0bbefb4bbfc18dbb320c80dab71.html#abeb3e0bbefb4bbfc18dbb320c80dab71">mdivide_left_spd</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:abeb3e0bbefb4bbfc18dbb320c80dab71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=B where A is symmetric positive definite.  <a href="namespacestan_1_1math_abeb3e0bbefb4bbfc18dbb320c80dab71.html#abeb3e0bbefb4bbfc18dbb320c80dab71">More...</a><br /></td></tr>
<tr class="separator:abeb3e0bbefb4bbfc18dbb320c80dab71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69def4096df9bff4ceab4c9465e7d250"><td class="memTemplParams" colspan="2">template&lt;Eigen::UpLoType TriView, typename T1 , typename T2 , require_all_eigen_vt&lt; is_var, T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a69def4096df9bff4ceab4c9465e7d250"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a69def4096df9bff4ceab4c9465e7d250.html#a69def4096df9bff4ceab4c9465e7d250">mdivide_left_tri</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="separator:a69def4096df9bff4ceab4c9465e7d250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b0904ff1c7a95f87d86491bbededfd"><td class="memTemplParams" colspan="2">template&lt;Eigen::UpLoType TriView, typename T1 , typename T2 , require_eigen_vt&lt; std::is_arithmetic, T1 &gt; *  = nullptr, require_eigen_vt&lt; is_var, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a24b0904ff1c7a95f87d86491bbededfd"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a24b0904ff1c7a95f87d86491bbededfd.html#a24b0904ff1c7a95f87d86491bbededfd">mdivide_left_tri</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="separator:a24b0904ff1c7a95f87d86491bbededfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f43d5e5c20cfda034659ed6d7998085"><td class="memTemplParams" colspan="2">template&lt;Eigen::UpLoType TriView, typename T1 , typename T2 , require_all_matrix_t&lt; T1, T2 &gt; *  = nullptr, require_any_var_matrix_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3f43d5e5c20cfda034659ed6d7998085"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3f43d5e5c20cfda034659ed6d7998085.html#a3f43d5e5c20cfda034659ed6d7998085">mdivide_left_tri</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:a3f43d5e5c20cfda034659ed6d7998085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=B when A is triangular.  <a href="namespacestan_1_1math_a3f43d5e5c20cfda034659ed6d7998085.html#a3f43d5e5c20cfda034659ed6d7998085">More...</a><br /></td></tr>
<tr class="separator:a3f43d5e5c20cfda034659ed6d7998085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1f488a4e237404d4c19238ee0095f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acb1f488a4e237404d4c19238ee0095f0.html#acb1f488a4e237404d4c19238ee0095f0">modified_bessel_first_kind</a> (int v, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="separator:acb1f488a4e237404d4c19238ee0095f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635aeb34fe4c2f0feb6f6de54a4b1c98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a635aeb34fe4c2f0feb6f6de54a4b1c98.html#a635aeb34fe4c2f0feb6f6de54a4b1c98">modified_bessel_second_kind</a> (int v, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="separator:a635aeb34fe4c2f0feb6f6de54a4b1c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7061a9c697c18e3a85737f37eb5d94c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_matrix_t&lt; T1, T2 &gt; *  = nullptr, require_return_type_t&lt; is_var, T1, T2 &gt; *  = nullptr, require_row_and_col_vector_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa7061a9c697c18e3a85737f37eb5d94c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa7061a9c697c18e3a85737f37eb5d94c.html#aa7061a9c697c18e3a85737f37eb5d94c">multiply</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:aa7061a9c697c18e3a85737f37eb5d94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of a row vector times a column vector as a scalar.  <a href="namespacestan_1_1math_aa7061a9c697c18e3a85737f37eb5d94c.html#aa7061a9c697c18e3a85737f37eb5d94c">More...</a><br /></td></tr>
<tr class="separator:aa7061a9c697c18e3a85737f37eb5d94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad762971ed82e286b6519d07dc85dee7e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_not_matrix_t&lt; T1 &gt; *  = nullptr, require_matrix_t&lt; T2 &gt; *  = nullptr, require_return_type_t&lt; is_var, T1, T2 &gt; *  = nullptr, require_not_row_and_col_vector_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad762971ed82e286b6519d07dc85dee7e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad762971ed82e286b6519d07dc85dee7e.html#ad762971ed82e286b6519d07dc85dee7e">multiply</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:ad762971ed82e286b6519d07dc85dee7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified matrix multiplied by specified scalar where at least one input has a scalar type of a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code>.  <a href="namespacestan_1_1math_ad762971ed82e286b6519d07dc85dee7e.html#ad762971ed82e286b6519d07dc85dee7e">More...</a><br /></td></tr>
<tr class="separator:ad762971ed82e286b6519d07dc85dee7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f269e2d0127d7483641283c9d85c8a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_matrix_t&lt; T1 &gt; *  = nullptr, require_not_matrix_t&lt; T2 &gt; *  = nullptr, require_any_st_var&lt; T1, T2 &gt; *  = nullptr, require_not_complex_t&lt; value_type_t&lt; T1 &gt;&gt; *  = nullptr, require_not_complex_t&lt; value_type_t&lt; T2 &gt;&gt; *  = nullptr, require_not_row_and_col_vector_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa3f269e2d0127d7483641283c9d85c8a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa3f269e2d0127d7483641283c9d85c8a.html#aa3f269e2d0127d7483641283c9d85c8a">multiply</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:aa3f269e2d0127d7483641283c9d85c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified matrix multiplied by specified scalar where at least one input has a scalar type of a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code>.  <a href="namespacestan_1_1math_aa3f269e2d0127d7483641283c9d85c8a.html#aa3f269e2d0127d7483641283c9d85c8a">More...</a><br /></td></tr>
<tr class="separator:aa3f269e2d0127d7483641283c9d85c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d01cbac5e3e2abec8eb42654df3241a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_any_var_matrix_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4d01cbac5e3e2abec8eb42654df3241a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4d01cbac5e3e2abec8eb42654df3241a.html#a4d01cbac5e3e2abec8eb42654df3241a">operator*</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a4d01cbac5e3e2abec8eb42654df3241a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for multiplying a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Matrix&gt;</code>.  <a href="namespacestan_1_1math_a4d01cbac5e3e2abec8eb42654df3241a.html#a4d01cbac5e3e2abec8eb42654df3241a">More...</a><br /></td></tr>
<tr class="separator:a4d01cbac5e3e2abec8eb42654df3241a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da7e77b75bf5f288ddc7c546f941c70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3da7e77b75bf5f288ddc7c546f941c70.html#a3da7e77b75bf5f288ddc7c546f941c70">multiply_log</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a3da7e77b75bf5f288ddc7c546f941c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a*log(b).  <a href="namespacestan_1_1math_a3da7e77b75bf5f288ddc7c546f941c70.html#a3da7e77b75bf5f288ddc7c546f941c70">More...</a><br /></td></tr>
<tr class="separator:a3da7e77b75bf5f288ddc7c546f941c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad003d3402294c4b06e2e7ec4ed8b117b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad003d3402294c4b06e2e7ec4ed8b117b.html#ad003d3402294c4b06e2e7ec4ed8b117b">multiply_log</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:ad003d3402294c4b06e2e7ec4ed8b117b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a*log(b).  <a href="namespacestan_1_1math_ad003d3402294c4b06e2e7ec4ed8b117b.html#ad003d3402294c4b06e2e7ec4ed8b117b">More...</a><br /></td></tr>
<tr class="separator:ad003d3402294c4b06e2e7ec4ed8b117b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b018469138223a1ffb1bb533855a00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a78b018469138223a1ffb1bb533855a00.html#a78b018469138223a1ffb1bb533855a00">multiply_log</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a78b018469138223a1ffb1bb533855a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a*log(b).  <a href="namespacestan_1_1math_a78b018469138223a1ffb1bb533855a00.html#a78b018469138223a1ffb1bb533855a00">More...</a><br /></td></tr>
<tr class="separator:a78b018469138223a1ffb1bb533855a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238fefb3948c85a4a691440f4259d7b1"><td class="memTemplParams" colspan="2">template&lt;typename T , require_rev_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a238fefb3948c85a4a691440f4259d7b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a238fefb3948c85a4a691440f4259d7b1.html#a238fefb3948c85a4a691440f4259d7b1">multiply_lower_tri_self_transpose</a> (const T &amp;L)</td></tr>
<tr class="separator:a238fefb3948c85a4a691440f4259d7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c041fd900c60e610c9beba69630bd3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4c041fd900c60e610c9beba69630bd3a.html#a4c041fd900c60e610c9beba69630bd3a">norm</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a4c041fd900c60e610c9beba69630bd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the squared magnitude of the complex argument.  <a href="namespacestan_1_1math_a4c041fd900c60e610c9beba69630bd3a.html#a4c041fd900c60e610c9beba69630bd3a">More...</a><br /></td></tr>
<tr class="separator:a4c041fd900c60e610c9beba69630bd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed9eb3c5608e15f33d215208646b734"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vector_vt&lt; is_var, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9ed9eb3c5608e15f33d215208646b734"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ed9eb3c5608e15f33d215208646b734.html#a9ed9eb3c5608e15f33d215208646b734">norm1</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a9ed9eb3c5608e15f33d215208646b734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the L1 norm of a vector of var.  <a href="namespacestan_1_1math_a9ed9eb3c5608e15f33d215208646b734.html#a9ed9eb3c5608e15f33d215208646b734">More...</a><br /></td></tr>
<tr class="separator:a9ed9eb3c5608e15f33d215208646b734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec92d584fff400826bdd7f10180db4fb"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vector_vt&lt; is_var, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aec92d584fff400826bdd7f10180db4fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aec92d584fff400826bdd7f10180db4fb.html#aec92d584fff400826bdd7f10180db4fb">norm2</a> (const T &amp;v)</td></tr>
<tr class="memdesc:aec92d584fff400826bdd7f10180db4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the L2 norm of a vector of var.  <a href="namespacestan_1_1math_aec92d584fff400826bdd7f10180db4fb.html#aec92d584fff400826bdd7f10180db4fb">More...</a><br /></td></tr>
<tr class="separator:aec92d584fff400826bdd7f10180db4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051fc17b0e31fdde842ee2c056f8149a"><td class="memTemplParams" colspan="2">template&lt;typename T , require_rev_col_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a051fc17b0e31fdde842ee2c056f8149a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a051fc17b0e31fdde842ee2c056f8149a.html#a051fc17b0e31fdde842ee2c056f8149a">ordered_constrain</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a051fc17b0e31fdde842ee2c056f8149a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an increasing ordered vector derived from the specified free vector.  <a href="namespacestan_1_1math_a051fc17b0e31fdde842ee2c056f8149a.html#a051fc17b0e31fdde842ee2c056f8149a">More...</a><br /></td></tr>
<tr class="separator:a051fc17b0e31fdde842ee2c056f8149a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b35cca48ebf9684d3e126fa84602a6"><td class="memTemplParams" colspan="2">template&lt;typename VarVec , require_var_col_vector_t&lt; VarVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a11b35cca48ebf9684d3e126fa84602a6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a11b35cca48ebf9684d3e126fa84602a6.html#a11b35cca48ebf9684d3e126fa84602a6">ordered_constrain</a> (const VarVec &amp;x, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; VarVec &gt; &amp;lp)</td></tr>
<tr class="memdesc:a11b35cca48ebf9684d3e126fa84602a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a positive valued, increasing ordered vector derived from the specified free vector and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <a href="namespacestan_1_1math_a11b35cca48ebf9684d3e126fa84602a6.html#a11b35cca48ebf9684d3e126fa84602a6">More...</a><br /></td></tr>
<tr class="separator:a11b35cca48ebf9684d3e126fa84602a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce972c51c4f103eedca6e7a0920dc72"><td class="memTemplParams" colspan="2">template&lt;typename Var1 , typename Var2 , require_all_st_var&lt; Var1, Var2 &gt; *  = nullptr, require_all_not_std_vector_t&lt; Var1, Var2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8ce972c51c4f103eedca6e7a0920dc72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8ce972c51c4f103eedca6e7a0920dc72.html#a8ce972c51c4f103eedca6e7a0920dc72">owens_t</a> (const Var1 &amp;h, const Var2 &amp;a)</td></tr>
<tr class="memdesc:a8ce972c51c4f103eedca6e7a0920dc72"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Owen's T function of h and a.  <a href="namespacestan_1_1math_a8ce972c51c4f103eedca6e7a0920dc72.html#a8ce972c51c4f103eedca6e7a0920dc72">More...</a><br /></td></tr>
<tr class="separator:a8ce972c51c4f103eedca6e7a0920dc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bb56fce707d5e370839fc056d83eb6"><td class="memTemplParams" colspan="2">template&lt;typename Var , typename Arith , require_st_arithmetic&lt; Arith &gt; *  = nullptr, require_all_not_std_vector_t&lt; Var, Arith &gt; *  = nullptr, require_st_var&lt; Var &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab0bb56fce707d5e370839fc056d83eb6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab0bb56fce707d5e370839fc056d83eb6.html#ab0bb56fce707d5e370839fc056d83eb6">owens_t</a> (const Var &amp;h, const Arith &amp;a)</td></tr>
<tr class="memdesc:ab0bb56fce707d5e370839fc056d83eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Owen's T function of h and a.  <a href="namespacestan_1_1math_ab0bb56fce707d5e370839fc056d83eb6.html#ab0bb56fce707d5e370839fc056d83eb6">More...</a><br /></td></tr>
<tr class="separator:ab0bb56fce707d5e370839fc056d83eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb8be1f60a252a12ff25e4114c9c1a0"><td class="memTemplParams" colspan="2">template&lt;typename Arith , typename Var , require_st_arithmetic&lt; Arith &gt; *  = nullptr, require_all_not_std_vector_t&lt; Var, Arith &gt; *  = nullptr, require_st_var&lt; Var &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5fb8be1f60a252a12ff25e4114c9c1a0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5fb8be1f60a252a12ff25e4114c9c1a0.html#a5fb8be1f60a252a12ff25e4114c9c1a0">owens_t</a> (const Arith &amp;h, const Var &amp;a)</td></tr>
<tr class="memdesc:a5fb8be1f60a252a12ff25e4114c9c1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Owen's T function of h and a.  <a href="namespacestan_1_1math_a5fb8be1f60a252a12ff25e4114c9c1a0.html#a5fb8be1f60a252a12ff25e4114c9c1a0">More...</a><br /></td></tr>
<tr class="separator:a5fb8be1f60a252a12ff25e4114c9c1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdc45f7a61effed182f9339318a44b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8cdc45f7a61effed182f9339318a44b8.html#a8cdc45f7a61effed182f9339318a44b8">Phi</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a8cdc45f7a61effed182f9339318a44b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unit normal cumulative density function for variables (stan).  <a href="namespacestan_1_1math_a8cdc45f7a61effed182f9339318a44b8.html#a8cdc45f7a61effed182f9339318a44b8">More...</a><br /></td></tr>
<tr class="separator:a8cdc45f7a61effed182f9339318a44b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0888540b70220ffd69e0a249a1625f88"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0888540b70220ffd69e0a249a1625f88"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0888540b70220ffd69e0a249a1625f88.html#a0888540b70220ffd69e0a249a1625f88">Phi</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a0888540b70220ffd69e0a249a1625f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise unit normal cumulative density function for varmat types.  <a href="namespacestan_1_1math_a0888540b70220ffd69e0a249a1625f88.html#a0888540b70220ffd69e0a249a1625f88">More...</a><br /></td></tr>
<tr class="separator:a0888540b70220ffd69e0a249a1625f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a33b2b613aa294e78d92704f9b23db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a62a33b2b613aa294e78d92704f9b23db.html#a62a33b2b613aa294e78d92704f9b23db">Phi_approx</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a62a33b2b613aa294e78d92704f9b23db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximation of the unit normal CDF for variables (stan).  <a href="namespacestan_1_1math_a62a33b2b613aa294e78d92704f9b23db.html#a62a33b2b613aa294e78d92704f9b23db">More...</a><br /></td></tr>
<tr class="separator:a62a33b2b613aa294e78d92704f9b23db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6681fe46a4c8fae11d60dd80e850d4eb"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6681fe46a4c8fae11d60dd80e850d4eb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6681fe46a4c8fae11d60dd80e850d4eb.html#a6681fe46a4c8fae11d60dd80e850d4eb">Phi_approx</a> (const T &amp;a)</td></tr>
<tr class="separator:a6681fe46a4c8fae11d60dd80e850d4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa5912ebe994aa397a1dce55b15e261"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3aa5912ebe994aa397a1dce55b15e261.html#a3aa5912ebe994aa397a1dce55b15e261">polar</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;r, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;theta)</td></tr>
<tr class="memdesc:a3aa5912ebe994aa397a1dce55b15e261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns complex number with specified magnitude and phase angle.  <a href="namespacestan_1_1math_a3aa5912ebe994aa397a1dce55b15e261.html#a3aa5912ebe994aa397a1dce55b15e261">More...</a><br /></td></tr>
<tr class="separator:a3aa5912ebe994aa397a1dce55b15e261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb316eae071001ab3e9f6f4358121583"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb316eae071001ab3e9f6f4358121583"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acb316eae071001ab3e9f6f4358121583.html#acb316eae071001ab3e9f6f4358121583">polar</a> (T r, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;theta)</td></tr>
<tr class="memdesc:acb316eae071001ab3e9f6f4358121583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns complex number with specified magnitude and phase angle.  <a href="namespacestan_1_1math_acb316eae071001ab3e9f6f4358121583.html#acb316eae071001ab3e9f6f4358121583">More...</a><br /></td></tr>
<tr class="separator:acb316eae071001ab3e9f6f4358121583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc48f722bf24cdc9edd08ffc8d60313"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abcc48f722bf24cdc9edd08ffc8d60313"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abcc48f722bf24cdc9edd08ffc8d60313.html#abcc48f722bf24cdc9edd08ffc8d60313">polar</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;r, T theta)</td></tr>
<tr class="memdesc:abcc48f722bf24cdc9edd08ffc8d60313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns complex number with specified magnitude and phase angle.  <a href="namespacestan_1_1math_abcc48f722bf24cdc9edd08ffc8d60313.html#abcc48f722bf24cdc9edd08ffc8d60313">More...</a><br /></td></tr>
<tr class="separator:abcc48f722bf24cdc9edd08ffc8d60313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c97664c9ab35e0eef1744986efacde8"><td class="memTemplParams" colspan="2">template&lt;typename T , require_rev_col_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8c97664c9ab35e0eef1744986efacde8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8c97664c9ab35e0eef1744986efacde8.html#a8c97664c9ab35e0eef1744986efacde8">positive_ordered_constrain</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a8c97664c9ab35e0eef1744986efacde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an increasing positive ordered vector derived from the specified free vector.  <a href="namespacestan_1_1math_a8c97664c9ab35e0eef1744986efacde8.html#a8c97664c9ab35e0eef1744986efacde8">More...</a><br /></td></tr>
<tr class="separator:a8c97664c9ab35e0eef1744986efacde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215acc171cf8c9b80a5ae7b7b8ab25db"><td class="memTemplParams" colspan="2">template&lt;typename Scal1 , typename Scal2 , require_any_st_var&lt; Scal1, Scal2 &gt; *  = nullptr, require_all_stan_scalar_t&lt; Scal1, Scal2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a215acc171cf8c9b80a5ae7b7b8ab25db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a215acc171cf8c9b80a5ae7b7b8ab25db.html#a215acc171cf8c9b80a5ae7b7b8ab25db">pow</a> (const Scal1 &amp;base, const Scal2 &amp;exponent)</td></tr>
<tr class="memdesc:a215acc171cf8c9b80a5ae7b7b8ab25db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base raised to the power of the exponent (cmath).  <a href="namespacestan_1_1math_a215acc171cf8c9b80a5ae7b7b8ab25db.html#a215acc171cf8c9b80a5ae7b7b8ab25db">More...</a><br /></td></tr>
<tr class="separator:a215acc171cf8c9b80a5ae7b7b8ab25db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157195dd19270eb1233a50d5412ef439"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , require_all_st_var_or_arithmetic&lt; Mat1, Mat2 &gt; *  = nullptr, require_any_matrix_st&lt; is_var, Mat1, Mat2 &gt; *  = nullptr, require_all_not_stan_scalar_t&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a157195dd19270eb1233a50d5412ef439"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a157195dd19270eb1233a50d5412ef439.html#a157195dd19270eb1233a50d5412ef439">pow</a> (const Mat1 &amp;base, const Mat2 &amp;exponent)</td></tr>
<tr class="memdesc:a157195dd19270eb1233a50d5412ef439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base raised to the power of the exponent (cmath).  <a href="namespacestan_1_1math_a157195dd19270eb1233a50d5412ef439.html#a157195dd19270eb1233a50d5412ef439">More...</a><br /></td></tr>
<tr class="separator:a157195dd19270eb1233a50d5412ef439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5f02cbf4087632e65c55ef4aa01ba8"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Scal1 , require_all_st_var_or_arithmetic&lt; Mat1, Scal1 &gt; *  = nullptr, require_all_matrix_st&lt; is_var, Mat1 &gt; *  = nullptr, require_stan_scalar_t&lt; Scal1 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9e5f02cbf4087632e65c55ef4aa01ba8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9e5f02cbf4087632e65c55ef4aa01ba8.html#a9e5f02cbf4087632e65c55ef4aa01ba8">pow</a> (const Mat1 &amp;base, const Scal1 &amp;exponent)</td></tr>
<tr class="memdesc:a9e5f02cbf4087632e65c55ef4aa01ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base raised to the power of the exponent (cmath).  <a href="namespacestan_1_1math_a9e5f02cbf4087632e65c55ef4aa01ba8.html#a9e5f02cbf4087632e65c55ef4aa01ba8">More...</a><br /></td></tr>
<tr class="separator:a9e5f02cbf4087632e65c55ef4aa01ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10658674cb2b0da30f637561df9b9594"><td class="memTemplParams" colspan="2">template&lt;typename Scal1 , typename Mat1 , require_all_st_var_or_arithmetic&lt; Scal1, Mat1 &gt; *  = nullptr, require_stan_scalar_t&lt; Scal1 &gt; *  = nullptr, require_all_matrix_st&lt; is_var, Mat1 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a10658674cb2b0da30f637561df9b9594"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a10658674cb2b0da30f637561df9b9594.html#a10658674cb2b0da30f637561df9b9594">pow</a> (Scal1 base, const Mat1 &amp;exponent)</td></tr>
<tr class="memdesc:a10658674cb2b0da30f637561df9b9594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base scalar raised to the power of the exponent matrix elementwise.  <a href="namespacestan_1_1math_a10658674cb2b0da30f637561df9b9594.html#a10658674cb2b0da30f637561df9b9594">More...</a><br /></td></tr>
<tr class="separator:a10658674cb2b0da30f637561df9b9594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfd8864e1117d86087848e5a72f1e86"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aecfd8864e1117d86087848e5a72f1e86.html#aecfd8864e1117d86087848e5a72f1e86">pow</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;x, const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;y)</td></tr>
<tr class="memdesc:aecfd8864e1117d86087848e5a72f1e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_aecfd8864e1117d86087848e5a72f1e86.html#aecfd8864e1117d86087848e5a72f1e86">More...</a><br /></td></tr>
<tr class="separator:aecfd8864e1117d86087848e5a72f1e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537d065c043500dd8f1f75495b397294"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a537d065c043500dd8f1f75495b397294"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a537d065c043500dd8f1f75495b397294.html#a537d065c043500dd8f1f75495b397294">pow</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;x, const std::complex&lt; T &gt; y)</td></tr>
<tr class="memdesc:a537d065c043500dd8f1f75495b397294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_a537d065c043500dd8f1f75495b397294.html#a537d065c043500dd8f1f75495b397294">More...</a><br /></td></tr>
<tr class="separator:a537d065c043500dd8f1f75495b397294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b31f76f975a3d517c6bd209a134f05"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a43b31f76f975a3d517c6bd209a134f05.html#a43b31f76f975a3d517c6bd209a134f05">pow</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y)</td></tr>
<tr class="memdesc:a43b31f76f975a3d517c6bd209a134f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_a43b31f76f975a3d517c6bd209a134f05.html#a43b31f76f975a3d517c6bd209a134f05">More...</a><br /></td></tr>
<tr class="separator:a43b31f76f975a3d517c6bd209a134f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e849d72ab6f7d9ff44ce871a9bde428"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a3e849d72ab6f7d9ff44ce871a9bde428"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3e849d72ab6f7d9ff44ce871a9bde428.html#a3e849d72ab6f7d9ff44ce871a9bde428">pow</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;x, T y)</td></tr>
<tr class="memdesc:a3e849d72ab6f7d9ff44ce871a9bde428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_a3e849d72ab6f7d9ff44ce871a9bde428.html#a3e849d72ab6f7d9ff44ce871a9bde428">More...</a><br /></td></tr>
<tr class="separator:a3e849d72ab6f7d9ff44ce871a9bde428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc86f0885abc00d97c2c0159e8f0253"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a4cc86f0885abc00d97c2c0159e8f0253"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4cc86f0885abc00d97c2c0159e8f0253.html#a4cc86f0885abc00d97c2c0159e8f0253">pow</a> (std::complex&lt; T &gt; x, const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;y)</td></tr>
<tr class="memdesc:a4cc86f0885abc00d97c2c0159e8f0253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_a4cc86f0885abc00d97c2c0159e8f0253.html#a4cc86f0885abc00d97c2c0159e8f0253">More...</a><br /></td></tr>
<tr class="separator:a4cc86f0885abc00d97c2c0159e8f0253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5726ea3d046ef5e6e4a1ee028565e1df"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a5726ea3d046ef5e6e4a1ee028565e1df"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5726ea3d046ef5e6e4a1ee028565e1df.html#a5726ea3d046ef5e6e4a1ee028565e1df">pow</a> (std::complex&lt; T &gt; x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y)</td></tr>
<tr class="memdesc:a5726ea3d046ef5e6e4a1ee028565e1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_a5726ea3d046ef5e6e4a1ee028565e1df.html#a5726ea3d046ef5e6e4a1ee028565e1df">More...</a><br /></td></tr>
<tr class="separator:a5726ea3d046ef5e6e4a1ee028565e1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3aceb51d2ab00b5d3a6f1d2df76fe4"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1f3aceb51d2ab00b5d3a6f1d2df76fe4.html#a1f3aceb51d2ab00b5d3a6f1d2df76fe4">pow</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;y)</td></tr>
<tr class="memdesc:a1f3aceb51d2ab00b5d3a6f1d2df76fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_a1f3aceb51d2ab00b5d3a6f1d2df76fe4.html#a1f3aceb51d2ab00b5d3a6f1d2df76fe4">More...</a><br /></td></tr>
<tr class="separator:a1f3aceb51d2ab00b5d3a6f1d2df76fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdcd01af53bf56e38a8b0c3374fe976"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a1fdcd01af53bf56e38a8b0c3374fe976"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1fdcd01af53bf56e38a8b0c3374fe976.html#a1fdcd01af53bf56e38a8b0c3374fe976">pow</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, std::complex&lt; T &gt; y)</td></tr>
<tr class="memdesc:a1fdcd01af53bf56e38a8b0c3374fe976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_a1fdcd01af53bf56e38a8b0c3374fe976.html#a1fdcd01af53bf56e38a8b0c3374fe976">More...</a><br /></td></tr>
<tr class="separator:a1fdcd01af53bf56e38a8b0c3374fe976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aec5d05d82943c20c5fda720b53adef"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a2aec5d05d82943c20c5fda720b53adef"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2aec5d05d82943c20c5fda720b53adef.html#a2aec5d05d82943c20c5fda720b53adef">pow</a> (T x, const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;y)</td></tr>
<tr class="memdesc:a2aec5d05d82943c20c5fda720b53adef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_a2aec5d05d82943c20c5fda720b53adef.html#a2aec5d05d82943c20c5fda720b53adef">More...</a><br /></td></tr>
<tr class="separator:a2aec5d05d82943c20c5fda720b53adef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1024d851eae6729712714c59712195"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade1024d851eae6729712714c59712195.html#ade1024d851eae6729712714c59712195">pow</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;x, int y)</td></tr>
<tr class="memdesc:ade1024d851eae6729712714c59712195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <a href="namespacestan_1_1math_ade1024d851eae6729712714c59712195.html#ade1024d851eae6729712714c59712195">More...</a><br /></td></tr>
<tr class="separator:ade1024d851eae6729712714c59712195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccbe1638f463027973553dec7175dbc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0ccbe1638f463027973553dec7175dbc.html#a0ccbe1638f463027973553dec7175dbc">primitive_value</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;v)</td></tr>
<tr class="memdesc:a0ccbe1638f463027973553dec7175dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the primitive double value for the specified autodiff variable.  <a href="namespacestan_1_1math_a0ccbe1638f463027973553dec7175dbc.html#a0ccbe1638f463027973553dec7175dbc">More...</a><br /></td></tr>
<tr class="separator:a0ccbe1638f463027973553dec7175dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d840f9d45ce35b912866c34f4d5ff43"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5d840f9d45ce35b912866c34f4d5ff43.html#a5d840f9d45ce35b912866c34f4d5ff43">proj</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a5d840f9d45ce35b912866c34f4d5ff43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the projection of the complex argument onto the Riemann sphere.  <a href="namespacestan_1_1math_a5d840f9d45ce35b912866c34f4d5ff43.html#a5d840f9d45ce35b912866c34f4d5ff43">More...</a><br /></td></tr>
<tr class="separator:a5d840f9d45ce35b912866c34f4d5ff43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7f6a5af470cc7f1db81c5fea57f984"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_eigen_t&lt; EigMat1, EigMat2 &gt; *  = nullptr, require_not_eigen_col_vector_t&lt; EigMat2 &gt; *  = nullptr, require_any_vt_var&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4c7f6a5af470cc7f1db81c5fea57f984"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">promote_scalar_t</a>&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, EigMat2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4c7f6a5af470cc7f1db81c5fea57f984.html#a4c7f6a5af470cc7f1db81c5fea57f984">quad_form</a> (const EigMat1 &amp;A, const EigMat2 &amp;B, bool symmetric=false)</td></tr>
<tr class="memdesc:a4c7f6a5af470cc7f1db81c5fea57f984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \).  <a href="namespacestan_1_1math_a4c7f6a5af470cc7f1db81c5fea57f984.html#a4c7f6a5af470cc7f1db81c5fea57f984">More...</a><br /></td></tr>
<tr class="separator:a4c7f6a5af470cc7f1db81c5fea57f984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fd97336bfb1a094fef97eac5d6fbd0"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename ColVec , require_eigen_t&lt; EigMat &gt; *  = nullptr, require_eigen_col_vector_t&lt; ColVec &gt; *  = nullptr, require_any_vt_var&lt; EigMat, ColVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a34fd97336bfb1a094fef97eac5d6fbd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a34fd97336bfb1a094fef97eac5d6fbd0.html#a34fd97336bfb1a094fef97eac5d6fbd0">quad_form</a> (const EigMat &amp;A, const ColVec &amp;B, bool symmetric=false)</td></tr>
<tr class="memdesc:a34fd97336bfb1a094fef97eac5d6fbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \).  <a href="namespacestan_1_1math_a34fd97336bfb1a094fef97eac5d6fbd0.html#a34fd97336bfb1a094fef97eac5d6fbd0">More...</a><br /></td></tr>
<tr class="separator:a34fd97336bfb1a094fef97eac5d6fbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a05ca20655977a6470770ae52b896c"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , require_all_matrix_t&lt; Mat1, Mat2 &gt; *  = nullptr, require_not_col_vector_t&lt; Mat2 &gt; *  = nullptr, require_any_var_matrix_t&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa2a05ca20655977a6470770ae52b896c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa2a05ca20655977a6470770ae52b896c.html#aa2a05ca20655977a6470770ae52b896c">quad_form</a> (const Mat1 &amp;A, const Mat2 &amp;B, bool symmetric=false)</td></tr>
<tr class="memdesc:aa2a05ca20655977a6470770ae52b896c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \).  <a href="namespacestan_1_1math_aa2a05ca20655977a6470770ae52b896c.html#aa2a05ca20655977a6470770ae52b896c">More...</a><br /></td></tr>
<tr class="separator:aa2a05ca20655977a6470770ae52b896c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d4202bac72da2ba0fddf453b694f2c"><td class="memTemplParams" colspan="2">template&lt;typename Mat , typename Vec , require_matrix_t&lt; Mat &gt; *  = nullptr, require_col_vector_t&lt; Vec &gt; *  = nullptr, require_any_var_matrix_t&lt; Mat, Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a41d4202bac72da2ba0fddf453b694f2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a41d4202bac72da2ba0fddf453b694f2c.html#a41d4202bac72da2ba0fddf453b694f2c">quad_form</a> (const Mat &amp;A, const Vec &amp;B, bool symmetric=false)</td></tr>
<tr class="memdesc:a41d4202bac72da2ba0fddf453b694f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \).  <a href="namespacestan_1_1math_a41d4202bac72da2ba0fddf453b694f2c.html#a41d4202bac72da2ba0fddf453b694f2c">More...</a><br /></td></tr>
<tr class="separator:a41d4202bac72da2ba0fddf453b694f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcd98e2772811936c1bfc6e441aa4a7"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , require_all_eigen_t&lt; EigMat1, EigMat2 &gt; *  = nullptr, require_any_vt_var&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aabcd98e2772811936c1bfc6e441aa4a7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aabcd98e2772811936c1bfc6e441aa4a7.html#aabcd98e2772811936c1bfc6e441aa4a7">quad_form_sym</a> (const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:aabcd98e2772811936c1bfc6e441aa4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \) of a symmetric matrix.  <a href="namespacestan_1_1math_aabcd98e2772811936c1bfc6e441aa4a7.html#aabcd98e2772811936c1bfc6e441aa4a7">More...</a><br /></td></tr>
<tr class="separator:aabcd98e2772811936c1bfc6e441aa4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5764580f874bfb327f5e737d3242fea"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa5764580f874bfb327f5e737d3242fea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa5764580f874bfb327f5e737d3242fea.html#aa5764580f874bfb327f5e737d3242fea">read_corr_L</a> (const T &amp;CPCs, size_t K)</td></tr>
<tr class="memdesc:aa5764580f874bfb327f5e737d3242fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations.  <a href="namespacestan_1_1math_aa5764580f874bfb327f5e737d3242fea.html#aa5764580f874bfb327f5e737d3242fea">More...</a><br /></td></tr>
<tr class="separator:aa5764580f874bfb327f5e737d3242fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c6412c7e37ad9a1d875fd86993a332"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_var_vector_t&lt; T1 &gt; *  = nullptr, require_stan_scalar_t&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa7c6412c7e37ad9a1d875fd86993a332"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa7c6412c7e37ad9a1d875fd86993a332.html#aa7c6412c7e37ad9a1d875fd86993a332">read_corr_L</a> (const T1 &amp;CPCs, size_t K, T2 &amp;log_prob)</td></tr>
<tr class="memdesc:aa7c6412c7e37ad9a1d875fd86993a332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations, incrementing the specified scalar reference with the log absolute determinant of the Jacobian of the transformation.  <a href="namespacestan_1_1math_aa7c6412c7e37ad9a1d875fd86993a332.html#aa7c6412c7e37ad9a1d875fd86993a332">More...</a><br /></td></tr>
<tr class="separator:aa7c6412c7e37ad9a1d875fd86993a332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c34d10f5019cd771e3a2dad84cd377"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , require_var_vector_t&lt; T_CPCs &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a36c34d10f5019cd771e3a2dad84cd377"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a36c34d10f5019cd771e3a2dad84cd377.html#a36c34d10f5019cd771e3a2dad84cd377">read_corr_matrix</a> (const T_CPCs &amp;CPCs, size_t K)</td></tr>
<tr class="memdesc:a36c34d10f5019cd771e3a2dad84cd377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations.  <a href="namespacestan_1_1math_a36c34d10f5019cd771e3a2dad84cd377.html#a36c34d10f5019cd771e3a2dad84cd377">More...</a><br /></td></tr>
<tr class="separator:a36c34d10f5019cd771e3a2dad84cd377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699b27671f8fa3d956bfb20f3920f105"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , require_var_vector_t&lt; T_CPCs &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a699b27671f8fa3d956bfb20f3920f105"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a699b27671f8fa3d956bfb20f3920f105.html#a699b27671f8fa3d956bfb20f3920f105">read_corr_matrix</a> (const T_CPCs &amp;CPCs, size_t K, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T_CPCs &gt; &amp;log_prob)</td></tr>
<tr class="memdesc:a699b27671f8fa3d956bfb20f3920f105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations, incrementing the specified scalar reference with the log absolute determinant of the Jacobian of the transformation.  <a href="namespacestan_1_1math_a699b27671f8fa3d956bfb20f3920f105.html#a699b27671f8fa3d956bfb20f3920f105">More...</a><br /></td></tr>
<tr class="separator:a699b27671f8fa3d956bfb20f3920f105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3616c201e1d4e6bfc8cb2c7b3766cb"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , typename T_sds , require_any_var_vector_t&lt; T_CPCs, T_sds &gt; *  = nullptr, require_vt_same&lt; T_CPCs, T_sds &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ade3616c201e1d4e6bfc8cb2c7b3766cb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade3616c201e1d4e6bfc8cb2c7b3766cb.html#ade3616c201e1d4e6bfc8cb2c7b3766cb">read_cov_L</a> (const T_CPCs &amp;CPCs, const T_sds &amp;sds, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T_CPCs &gt; &amp;log_prob)</td></tr>
<tr class="memdesc:ade3616c201e1d4e6bfc8cb2c7b3766cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function that should be called prior to evaluating the density of any elliptical distribution.  <a href="namespacestan_1_1math_ade3616c201e1d4e6bfc8cb2c7b3766cb.html#ade3616c201e1d4e6bfc8cb2c7b3766cb">More...</a><br /></td></tr>
<tr class="separator:ade3616c201e1d4e6bfc8cb2c7b3766cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae0f8ecf209a072ecb8b16b49022b29"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , typename T_sds , require_all_var_vector_t&lt; T_CPCs, T_sds &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adae0f8ecf209a072ecb8b16b49022b29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adae0f8ecf209a072ecb8b16b49022b29.html#adae0f8ecf209a072ecb8b16b49022b29">read_cov_matrix</a> (const T_CPCs &amp;CPCs, const T_sds &amp;sds, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T_CPCs &gt; &amp;log_prob)</td></tr>
<tr class="memdesc:adae0f8ecf209a072ecb8b16b49022b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generally worse alternative to call prior to evaluating the density of an elliptical distribution.  <a href="namespacestan_1_1math_adae0f8ecf209a072ecb8b16b49022b29.html#adae0f8ecf209a072ecb8b16b49022b29">More...</a><br /></td></tr>
<tr class="separator:adae0f8ecf209a072ecb8b16b49022b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765863bf295858374d0bcd12d51567e8"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , typename T_sds , require_all_var_vector_t&lt; T_CPCs, T_sds &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a765863bf295858374d0bcd12d51567e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a765863bf295858374d0bcd12d51567e8.html#a765863bf295858374d0bcd12d51567e8">read_cov_matrix</a> (const T_CPCs &amp;CPCs, const T_sds &amp;sds)</td></tr>
<tr class="memdesc:a765863bf295858374d0bcd12d51567e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a covariance matrix from CPCs and standard deviations.  <a href="namespacestan_1_1math_a765863bf295858374d0bcd12d51567e8.html#a765863bf295858374d0bcd12d51567e8">More...</a><br /></td></tr>
<tr class="separator:a765863bf295858374d0bcd12d51567e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267f6f928b29d06f15a7084044260ab8"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Vec , require_var_matrix_t&lt; Ret &gt; *  = nullptr, require_var_matrix_t&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a267f6f928b29d06f15a7084044260ab8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a267f6f928b29d06f15a7084044260ab8.html#a267f6f928b29d06f15a7084044260ab8">rep_matrix</a> (const Vec &amp;x, int n)</td></tr>
<tr class="memdesc:a267f6f928b29d06f15a7084044260ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impl of rep_matrix returning a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Eigen::Matrix&gt;</code> from a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code> with an inner <a class="el" href="namespace_eigen.html">Eigen</a> vector type.  <a href="namespacestan_1_1math_a267f6f928b29d06f15a7084044260ab8.html#a267f6f928b29d06f15a7084044260ab8">More...</a><br /></td></tr>
<tr class="separator:a267f6f928b29d06f15a7084044260ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35656cc627ac0d8fec00c9ff145875cc"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , require_var_matrix_t&lt; T_ret &gt; *  = nullptr, require_eigen_row_vector_t&lt; value_type_t&lt; T_ret &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a35656cc627ac0d8fec00c9ff145875cc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a35656cc627ac0d8fec00c9ff145875cc.html#a35656cc627ac0d8fec00c9ff145875cc">rep_row_vector</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> x, int n)</td></tr>
<tr class="memdesc:a35656cc627ac0d8fec00c9ff145875cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Vector&gt;</code>.  <a href="namespacestan_1_1math_a35656cc627ac0d8fec00c9ff145875cc.html#a35656cc627ac0d8fec00c9ff145875cc">More...</a><br /></td></tr>
<tr class="separator:a35656cc627ac0d8fec00c9ff145875cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b45872b1ffc5df2700aa32653e3b50"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , require_var_matrix_t&lt; T_ret &gt; *  = nullptr, require_eigen_col_vector_t&lt; value_type_t&lt; T_ret &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab0b45872b1ffc5df2700aa32653e3b50"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab0b45872b1ffc5df2700aa32653e3b50.html#ab0b45872b1ffc5df2700aa32653e3b50">rep_vector</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> x, int n)</td></tr>
<tr class="memdesc:ab0b45872b1ffc5df2700aa32653e3b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Vector&gt;</code>.  <a href="namespacestan_1_1math_ab0b45872b1ffc5df2700aa32653e3b50.html#ab0b45872b1ffc5df2700aa32653e3b50">More...</a><br /></td></tr>
<tr class="separator:ab0b45872b1ffc5df2700aa32653e3b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f816575a235ef07b3e9e62478d3ee42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8f816575a235ef07b3e9e62478d3ee42.html#a8f816575a235ef07b3e9e62478d3ee42">rising_factorial</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, int b)</td></tr>
<tr class="separator:a8f816575a235ef07b3e9e62478d3ee42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab259f70f4c7ebcdf3e032f01efb66c02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab259f70f4c7ebcdf3e032f01efb66c02.html#ab259f70f4c7ebcdf3e032f01efb66c02">round</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:ab259f70f4c7ebcdf3e032f01efb66c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rounded form of the specified variable (C99).  <a href="namespacestan_1_1math_ab259f70f4c7ebcdf3e032f01efb66c02.html#ab259f70f4c7ebcdf3e032f01efb66c02">More...</a><br /></td></tr>
<tr class="separator:ab259f70f4c7ebcdf3e032f01efb66c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3febf862255d171981fadddf89665b8f"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , require_all_eigen_t&lt; Mat1, Mat2 &gt; *  = nullptr, require_any_eigen_vt&lt; is_var, Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3febf862255d171981fadddf89665b8f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Mat1::RowsAtCompileTime, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3febf862255d171981fadddf89665b8f.html#a3febf862255d171981fadddf89665b8f">rows_dot_product</a> (const Mat1 &amp;v1, const Mat2 &amp;v2)</td></tr>
<tr class="memdesc:a3febf862255d171981fadddf89665b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of rows of the specified matrices.  <a href="namespacestan_1_1math_a3febf862255d171981fadddf89665b8f.html#a3febf862255d171981fadddf89665b8f">More...</a><br /></td></tr>
<tr class="separator:a3febf862255d171981fadddf89665b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999e544019c0e28886933b4c93072553"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , require_all_matrix_t&lt; Mat1, Mat2 &gt; *  = nullptr, require_any_var_matrix_t&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a999e544019c0e28886933b4c93072553"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a999e544019c0e28886933b4c93072553.html#a999e544019c0e28886933b4c93072553">rows_dot_product</a> (const Mat1 &amp;v1, const Mat2 &amp;v2)</td></tr>
<tr class="memdesc:a999e544019c0e28886933b4c93072553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of rows of the specified matrices.  <a href="namespacestan_1_1math_a999e544019c0e28886933b4c93072553.html#a999e544019c0e28886933b4c93072553">More...</a><br /></td></tr>
<tr class="separator:a999e544019c0e28886933b4c93072553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7d92ff93a55b06e392f4a4617c5aba"><td class="memTemplParams" colspan="2">template&lt;typename Mat , require_eigen_vt&lt; is_var, Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9d7d92ff93a55b06e392f4a4617c5aba"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Mat::RowsAtCompileTime, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9d7d92ff93a55b06e392f4a4617c5aba.html#a9d7d92ff93a55b06e392f4a4617c5aba">rows_dot_self</a> (const Mat &amp;x)</td></tr>
<tr class="memdesc:a9d7d92ff93a55b06e392f4a4617c5aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each row of a matrix with itself.  <a href="namespacestan_1_1math_a9d7d92ff93a55b06e392f4a4617c5aba.html#a9d7d92ff93a55b06e392f4a4617c5aba">More...</a><br /></td></tr>
<tr class="separator:a9d7d92ff93a55b06e392f4a4617c5aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab314fd37bd2a8316d44fed7e6ac6ae5f"><td class="memTemplParams" colspan="2">template&lt;typename Mat , require_var_matrix_t&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab314fd37bd2a8316d44fed7e6ac6ae5f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab314fd37bd2a8316d44fed7e6ac6ae5f.html#ab314fd37bd2a8316d44fed7e6ac6ae5f">rows_dot_self</a> (const Mat &amp;x)</td></tr>
<tr class="memdesc:ab314fd37bd2a8316d44fed7e6ac6ae5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of row row of a matrix with itself.  <a href="namespacestan_1_1math_ab314fd37bd2a8316d44fed7e6ac6ae5f.html#ab314fd37bd2a8316d44fed7e6ac6ae5f">More...</a><br /></td></tr>
<tr class="separator:ab314fd37bd2a8316d44fed7e6ac6ae5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb57f17d92038aa778bd67136a3ccde"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_st&lt; is_var, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1bb57f17d92038aa778bd67136a3ccde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1bb57f17d92038aa778bd67136a3ccde.html#a1bb57f17d92038aa778bd67136a3ccde">sd</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a1bb57f17d92038aa778bd67136a3ccde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample standard deviation of a variable which inherits from EigenBase.  <a href="namespacestan_1_1math_a1bb57f17d92038aa778bd67136a3ccde.html#a1bb57f17d92038aa778bd67136a3ccde">More...</a><br /></td></tr>
<tr class="separator:a1bb57f17d92038aa778bd67136a3ccde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef0ad5fb85ef3b77bb2196c36485198"><td class="memTemplParams" colspan="2">template&lt;typename T , require_std_vector_st&lt; is_var, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9ef0ad5fb85ef3b77bb2196c36485198"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ef0ad5fb85ef3b77bb2196c36485198.html#a9ef0ad5fb85ef3b77bb2196c36485198">sd</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a9ef0ad5fb85ef3b77bb2196c36485198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample standard deviation of the specified std vector, column vector, row vector, matrix, or std vector of any of these types.  <a href="namespacestan_1_1math_a9ef0ad5fb85ef3b77bb2196c36485198.html#a9ef0ad5fb85ef3b77bb2196c36485198">More...</a><br /></td></tr>
<tr class="separator:a9ef0ad5fb85ef3b77bb2196c36485198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60d44bfc1facf7b7c63a802bab2ee53"><td class="memTemplParams" colspan="2">template&lt;typename T , require_rev_col_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad60d44bfc1facf7b7c63a802bab2ee53"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad60d44bfc1facf7b7c63a802bab2ee53.html#ad60d44bfc1facf7b7c63a802bab2ee53">simplex_constrain</a> (const T &amp;y)</td></tr>
<tr class="memdesc:ad60d44bfc1facf7b7c63a802bab2ee53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the simplex corresponding to the specified free vector.  <a href="namespacestan_1_1math_ad60d44bfc1facf7b7c63a802bab2ee53.html#ad60d44bfc1facf7b7c63a802bab2ee53">More...</a><br /></td></tr>
<tr class="separator:ad60d44bfc1facf7b7c63a802bab2ee53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae564ce05fcd2814e6c7e6feee98fa3ee"><td class="memTemplParams" colspan="2">template&lt;typename T , require_rev_col_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae564ce05fcd2814e6c7e6feee98fa3ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae564ce05fcd2814e6c7e6feee98fa3ee.html#ae564ce05fcd2814e6c7e6feee98fa3ee">simplex_constrain</a> (const T &amp;y, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:ae564ce05fcd2814e6c7e6feee98fa3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the simplex corresponding to the specified free vector and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <a href="namespacestan_1_1math_ae564ce05fcd2814e6c7e6feee98fa3ee.html#ae564ce05fcd2814e6c7e6feee98fa3ee">More...</a><br /></td></tr>
<tr class="separator:ae564ce05fcd2814e6c7e6feee98fa3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae306538402ac590b8b84e6ed58989629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae306538402ac590b8b84e6ed58989629.html#ae306538402ac590b8b84e6ed58989629">sin</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:ae306538402ac590b8b84e6ed58989629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sine of a radian-scaled variable (cmath).  <a href="namespacestan_1_1math_ae306538402ac590b8b84e6ed58989629.html#ae306538402ac590b8b84e6ed58989629">More...</a><br /></td></tr>
<tr class="separator:ae306538402ac590b8b84e6ed58989629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7434c28c0c2c2d63c674cdab45a031e7"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , require_var_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7434c28c0c2c2d63c674cdab45a031e7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7434c28c0c2c2d63c674cdab45a031e7.html#a7434c28c0c2c2d63c674cdab45a031e7">sin</a> (const VarMat &amp;a)</td></tr>
<tr class="memdesc:a7434c28c0c2c2d63c674cdab45a031e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sine of a radian-scaled variable (cmath).  <a href="namespacestan_1_1math_a7434c28c0c2c2d63c674cdab45a031e7.html#a7434c28c0c2c2d63c674cdab45a031e7">More...</a><br /></td></tr>
<tr class="separator:a7434c28c0c2c2d63c674cdab45a031e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05161016884ccc0e51d9b184a8124731"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a05161016884ccc0e51d9b184a8124731.html#a05161016884ccc0e51d9b184a8124731">sin</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a05161016884ccc0e51d9b184a8124731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sine of the complex argument.  <a href="namespacestan_1_1math_a05161016884ccc0e51d9b184a8124731.html#a05161016884ccc0e51d9b184a8124731">More...</a><br /></td></tr>
<tr class="separator:a05161016884ccc0e51d9b184a8124731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d74ca247a7cafe2d08f7c642209022"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_rev_matrix_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a25d74ca247a7cafe2d08f7c642209022"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a25d74ca247a7cafe2d08f7c642209022.html#a25d74ca247a7cafe2d08f7c642209022">singular_values</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a25d74ca247a7cafe2d08f7c642209022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the singular values of the specified matrix.  <a href="namespacestan_1_1math_a25d74ca247a7cafe2d08f7c642209022.html#a25d74ca247a7cafe2d08f7c642209022">More...</a><br /></td></tr>
<tr class="separator:a25d74ca247a7cafe2d08f7c642209022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241b79300774f40a6e67b7156b494462"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a241b79300774f40a6e67b7156b494462.html#a241b79300774f40a6e67b7156b494462">sinh</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a241b79300774f40a6e67b7156b494462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic sine of the specified variable (cmath).  <a href="namespacestan_1_1math_a241b79300774f40a6e67b7156b494462.html#a241b79300774f40a6e67b7156b494462">More...</a><br /></td></tr>
<tr class="separator:a241b79300774f40a6e67b7156b494462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971a11c14a0fd7d83ddbb2b06f29c92c"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , require_var_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a971a11c14a0fd7d83ddbb2b06f29c92c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a971a11c14a0fd7d83ddbb2b06f29c92c.html#a971a11c14a0fd7d83ddbb2b06f29c92c">sinh</a> (const VarMat &amp;a)</td></tr>
<tr class="memdesc:a971a11c14a0fd7d83ddbb2b06f29c92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic of a radian-scaled variable (cmath).  <a href="namespacestan_1_1math_a971a11c14a0fd7d83ddbb2b06f29c92c.html#a971a11c14a0fd7d83ddbb2b06f29c92c">More...</a><br /></td></tr>
<tr class="separator:a971a11c14a0fd7d83ddbb2b06f29c92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8806400904d4f553e1f64e62793e3354"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8806400904d4f553e1f64e62793e3354.html#a8806400904d4f553e1f64e62793e3354">sinh</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a8806400904d4f553e1f64e62793e3354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic sine of the complex argument.  <a href="namespacestan_1_1math_a8806400904d4f553e1f64e62793e3354.html#a8806400904d4f553e1f64e62793e3354">More...</a><br /></td></tr>
<tr class="separator:a8806400904d4f553e1f64e62793e3354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97203c1dea7e34e9bbf1ebd9dc064c06"><td class="memTemplParams" colspan="2">template&lt;typename Mat , require_rev_matrix_t&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a97203c1dea7e34e9bbf1ebd9dc064c06"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a97203c1dea7e34e9bbf1ebd9dc064c06.html#a97203c1dea7e34e9bbf1ebd9dc064c06">softmax</a> (const Mat &amp;alpha)</td></tr>
<tr class="memdesc:a97203c1dea7e34e9bbf1ebd9dc064c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the softmax of the specified <a class="el" href="namespace_eigen.html">Eigen</a> vector.  <a href="namespacestan_1_1math_a97203c1dea7e34e9bbf1ebd9dc064c06.html#a97203c1dea7e34e9bbf1ebd9dc064c06">More...</a><br /></td></tr>
<tr class="separator:a97203c1dea7e34e9bbf1ebd9dc064c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab438f4b0a11d8551fe5605237f655730"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab438f4b0a11d8551fe5605237f655730.html#ab438f4b0a11d8551fe5605237f655730">sqrt</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:ab438f4b0a11d8551fe5605237f655730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of the specified variable (cmath).  <a href="namespacestan_1_1math_ab438f4b0a11d8551fe5605237f655730.html#ab438f4b0a11d8551fe5605237f655730">More...</a><br /></td></tr>
<tr class="separator:ab438f4b0a11d8551fe5605237f655730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409cc3a1e2a6a5e76b0475264c7c9d18"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a409cc3a1e2a6a5e76b0475264c7c9d18"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a409cc3a1e2a6a5e76b0475264c7c9d18.html#a409cc3a1e2a6a5e76b0475264c7c9d18">sqrt</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a409cc3a1e2a6a5e76b0475264c7c9d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return elementwise square root of vector.  <a href="namespacestan_1_1math_a409cc3a1e2a6a5e76b0475264c7c9d18.html#a409cc3a1e2a6a5e76b0475264c7c9d18">More...</a><br /></td></tr>
<tr class="separator:a409cc3a1e2a6a5e76b0475264c7c9d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d0c2db3d86ac8dd80f0c42563cc43e"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad2d0c2db3d86ac8dd80f0c42563cc43e.html#ad2d0c2db3d86ac8dd80f0c42563cc43e">sqrt</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:ad2d0c2db3d86ac8dd80f0c42563cc43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of the complex argument.  <a href="namespacestan_1_1math_ad2d0c2db3d86ac8dd80f0c42563cc43e.html#ad2d0c2db3d86ac8dd80f0c42563cc43e">More...</a><br /></td></tr>
<tr class="separator:ad2d0c2db3d86ac8dd80f0c42563cc43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b349cd070427c412c2c0a0d32327b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa1b349cd070427c412c2c0a0d32327b5.html#aa1b349cd070427c412c2c0a0d32327b5">square</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:aa1b349cd070427c412c2c0a0d32327b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of the input variable.  <a href="namespacestan_1_1math_aa1b349cd070427c412c2c0a0d32327b5.html#aa1b349cd070427c412c2c0a0d32327b5">More...</a><br /></td></tr>
<tr class="separator:aa1b349cd070427c412c2c0a0d32327b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96eaa2f4afd30db9c2cf0e3bdfaf5df"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae96eaa2f4afd30db9c2cf0e3bdfaf5df"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae96eaa2f4afd30db9c2cf0e3bdfaf5df.html#ae96eaa2f4afd30db9c2cf0e3bdfaf5df">square</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae96eaa2f4afd30db9c2cf0e3bdfaf5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise square of x.  <a href="namespacestan_1_1math_ae96eaa2f4afd30db9c2cf0e3bdfaf5df.html#ae96eaa2f4afd30db9c2cf0e3bdfaf5df">More...</a><br /></td></tr>
<tr class="separator:ae96eaa2f4afd30db9c2cf0e3bdfaf5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ff53e8fd4aa89af1e8f95cf669529e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a61ff53e8fd4aa89af1e8f95cf669529e.html#a61ff53e8fd4aa89af1e8f95cf669529e">squared_distance</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a61ff53e8fd4aa89af1e8f95cf669529e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance.  <a href="namespacestan_1_1math_a61ff53e8fd4aa89af1e8f95cf669529e.html#a61ff53e8fd4aa89af1e8f95cf669529e">More...</a><br /></td></tr>
<tr class="separator:a61ff53e8fd4aa89af1e8f95cf669529e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2919d7ff701b0c109254090471c8be30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2919d7ff701b0c109254090471c8be30.html#a2919d7ff701b0c109254090471c8be30">squared_distance</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:a2919d7ff701b0c109254090471c8be30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance.  <a href="namespacestan_1_1math_a2919d7ff701b0c109254090471c8be30.html#a2919d7ff701b0c109254090471c8be30">More...</a><br /></td></tr>
<tr class="separator:a2919d7ff701b0c109254090471c8be30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267a694b865507ce2aff00f83de31d5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a267a694b865507ce2aff00f83de31d5b.html#a267a694b865507ce2aff00f83de31d5b">squared_distance</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a267a694b865507ce2aff00f83de31d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance.  <a href="namespacestan_1_1math_a267a694b865507ce2aff00f83de31d5b.html#a267a694b865507ce2aff00f83de31d5b">More...</a><br /></td></tr>
<tr class="separator:a267a694b865507ce2aff00f83de31d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43923273fec40cf29005e2d1d0335f9"><td class="memTemplParams" colspan="2">template&lt;typename EigVecVar1 , typename EigVecVar2 , require_all_eigen_vector_vt&lt; is_var, EigVecVar1, EigVecVar2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa43923273fec40cf29005e2d1d0335f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa43923273fec40cf29005e2d1d0335f9.html#aa43923273fec40cf29005e2d1d0335f9">squared_distance</a> (const EigVecVar1 &amp;v1, const EigVecVar2 &amp;v2)</td></tr>
<tr class="separator:aa43923273fec40cf29005e2d1d0335f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683327eb4ba74872ddf550de5bd30da4"><td class="memTemplParams" colspan="2">template&lt;typename EigVecVar , typename EigVecArith , require_eigen_vector_vt&lt; is_var, EigVecVar &gt; *  = nullptr, require_eigen_vector_vt&lt; std::is_arithmetic, EigVecArith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a683327eb4ba74872ddf550de5bd30da4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a683327eb4ba74872ddf550de5bd30da4.html#a683327eb4ba74872ddf550de5bd30da4">squared_distance</a> (const EigVecVar &amp;v1, const EigVecArith &amp;v2)</td></tr>
<tr class="separator:a683327eb4ba74872ddf550de5bd30da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95a11718edba243ef87525eac8b1529"><td class="memTemplParams" colspan="2">template&lt;typename EigVecArith , typename EigVecVar , require_eigen_vector_vt&lt; std::is_arithmetic, EigVecArith &gt; *  = nullptr, require_eigen_vector_vt&lt; is_var, EigVecVar &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac95a11718edba243ef87525eac8b1529"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac95a11718edba243ef87525eac8b1529.html#ac95a11718edba243ef87525eac8b1529">squared_distance</a> (const EigVecArith &amp;v1, const EigVecVar &amp;v2)</td></tr>
<tr class="separator:ac95a11718edba243ef87525eac8b1529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c719996e0349809cf0aee7f41b7590"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_vector_t&lt; T1, T2 &gt; *  = nullptr, require_any_var_vector_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a98c719996e0349809cf0aee7f41b7590"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a98c719996e0349809cf0aee7f41b7590.html#a98c719996e0349809cf0aee7f41b7590">squared_distance</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:a98c719996e0349809cf0aee7f41b7590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the squared distance between the elements in two inputs.  <a href="namespacestan_1_1math_a98c719996e0349809cf0aee7f41b7590.html#a98c719996e0349809cf0aee7f41b7590">More...</a><br /></td></tr>
<tr class="separator:a98c719996e0349809cf0aee7f41b7590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab45f57a15327ae4f94a1aef0bcd869f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab45f57a15327ae4f94a1aef0bcd869f.html#aab45f57a15327ae4f94a1aef0bcd869f">stan_print</a> (std::ostream *o, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="separator:aab45f57a15327ae4f94a1aef0bcd869f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686aa4165aa247ce689d222b67735810"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a686aa4165aa247ce689d222b67735810.html#a686aa4165aa247ce689d222b67735810">step</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a686aa4165aa247ce689d222b67735810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the step, or heaviside, function applied to the specified variable (stan).  <a href="namespacestan_1_1math_a686aa4165aa247ce689d222b67735810.html#a686aa4165aa247ce689d222b67735810">More...</a><br /></td></tr>
<tr class="separator:a686aa4165aa247ce689d222b67735810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619275173fb7baa7e80adbd6910134ee"><td class="memTemplParams" colspan="2">template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:a619275173fb7baa7e80adbd6910134ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a619275173fb7baa7e80adbd6910134ee.html#a619275173fb7baa7e80adbd6910134ee">sum</a> (const std::vector&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Alloc &gt; &amp;m)</td></tr>
<tr class="memdesc:a619275173fb7baa7e80adbd6910134ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of the entries of the specified vector.  <a href="namespacestan_1_1math_a619275173fb7baa7e80adbd6910134ee.html#a619275173fb7baa7e80adbd6910134ee">More...</a><br /></td></tr>
<tr class="separator:a619275173fb7baa7e80adbd6910134ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bee466899e15a53f86764ffeed9936"><td class="memTemplParams" colspan="2">template&lt;typename T , require_rev_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a69bee466899e15a53f86764ffeed9936"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a69bee466899e15a53f86764ffeed9936.html#a69bee466899e15a53f86764ffeed9936">sum</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a69bee466899e15a53f86764ffeed9936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of the coefficients of the specified matrix.  <a href="namespacestan_1_1math_a69bee466899e15a53f86764ffeed9936.html#a69bee466899e15a53f86764ffeed9936">More...</a><br /></td></tr>
<tr class="separator:a69bee466899e15a53f86764ffeed9936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc39c0b4f48e122011c1a6d1595ae85"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_rev_matrix_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2fc39c0b4f48e122011c1a6d1595ae85"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2fc39c0b4f48e122011c1a6d1595ae85.html#a2fc39c0b4f48e122011c1a6d1595ae85">svd_U</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a2fc39c0b4f48e122011c1a6d1595ae85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given input matrix m, return matrix U where <code>m = UDV^{T}</code>  <a href="namespacestan_1_1math_a2fc39c0b4f48e122011c1a6d1595ae85.html#a2fc39c0b4f48e122011c1a6d1595ae85">More...</a><br /></td></tr>
<tr class="separator:a2fc39c0b4f48e122011c1a6d1595ae85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa3532f2b8ced3ad957075a9cf9165f"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_rev_matrix_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acaa3532f2b8ced3ad957075a9cf9165f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acaa3532f2b8ced3ad957075a9cf9165f.html#acaa3532f2b8ced3ad957075a9cf9165f">svd_V</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:acaa3532f2b8ced3ad957075a9cf9165f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given input matrix m, return matrix V where <code>m = UDV^{T}</code>  <a href="namespacestan_1_1math_acaa3532f2b8ced3ad957075a9cf9165f.html#acaa3532f2b8ced3ad957075a9cf9165f">More...</a><br /></td></tr>
<tr class="separator:acaa3532f2b8ced3ad957075a9cf9165f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8320fd61a3c0c73f2ab8d78d949e58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adf8320fd61a3c0c73f2ab8d78d949e58.html#adf8320fd61a3c0c73f2ab8d78d949e58">tan</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:adf8320fd61a3c0c73f2ab8d78d949e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tangent of a radian-scaled variable (cmath).  <a href="namespacestan_1_1math_adf8320fd61a3c0c73f2ab8d78d949e58.html#adf8320fd61a3c0c73f2ab8d78d949e58">More...</a><br /></td></tr>
<tr class="separator:adf8320fd61a3c0c73f2ab8d78d949e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037201c6eba2c196faf3e93f58e0dc4b"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , require_var_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a037201c6eba2c196faf3e93f58e0dc4b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a037201c6eba2c196faf3e93f58e0dc4b.html#a037201c6eba2c196faf3e93f58e0dc4b">tan</a> (const VarMat &amp;a)</td></tr>
<tr class="memdesc:a037201c6eba2c196faf3e93f58e0dc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tangent of a radian-scaled variable (cmath).  <a href="namespacestan_1_1math_a037201c6eba2c196faf3e93f58e0dc4b.html#a037201c6eba2c196faf3e93f58e0dc4b">More...</a><br /></td></tr>
<tr class="separator:a037201c6eba2c196faf3e93f58e0dc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a96255685b80dc210e3ef3eb778a54"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af1a96255685b80dc210e3ef3eb778a54.html#af1a96255685b80dc210e3ef3eb778a54">tan</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:af1a96255685b80dc210e3ef3eb778a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tangent of the complex argument.  <a href="namespacestan_1_1math_af1a96255685b80dc210e3ef3eb778a54.html#af1a96255685b80dc210e3ef3eb778a54">More...</a><br /></td></tr>
<tr class="separator:af1a96255685b80dc210e3ef3eb778a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d342831ec24762b18f71ba4fba54621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6d342831ec24762b18f71ba4fba54621.html#a6d342831ec24762b18f71ba4fba54621">tanh</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a6d342831ec24762b18f71ba4fba54621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic tangent of the specified variable (cmath).  <a href="namespacestan_1_1math_a6d342831ec24762b18f71ba4fba54621.html#a6d342831ec24762b18f71ba4fba54621">More...</a><br /></td></tr>
<tr class="separator:a6d342831ec24762b18f71ba4fba54621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad087da016f682bc2ce1899d8d02389fe"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , require_var_matrix_t&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad087da016f682bc2ce1899d8d02389fe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad087da016f682bc2ce1899d8d02389fe.html#ad087da016f682bc2ce1899d8d02389fe">tanh</a> (const VarMat &amp;a)</td></tr>
<tr class="memdesc:ad087da016f682bc2ce1899d8d02389fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic tangent of elements of a.  <a href="namespacestan_1_1math_ad087da016f682bc2ce1899d8d02389fe.html#ad087da016f682bc2ce1899d8d02389fe">More...</a><br /></td></tr>
<tr class="separator:ad087da016f682bc2ce1899d8d02389fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbe0ac1a4971ba605f7388d7d2cca63"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7fbe0ac1a4971ba605f7388d7d2cca63.html#a7fbe0ac1a4971ba605f7388d7d2cca63">tanh</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a7fbe0ac1a4971ba605f7388d7d2cca63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic tangent of the complex argument.  <a href="namespacestan_1_1math_a7fbe0ac1a4971ba605f7388d7d2cca63.html#a7fbe0ac1a4971ba605f7388d7d2cca63">More...</a><br /></td></tr>
<tr class="separator:a7fbe0ac1a4971ba605f7388d7d2cca63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e795209f13f6c4f9c273b560143ecf7"><td class="memTemplParams" colspan="2">template&lt;typename T , require_rev_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2e795209f13f6c4f9c273b560143ecf7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2e795209f13f6c4f9c273b560143ecf7.html#a2e795209f13f6c4f9c273b560143ecf7">tcrossprod</a> (const T &amp;M)</td></tr>
<tr class="memdesc:a2e795209f13f6c4f9c273b560143ecf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of post-multiplying a matrix by its own transpose.  <a href="namespacestan_1_1math_a2e795209f13f6c4f9c273b560143ecf7.html#a2e795209f13f6c4f9c273b560143ecf7">More...</a><br /></td></tr>
<tr class="separator:a2e795209f13f6c4f9c273b560143ecf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfeb8acb79c37f69d755a27ad515323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afdfeb8acb79c37f69d755a27ad515323.html#afdfeb8acb79c37f69d755a27ad515323">tgamma</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:afdfeb8acb79c37f69d755a27ad515323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Gamma function applied to the specified variable (C99).  <a href="namespacestan_1_1math_afdfeb8acb79c37f69d755a27ad515323.html#afdfeb8acb79c37f69d755a27ad515323">More...</a><br /></td></tr>
<tr class="separator:afdfeb8acb79c37f69d755a27ad515323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec682a7e94f3a897173c557f19f5d85d"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aec682a7e94f3a897173c557f19f5d85d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aec682a7e94f3a897173c557f19f5d85d.html#aec682a7e94f3a897173c557f19f5d85d">tgamma</a> (const T &amp;a)</td></tr>
<tr class="memdesc:aec682a7e94f3a897173c557f19f5d85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return elementwise gamma function.  <a href="namespacestan_1_1math_aec682a7e94f3a897173c557f19f5d85d.html#aec682a7e94f3a897173c557f19f5d85d">More...</a><br /></td></tr>
<tr class="separator:aec682a7e94f3a897173c557f19f5d85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f8df8d0b40a0e288d708748d187d9b"><td class="memTemplParams" colspan="2">template&lt;typename T , require_not_same_t&lt; T, arena_t&lt; T &gt;&gt; *  = nullptr, require_not_container_t&lt; T &gt; *  = nullptr, require_not_matrix_cl_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac8f8df8d0b40a0e288d708748d187d9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">arena_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac8f8df8d0b40a0e288d708748d187d9b.html#ac8f8df8d0b40a0e288d708748d187d9b">to_arena</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ac8f8df8d0b40a0e288d708748d187d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts given argument into a type that either has any dynamic allocation on AD stack or schedules its destructor to be called when AD stack memory is recovered.  <a href="namespacestan_1_1math_ac8f8df8d0b40a0e288d708748d187d9b.html#ac8f8df8d0b40a0e288d708748d187d9b">More...</a><br /></td></tr>
<tr class="separator:ac8f8df8d0b40a0e288d708748d187d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662ab4197c850085d5e5c03fd47b48e5"><td class="memTemplParams" colspan="2">template&lt;typename T , require_same_t&lt; T, arena_t&lt; T &gt;&gt; *  = nullptr, require_not_matrix_cl_t&lt; T &gt; *  = nullptr, require_not_std_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a662ab4197c850085d5e5c03fd47b48e5"><td class="memTemplItemLeft" align="right" valign="top">std::remove_reference_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a662ab4197c850085d5e5c03fd47b48e5.html#a662ab4197c850085d5e5c03fd47b48e5">to_arena</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a662ab4197c850085d5e5c03fd47b48e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts given argument into a type that either has any dynamic allocation on AD stack or schedules its destructor to be called when AD stack memory is recovered.  <a href="namespacestan_1_1math_a662ab4197c850085d5e5c03fd47b48e5.html#a662ab4197c850085d5e5c03fd47b48e5">More...</a><br /></td></tr>
<tr class="separator:a662ab4197c850085d5e5c03fd47b48e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8d246d2d0ed755cf2201bf72e12a0f"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_t&lt; T &gt; *  = nullptr, require_not_same_t&lt; T, arena_t&lt; T &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aed8d246d2d0ed755cf2201bf72e12a0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">arena_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aed8d246d2d0ed755cf2201bf72e12a0f.html#aed8d246d2d0ed755cf2201bf72e12a0f">to_arena</a> (const T &amp;a)</td></tr>
<tr class="memdesc:aed8d246d2d0ed755cf2201bf72e12a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts given argument into a type that either has any dynamic allocation on AD stack or schedules its destructor to be called when AD stack memory is recovered.  <a href="namespacestan_1_1math_aed8d246d2d0ed755cf2201bf72e12a0f.html#aed8d246d2d0ed755cf2201bf72e12a0f">More...</a><br /></td></tr>
<tr class="separator:aed8d246d2d0ed755cf2201bf72e12a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2209a4ca00e46bcab7c0f45f551d18f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2209a4ca00e46bcab7c0f45f551d18f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T, <a class="el" href="structstan_1_1math_1_1arena__allocator.html">arena_allocator</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab2209a4ca00e46bcab7c0f45f551d18f.html#ab2209a4ca00e46bcab7c0f45f551d18f">to_arena</a> (const std::vector&lt; T, <a class="el" href="structstan_1_1math_1_1arena__allocator.html">arena_allocator</a>&lt; T &gt;&gt; &amp;a)</td></tr>
<tr class="memdesc:ab2209a4ca00e46bcab7c0f45f551d18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts given argument into a type that either has any dynamic allocation on AD stack or schedules its destructor to be called when AD stack memory is recovered.  <a href="namespacestan_1_1math_ab2209a4ca00e46bcab7c0f45f551d18f.html#ab2209a4ca00e46bcab7c0f45f551d18f">More...</a><br /></td></tr>
<tr class="separator:ab2209a4ca00e46bcab7c0f45f551d18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3226f2fbdd5e8b1b03c82151413b44"><td class="memTemplParams" colspan="2">template&lt;typename T , require_same_t&lt; T, arena_t&lt; T &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5a3226f2fbdd5e8b1b03c82151413b44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">arena_t</a>&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5a3226f2fbdd5e8b1b03c82151413b44.html#a5a3226f2fbdd5e8b1b03c82151413b44">to_arena</a> (const std::vector&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a5a3226f2fbdd5e8b1b03c82151413b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts given argument into a type that has any dynamic allocation on AD stack.  <a href="namespacestan_1_1math_a5a3226f2fbdd5e8b1b03c82151413b44.html#a5a3226f2fbdd5e8b1b03c82151413b44">More...</a><br /></td></tr>
<tr class="separator:a5a3226f2fbdd5e8b1b03c82151413b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cca281d73b87228a1a73f518222cf8"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename T , std::enable_if_t&lt;!Condition &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab6cca281d73b87228a1a73f518222cf8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab6cca281d73b87228a1a73f518222cf8.html#ab6cca281d73b87228a1a73f518222cf8">to_arena_if</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ab6cca281d73b87228a1a73f518222cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the condition is true, converts given argument into a type that has any dynamic allocation on AD stack.  <a href="namespacestan_1_1math_ab6cca281d73b87228a1a73f518222cf8.html#ab6cca281d73b87228a1a73f518222cf8">More...</a><br /></td></tr>
<tr class="separator:ab6cca281d73b87228a1a73f518222cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b0085e0e3a1da02146e43de3de0858"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename T , std::enable_if_t&lt; Condition &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab6b0085e0e3a1da02146e43de3de0858"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">arena_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab6b0085e0e3a1da02146e43de3de0858.html#ab6b0085e0e3a1da02146e43de3de0858">to_arena_if</a> (const T &amp;a)</td></tr>
<tr class="separator:ab6b0085e0e3a1da02146e43de3de0858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa3540b09f1cb6232de90cb992dabfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0aa3540b09f1cb6232de90cb992dabfa.html#a0aa3540b09f1cb6232de90cb992dabfa">to_var</a> (double x)</td></tr>
<tr class="memdesc:a0aa3540b09f1cb6232de90cb992dabfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <a href="namespacestan_1_1math_a0aa3540b09f1cb6232de90cb992dabfa.html#a0aa3540b09f1cb6232de90cb992dabfa">More...</a><br /></td></tr>
<tr class="separator:a0aa3540b09f1cb6232de90cb992dabfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9b21508372b8ddd54170930dcc777a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7b9b21508372b8ddd54170930dcc777a.html#a7b9b21508372b8ddd54170930dcc777a">to_var</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:a7b9b21508372b8ddd54170930dcc777a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var for non-const var input.  <a href="namespacestan_1_1math_a7b9b21508372b8ddd54170930dcc777a.html#a7b9b21508372b8ddd54170930dcc777a">More...</a><br /></td></tr>
<tr class="separator:a7b9b21508372b8ddd54170930dcc777a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693d597e49aeb28a4966f64356ef433d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a693d597e49aeb28a4966f64356ef433d.html#a693d597e49aeb28a4966f64356ef433d">to_var</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:a693d597e49aeb28a4966f64356ef433d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var for const var input.  <a href="namespacestan_1_1math_a693d597e49aeb28a4966f64356ef433d.html#a693d597e49aeb28a4966f64356ef433d">More...</a><br /></td></tr>
<tr class="separator:a693d597e49aeb28a4966f64356ef433d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cb5d53612dd12c7038fe711b8dad30"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a82cb5d53612dd12c7038fe711b8dad30.html#a82cb5d53612dd12c7038fe711b8dad30">to_var</a> (const std::vector&lt; double &gt; &amp;v)</td></tr>
<tr class="memdesc:a82cb5d53612dd12c7038fe711b8dad30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <a href="namespacestan_1_1math_a82cb5d53612dd12c7038fe711b8dad30.html#a82cb5d53612dd12c7038fe711b8dad30">More...</a><br /></td></tr>
<tr class="separator:a82cb5d53612dd12c7038fe711b8dad30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f8f146b7a74af1cfb3554f2a0efb86"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a42f8f146b7a74af1cfb3554f2a0efb86.html#a42f8f146b7a74af1cfb3554f2a0efb86">to_var</a> (const std::vector&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a42f8f146b7a74af1cfb3554f2a0efb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var to for const input vector of var.  <a href="namespacestan_1_1math_a42f8f146b7a74af1cfb3554f2a0efb86.html#a42f8f146b7a74af1cfb3554f2a0efb86">More...</a><br /></td></tr>
<tr class="separator:a42f8f146b7a74af1cfb3554f2a0efb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a180b56a53448d73c27d2c1a18c5b4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a72a180b56a53448d73c27d2c1a18c5b4.html#a72a180b56a53448d73c27d2c1a18c5b4">to_var</a> (std::vector&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a72a180b56a53448d73c27d2c1a18c5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var to for non-const input vector of var.  <a href="namespacestan_1_1math_a72a180b56a53448d73c27d2c1a18c5b4.html#a72a180b56a53448d73c27d2c1a18c5b4">More...</a><br /></td></tr>
<tr class="separator:a72a180b56a53448d73c27d2c1a18c5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ac82e2c2773d5f460b49dd3b207f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a3a1b132685d7ca52bbeb05731a5674d5.html#a3a1b132685d7ca52bbeb05731a5674d5">matrix_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a12ac82e2c2773d5f460b49dd3b207f56.html#a12ac82e2c2773d5f460b49dd3b207f56">to_var</a> (const <a class="el" href="namespacestan_1_1math_aca2e8a0b7c1cca979b7ff43cbb75ca65.html#aca2e8a0b7c1cca979b7ff43cbb75ca65">matrix_d</a> &amp;m)</td></tr>
<tr class="memdesc:a12ac82e2c2773d5f460b49dd3b207f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <a href="namespacestan_1_1math_a12ac82e2c2773d5f460b49dd3b207f56.html#a12ac82e2c2773d5f460b49dd3b207f56">More...</a><br /></td></tr>
<tr class="separator:a12ac82e2c2773d5f460b49dd3b207f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36eea736434fd2180d8843ff29469c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a3a1b132685d7ca52bbeb05731a5674d5.html#a3a1b132685d7ca52bbeb05731a5674d5">matrix_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac36eea736434fd2180d8843ff29469c7.html#ac36eea736434fd2180d8843ff29469c7">to_var</a> (<a class="el" href="namespacestan_1_1math_a3a1b132685d7ca52bbeb05731a5674d5.html#a3a1b132685d7ca52bbeb05731a5674d5">matrix_v</a> &amp;m)</td></tr>
<tr class="memdesc:ac36eea736434fd2180d8843ff29469c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var for non-const matrices of vars.  <a href="namespacestan_1_1math_ac36eea736434fd2180d8843ff29469c7.html#ac36eea736434fd2180d8843ff29469c7">More...</a><br /></td></tr>
<tr class="separator:ac36eea736434fd2180d8843ff29469c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c57d0ab475398e2dfa84b6a7585f9c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a3a1b132685d7ca52bbeb05731a5674d5.html#a3a1b132685d7ca52bbeb05731a5674d5">matrix_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a80c57d0ab475398e2dfa84b6a7585f9c.html#a80c57d0ab475398e2dfa84b6a7585f9c">to_var</a> (const <a class="el" href="namespacestan_1_1math_a3a1b132685d7ca52bbeb05731a5674d5.html#a3a1b132685d7ca52bbeb05731a5674d5">matrix_v</a> &amp;m)</td></tr>
<tr class="memdesc:a80c57d0ab475398e2dfa84b6a7585f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var for const matrices of vars.  <a href="namespacestan_1_1math_a80c57d0ab475398e2dfa84b6a7585f9c.html#a80c57d0ab475398e2dfa84b6a7585f9c">More...</a><br /></td></tr>
<tr class="separator:a80c57d0ab475398e2dfa84b6a7585f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c88a848b4593ca978bb64d78053eee5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_aab8c89394ec1b09c99d6a5bd2eabfba5.html#aab8c89394ec1b09c99d6a5bd2eabfba5">vector_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3c88a848b4593ca978bb64d78053eee5.html#a3c88a848b4593ca978bb64d78053eee5">to_var</a> (const <a class="el" href="namespacestan_1_1math_a4954408ac287ec405ca9b7bf59b3c19b.html#a4954408ac287ec405ca9b7bf59b3c19b">vector_d</a> &amp;v)</td></tr>
<tr class="memdesc:a3c88a848b4593ca978bb64d78053eee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <a href="namespacestan_1_1math_a3c88a848b4593ca978bb64d78053eee5.html#a3c88a848b4593ca978bb64d78053eee5">More...</a><br /></td></tr>
<tr class="separator:a3c88a848b4593ca978bb64d78053eee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8605706fe1267df7619a98a3d0073fac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_aab8c89394ec1b09c99d6a5bd2eabfba5.html#aab8c89394ec1b09c99d6a5bd2eabfba5">vector_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8605706fe1267df7619a98a3d0073fac.html#a8605706fe1267df7619a98a3d0073fac">to_var</a> (const <a class="el" href="namespacestan_1_1math_aab8c89394ec1b09c99d6a5bd2eabfba5.html#aab8c89394ec1b09c99d6a5bd2eabfba5">vector_v</a> &amp;v)</td></tr>
<tr class="memdesc:a8605706fe1267df7619a98a3d0073fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var for const column vector of vars.  <a href="namespacestan_1_1math_a8605706fe1267df7619a98a3d0073fac.html#a8605706fe1267df7619a98a3d0073fac">More...</a><br /></td></tr>
<tr class="separator:a8605706fe1267df7619a98a3d0073fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff7550d704e64d5e4706ce57d1484f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_aab8c89394ec1b09c99d6a5bd2eabfba5.html#aab8c89394ec1b09c99d6a5bd2eabfba5">vector_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3ff7550d704e64d5e4706ce57d1484f5.html#a3ff7550d704e64d5e4706ce57d1484f5">to_var</a> (<a class="el" href="namespacestan_1_1math_aab8c89394ec1b09c99d6a5bd2eabfba5.html#aab8c89394ec1b09c99d6a5bd2eabfba5">vector_v</a> &amp;v)</td></tr>
<tr class="memdesc:a3ff7550d704e64d5e4706ce57d1484f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var for non-const column vector of vars.  <a href="namespacestan_1_1math_a3ff7550d704e64d5e4706ce57d1484f5.html#a3ff7550d704e64d5e4706ce57d1484f5">More...</a><br /></td></tr>
<tr class="separator:a3ff7550d704e64d5e4706ce57d1484f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf81f695d1c8f4c76e29fc31a496613a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a42483d058e437874b89ced9a3add3e9b.html#a42483d058e437874b89ced9a3add3e9b">row_vector_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaf81f695d1c8f4c76e29fc31a496613a.html#aaf81f695d1c8f4c76e29fc31a496613a">to_var</a> (const <a class="el" href="namespacestan_1_1math_abc78fff4ae93add582ece429d038796a.html#abc78fff4ae93add582ece429d038796a">row_vector_d</a> &amp;rv)</td></tr>
<tr class="memdesc:aaf81f695d1c8f4c76e29fc31a496613a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <a href="namespacestan_1_1math_aaf81f695d1c8f4c76e29fc31a496613a.html#aaf81f695d1c8f4c76e29fc31a496613a">More...</a><br /></td></tr>
<tr class="separator:aaf81f695d1c8f4c76e29fc31a496613a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533d64018b418759f2da216e5ccad255"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a42483d058e437874b89ced9a3add3e9b.html#a42483d058e437874b89ced9a3add3e9b">row_vector_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a533d64018b418759f2da216e5ccad255.html#a533d64018b418759f2da216e5ccad255">to_var</a> (const <a class="el" href="namespacestan_1_1math_a42483d058e437874b89ced9a3add3e9b.html#a42483d058e437874b89ced9a3add3e9b">row_vector_v</a> &amp;rv)</td></tr>
<tr class="memdesc:a533d64018b418759f2da216e5ccad255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var for const row vector of vars.  <a href="namespacestan_1_1math_a533d64018b418759f2da216e5ccad255.html#a533d64018b418759f2da216e5ccad255">More...</a><br /></td></tr>
<tr class="separator:a533d64018b418759f2da216e5ccad255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273dd83f6fef1eb4350631f9783c0d9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a42483d058e437874b89ced9a3add3e9b.html#a42483d058e437874b89ced9a3add3e9b">row_vector_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a273dd83f6fef1eb4350631f9783c0d9b.html#a273dd83f6fef1eb4350631f9783c0d9b">to_var</a> (<a class="el" href="namespacestan_1_1math_a42483d058e437874b89ced9a3add3e9b.html#a42483d058e437874b89ced9a3add3e9b">row_vector_v</a> &amp;rv)</td></tr>
<tr class="memdesc:a273dd83f6fef1eb4350631f9783c0d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var for non-const row vector of vars.  <a href="namespacestan_1_1math_a273dd83f6fef1eb4350631f9783c0d9b.html#a273dd83f6fef1eb4350631f9783c0d9b">More...</a><br /></td></tr>
<tr class="separator:a273dd83f6fef1eb4350631f9783c0d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b2c974ada0eea701b509d5c3b2294a"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_vt&lt; is_var, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a19b2c974ada0eea701b509d5c3b2294a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::Matrix&lt; double, T::RowsAtCompileTime, T::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a19b2c974ada0eea701b509d5c3b2294a.html#a19b2c974ada0eea701b509d5c3b2294a">to_var_value</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a19b2c974ada0eea701b509d5c3b2294a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="namespace_eigen.html">Eigen</a> matrix (or vector or row_vector) or expression of <code>var</code>s into <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code>.  <a href="namespacestan_1_1math_a19b2c974ada0eea701b509d5c3b2294a.html#a19b2c974ada0eea701b509d5c3b2294a">More...</a><br /></td></tr>
<tr class="separator:a19b2c974ada0eea701b509d5c3b2294a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73566ce6a0c149e31fb9b7837efb351"><td class="memTemplParams" colspan="2">template&lt;typename T , require_var_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac73566ce6a0c149e31fb9b7837efb351"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac73566ce6a0c149e31fb9b7837efb351.html#ac73566ce6a0c149e31fb9b7837efb351">to_var_value</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ac73566ce6a0c149e31fb9b7837efb351"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a no-op for var_values.  <a href="namespacestan_1_1math_ac73566ce6a0c149e31fb9b7837efb351.html#ac73566ce6a0c149e31fb9b7837efb351">More...</a><br /></td></tr>
<tr class="separator:ac73566ce6a0c149e31fb9b7837efb351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf51d7701dd3ad82c3b0a313518d88d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeaf51d7701dd3ad82c3b0a313518d88d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeaf51d7701dd3ad82c3b0a313518d88d.html#aeaf51d7701dd3ad82c3b0a313518d88d">to_var_value</a> (const std::vector&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:aeaf51d7701dd3ad82c3b0a313518d88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the elements of the <code>std::vector</code> input to <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code> types if possible.  <a href="namespacestan_1_1math_aeaf51d7701dd3ad82c3b0a313518d88d.html#aeaf51d7701dd3ad82c3b0a313518d88d">More...</a><br /></td></tr>
<tr class="separator:aeaf51d7701dd3ad82c3b0a313518d88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab102289c580edd2ef0a36a674b969271"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_t&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab102289c580edd2ef0a36a674b969271"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab102289c580edd2ef0a36a674b969271.html#ab102289c580edd2ef0a36a674b969271">to_vector</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; EigMat &gt; &amp;x)</td></tr>
<tr class="memdesc:ab102289c580edd2ef0a36a674b969271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Matrix&gt;</code> to a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;ColumnVector&gt;</code>.  <a href="namespacestan_1_1math_ab102289c580edd2ef0a36a674b969271.html#ab102289c580edd2ef0a36a674b969271">More...</a><br /></td></tr>
<tr class="separator:ab102289c580edd2ef0a36a674b969271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381a6b048c0d3ecf8ffe317b5567d3d9"><td class="memTemplParams" colspan="2">template&lt;typename T , require_rev_matrix_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a381a6b048c0d3ecf8ffe317b5567d3d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a381a6b048c0d3ecf8ffe317b5567d3d9.html#a381a6b048c0d3ecf8ffe317b5567d3d9">trace</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a381a6b048c0d3ecf8ffe317b5567d3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trace of the specified matrix.  <a href="namespacestan_1_1math_a381a6b048c0d3ecf8ffe317b5567d3d9.html#a381a6b048c0d3ecf8ffe317b5567d3d9">More...</a><br /></td></tr>
<tr class="separator:a381a6b048c0d3ecf8ffe317b5567d3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155c353bdd346e1ee8895bac6c580909"><td class="memTemplParams" colspan="2">template&lt;typename Td , typename Ta , typename Tb , require_not_col_vector_t&lt; Td &gt; *  = nullptr, require_all_matrix_t&lt; Td, Ta, Tb &gt; *  = nullptr, require_any_st_var&lt; Td, Ta, Tb &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a155c353bdd346e1ee8895bac6c580909"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a155c353bdd346e1ee8895bac6c580909.html#a155c353bdd346e1ee8895bac6c580909">trace_gen_inv_quad_form_ldlt</a> (const Td &amp;D, <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; Ta &gt; &amp;A, const Tb &amp;B)</td></tr>
<tr class="memdesc:a155c353bdd346e1ee8895bac6c580909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the trace of an inverse quadratic form premultiplied by a square matrix.  <a href="namespacestan_1_1math_a155c353bdd346e1ee8895bac6c580909.html#a155c353bdd346e1ee8895bac6c580909">More...</a><br /></td></tr>
<tr class="separator:a155c353bdd346e1ee8895bac6c580909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f14f59ccbad883d17f60885bca6a2b1"><td class="memTemplParams" colspan="2">template&lt;typename Td , typename Ta , typename Tb , require_col_vector_t&lt; Td &gt; *  = nullptr, require_all_matrix_t&lt; Ta, Tb &gt; *  = nullptr, require_any_st_var&lt; Td, Ta, Tb &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8f14f59ccbad883d17f60885bca6a2b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8f14f59ccbad883d17f60885bca6a2b1.html#a8f14f59ccbad883d17f60885bca6a2b1">trace_gen_inv_quad_form_ldlt</a> (const Td &amp;D, const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; Ta &gt; &amp;A, const Tb &amp;B)</td></tr>
<tr class="memdesc:a8f14f59ccbad883d17f60885bca6a2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the trace of an inverse quadratic form.  <a href="namespacestan_1_1math_a8f14f59ccbad883d17f60885bca6a2b1.html#a8f14f59ccbad883d17f60885bca6a2b1">More...</a><br /></td></tr>
<tr class="separator:a8f14f59ccbad883d17f60885bca6a2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117ac9ee22077e7e02b3d06494a9d607"><td class="memTemplParams" colspan="2">template&lt;typename Td , typename Ta , typename Tb , typename  = require_any_var_t&lt;value_type_t&lt;Td&gt;, value_type_t&lt;Ta&gt;,                                       value_type_t&lt;Tb&gt;&gt;, typename  = require_all_eigen_t&lt;Td, Ta, Tb&gt;&gt; </td></tr>
<tr class="memitem:a117ac9ee22077e7e02b3d06494a9d607"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a117ac9ee22077e7e02b3d06494a9d607.html#a117ac9ee22077e7e02b3d06494a9d607">trace_gen_quad_form</a> (const Td &amp;D, const Ta &amp;A, const Tb &amp;B)</td></tr>
<tr class="memdesc:a117ac9ee22077e7e02b3d06494a9d607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the trace of D times the quadratic form of B and A.  <a href="namespacestan_1_1math_a117ac9ee22077e7e02b3d06494a9d607.html#a117ac9ee22077e7e02b3d06494a9d607">More...</a><br /></td></tr>
<tr class="separator:a117ac9ee22077e7e02b3d06494a9d607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ae71980a3d13d358fdd4a52d8ada6a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , require_all_matrix_t&lt; T1, T2 &gt; *  = nullptr, require_any_st_var&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad4ae71980a3d13d358fdd4a52d8ada6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad4ae71980a3d13d358fdd4a52d8ada6a.html#ad4ae71980a3d13d358fdd4a52d8ada6a">trace_inv_quad_form_ldlt</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T1 &gt; &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:ad4ae71980a3d13d358fdd4a52d8ada6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the trace of an inverse quadratic form premultiplied by a square matrix.  <a href="namespacestan_1_1math_ad4ae71980a3d13d358fdd4a52d8ada6a.html#ad4ae71980a3d13d358fdd4a52d8ada6a">More...</a><br /></td></tr>
<tr class="separator:ad4ae71980a3d13d358fdd4a52d8ada6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273f011fead1620ecc263dc652b76527"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , require_all_matrix_t&lt; Mat1, Mat2 &gt; *  = nullptr, require_any_var_matrix_t&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a273f011fead1620ecc263dc652b76527"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a273f011fead1620ecc263dc652b76527.html#a273f011fead1620ecc263dc652b76527">trace_quad_form</a> (const Mat1 &amp;A, const Mat2 &amp;B)</td></tr>
<tr class="memdesc:a273f011fead1620ecc263dc652b76527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute trace(B^T A B).  <a href="namespacestan_1_1math_a273f011fead1620ecc263dc652b76527.html#a273f011fead1620ecc263dc652b76527">More...</a><br /></td></tr>
<tr class="separator:a273f011fead1620ecc263dc652b76527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7148d5c579f4dab06d820585a8ec021b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7148d5c579f4dab06d820585a8ec021b.html#a7148d5c579f4dab06d820585a8ec021b">trigamma</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;u)</td></tr>
<tr class="memdesc:a7148d5c579f4dab06d820585a8ec021b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the trigamma function at the specified argument (i.e., the second derivative of the log Gamma function at the specified argument).  <a href="namespacestan_1_1math_a7148d5c579f4dab06d820585a8ec021b.html#a7148d5c579f4dab06d820585a8ec021b">More...</a><br /></td></tr>
<tr class="separator:a7148d5c579f4dab06d820585a8ec021b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e85e1eba4076438c72cd986fde40e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a80e85e1eba4076438c72cd986fde40e8.html#a80e85e1eba4076438c72cd986fde40e8">trunc</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a80e85e1eba4076438c72cd986fde40e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the truncation of the specified variable (C99).  <a href="namespacestan_1_1math_a80e85e1eba4076438c72cd986fde40e8.html#a80e85e1eba4076438c72cd986fde40e8">More...</a><br /></td></tr>
<tr class="separator:a80e85e1eba4076438c72cd986fde40e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422e6a6d0bc04f80195b36330d706d4f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , require_matrix_t&lt; T &gt; *  = nullptr, require_stan_scalar_t&lt; U &gt; *  = nullptr, require_any_st_var&lt; T, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a422e6a6d0bc04f80195b36330d706d4f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a422e6a6d0bc04f80195b36330d706d4f.html#a422e6a6d0bc04f80195b36330d706d4f">ub_constrain</a> (const T &amp;x, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:a422e6a6d0bc04f80195b36330d706d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>ub_constrain</code> to apply a scalar upper bound elementwise to each input.  <a href="namespacestan_1_1math_a422e6a6d0bc04f80195b36330d706d4f.html#a422e6a6d0bc04f80195b36330d706d4f">More...</a><br /></td></tr>
<tr class="separator:a422e6a6d0bc04f80195b36330d706d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc52f12b79ab010d889926f6bf09fd3a"><td class="memTemplParams" colspan="2">template&lt;typename T , require_rev_col_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acc52f12b79ab010d889926f6bf09fd3a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acc52f12b79ab010d889926f6bf09fd3a.html#acc52f12b79ab010d889926f6bf09fd3a">unit_vector_constrain</a> (const T &amp;y)</td></tr>
<tr class="memdesc:acc52f12b79ab010d889926f6bf09fd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the free vector y.  <a href="namespacestan_1_1math_acc52f12b79ab010d889926f6bf09fd3a.html#acc52f12b79ab010d889926f6bf09fd3a">More...</a><br /></td></tr>
<tr class="separator:acc52f12b79ab010d889926f6bf09fd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b58913d4b412f569178256482d2679"><td class="memTemplParams" colspan="2">template&lt;typename T , require_eigen_col_vector_vt&lt; is_var, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a56b58913d4b412f569178256482d2679"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a56b58913d4b412f569178256482d2679.html#a56b58913d4b412f569178256482d2679">unit_vector_constrain</a> (const T &amp;y, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;lp)</td></tr>
<tr class="memdesc:a56b58913d4b412f569178256482d2679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the free vector y.  <a href="namespacestan_1_1math_a56b58913d4b412f569178256482d2679.html#a56b58913d4b412f569178256482d2679">More...</a><br /></td></tr>
<tr class="separator:a56b58913d4b412f569178256482d2679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a3e1c6ccdab2925f7eb8456d267903"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a83a3e1c6ccdab2925f7eb8456d267903"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a83a3e1c6ccdab2925f7eb8456d267903.html#a83a3e1c6ccdab2925f7eb8456d267903">value_of</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a83a3e1c6ccdab2925f7eb8456d267903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified variable.  <a href="namespacestan_1_1math_a83a3e1c6ccdab2925f7eb8456d267903.html#a83a3e1c6ccdab2925f7eb8456d267903">More...</a><br /></td></tr>
<tr class="separator:a83a3e1c6ccdab2925f7eb8456d267903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c30da1f1e1ac90844d76a0ad2c93f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85c30da1f1e1ac90844d76a0ad2c93f9"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a85c30da1f1e1ac90844d76a0ad2c93f9.html#a85c30da1f1e1ac90844d76a0ad2c93f9">value_of_rec</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a85c30da1f1e1ac90844d76a0ad2c93f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified variable.  <a href="namespacestan_1_1math_a85c30da1f1e1ac90844d76a0ad2c93f9.html#a85c30da1f1e1ac90844d76a0ad2c93f9">More...</a><br /></td></tr>
<tr class="separator:a85c30da1f1e1ac90844d76a0ad2c93f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0400489c86a0f208ed17371ab97254f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac0400489c86a0f208ed17371ab97254f.html#ac0400489c86a0f208ed17371ab97254f">variance</a> (const std::vector&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:ac0400489c86a0f208ed17371ab97254f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample variance of the specified standard vector.  <a href="namespacestan_1_1math_ac0400489c86a0f208ed17371ab97254f.html#ac0400489c86a0f208ed17371ab97254f">More...</a><br /></td></tr>
<tr class="separator:ac0400489c86a0f208ed17371ab97254f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40726361af6601f89530a5c1db6df513"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , require_eigen_vt&lt; is_var, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a40726361af6601f89530a5c1db6df513"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a40726361af6601f89530a5c1db6df513.html#a40726361af6601f89530a5c1db6df513">variance</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a40726361af6601f89530a5c1db6df513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample variance of the specified vector, row vector, or matrix.  <a href="namespacestan_1_1math_a40726361af6601f89530a5c1db6df513.html#a40726361af6601f89530a5c1db6df513">More...</a><br /></td></tr>
<tr class="separator:a40726361af6601f89530a5c1db6df513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce0ad49d02d149aaf8a0805bc96bc9c"><td class="memTemplParams" colspan="2">template&lt;typename Mat , require_var_matrix_t&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3ce0ad49d02d149aaf8a0805bc96bc9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3ce0ad49d02d149aaf8a0805bc96bc9c.html#a3ce0ad49d02d149aaf8a0805bc96bc9c">variance</a> (const Mat &amp;x)</td></tr>
<tr class="memdesc:a3ce0ad49d02d149aaf8a0805bc96bc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample variance of the <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a> matrix Raise domain error if size is not greater than zero.  <a href="namespacestan_1_1math_a3ce0ad49d02d149aaf8a0805bc96bc9c.html#a3ce0ad49d02d149aaf8a0805bc96bc9c">More...</a><br /></td></tr>
<tr class="separator:a3ce0ad49d02d149aaf8a0805bc96bc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061c94a66b7552774298852af5bd464c"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 , typename T_u , typename T_f &gt; </td></tr>
<tr class="memitem:a061c94a66b7552774298852af5bd464c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T2, -1, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a061c94a66b7552774298852af5bd464c.html#a061c94a66b7552774298852af5bd464c">algebra_solver_fp</a> (const F &amp;f, const Eigen::Matrix&lt; T1, -1, 1 &gt; &amp;x, const Eigen::Matrix&lt; T2, -1, 1 &gt; &amp;y, const std::vector&lt; double &gt; &amp;x_r, const std::vector&lt; int &gt; &amp;x_i, const std::vector&lt; T_u &gt; &amp;u_scale, const std::vector&lt; T_f &gt; &amp;f_scale, std::ostream *msgs=nullptr, double f_tol=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-8, int max_num_steps=200)</td></tr>
<tr class="memdesc:a061c94a66b7552774298852af5bd464c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a fixed pointer to the specified system of algebraic equations of form.  <a href="namespacestan_1_1math_a061c94a66b7552774298852af5bd464c.html#a061c94a66b7552774298852af5bd464c">More...</a><br /></td></tr>
<tr class="separator:a061c94a66b7552774298852af5bd464c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a17453b05fc8a869969f1c43a4c3e56"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... Args, require_eigen_vector_t&lt; T &gt; *  = nullptr, require_all_st_arithmetic&lt; Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9a17453b05fc8a869969f1c43a4c3e56"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9a17453b05fc8a869969f1c43a4c3e56.html#a9a17453b05fc8a869969f1c43a4c3e56">algebra_solver_newton_impl</a> (const F &amp;f, const T &amp;x, std::ostream *const msgs, const double scaling_step_size, const double function_tolerance, const int64_t max_num_steps, const Args &amp;... args)</td></tr>
<tr class="memdesc:a9a17453b05fc8a869969f1c43a4c3e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution to the specified system of algebraic equations given an initial guess, and parameters and data, which get passed into the algebraic system.  <a href="namespacestan_1_1math_a9a17453b05fc8a869969f1c43a4c3e56.html#a9a17453b05fc8a869969f1c43a4c3e56">More...</a><br /></td></tr>
<tr class="separator:a9a17453b05fc8a869969f1c43a4c3e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25347c5f7e2b4fcba71cee671c3297c4"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... T_Args, require_eigen_vector_t&lt; T &gt; *  = nullptr, require_any_st_var&lt; T_Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a25347c5f7e2b4fcba71cee671c3297c4"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a25347c5f7e2b4fcba71cee671c3297c4.html#a25347c5f7e2b4fcba71cee671c3297c4">algebra_solver_newton_impl</a> (const F &amp;f, const T &amp;x, std::ostream *const msgs, const double scaling_step_size, const double function_tolerance, const int64_t max_num_steps, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a25347c5f7e2b4fcba71cee671c3297c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution to the specified system of algebraic equations given an initial guess, and parameters and data, which get passed into the algebraic system.  <a href="namespacestan_1_1math_a25347c5f7e2b4fcba71cee671c3297c4.html#a25347c5f7e2b4fcba71cee671c3297c4">More...</a><br /></td></tr>
<tr class="separator:a25347c5f7e2b4fcba71cee671c3297c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8633ae482d606d3a183087e5bc03b0cc"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 , require_all_eigen_vector_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8633ae482d606d3a183087e5bc03b0cc"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T2 &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8633ae482d606d3a183087e5bc03b0cc.html#a8633ae482d606d3a183087e5bc03b0cc">algebra_solver_newton</a> (const F &amp;f, const T1 &amp;x, const T2 &amp;y, const std::vector&lt; double &gt; &amp;dat, const std::vector&lt; int &gt; &amp;dat_int, std::ostream *const msgs=nullptr, const double scaling_step_size=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-3, const double function_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-6, const long int max_num_steps=200)</td></tr>
<tr class="memdesc:a8633ae482d606d3a183087e5bc03b0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution to the specified system of algebraic equations given an initial guess, and parameters and data, which get passed into the algebraic system.  <a href="namespacestan_1_1math_a8633ae482d606d3a183087e5bc03b0cc.html#a8633ae482d606d3a183087e5bc03b0cc">More...</a><br /></td></tr>
<tr class="separator:a8633ae482d606d3a183087e5bc03b0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bd9d2c5504aba368578a9454a9e628"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... Args, require_eigen_vector_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a69bd9d2c5504aba368578a9454a9e628"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a69bd9d2c5504aba368578a9454a9e628.html#a69bd9d2c5504aba368578a9454a9e628">algebra_solver_powell_call_solver</a> (const F &amp;f, T &amp;x, std::ostream *const msgs, const double relative_tolerance, const double function_tolerance, const int64_t max_num_steps, const Args &amp;... args)</td></tr>
<tr class="memdesc:a69bd9d2c5504aba368578a9454a9e628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve algebraic equations using Powell solver.  <a href="namespacestan_1_1math_a69bd9d2c5504aba368578a9454a9e628.html#a69bd9d2c5504aba368578a9454a9e628">More...</a><br /></td></tr>
<tr class="separator:a69bd9d2c5504aba368578a9454a9e628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6fe03b58459aadf022c52d7b9c18b6"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... Args, require_eigen_vector_t&lt; T &gt; *  = nullptr, require_all_st_arithmetic&lt; Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aea6fe03b58459aadf022c52d7b9c18b6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aea6fe03b58459aadf022c52d7b9c18b6.html#aea6fe03b58459aadf022c52d7b9c18b6">algebra_solver_powell_impl</a> (const F &amp;f, const T &amp;x, std::ostream *const msgs, const double relative_tolerance, const double function_tolerance, const int64_t max_num_steps, const Args &amp;... args)</td></tr>
<tr class="memdesc:aea6fe03b58459aadf022c52d7b9c18b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution to the specified system of algebraic equations given an initial guess, and parameters and data, which get passed into the algebraic system.  <a href="namespacestan_1_1math_aea6fe03b58459aadf022c52d7b9c18b6.html#aea6fe03b58459aadf022c52d7b9c18b6">More...</a><br /></td></tr>
<tr class="separator:aea6fe03b58459aadf022c52d7b9c18b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dee09b8f5cdf6b4c9ebf2e61060bccc"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 , require_all_eigen_vector_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3dee09b8f5cdf6b4c9ebf2e61060bccc"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T2 &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3dee09b8f5cdf6b4c9ebf2e61060bccc.html#a3dee09b8f5cdf6b4c9ebf2e61060bccc">algebra_solver_powell</a> (const F &amp;f, const T1 &amp;x, const T2 &amp;y, const std::vector&lt; double &gt; &amp;dat, const std::vector&lt; int &gt; &amp;dat_int, std::ostream *const msgs=nullptr, const double relative_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-10, const double function_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-6, const int64_t max_num_steps=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>+3)</td></tr>
<tr class="memdesc:a3dee09b8f5cdf6b4c9ebf2e61060bccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution to the specified system of algebraic equations given an initial guess, and parameters and data, which get passed into the algebraic system.  <a href="namespacestan_1_1math_a3dee09b8f5cdf6b4c9ebf2e61060bccc.html#a3dee09b8f5cdf6b4c9ebf2e61060bccc">More...</a><br /></td></tr>
<tr class="separator:a3dee09b8f5cdf6b4c9ebf2e61060bccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50542124cb9591431a2485bdd9d5b771"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 , require_all_eigen_vector_t&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a50542124cb9591431a2485bdd9d5b771"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T2 &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a50542124cb9591431a2485bdd9d5b771.html#a50542124cb9591431a2485bdd9d5b771">algebra_solver</a> (const F &amp;f, const T1 &amp;x, const T2 &amp;y, const std::vector&lt; double &gt; &amp;dat, const std::vector&lt; int &gt; &amp;dat_int, std::ostream *msgs=nullptr, const double relative_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-10, const double function_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-6, const int64_t max_num_steps=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>+3)</td></tr>
<tr class="memdesc:a50542124cb9591431a2485bdd9d5b771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution to the specified system of algebraic equations given an initial guess, and parameters and data, which get passed into the algebraic system.  <a href="namespacestan_1_1math_a50542124cb9591431a2485bdd9d5b771.html#a50542124cb9591431a2485bdd9d5b771">More...</a><br /></td></tr>
<tr class="separator:a50542124cb9591431a2485bdd9d5b771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6576680ee52106b54915ba76e4e05f12"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... T_Args, require_eigen_vector_t&lt; T &gt; *  = nullptr, require_any_st_var&lt; T_Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6576680ee52106b54915ba76e4e05f12"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6576680ee52106b54915ba76e4e05f12.html#a6576680ee52106b54915ba76e4e05f12">algebra_solver_powell_impl</a> (const F &amp;f, const T &amp;x, std::ostream *const msgs, const double relative_tolerance, const double function_tolerance, const int64_t max_num_steps, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a6576680ee52106b54915ba76e4e05f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution to the specified system of algebraic equations given an initial guess, and parameters and data, which get passed into the algebraic system.  <a href="namespacestan_1_1math_a6576680ee52106b54915ba76e4e05f12.html#a6576680ee52106b54915ba76e4e05f12">More...</a><br /></td></tr>
<tr class="separator:a6576680ee52106b54915ba76e4e05f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af651e03101be764ba7569888ae4d73"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a2af651e03101be764ba7569888ae4d73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2af651e03101be764ba7569888ae4d73.html#a2af651e03101be764ba7569888ae4d73">algebra_solver_check</a> (const Eigen::Matrix&lt; T1, Eigen::Dynamic, 1 &gt; &amp;x, const Eigen::Matrix&lt; T2, Eigen::Dynamic, 1 &gt; y, const std::vector&lt; double &gt; &amp;dat, const std::vector&lt; int &gt; &amp;dat_int, double function_tolerance, long int max_num_steps)</td></tr>
<tr class="separator:a2af651e03101be764ba7569888ae4d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4111e32e382a574e78391239daeaaf96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4111e32e382a574e78391239daeaaf96.html#a4111e32e382a574e78391239daeaaf96">cvodes_set_options</a> (void *cvodes_mem, long int max_num_steps)</td></tr>
<tr class="separator:a4111e32e382a574e78391239daeaaf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f3f76fa8f704729df73b64ecba440f"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_yy , typename T_yp , typename... T_Args, require_all_eigen_col_vector_t&lt; T_yy, T_yp &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae7f3f76fa8f704729df73b64ecba440f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_yy, T_yp, T_Args... &gt;, -1, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae7f3f76fa8f704729df73b64ecba440f.html#ae7f3f76fa8f704729df73b64ecba440f">dae_tol_impl</a> (const char *func, const F &amp;f, const T_yy &amp;yy0, const T_yp &amp;yp0, double t0, const std::vector&lt; double &gt; &amp;ts, double rtol, double atol, int64_t max_num_steps, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:ae7f3f76fa8f704729df73b64ecba440f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the DAE initial value problem f(t, y, y')=0, y(t0) = yy0, y'(t0)=yp0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_ae7f3f76fa8f704729df73b64ecba440f.html#ae7f3f76fa8f704729df73b64ecba440f">More...</a><br /></td></tr>
<tr class="separator:ae7f3f76fa8f704729df73b64ecba440f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69f11f4b8b88e30f203ebf9df85c129"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_yy , typename T_yp , typename... T_Args, require_all_eigen_col_vector_t&lt; T_yy, T_yp &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af69f11f4b8b88e30f203ebf9df85c129"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_yy, T_yp, T_Args... &gt;, -1, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af69f11f4b8b88e30f203ebf9df85c129.html#af69f11f4b8b88e30f203ebf9df85c129">dae_tol</a> (const F &amp;f, const T_yy &amp;yy0, const T_yp &amp;yp0, double t0, const std::vector&lt; double &gt; &amp;ts, double rtol, double atol, int64_t max_num_steps, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:af69f11f4b8b88e30f203ebf9df85c129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the DAE initial value problem f(t, y, y')=0, y(t0) = yy0, y'(t0)=yp0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_af69f11f4b8b88e30f203ebf9df85c129.html#af69f11f4b8b88e30f203ebf9df85c129">More...</a><br /></td></tr>
<tr class="separator:af69f11f4b8b88e30f203ebf9df85c129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f096aac1fe7c841a0bcbb0f46df841e"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_yy , typename T_yp , typename... T_Args, require_all_eigen_col_vector_t&lt; T_yy, T_yp &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4f096aac1fe7c841a0bcbb0f46df841e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_yy, T_yp, T_Args... &gt;, -1, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4f096aac1fe7c841a0bcbb0f46df841e.html#a4f096aac1fe7c841a0bcbb0f46df841e">dae</a> (const F &amp;f, const T_yy &amp;yy0, const T_yp &amp;yp0, double t0, const std::vector&lt; double &gt; &amp;ts, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a4f096aac1fe7c841a0bcbb0f46df841e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the DAE initial value problem f(t, y, y')=0, y(t0) = yy0, y'(t0)=yp0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_a4f096aac1fe7c841a0bcbb0f46df841e.html#a4f096aac1fe7c841a0bcbb0f46df841e">More...</a><br /></td></tr>
<tr class="separator:a4f096aac1fe7c841a0bcbb0f46df841e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4666717786c59b911d557d8865a41d74"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a4666717786c59b911d557d8865a41d74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4666717786c59b911d557d8865a41d74.html#a4666717786c59b911d557d8865a41d74">gradient</a> (const F &amp;f, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, double &amp;fx, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;grad_fx)</td></tr>
<tr class="memdesc:a4666717786c59b911d557d8865a41d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value and the gradient of the specified function at the specified argument.  <a href="namespacestan_1_1math_a4666717786c59b911d557d8865a41d74.html#a4666717786c59b911d557d8865a41d74">More...</a><br /></td></tr>
<tr class="separator:a4666717786c59b911d557d8865a41d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53b95899f2dc2953d283f8301574969"><td class="memTemplParams" colspan="2">template&lt;typename F , typename EigVec , typename InputIt , require_eigen_vector_vt&lt; std::is_arithmetic, EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae53b95899f2dc2953d283f8301574969"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae53b95899f2dc2953d283f8301574969.html#ae53b95899f2dc2953d283f8301574969">gradient</a> (const F &amp;f, const EigVec &amp;x, double &amp;fx, InputIt first_grad_fx, InputIt last_grad_fx)</td></tr>
<tr class="memdesc:ae53b95899f2dc2953d283f8301574969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value and the gradient of the specified function at the specified argument.  <a href="namespacestan_1_1math_ae53b95899f2dc2953d283f8301574969.html#ae53b95899f2dc2953d283f8301574969">More...</a><br /></td></tr>
<tr class="separator:ae53b95899f2dc2953d283f8301574969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3290c1b18981907db8ca48f496ce43c"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_a , typename T_b , typename... Args, require_any_st_var&lt; T_a, T_b, Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab3290c1b18981907db8ca48f496ce43c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_a, T_b, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab3290c1b18981907db8ca48f496ce43c.html#ab3290c1b18981907db8ca48f496ce43c">integrate_1d_impl</a> (const F &amp;f, const T_a &amp;a, const T_b &amp;b, double relative_tolerance, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:ab3290c1b18981907db8ca48f496ce43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the integral of f from a to b to the given relative tolerance.  <a href="namespacestan_1_1math_ab3290c1b18981907db8ca48f496ce43c.html#ab3290c1b18981907db8ca48f496ce43c">More...</a><br /></td></tr>
<tr class="separator:ab3290c1b18981907db8ca48f496ce43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e91a7ac4302e35269b1c99d8b0d969"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_a , typename T_b , typename T_theta , typename  = require_any_var_t&lt;T_a, T_b, T_theta&gt;&gt; </td></tr>
<tr class="memitem:ad6e91a7ac4302e35269b1c99d8b0d969"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_a, T_b, T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad6e91a7ac4302e35269b1c99d8b0d969.html#ad6e91a7ac4302e35269b1c99d8b0d969">integrate_1d</a> (const F &amp;f, const T_a &amp;a, const T_b &amp;b, const std::vector&lt; T_theta &gt; &amp;theta, const std::vector&lt; double &gt; &amp;x_r, const std::vector&lt; int &gt; &amp;x_i, std::ostream *msgs, const double relative_tolerance=std::sqrt(<a class="el" href="namespacestan_1_1math_a28af31756798a98947ed5351b67fd9c4.html#a28af31756798a98947ed5351b67fd9c4">EPSILON</a>))</td></tr>
<tr class="memdesc:ad6e91a7ac4302e35269b1c99d8b0d969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integral of the single variable function f from a to b to within a specified relative tolerance.  <a href="namespacestan_1_1math_ad6e91a7ac4302e35269b1c99d8b0d969.html#ad6e91a7ac4302e35269b1c99d8b0d969">More...</a><br /></td></tr>
<tr class="separator:ad6e91a7ac4302e35269b1c99d8b0d969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446175120cc90cf2f203716187b61644"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_param , typename T_t0 , typename T_ts &gt; </td></tr>
<tr class="memitem:a446175120cc90cf2f203716187b61644"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y0, T_param, T_t0, T_ts &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a446175120cc90cf2f203716187b61644.html#a446175120cc90cf2f203716187b61644">integrate_ode_adams</a> (const F &amp;f, const std::vector&lt; T_y0 &gt; &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, const std::vector&lt; T_param &gt; &amp;theta, const std::vector&lt; double &gt; &amp;x, const std::vector&lt; int &gt; &amp;x_int, std::ostream *msgs=nullptr, double relative_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-10, double absolute_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-10, long int max_num_steps=1e8)</td></tr>
<tr class="separator:a446175120cc90cf2f203716187b61644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd187ba9af36dcd85cf7acdd56315bee"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_param , typename T_t0 , typename T_ts &gt; </td></tr>
<tr class="memitem:afd187ba9af36dcd85cf7acdd56315bee"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y0, T_param, T_t0, T_ts &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afd187ba9af36dcd85cf7acdd56315bee.html#afd187ba9af36dcd85cf7acdd56315bee">integrate_ode_bdf</a> (const F &amp;f, const std::vector&lt; T_y0 &gt; &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, const std::vector&lt; T_param &gt; &amp;theta, const std::vector&lt; double &gt; &amp;x, const std::vector&lt; int &gt; &amp;x_int, std::ostream *msgs=nullptr, double relative_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-10, double absolute_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-10, long int max_num_steps=1e8)</td></tr>
<tr class="separator:afd187ba9af36dcd85cf7acdd56315bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ceeaed84c0c91fea1c362395f4e464c"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a9ceeaed84c0c91fea1c362395f4e464c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ceeaed84c0c91fea1c362395f4e464c.html#a9ceeaed84c0c91fea1c362395f4e464c">jacobian</a> (const F &amp;f, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;fx, Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;J)</td></tr>
<tr class="separator:a9ceeaed84c0c91fea1c362395f4e464c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcd0bbd80073fb7a910f5f6e36a702e"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename... Args&gt; </td></tr>
<tr class="memitem:afdcd0bbd80073fb7a910f5f6e36a702e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afdcd0bbd80073fb7a910f5f6e36a702e.html#afdcd0bbd80073fb7a910f5f6e36a702e">kinsol_solve</a> (const F1 &amp;f, const Eigen::VectorXd &amp;x, const double scaling_step_tol, const double function_tolerance, const int64_t max_num_steps, const bool custom_jacobian, const int steps_eval_jacobian, const int global_line_search, std::ostream *const msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:afdcd0bbd80073fb7a910f5f6e36a702e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution to the specified algebraic system, given an initial guess.  <a href="namespacestan_1_1math_afdcd0bbd80073fb7a910f5f6e36a702e.html#afdcd0bbd80073fb7a910f5f6e36a702e">More...</a><br /></td></tr>
<tr class="separator:afdcd0bbd80073fb7a910f5f6e36a702e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45be08dc891a86ebf44e6314545943ac"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... T_Args, require_eigen_col_vector_t&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a45be08dc891a86ebf44e6314545943ac"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, T_Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a45be08dc891a86ebf44e6314545943ac.html#a45be08dc891a86ebf44e6314545943ac">ode_adams_tol_impl</a> (const char *function_name, const F &amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance, double absolute_tolerance, long int max_num_steps, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a45be08dc891a86ebf44e6314545943ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_a45be08dc891a86ebf44e6314545943ac.html#a45be08dc891a86ebf44e6314545943ac">More...</a><br /></td></tr>
<tr class="separator:a45be08dc891a86ebf44e6314545943ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94111d70788da4eb09657932ad8286bf"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... T_Args, require_eigen_col_vector_t&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a94111d70788da4eb09657932ad8286bf"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, T_Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a94111d70788da4eb09657932ad8286bf.html#a94111d70788da4eb09657932ad8286bf">ode_adams_tol</a> (const F &amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance, double absolute_tolerance, long int max_num_steps, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a94111d70788da4eb09657932ad8286bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_a94111d70788da4eb09657932ad8286bf.html#a94111d70788da4eb09657932ad8286bf">More...</a><br /></td></tr>
<tr class="separator:a94111d70788da4eb09657932ad8286bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6c31ce96a530d9358d4004a039910c"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... T_Args, require_eigen_col_vector_t&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3d6c31ce96a530d9358d4004a039910c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, T_Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3d6c31ce96a530d9358d4004a039910c.html#a3d6c31ce96a530d9358d4004a039910c">ode_adams</a> (const F &amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a3d6c31ce96a530d9358d4004a039910c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_a3d6c31ce96a530d9358d4004a039910c.html#a3d6c31ce96a530d9358d4004a039910c">More...</a><br /></td></tr>
<tr class="separator:a3d6c31ce96a530d9358d4004a039910c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055a253d0596a1266c5dcb03b4385583"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename T_abs_tol_fwd , typename T_abs_tol_bwd , typename... T_Args, require_all_eigen_col_vector_t&lt; T_y0, T_abs_tol_fwd, T_abs_tol_bwd &gt; *  = nullptr, require_any_not_st_arithmetic&lt; T_y0, T_t0, T_ts, T_Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a055a253d0596a1266c5dcb03b4385583"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a055a253d0596a1266c5dcb03b4385583.html#a055a253d0596a1266c5dcb03b4385583">ode_adjoint_impl</a> (const char *function_name, F &amp;&amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance_forward, const T_abs_tol_fwd &amp;absolute_tolerance_forward, double relative_tolerance_backward, const T_abs_tol_bwd &amp;absolute_tolerance_backward, double relative_tolerance_quadrature, double absolute_tolerance_quadrature, long int max_num_steps, long int num_steps_between_checkpoints, int interpolation_polynomial, int solver_forward, int solver_backward, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a055a253d0596a1266c5dcb03b4385583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_a055a253d0596a1266c5dcb03b4385583.html#a055a253d0596a1266c5dcb03b4385583">More...</a><br /></td></tr>
<tr class="separator:a055a253d0596a1266c5dcb03b4385583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7c31d24cdcb9a8b99316c396bf8095"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename T_abs_tol_fwd , typename T_abs_tol_bwd , typename... T_Args, require_all_eigen_col_vector_t&lt; T_y0, T_abs_tol_fwd, T_abs_tol_bwd &gt; *  = nullptr, require_all_st_arithmetic&lt; T_y0, T_t0, T_ts, T_Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:add7c31d24cdcb9a8b99316c396bf8095"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::VectorXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_add7c31d24cdcb9a8b99316c396bf8095.html#add7c31d24cdcb9a8b99316c396bf8095">ode_adjoint_impl</a> (const char *function_name, F &amp;&amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance_forward, const T_abs_tol_fwd &amp;absolute_tolerance_forward, double relative_tolerance_backward, const T_abs_tol_bwd &amp;absolute_tolerance_backward, double relative_tolerance_quadrature, double absolute_tolerance_quadrature, long int max_num_steps, long int num_steps_between_checkpoints, int interpolation_polynomial, int solver_forward, int solver_backward, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:add7c31d24cdcb9a8b99316c396bf8095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_add7c31d24cdcb9a8b99316c396bf8095.html#add7c31d24cdcb9a8b99316c396bf8095">More...</a><br /></td></tr>
<tr class="separator:add7c31d24cdcb9a8b99316c396bf8095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0082fb6580a5ca3a9e10762b94753aed"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename T_abs_tol_fwd , typename T_abs_tol_bwd , typename... T_Args, require_all_eigen_col_vector_t&lt; T_y0, T_abs_tol_fwd, T_abs_tol_bwd &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0082fb6580a5ca3a9e10762b94753aed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0082fb6580a5ca3a9e10762b94753aed.html#a0082fb6580a5ca3a9e10762b94753aed">ode_adjoint_tol_ctl</a> (F &amp;&amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance_forward, const T_abs_tol_fwd &amp;absolute_tolerance_forward, double relative_tolerance_backward, const T_abs_tol_bwd &amp;absolute_tolerance_backward, double relative_tolerance_quadrature, double absolute_tolerance_quadrature, long int max_num_steps, long int num_steps_between_checkpoints, int interpolation_polynomial, int solver_forward, int solver_backward, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a0082fb6580a5ca3a9e10762b94753aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_a0082fb6580a5ca3a9e10762b94753aed.html#a0082fb6580a5ca3a9e10762b94753aed">More...</a><br /></td></tr>
<tr class="separator:a0082fb6580a5ca3a9e10762b94753aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb83cac8e5b931e55ea062a305e6938e"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... T_Args, require_eigen_col_vector_t&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afb83cac8e5b931e55ea062a305e6938e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, T_Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afb83cac8e5b931e55ea062a305e6938e.html#afb83cac8e5b931e55ea062a305e6938e">ode_bdf_tol_impl</a> (const char *function_name, const F &amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance, double absolute_tolerance, long int max_num_steps, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:afb83cac8e5b931e55ea062a305e6938e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_afb83cac8e5b931e55ea062a305e6938e.html#afb83cac8e5b931e55ea062a305e6938e">More...</a><br /></td></tr>
<tr class="separator:afb83cac8e5b931e55ea062a305e6938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3a5f6c80ec85689eb5fe58ce258d8d"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... T_Args, require_eigen_col_vector_t&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abd3a5f6c80ec85689eb5fe58ce258d8d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, T_Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abd3a5f6c80ec85689eb5fe58ce258d8d.html#abd3a5f6c80ec85689eb5fe58ce258d8d">ode_bdf_tol</a> (const F &amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance, double absolute_tolerance, long int max_num_steps, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:abd3a5f6c80ec85689eb5fe58ce258d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_abd3a5f6c80ec85689eb5fe58ce258d8d.html#abd3a5f6c80ec85689eb5fe58ce258d8d">More...</a><br /></td></tr>
<tr class="separator:abd3a5f6c80ec85689eb5fe58ce258d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4bff737ea7d8128253b7a9ea1e9922"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... T_Args, require_eigen_col_vector_t&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acc4bff737ea7d8128253b7a9ea1e9922"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, T_Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acc4bff737ea7d8128253b7a9ea1e9922.html#acc4bff737ea7d8128253b7a9ea1e9922">ode_bdf</a> (const F &amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:acc4bff737ea7d8128253b7a9ea1e9922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ...  <a href="namespacestan_1_1math_acc4bff737ea7d8128253b7a9ea1e9922.html#acc4bff737ea7d8128253b7a9ea1e9922">More...</a><br /></td></tr>
<tr class="separator:acc4bff737ea7d8128253b7a9ea1e9922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4272fe1d2d985ae3681d9b6405d493c4"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0_t0 , typename T_t0 , typename T_t , typename... Args, require_any_autodiff_t&lt; T_y0_t0, T_t0, T_t, scalar_type_t&lt; Args &gt;... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4272fe1d2d985ae3681d9b6405d493c4"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4272fe1d2d985ae3681d9b6405d493c4.html#a4272fe1d2d985ae3681d9b6405d493c4">ode_store_sensitivities</a> (const F &amp;f, const std::vector&lt; double &gt; &amp;coupled_state, const Eigen::Matrix&lt; T_y0_t0, Eigen::Dynamic, 1 &gt; &amp;y0, const T_t0 &amp;t0, const T_t &amp;t, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:a4272fe1d2d985ae3681d9b6405d493c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build output vars for a state of the ODE solve, storing the sensitivities precomputed using the forward sensitivity problem in precomputed varis.  <a href="namespacestan_1_1math_a4272fe1d2d985ae3681d9b6405d493c4.html#a4272fe1d2d985ae3681d9b6405d493c4">More...</a><br /></td></tr>
<tr class="separator:a4272fe1d2d985ae3681d9b6405d493c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8b1a4214b4e3a9f40365632dacf676"><td class="memTemplParams" colspan="2">template&lt;typename T , require_stan_scalar_or_eigen_t&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3f8b1a4214b4e3a9f40365632dacf676"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3f8b1a4214b4e3a9f40365632dacf676.html#a3f8b1a4214b4e3a9f40365632dacf676">std_normal_log_qf</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;log_p)</td></tr>
<tr class="memdesc:a3f8b1a4214b4e3a9f40365632dacf676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise inverse of unit normal cumulative density function.  <a href="namespacestan_1_1math_a3f8b1a4214b4e3a9f40365632dacf676.html#a3f8b1a4214b4e3a9f40365632dacf676">More...</a><br /></td></tr>
<tr class="separator:a3f8b1a4214b4e3a9f40365632dacf676"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac077c45a1bee62fe39ab275715813db5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classstan_1_1math_1_1opencl__context.html">opencl_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac077c45a1bee62fe39ab275715813db5.html#ac077c45a1bee62fe39ab275715813db5">opencl_context</a></td></tr>
<tr class="separator:ac077c45a1bee62fe39ab275715813db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece739c5a2672028f0c7848045b89f08"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aece739c5a2672028f0c7848045b89f08.html#aece739c5a2672028f0c7848045b89f08">CONSTRAINT_TOLERANCE</a> = 1E-8</td></tr>
<tr class="memdesc:aece739c5a2672028f0c7848045b89f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tolerance for checking arithmetic bounds in rank and in simplexes.  <a href="namespacestan_1_1math_aece739c5a2672028f0c7848045b89f08.html#aece739c5a2672028f0c7848045b89f08">More...</a><br /></td></tr>
<tr class="separator:aece739c5a2672028f0c7848045b89f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28af31756798a98947ed5351b67fd9c4"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a28af31756798a98947ed5351b67fd9c4.html#a28af31756798a98947ed5351b67fd9c4">EPSILON</a> = std::numeric_limits&lt;double&gt;::epsilon()</td></tr>
<tr class="memdesc:a28af31756798a98947ed5351b67fd9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smallest positive value.  <a href="namespacestan_1_1math_a28af31756798a98947ed5351b67fd9c4.html#a28af31756798a98947ed5351b67fd9c4">More...</a><br /></td></tr>
<tr class="separator:a28af31756798a98947ed5351b67fd9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af856ce6d38a5ec3da54c22bbbeab1ef7"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af856ce6d38a5ec3da54c22bbbeab1ef7.html#af856ce6d38a5ec3da54c22bbbeab1ef7">INFTY</a> = std::numeric_limits&lt;double&gt;::infinity()</td></tr>
<tr class="memdesc:af856ce6d38a5ec3da54c22bbbeab1ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive infinity.  <a href="namespacestan_1_1math_af856ce6d38a5ec3da54c22bbbeab1ef7.html#af856ce6d38a5ec3da54c22bbbeab1ef7">More...</a><br /></td></tr>
<tr class="separator:af856ce6d38a5ec3da54c22bbbeab1ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64898a2ef4ecd64e10f379b692cbc307"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a64898a2ef4ecd64e10f379b692cbc307.html#a64898a2ef4ecd64e10f379b692cbc307">NEGATIVE_INFTY</a> = -<a class="el" href="namespacestan_1_1math_af856ce6d38a5ec3da54c22bbbeab1ef7.html#af856ce6d38a5ec3da54c22bbbeab1ef7">INFTY</a></td></tr>
<tr class="memdesc:a64898a2ef4ecd64e10f379b692cbc307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative infinity.  <a href="namespacestan_1_1math_a64898a2ef4ecd64e10f379b692cbc307.html#a64898a2ef4ecd64e10f379b692cbc307">More...</a><br /></td></tr>
<tr class="separator:a64898a2ef4ecd64e10f379b692cbc307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca7e4ef68cbab81021c58ea583edad9"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1ca7e4ef68cbab81021c58ea583edad9.html#a1ca7e4ef68cbab81021c58ea583edad9">NOT_A_NUMBER</a> = std::numeric_limits&lt;double&gt;::quiet_NaN()</td></tr>
<tr class="memdesc:a1ca7e4ef68cbab81021c58ea583edad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Quiet) not-a-number value.  <a href="namespacestan_1_1math_a1ca7e4ef68cbab81021c58ea583edad9.html#a1ca7e4ef68cbab81021c58ea583edad9">More...</a><br /></td></tr>
<tr class="separator:a1ca7e4ef68cbab81021c58ea583edad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9553730930966dc7e05d451ae28bc64"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab9553730930966dc7e05d451ae28bc64.html#ab9553730930966dc7e05d451ae28bc64">TWO_PI</a> = boost::math::constants::two_pi&lt;double&gt;()</td></tr>
<tr class="memdesc:ab9553730930966dc7e05d451ae28bc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Twice the value of \( \pi \), \( 2\pi \).  <a href="namespacestan_1_1math_ab9553730930966dc7e05d451ae28bc64.html#ab9553730930966dc7e05d451ae28bc64">More...</a><br /></td></tr>
<tr class="separator:ab9553730930966dc7e05d451ae28bc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0489b13217420005c7ee4bd1967e538e"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0489b13217420005c7ee4bd1967e538e.html#a0489b13217420005c7ee4bd1967e538e">LOG_ZERO</a> = -<a class="el" href="namespacestan_1_1math_af856ce6d38a5ec3da54c22bbbeab1ef7.html#af856ce6d38a5ec3da54c22bbbeab1ef7">INFTY</a></td></tr>
<tr class="memdesc:a0489b13217420005c7ee4bd1967e538e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 0, \( \log 0 \).  <a href="namespacestan_1_1math_a0489b13217420005c7ee4bd1967e538e.html#a0489b13217420005c7ee4bd1967e538e">More...</a><br /></td></tr>
<tr class="separator:a0489b13217420005c7ee4bd1967e538e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6367c20993309bad780502a4497408"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adc6367c20993309bad780502a4497408.html#adc6367c20993309bad780502a4497408">LOG_EPSILON</a> = std::log(<a class="el" href="namespacestan_1_1math_a28af31756798a98947ed5351b67fd9c4.html#a28af31756798a98947ed5351b67fd9c4">EPSILON</a>)</td></tr>
<tr class="memdesc:adc6367c20993309bad780502a4497408"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of machine precision \( \epsilon \), \( \log \epsilon \).  <a href="namespacestan_1_1math_adc6367c20993309bad780502a4497408.html#adc6367c20993309bad780502a4497408">More...</a><br /></td></tr>
<tr class="separator:adc6367c20993309bad780502a4497408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dd9cf6abfd8930528d3635890982b1"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af6dd9cf6abfd8930528d3635890982b1.html#af6dd9cf6abfd8930528d3635890982b1">LOG_PI</a> = std::log(<a class="el" href="namespacestan_1_1math_ac30268675d705278387b7019a50431a9.html#ac30268675d705278387b7019a50431a9">pi</a>())</td></tr>
<tr class="memdesc:af6dd9cf6abfd8930528d3635890982b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of \( \pi \), \( \log \pi \).  <a href="namespacestan_1_1math_af6dd9cf6abfd8930528d3635890982b1.html#af6dd9cf6abfd8930528d3635890982b1">More...</a><br /></td></tr>
<tr class="separator:af6dd9cf6abfd8930528d3635890982b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d08de1e5731f6fb99b24ddf57aa5b7"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a75d08de1e5731f6fb99b24ddf57aa5b7.html#a75d08de1e5731f6fb99b24ddf57aa5b7">LOG_TWO</a> = boost::math::constants::ln_two&lt;double&gt;()</td></tr>
<tr class="memdesc:a75d08de1e5731f6fb99b24ddf57aa5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 2, \( \log 2 \).  <a href="namespacestan_1_1math_a75d08de1e5731f6fb99b24ddf57aa5b7.html#a75d08de1e5731f6fb99b24ddf57aa5b7">More...</a><br /></td></tr>
<tr class="separator:a75d08de1e5731f6fb99b24ddf57aa5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15417f324298da63a581fe6d70b7d0dc"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a15417f324298da63a581fe6d70b7d0dc.html#a15417f324298da63a581fe6d70b7d0dc">LOG_HALF</a> = -<a class="el" href="namespacestan_1_1math_a75d08de1e5731f6fb99b24ddf57aa5b7.html#a75d08de1e5731f6fb99b24ddf57aa5b7">LOG_TWO</a></td></tr>
<tr class="memdesc:a15417f324298da63a581fe6d70b7d0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 0.5, \( \log 0.5 = \log 1 - \log 2 \).  <a href="namespacestan_1_1math_a15417f324298da63a581fe6d70b7d0dc.html#a15417f324298da63a581fe6d70b7d0dc">More...</a><br /></td></tr>
<tr class="separator:a15417f324298da63a581fe6d70b7d0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938e5d349b0ffdfdae9674f9dd4dbebe"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a938e5d349b0ffdfdae9674f9dd4dbebe.html#a938e5d349b0ffdfdae9674f9dd4dbebe">LOG_TWO_PI</a> = <a class="el" href="namespacestan_1_1math_a75d08de1e5731f6fb99b24ddf57aa5b7.html#a75d08de1e5731f6fb99b24ddf57aa5b7">LOG_TWO</a> + <a class="el" href="namespacestan_1_1math_af6dd9cf6abfd8930528d3635890982b1.html#af6dd9cf6abfd8930528d3635890982b1">LOG_PI</a></td></tr>
<tr class="memdesc:a938e5d349b0ffdfdae9674f9dd4dbebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 2 plus the natural logarithm of \( \pi \), \( \log(2\pi) \).  <a href="namespacestan_1_1math_a938e5d349b0ffdfdae9674f9dd4dbebe.html#a938e5d349b0ffdfdae9674f9dd4dbebe">More...</a><br /></td></tr>
<tr class="separator:a938e5d349b0ffdfdae9674f9dd4dbebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177764626d2378e0d7bdfb26aac187b6"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a177764626d2378e0d7bdfb26aac187b6.html#a177764626d2378e0d7bdfb26aac187b6">LOG_PI_OVER_FOUR</a> = 0.25 * <a class="el" href="namespacestan_1_1math_af6dd9cf6abfd8930528d3635890982b1.html#af6dd9cf6abfd8930528d3635890982b1">LOG_PI</a></td></tr>
<tr class="memdesc:a177764626d2378e0d7bdfb26aac187b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of one quarter the natural logarithm of \( \pi \), \( \log(\pi) / 4 \).  <a href="namespacestan_1_1math_a177764626d2378e0d7bdfb26aac187b6.html#a177764626d2378e0d7bdfb26aac187b6">More...</a><br /></td></tr>
<tr class="separator:a177764626d2378e0d7bdfb26aac187b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab836723c882918b6263042bdefa3c0d7"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab836723c882918b6263042bdefa3c0d7.html#ab836723c882918b6263042bdefa3c0d7">LOG_SQRT_PI</a> = std::log(boost::math::constants::root_pi&lt;double&gt;())</td></tr>
<tr class="memdesc:ab836723c882918b6263042bdefa3c0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of the square root of \( \pi \), \( \log(sqrt{\pi}) \).  <a href="namespacestan_1_1math_ab836723c882918b6263042bdefa3c0d7.html#ab836723c882918b6263042bdefa3c0d7">More...</a><br /></td></tr>
<tr class="separator:ab836723c882918b6263042bdefa3c0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bc64a6dbd8e9034abd4731d4b81062"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a52bc64a6dbd8e9034abd4731d4b81062.html#a52bc64a6dbd8e9034abd4731d4b81062">LOG_TEN</a> = boost::math::constants::ln_ten&lt;double&gt;()</td></tr>
<tr class="memdesc:a52bc64a6dbd8e9034abd4731d4b81062"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 10, \( \log 10 \).  <a href="namespacestan_1_1math_a52bc64a6dbd8e9034abd4731d4b81062.html#a52bc64a6dbd8e9034abd4731d4b81062">More...</a><br /></td></tr>
<tr class="separator:a52bc64a6dbd8e9034abd4731d4b81062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9a334555c7e8e6bb05d53d153971fd"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6b9a334555c7e8e6bb05d53d153971fd.html#a6b9a334555c7e8e6bb05d53d153971fd">SQRT_TWO</a> = boost::math::constants::root_two&lt;double&gt;()</td></tr>
<tr class="memdesc:a6b9a334555c7e8e6bb05d53d153971fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the square root of 2, \( \sqrt{2} \).  <a href="namespacestan_1_1math_a6b9a334555c7e8e6bb05d53d153971fd.html#a6b9a334555c7e8e6bb05d53d153971fd">More...</a><br /></td></tr>
<tr class="separator:a6b9a334555c7e8e6bb05d53d153971fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6deae732f2a24a4c91d1aea01eddc296"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6deae732f2a24a4c91d1aea01eddc296.html#a6deae732f2a24a4c91d1aea01eddc296">SQRT_PI</a> = boost::math::constants::root_pi&lt;double&gt;()</td></tr>
<tr class="memdesc:a6deae732f2a24a4c91d1aea01eddc296"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the square root of \( \pi \), \( \sqrt{\pi} \).  <a href="namespacestan_1_1math_a6deae732f2a24a4c91d1aea01eddc296.html#a6deae732f2a24a4c91d1aea01eddc296">More...</a><br /></td></tr>
<tr class="separator:a6deae732f2a24a4c91d1aea01eddc296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa751c757b29468e3cb242fae5c8bdef9"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa751c757b29468e3cb242fae5c8bdef9.html#aa751c757b29468e3cb242fae5c8bdef9">SQRT_TWO_PI</a> = boost::math::constants::root_two_pi&lt;double&gt;()</td></tr>
<tr class="memdesc:aa751c757b29468e3cb242fae5c8bdef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the square root of \( 2\pi \), \( \sqrt{2\pi} \).  <a href="namespacestan_1_1math_aa751c757b29468e3cb242fae5c8bdef9.html#aa751c757b29468e3cb242fae5c8bdef9">More...</a><br /></td></tr>
<tr class="separator:aa751c757b29468e3cb242fae5c8bdef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2403a9e86787dcb725562ff781b853c2"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2403a9e86787dcb725562ff781b853c2.html#a2403a9e86787dcb725562ff781b853c2">SQRT_TWO_OVER_SQRT_PI</a> = <a class="el" href="namespacestan_1_1math_a6b9a334555c7e8e6bb05d53d153971fd.html#a6b9a334555c7e8e6bb05d53d153971fd">SQRT_TWO</a> / <a class="el" href="namespacestan_1_1math_a6deae732f2a24a4c91d1aea01eddc296.html#a6deae732f2a24a4c91d1aea01eddc296">SQRT_PI</a></td></tr>
<tr class="memdesc:a2403a9e86787dcb725562ff781b853c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The square root of 2 divided by the square root of \( \pi \), \( \sqrt{2} / \sqrt{\pi} \).  <a href="namespacestan_1_1math_a2403a9e86787dcb725562ff781b853c2.html#a2403a9e86787dcb725562ff781b853c2">More...</a><br /></td></tr>
<tr class="separator:a2403a9e86787dcb725562ff781b853c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f300ea7d2367d21741ad731072a8f0d"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5f300ea7d2367d21741ad731072a8f0d.html#a5f300ea7d2367d21741ad731072a8f0d">INV_SQRT_TWO</a> = boost::math::constants::one_div_root_two&lt;double&gt;()</td></tr>
<tr class="memdesc:a5f300ea7d2367d21741ad731072a8f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of 1 over the square root of 2, \( 1 / \sqrt{2} \).  <a href="namespacestan_1_1math_a5f300ea7d2367d21741ad731072a8f0d.html#a5f300ea7d2367d21741ad731072a8f0d">More...</a><br /></td></tr>
<tr class="separator:a5f300ea7d2367d21741ad731072a8f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7b12c46cb271490a0ef92e76b068de"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aae7b12c46cb271490a0ef92e76b068de.html#aae7b12c46cb271490a0ef92e76b068de">INV_SQRT_PI</a> = boost::math::constants::one_div_root_pi&lt;double&gt;()</td></tr>
<tr class="memdesc:aae7b12c46cb271490a0ef92e76b068de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of 1 over the square root of \( \pi \), \( 1 / \sqrt{\pi} \).  <a href="namespacestan_1_1math_aae7b12c46cb271490a0ef92e76b068de.html#aae7b12c46cb271490a0ef92e76b068de">More...</a><br /></td></tr>
<tr class="separator:aae7b12c46cb271490a0ef92e76b068de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dcd6f480d9e53bf99be0a0ff967b88"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a60dcd6f480d9e53bf99be0a0ff967b88.html#a60dcd6f480d9e53bf99be0a0ff967b88">INV_SQRT_TWO_PI</a> = boost::math::constants::one_div_root_two_pi&lt;double&gt;()</td></tr>
<tr class="memdesc:a60dcd6f480d9e53bf99be0a0ff967b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of 1 over the square root of \( 2\pi \), \( 1 / \sqrt{2\pi} \).  <a href="namespacestan_1_1math_a60dcd6f480d9e53bf99be0a0ff967b88.html#a60dcd6f480d9e53bf99be0a0ff967b88">More...</a><br /></td></tr>
<tr class="separator:a60dcd6f480d9e53bf99be0a0ff967b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba20a8bafd6456338197d25c01ba61ec"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aba20a8bafd6456338197d25c01ba61ec.html#aba20a8bafd6456338197d25c01ba61ec">TWO_OVER_SQRT_PI</a> = boost::math::constants::two_div_root_pi&lt;double&gt;()</td></tr>
<tr class="memdesc:aba20a8bafd6456338197d25c01ba61ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of 2 over the square root of \( \pi \), \( 2 / \sqrt{\pi} \).  <a href="namespacestan_1_1math_aba20a8bafd6456338197d25c01ba61ec.html#aba20a8bafd6456338197d25c01ba61ec">More...</a><br /></td></tr>
<tr class="separator:aba20a8bafd6456338197d25c01ba61ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08489116f12293545f5fcf324658fdaf"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a08489116f12293545f5fcf324658fdaf.html#a08489116f12293545f5fcf324658fdaf">HALF_LOG_TWO</a> = 0.5 * <a class="el" href="namespacestan_1_1math_a75d08de1e5731f6fb99b24ddf57aa5b7.html#a75d08de1e5731f6fb99b24ddf57aa5b7">LOG_TWO</a></td></tr>
<tr class="memdesc:a08489116f12293545f5fcf324658fdaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of half the natural logarithm 2, \( \log(2) / 2 \).  <a href="namespacestan_1_1math_a08489116f12293545f5fcf324658fdaf.html#a08489116f12293545f5fcf324658fdaf">More...</a><br /></td></tr>
<tr class="separator:a08489116f12293545f5fcf324658fdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2222c1646cbe8457156159ec60f3039e"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2222c1646cbe8457156159ec60f3039e.html#a2222c1646cbe8457156159ec60f3039e">HALF_LOG_TWO_PI</a> = 0.5 * <a class="el" href="namespacestan_1_1math_a938e5d349b0ffdfdae9674f9dd4dbebe.html#a938e5d349b0ffdfdae9674f9dd4dbebe">LOG_TWO_PI</a></td></tr>
<tr class="memdesc:a2222c1646cbe8457156159ec60f3039e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of half the natural logarithm \( 2\pi \), \( \log(2\pi) / 2 \).  <a href="namespacestan_1_1math_a2222c1646cbe8457156159ec60f3039e.html#a2222c1646cbe8457156159ec60f3039e">More...</a><br /></td></tr>
<tr class="separator:a2222c1646cbe8457156159ec60f3039e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f7f156224f9e60c2fb3e99034212eb"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a59f7f156224f9e60c2fb3e99034212eb.html#a59f7f156224f9e60c2fb3e99034212eb">NEG_LOG_SQRT_TWO_PI</a> = -std::log(<a class="el" href="namespacestan_1_1math_aa751c757b29468e3cb242fae5c8bdef9.html#aa751c757b29468e3cb242fae5c8bdef9">SQRT_TWO_PI</a>)</td></tr>
<tr class="memdesc:a59f7f156224f9e60c2fb3e99034212eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of minus the natural logarithm of the square root of \( 2\pi \), \( -\log(\sqrt{2\pi}) \).  <a href="namespacestan_1_1math_a59f7f156224f9e60c2fb3e99034212eb.html#a59f7f156224f9e60c2fb3e99034212eb">More...</a><br /></td></tr>
<tr class="separator:a59f7f156224f9e60c2fb3e99034212eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea938c86917d89bbd13e4edcbecb1be"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4ea938c86917d89bbd13e4edcbecb1be.html#a4ea938c86917d89bbd13e4edcbecb1be">POISSON_MAX_RATE</a> = std::pow(2.0, 30)</td></tr>
<tr class="memdesc:a4ea938c86917d89bbd13e4edcbecb1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Largest rate parameter allowed in Poisson RNG.  <a href="namespacestan_1_1math_a4ea938c86917d89bbd13e4edcbecb1be.html#a4ea938c86917d89bbd13e4edcbecb1be">More...</a><br /></td></tr>
<tr class="separator:a4ea938c86917d89bbd13e4edcbecb1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad739ae95d8525331e40a226c6330700b"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad739ae95d8525331e40a226c6330700b.html#ad739ae95d8525331e40a226c6330700b">lgamma_stirling_diff_useful</a> = 10</td></tr>
<tr class="separator:ad739ae95d8525331e40a226c6330700b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a063d6b0347cc193b69270211e8aadd"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8a063d6b0347cc193b69270211e8aadd.html#a8a063d6b0347cc193b69270211e8aadd">MAJOR_VERSION</a> = &quot;4&quot;</td></tr>
<tr class="memdesc:a8a063d6b0347cc193b69270211e8aadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Major version number for Stan math library.  <a href="namespacestan_1_1math_a8a063d6b0347cc193b69270211e8aadd.html#a8a063d6b0347cc193b69270211e8aadd">More...</a><br /></td></tr>
<tr class="separator:a8a063d6b0347cc193b69270211e8aadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60295ca22b8701af9a3ccf3b607231f4"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a60295ca22b8701af9a3ccf3b607231f4.html#a60295ca22b8701af9a3ccf3b607231f4">MINOR_VERSION</a> = &quot;4&quot;</td></tr>
<tr class="memdesc:a60295ca22b8701af9a3ccf3b607231f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minor version number for Stan math library.  <a href="namespacestan_1_1math_a60295ca22b8701af9a3ccf3b607231f4.html#a60295ca22b8701af9a3ccf3b607231f4">More...</a><br /></td></tr>
<tr class="separator:a60295ca22b8701af9a3ccf3b607231f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c620fffa8fa7ddd68ffb46fb64667b"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad4c620fffa8fa7ddd68ffb46fb64667b.html#ad4c620fffa8fa7ddd68ffb46fb64667b">PATCH_VERSION</a> = &quot;0&quot;</td></tr>
<tr class="memdesc:ad4c620fffa8fa7ddd68ffb46fb64667b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch version for Stan math library.  <a href="namespacestan_1_1math_ad4c620fffa8fa7ddd68ffb46fb64667b.html#ad4c620fffa8fa7ddd68ffb46fb64667b">More...</a><br /></td></tr>
<tr class="separator:ad4c620fffa8fa7ddd68ffb46fb64667b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacestan.html">stan</a></li><li class="navelem"><a class="el" href="namespacestan_1_1math.html">math</a></li>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
